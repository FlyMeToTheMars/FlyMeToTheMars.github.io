<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mars</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2025-07-30T06:29:13.231Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Fly Hugh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>朝花夕拾</title>
    <link href="http://yoursite.com/2050/10/14/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    <id>http://yoursite.com/2050/10/14/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/</id>
    <published>2050-10-13T22:31:42.000Z</published>
    <updated>2025-07-30T06:29:13.231Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笨猫不如烂笔头</p></blockquote><a id="more"></a> <h3 id="更友好的创建对象方式"><a href="#更友好的创建对象方式" class="headerlink" title="更友好的创建对象方式"></a>更友好的创建对象方式</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gdnjra9kkrj20sk0c6myf.jpg" alt="3d5024b55687373af54fcb9ef4e0eb4.png"></p><p>上面的方式，对JVM来说是更友好的，因为堆内存的调用无法避免，所以从栈内存这边入手解决内存问题是一个不错的解决的方式</p><hr><h3 id="下面代码是否线程安全"><a href="#下面代码是否线程安全" class="headerlink" title="下面代码是否线程安全"></a>下面代码是否线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看类似饿汉式的单例，线程安全，其实是有问题的</p><p>虽然只有一个线程能够获得锁，并且这个锁还是类锁，所有对象共享的</p><p>关键在于 jvm 对 new 的优化，这个变量没有声明 volatile，new 不是一个线程安全的操作，</p><p>对于 new 这个指令，一般的顺序是申请内存空间，初始化内存空间，然后把内存地址赋给 instance 对象，但是 jvm 会对这段指令进行优化，优化之后变成 申请内存空间，内存地址赋给 instance 对象，初始化内存空间，这就导致 第二层检查可能会出错，标准写法只需要在变量前声明 volatile 即可。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gdnkbsp9sij20pp0gy75i.jpg" alt="677701574e4f69f35e226ed6bc9a380.png"></p><hr><h3 id="volatile利用了什么协议来实现可见性"><a href="#volatile利用了什么协议来实现可见性" class="headerlink" title="volatile利用了什么协议来实现可见性"></a>volatile利用了什么协议来实现可见性</h3><p>volatile 是通过内存屏障实现的，MESI协议，缓存一致性协议</p><p>JVM推荐书《The Java Language Specification》<br>volatile 修饰的变量如果值发生变化 发现线程的高速缓存与主存数据不一致时候 由于缓存一致性协议 则总线将高速缓存中的值清空 其他线程只能通过访问主存来获取最新的值 并缓存到告诉缓存上。</p><hr><h3 id="Java-Trainsient-关键字"><a href="#Java-Trainsient-关键字" class="headerlink" title="Java Trainsient 关键字"></a>Java Trainsient 关键字</h3><p>1.一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 </p><p>2.transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 </p><p>3.一个静态变量不管是否被transient修饰，均不能被序列化。 </p><p>使用总结和场景：某个类的有些属性需要序列化，其他属性不需要被序列化，比如：敏感信息（如密码，银行卡号等），java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><h3 id="多线程中Random的使用"><a href="#多线程中Random的使用" class="headerlink" title="多线程中Random的使用"></a>多线程中Random的使用</h3><p>1.不要在多个线程间共享一个java.util.Random实例，而该把它放入ThreadLocal之中。</p><p>2.Java7以上我们更推荐使用java.util.concurrent.ThreadLocalRandom。</p><p>下面两条建议是 IDEA给的:</p><p>1.不要将将随机数放大10的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法</p><p>2.Math.random()应避免在多线程环境下使用</p><h3 id="为什么阿里禁止使用Executor创建线程池"><a href="#为什么阿里禁止使用Executor创建线程池" class="headerlink" title="为什么阿里禁止使用Executor创建线程池"></a>为什么阿里禁止使用Executor创建线程池</h3><p>阿里规约之所以强制要求手动创建线程池，也是和这些参数有关。具体为什么不允许，规约是这么说的：</p><p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>Executor提供的四个静态方法创建线程池，但是阿里规约却并不建议使用它。</p><p>Executors各个方法的弊端：<br>1）newFixedThreadPool和newSingleThreadExecutor:<br>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。<br>2）newCachedThreadPool和newScheduledThreadPool:<br>  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p><p>看一下这两种弊端怎么导致的。</p><p>第一种，newFixedThreadPool和newSingleThreadExecutor分别获得 FixedThreadPool 类型的线程池 和  SingleThreadExecutor 类型的线程池。　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">       return new FinalizableDelegatedExecutorService</span><br><span class="line">           (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                   0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为，创建了一个无界队列LinkedBlockingQueuesize，是一个最大值为Integer.MAX_VALUE的线程阻塞队列，当添加任务的速度大于线程池处理任务的速度，可能会在队列堆积大量的请求，消耗很大的内存，甚至导致OOM。</p><h3 id="阿里开发手册上不推荐（禁止）使用Double的根本原因"><a href="#阿里开发手册上不推荐（禁止）使用Double的根本原因" class="headerlink" title="阿里开发手册上不推荐（禁止）使用Double的根本原因"></a>阿里开发手册上不推荐（禁止）使用Double的根本原因</h3><p>精度丢失就不谈了，稍微深入一下为什么精度会丢失，分为一些不同情况</p><p><strong>典型现象（一）：条件判断超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.9999999f</span> );   <span class="comment">// 打印：false</span></span><br><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.99999999f</span> );  <span class="comment">// 打印：true    纳尼？</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.0</span>（十进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">00111111</span> <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span>（二进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">0x3F800000</span>（十六进制）</span><br><span class="line">    </span><br><span class="line"><span class="number">0.99999999</span>（十进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">00111111</span> <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span>（二进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">0x3F800000</span>（十六进制）</span><br><span class="line">    </span><br><span class="line">果不其然，这两个十进制浮点数的底层二进制表示是一毛一样的，怪不得==的判断结果返回<span class="keyword">true</span>！</span><br><span class="line"></span><br><span class="line">浮点数的精度问题。</span><br><span class="line">    </span><br><span class="line">浮点数在计算机中的存储方式遵循IEEE <span class="number">754</span> 浮点数计数标准，可以用科学计数法表示为：</span><br><span class="line">    <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、符号部分（S）</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>-正  <span class="number">1</span>-负</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、阶码部分（E）（指数部分）：</span><br><span class="line"></span><br><span class="line">对于<span class="keyword">float</span>型浮点数，指数部分<span class="number">8</span>位，考虑可正可负，因此可以表示的指数范围为-<span class="number">127</span> ~ <span class="number">128</span></span><br><span class="line">对于<span class="keyword">double</span>型浮点数，指数部分<span class="number">11</span>位，考虑可正可负，因此可以表示的指数范围为-<span class="number">1023</span> ~ <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、尾数部分（M）：</span><br><span class="line"></span><br><span class="line">浮点数的精度是由尾数的位数来决定的：</span><br><span class="line"></span><br><span class="line">对于<span class="keyword">float</span>型浮点数，尾数部分<span class="number">23</span>位，换算成十进制就是 <span class="number">2</span>^<span class="number">23</span>=<span class="number">8388608</span>，所以十进制精度只有<span class="number">6</span> ~ <span class="number">7</span>位；</span><br><span class="line">对于<span class="keyword">double</span>型浮点数，尾数部分<span class="number">52</span>位，换算成十进制就是 <span class="number">2</span>^<span class="number">52</span> = <span class="number">4503599627370496</span>，所以十进制精度只有<span class="number">15</span> ~ <span class="number">16</span>位</span><br><span class="line"></span><br><span class="line">所以对于上面的数值<span class="number">0.99999999f</span>，很明显已经超过了<span class="keyword">float</span>型浮点数据的精度范围，出问题也是在所难免的。</span><br></pre></td></tr></table></figure><p><strong>典型现象（二）：数据转换超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span>;</span><br><span class="line"><span class="keyword">double</span> d = (<span class="keyword">double</span>) f;</span><br><span class="line">System.out.println(f);  <span class="comment">// 打印：1.1</span></span><br><span class="line">System.out.println(d);  <span class="comment">// 打印：1.100000023841858  纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>典型现象（三）：基本运算超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">0.2</span> + <span class="number">0.7</span> );  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：0.8999999999999999   纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>典型现象（四）：数据自增超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = <span class="number">8455263f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(f1);</span><br><span class="line">    f1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印：8455263.0</span></span><br><span class="line"><span class="comment">// 打印：8455264.0</span></span><br><span class="line"><span class="comment">// 打印：8455265.0</span></span><br><span class="line"><span class="comment">// 打印：8455266.0</span></span><br><span class="line"><span class="comment">// 打印：8455267.0</span></span><br><span class="line"><span class="comment">// 打印：8455268.0</span></span><br><span class="line"><span class="comment">// 打印：8455269.0</span></span><br><span class="line"><span class="comment">// 打印：8455270.0</span></span><br><span class="line"><span class="comment">// 打印：8455271.0</span></span><br><span class="line"><span class="comment">// 打印：8455272.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">84552631f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(f2);</span><br><span class="line">    f2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br></pre></td></tr></table></figure><p>解决办法：</p><p>1.我们我们可以用字符串或者数组来表示这种大数，然后按照四则运算的规则来手动模拟出具体计算过程，中间还需要考虑各种诸如：<strong>进位、借位、符号</strong>等等问题的处理，有点复杂。</p><ol start="2"><li>JDK早已为我们考虑到了浮点数的计算精度问题，因此提供了专用于高精度数值计算的<strong>大数类</strong>来方便我们使用。</li></ol><h3 id="mac-清理maven仓库的脚本"><a href="#mac-清理maven仓库的脚本" class="headerlink" title="mac 清理maven仓库的脚本"></a>mac 清理maven仓库的脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这里写你的仓库路径</span><br><span class="line">REPOSITORY_PATH=~/Documents/tools/apache-maven-3.0.3/repository</span><br><span class="line">echo 正在搜索...</span><br><span class="line">find $REPOSITORY_PATH -name &quot;*lastUpdated*&quot; | xargs rm -fr</span><br><span class="line">echo 删除完毕</span><br><span class="line"></span><br><span class="line">mac（linux）系统-创建.sh文件脚本执行（mac用.command终端也可以）</span><br></pre></td></tr></table></figure><h3 id="idea目录较多，文件名较长产生的错误"><a href="#idea目录较多，文件名较长产生的错误" class="headerlink" title="idea目录较多，文件名较长产生的错误"></a>idea目录较多，文件名较长产生的错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error running &apos;ServiceStarter&apos;: Command line is too long. Shorten command line for ServiceStarter or also for Application default configuration.</span><br><span class="line"></span><br><span class="line">修改项目下 .idea\workspace.xml，找到标签 &lt;component name=&quot;PropertiesComponent&quot;&gt; ， 在标签里加一行 &lt;property name=&quot;dynamic.classpath&quot; value=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="Log4J-指定屏蔽某些特定报警信息"><a href="#Log4J-指定屏蔽某些特定报警信息" class="headerlink" title="Log4J 指定屏蔽某些特定报警信息"></a>Log4J 指定屏蔽某些特定报警信息</h3><p>Logger.getLogger(“org.apache.library”).setLevel(Level.OFF)</p><h3 id="Flink-Source并行度为1的意义"><a href="#Flink-Source并行度为1的意义" class="headerlink" title="Flink Source并行度为1的意义"></a>Flink Source并行度为1的意义</h3><p>对于需要设置EventTime的流来说，我们的TimestampAssigner应该在Source之后立即调用，原因是时间戳分配器看到的元素的顺序应该和source操作符产生数据的顺序是一样的，否则就乱了，也就是说，任何分区操作都会将元素的顺序打乱，例如：改变并行度 keyBy操作等等。，所以最佳实践是：</p><p>在尽量接近数据源source操作符的地方分配时间戳和产生水位线，甚至最好在SourceFunction中分配时间戳和产生水位线。当然在分配时间戳和产生水位线之前可以对流进行map和filter操作是没问题的，也就是说必须是窄依赖。</p><h3 id="JB套件的一个实用功能"><a href="#JB套件的一个实用功能" class="headerlink" title="JB套件的一个实用功能"></a>JB套件的一个实用功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前没注意，更改变量名字的时候直接使用refactor就可以了，真的实用</span><br></pre></td></tr></table></figure><h3 id="zk使用的分布式协议并不是paxos"><a href="#zk使用的分布式协议并不是paxos" class="headerlink" title="zk使用的分布式协议并不是paxos"></a>zk使用的分布式协议并不是paxos</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而是zab协议</span><br></pre></td></tr></table></figure><h3 id="为什么说NULL是计算机科学中最大的错误，至少值十亿美金"><a href="#为什么说NULL是计算机科学中最大的错误，至少值十亿美金" class="headerlink" title="为什么说NULL是计算机科学中最大的错误，至少值十亿美金"></a>为什么说NULL是计算机科学中最大的错误，至少值十亿美金</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.覆类型</span><br><span class="line">2.是凌乱的</span><br><span class="line">3.是一个特例</span><br><span class="line">4.使 API 变得糟糕</span><br><span class="line">5.使错误的语言决策更加恶化</span><br><span class="line">6.难以调试</span><br><span class="line">7.是不可组合的</span><br></pre></td></tr></table></figure><h4 id="1-NULL-颠覆类型"><a href="#1-NULL-颠覆类型" class="headerlink" title="1. NULL 颠覆类型"></a>1. NULL 颠覆类型</h4><p>静态类型语言不需要实际去执行程序，就可以检查程序中类型的使用，并且提供一定的程序行为保证。</p><p>例如，在 Java 中，如果我编写 <code>x.toUppercase()</code>，编译器会检查 <code>x</code> 的类型。如果 <code>x</code> 是一个 <code>String</code>，那么类型检查成功；如果 <code>x</code> 是一个 <code>Socket</code>，那么类型检查失败。</p><p>在编写庞大的、复杂的软件时，静态类型检查是一个强大的工具。但是对于 Java，这些很棒的编译时检查存在一个致命缺陷：任何引用都可以是 null，而调用一个 null 对象的方法会产生一个 <code>NullPointerException</code>。所以，</p><ul><li><code>toUppercase()</code> 可以被任意 <code>String</code> 对象调用。除非 <code>String</code> 是 null。</li><li><code>read()</code> 可以被任意 <code>InputStream</code> 对象调用。除非 <code>InputStream</code> 是 null。</li><li><code>toString()</code> 可以被任意 <code>Object</code> 对象调用。除非 <code>Object</code> 是 null。</li></ul><p>Java 不是唯一引起这个问题的语言；很多其它的类型系统也有同样的缺点，当然包括 AGOL W 语言。</p><p>在这些语言中，NULL 超出了类型检查的范围。它悄悄地越过类型检查，等待运行时，最后一下子释放出一大批错误。NULL 什么也不是，同时又什么都是。</p><h4 id="2-NULL-是凌乱的"><a href="#2-NULL-是凌乱的" class="headerlink" title="2. NULL 是凌乱的"></a>2. NULL 是凌乱的</h4><p>在很多情况下 null 是没有意义的。不幸的是，如果一种语言允许任何东西为 null，好吧，那么任何东西都可以是 null。</p><p>Java 程序员冒着患腕管综合症的风险写下</p><p>Java</p><p> <code>if (str == null 丨丨 str.equals(&quot;&quot;)) {}</code> </p><p>而在 C# 中添加 <code>String.IsNullOrEmpty</code> 是一个常见的语法</p><p>C#</p><p> <code>if (string.IsNullOrEmpty(str)) {}</code> </p><p>真可恶！</p><p>每次你写代码，将 null 字符串和空字符串混为一谈时，Guava 团队都要哭了。– <a href="https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="noopener">Google Guava</a></p><p>说得好。但是当你的类型系统（例如，Java 或者 C#）到处都允许 NULL 时，你就不能可靠地排除 NULL 的可能性，并且不可避免的会在某个地方混淆。</p><p>null 无处不在的可能性造成了这样一个问题，Java 8 添加了 <code>@NonNull</code> 标注，尝试着在它的类型系统中以追溯方式解决这个缺陷。</p><h4 id="3-NULL-是一个特例"><a href="#3-NULL-是一个特例" class="headerlink" title="3. NULL 是一个特例"></a>3. NULL 是一个特例</h4><p>考虑到 NULL 不是一个值却又起到一个值的作用，NULL 自然地成为各种特别处理方法的课题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char c = &apos;A&apos;;</span><br><span class="line">char *myChar = &amp;c;</span><br><span class="line">std::cout &lt;&lt; *myChar &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>单个 NUL 字符的例外已经导致无数的错误：API 的怪异行为、安全漏洞和缓冲区溢出。</p><p>NULL 是 C 字符串中最糟糕的错误；更确切地说，以 NUL 结尾的字符串是<a href="http://queue.acm.org/detail.cfm?id=2010365" target="_blank" rel="noopener">最昂贵的<strong>一字节</strong>错误</a>。</p><h4 id="4-NULL-使-API-变得糟糕"><a href="#4-NULL-使-API-变得糟糕" class="headerlink" title="4.NULL 使 API 变得糟糕"></a>4.NULL 使 API 变得糟糕</h4><p>我们可以想象在很多语言中类似的类（Python、JavaScript、Java、C# 等）。</p><p>现在假设我们的程序有一个慢的或者占用大量资源的方法，来找到某个人的电话号码——可能通过连通一个网络服务。</p><p>为了提高性能，我们将会使用本地存储作为缓存，将一个人名映射到他的电话号码上。</p><p>然而，一些人没有电话号码（即他们的电话号码是 nil）。我们仍然会缓存那些信息，所以我们不需要在后面重新填充那些信息。</p><p>但是现在意味着我们的结果模棱两可！它可能表示：</p><ol><li>这个人不存在于缓存中（Alice）</li><li>这个人存在于缓存中，但是没有电话号码（Tom）</li></ol><p>一种情形要求昂贵的重新计算，另一种需要即时的答复。但是我们的代码不够精密来区分这两种情况。</p><p>在实际的代码中，像这样的情况经常会以复杂且不易察觉的方式出现。因此，简单通用的 API 可以马上变成特例，迷惑了 null 凌乱行为的来源。</p><p>用一个 <code>contains()</code> 方法来修补 <code>Store</code> 类可能会有帮助。但是这引入重复的查找，导致降低性能和竞争条件。</p><h4 id="5-NULL-使错误的语言决策更加恶化"><a href="#5-NULL-使错误的语言决策更加恶化" class="headerlink" title="5.NULL 使错误的语言决策更加恶化"></a>5.NULL 使错误的语言决策更加恶化</h4><h4 id="6-NULL-难以调试"><a href="#6-NULL-难以调试" class="headerlink" title="6.NULL 难以调试"></a>6.NULL 难以调试</h4><p>来解释 NULL 是多么的麻烦，C++ 是一个很好的例子。调用成员函数指向一个 NULL 指针不一定会导致程序崩溃。更糟糕的是：它可能会导致程序崩溃。</p><h4 id="7-NULL不可组合"><a href="#7-NULL不可组合" class="headerlink" title="7.NULL不可组合"></a>7.NULL不可组合</h4><h3 id="IDEA-maven修改pom文件，导致jdk版本重置问题"><a href="#IDEA-maven修改pom文件，导致jdk版本重置问题" class="headerlink" title="IDEA maven修改pom文件，导致jdk版本重置问题"></a>IDEA maven修改pom文件，导致jdk版本重置问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><h3 id="MAVEN的scope"><a href="#MAVEN的scope" class="headerlink" title="MAVEN的scope"></a>MAVEN的scope</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">compile</span><br><span class="line">默认就是compile，什么都不配置也就是意味着compile。compile表示被依赖项目需要参与当前项目的编译，当然后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去。</span><br><span class="line"></span><br><span class="line">test</span><br><span class="line">scope为test表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的如junit。</span><br><span class="line"></span><br><span class="line">runntime</span><br><span class="line">runntime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过编译而已，说实话在终端的项目（非开源，企业内部系统）中，和compile区别不是很大。比较常见的如JSR×××的实现，对应的API jar是compile的，具体实现是runtime的，compile只需要知道接口就足够了。oracle jdbc驱动架包就是一个很好的例子，一般scope为runntime。另外runntime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。</span><br><span class="line"></span><br><span class="line">provided</span><br><span class="line">provided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。</span><br><span class="line"></span><br><span class="line">system</span><br><span class="line">从参与度来说，也provided相同，不过被依赖项不会从maven仓库抓，而是从本地文件系统拿，一定需要配合systemPath属性使用。</span><br><span class="line"></span><br><span class="line">scope的依赖传递</span><br><span class="line">A–&gt;B–&gt;C。当前项目为A，A依赖于B，B依赖于C。知道B在A项目中的scope，那么怎么知道C在A中的scope呢？</span><br><span class="line">答案是：</span><br><span class="line">当C是test或者provided时，C直接被丢弃，A不依赖C；</span><br><span class="line">否则A依赖C，C的scope继承于B的scope。</span><br></pre></td></tr></table></figure><h3 id="EXCEL一点小技巧"><a href="#EXCEL一点小技巧" class="headerlink" title="EXCEL一点小技巧"></a>EXCEL一点小技巧</h3><p>正好最近用来有点小用处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.从固定的单元格里随机取一个值</span><br><span class="line">=INDEX($G$2:$M$2, RANDBETWEEN(1,7))</span><br><span class="line">$G$2：下拉的时候不会自动延伸</span><br><span class="line"></span><br><span class="line">2.从固定列取值用在本单元格里</span><br><span class="line">=&quot;INSERT INTO `event_mapping` VALUES (&apos;&quot;&amp;B2&amp;&quot;&apos;,&quot;&amp;C2&amp;&quot;,&quot;&amp;D2&amp;&quot;);&quot;</span><br><span class="line"></span><br><span class="line">3.下拉到某行</span><br><span class="line">在有第一行的情况下，直接双击右下角小箭头即可</span><br></pre></td></tr></table></figure><h3 id="Flink-On-Zeppelin上传Jar包的位置"><a href="#Flink-On-Zeppelin上传Jar包的位置" class="headerlink" title="Flink On Zeppelin上传Jar包的位置"></a>Flink On Zeppelin上传Jar包的位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/opt/flink-1.10/flink-1.10.0/lib</span><br><span class="line"></span><br><span class="line">目前看来应该是放在flink包里面的，会稳定上传，已经确定</span><br><span class="line"></span><br><span class="line">在interpreter 依赖里面设置了路劲</span><br><span class="line">/opt/flink-1.10/flink-1.10.0/lib/jimipojo-1.0.jar</span><br></pre></td></tr></table></figure><h3 id="Flink系列深度好文，等待细读"><a href="#Flink系列深度好文，等待细读" class="headerlink" title="Flink系列深度好文，等待细读"></a>Flink系列深度好文，等待细读</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.jianshu.com/c/b6089c70072f</span><br><span class="line">flink的apply和process方法有什么区别呢</span><br></pre></td></tr></table></figure><h3 id="FastJson直接解析"><a href="#FastJson直接解析" class="headerlink" title="FastJson直接解析"></a>FastJson直接解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.map(</span><br><span class="line">a -&gt; JSON</span><br><span class="line">.parseObject(</span><br><span class="line">a,</span><br><span class="line">Pojo.class)</span><br><span class="line">).returns(</span><br><span class="line">Pojo.class</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>具体的还要试一下，我故意写的很难看来督促自己。。。</p><h3 id="FastJson很多坑-准备放弃"><a href="#FastJson很多坑-准备放弃" class="headerlink" title="FastJson很多坑 准备放弃"></a>FastJson很多坑 准备放弃</h3><h3 id="配置框架无法访问的问题"><a href="#配置框架无法访问的问题" class="headerlink" title="配置框架无法访问的问题"></a>配置框架无法访问的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有点脑残了，今天在mac上配置了zeppelin win无法访问，其原因是配置文件中的网络地址写死了 172.0.0.1, 如果想要别尔德位置能够访问的话，必须改变配置为其局域网id</span><br><span class="line"></span><br><span class="line">更好的选择是更改为0.0.0.0</span><br></pre></td></tr></table></figure><h3 id="解决GitHub提交历史头像不显示问题-以及首页没有绿色方块的问题"><a href="#解决GitHub提交历史头像不显示问题-以及首页没有绿色方块的问题" class="headerlink" title="解决GitHub提交历史头像不显示问题,以及首页没有绿色方块的问题"></a>解决GitHub提交历史头像不显示问题,以及首页没有绿色方块的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">最近把本地的一个项目提交推送到GitHub的时候发现有两个问题, </span><br><span class="line">1.在commit提交历史里面</span><br><span class="line"></span><br><span class="line">提交内容的旁边,显示的不是原本github主页的头像,而是默认的灰色章鱼头像</span><br><span class="line"></span><br><span class="line">2.我的contributions里面提交的历史(绿色方块)也没有了</span><br><span class="line"></span><br><span class="line">怎么解决呢？</span><br><span class="line"></span><br><span class="line">1.首先在终端里切到项目所在目录</span><br><span class="line"></span><br><span class="line">2.输入git show命令,你会发现 有一行写着Author: Apple &lt;邮箱&gt;,这个邮箱肯定不是你绑定到github的邮箱</span><br><span class="line"></span><br><span class="line">3.输入git config user.email &quot;你的邮箱地址&quot;,修改邮箱</span><br><span class="line"></span><br><span class="line">4.修改完以后输入git config user.email 检查是否修改成了你的邮箱</span><br><span class="line"></span><br><span class="line">5.到目前为止现在只是修改这个项目的邮箱,重新推送一个新的改动,在查看该项目的提交历史和contributions里面提交的历史(绿色方块),问题已经解决了(之前的依旧不显示)</span><br><span class="line"></span><br><span class="line">6.如果你想其他项目提交时,也避免此类情况,把上面的两条命令改成 （1） git config --global user.email &quot;your_email@example.com&quot;</span><br><span class="line"></span><br><span class="line">（2）git config --global user.email 就可以了</span><br></pre></td></tr></table></figure><h3 id="解决anaconda无法连接的问题"><a href="#解决anaconda无法连接的问题" class="headerlink" title="解决anaconda无法连接的问题"></a>解决anaconda无法连接的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win10下更换清华镜像后无法连接 是因为win10里面无法解析https协议，修改‪~\.condarc文件，把https换成http</span><br></pre></td></tr></table></figure><h3 id="排查挖矿程序中会用到的一些追踪某个进程的命令"><a href="#排查挖矿程序中会用到的一些追踪某个进程的命令" class="headerlink" title="排查挖矿程序中会用到的一些追踪某个进程的命令"></a>排查挖矿程序中会用到的一些追踪某个进程的命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>查看PID启动文件的路径</span><br><span class="line">ls -l /proc/$PID/exe</span><br><span class="line"><span class="meta">#</span>查看PID执行目录的路径</span><br><span class="line">ls -l /proc/$PID/cwd</span><br><span class="line"><span class="meta">#</span>在定时器配置目录查看是否存在异常定时器配置</span><br><span class="line">/var/spool/cron/root 和/etc/crontab 和/etc/rc.lcoal</span><br><span class="line"><span class="meta">#</span>查看定时器启动日志,跟踪自启动程序</span><br><span class="line">tail -f /var/log/cron</span><br><span class="line"><span class="meta">#</span>查看各个进程的cpu使用情况，默认按cpu使用率排序</span><br><span class="line">top</span><br><span class="line"><span class="meta">#</span>显示所有运行中的进程，q退出</span><br><span class="line">ps aux | less</span><br><span class="line"><span class="meta">#</span>查看test.jar进程号</span><br><span class="line">ps -aux|grep test.jar | grep -v grep</span><br><span class="line"><span class="meta">#</span>查看test.jar进程号</span><br><span class="line">ps -ef|grep test.jar | grep -v grep</span><br><span class="line"><span class="meta">#</span>查看该进程下各个线程的cpu使用情况</span><br><span class="line">top -Hp pid</span><br><span class="line"><span class="meta">#</span>将线程pid转换为十六进制 8f7</span><br><span class="line">printf "%x\n" pid</span><br><span class="line"><span class="meta">#</span>查看pid进程里面的线程信息,线程Id为十六进制</span><br><span class="line">jstack pid | grep 8f7</span><br><span class="line"><span class="meta">#</span>查看该进程打开的文件</span><br><span class="line">lsof -p pid</span><br><span class="line"><span class="meta">#</span>查看pid线程内存分配</span><br><span class="line">cat /proc/pid/maps </span><br><span class="line"><span class="meta">#</span>查看PID启动文件的路径</span><br><span class="line">ls -l /proc/$PID/exe </span><br><span class="line"><span class="meta">#</span>查看PID执行目录的路径</span><br><span class="line">ls -l /proc/$PID/cwd </span><br><span class="line"><span class="meta">#</span>查看PID详细的内存占比</span><br><span class="line">cat /proc/$PID/status</span><br></pre></td></tr></table></figure><h3 id="Kerberos缺点"><a href="#Kerberos缺点" class="headerlink" title="Kerberos缺点"></a>Kerberos缺点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、KDC 有单点风险，除非设置HA系统(Aictive Directory 可以做到这一点，目前apache directoryserver 也可以做到这一点)；</span><br><span class="line"></span><br><span class="line">2、访问压力可能使KDC过载；分布式服务使用Kerberos 必须做到这一点，KDC无法承受高负载请求；为什么Hadoop 要使用代理tokens的原因也是如此；</span><br><span class="line"></span><br><span class="line">3、服务之间的通信通道也需要安全认证，kerberos不保证数据加密；如果通信通道不安全，tickets 可能会被拦截或者通信伪造；</span><br><span class="line"></span><br><span class="line">4、机器之前需要保证时间的精确一致性，不然具备时限的tockens不会正常工作；这个在分布式领域是一个典型的问题，Paxos &amp;Raft协议也必须保证时间的一致性；</span><br><span class="line"></span><br><span class="line">5、如果机器间的时间没有被安全管理，理论上可能延长被盗token的使用时间；</span><br><span class="line"></span><br><span class="line">6、被盗用的token可以拿来直接访问服务，在KDC是没有访问日志的。每一个application需要拥有自己的以用户为单位的审计日志，这样才能保证被盗的ticket可被追踪，比如在Hadoop里面HDFS审计日志；</span><br><span class="line"></span><br><span class="line">7、这是一个仅仅认证服务：验证caller的合法性并准许给caller传递认证信息，他不处理任何授权信息；</span><br></pre></td></tr></table></figure><h3 id="mac无法运行-sh文件的解决办法"><a href="#mac无法运行-sh文件的解决办法" class="headerlink" title="mac无法运行.sh文件的解决办法"></a>mac无法运行.sh文件的解决办法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">今天解决了一下内网穿透的问题，</span><br><span class="line">轻量级的选择有frp，</span><br><span class="line">重量级的有goproxy</span><br><span class="line"></span><br><span class="line">几个问题记录一下，第一点：</span><br><span class="line">zsh无法运行.sh文件，要进行切换</span><br><span class="line">chsh -s /bin/bash</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h3 id="解决git下载速度慢的终极方法"><a href="#解决git下载速度慢的终极方法" class="headerlink" title="解决git下载速度慢的终极方法"></a>解决git下载速度慢的终极方法</h3><p>因为本地的网络始终有一些问题，再忍受了很久很久的龟速下载之后，终于找了个一个非常顶的方法</p><p>前提是现有一个vpn，但是vpn不会自动代理git的流量，不管是在windows下面还是在mac下面都不会自动代理git，这点一直让我十分苦恼，现在终于找到了一劳永逸的办法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos; </span><br><span class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br></pre></td></tr></table></figure><p>简单说明：vpn一般都是走的1080端口，通过这个端口转发git的流量，跳过本地运营商。</p><p>取消代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 取消代理</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line"></span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h3 id="Maven代理配置"><a href="#Maven代理配置" class="headerlink" title="Maven代理配置"></a>Maven代理配置</h3><p>不需要配置什么https或者http模式，在有代理的前提下，只要配置一个代理即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>ss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>socks5<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">host</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span>&gt;</span>1080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要注意的是监控一下端口，如果代理没开的话那肯定是无法连接上的，mirror就不用设置了，直接从中央仓库拉去数据。</p><h3 id="npm更换源"><a href="#npm更换源" class="headerlink" title="npm更换源"></a>npm更换源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//设置淘宝源</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">//设置公司的源</span><br><span class="line">npm config set registry http://127.0.0.1:4873</span><br><span class="line"></span><br><span class="line">//查看源，可以看到设置过的所有的源</span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>其实感觉应该把Mac管理node的brew n弄一下</p><h3 id="HDFS的某个错误"><a href="#HDFS的某个错误" class="headerlink" title="HDFS的某个错误"></a>HDFS的某个错误</h3><p>HBase和Flink在运行的时候报错</p><p>hbase启动后region自动挂了，Flink任务失败，文件丢失，然后查看hdfs日志</p><p>错误原因 dfs.datanode.max.transfer.threads 的参数4096，已经不足以支持现在的Thread，修改为2倍或者4倍或者更多</p><h3 id="IDEA-MAVEN停止加载"><a href="#IDEA-MAVEN停止加载" class="headerlink" title="IDEA MAVEN停止加载"></a>IDEA MAVEN停止加载</h3><p>经常遇到大型项目idea 停止加载mvn，然后就没办法了。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maven -&gt; maven goal idea的maven第六个按钮</span><br><span class="line">点击 然后</span><br><span class="line">mvn -U idea:idea</span><br><span class="line">即可</span><br></pre></td></tr></table></figure><h3 id="窗口触发的一些问题"><a href="#窗口触发的一些问题" class="headerlink" title="窗口触发的一些问题"></a>窗口触发的一些问题</h3><p>窗口是按 watermark 触发的，watermark 如果没有前进到 window end ， window 是不会触发的。</p><p>Flink的窗口触发具体机制需要去源码里面探寻</p><h3 id="Flink-SQL中的爆炸函数"><a href="#Flink-SQL中的爆炸函数" class="headerlink" title="Flink SQL中的爆炸函数"></a>Flink SQL中的爆炸函数</h3><p>Lateral View() 在Flink SQL中是unnest</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">users</span>, tag <span class="keyword">FROM</span> Orders <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> <span class="keyword">UNNEST</span>(tags) <span class="keyword">AS</span> t (tag)</span><br></pre></td></tr></table></figure><h3 id="Flink-UI在Yarn下"><a href="#Flink-UI在Yarn下" class="headerlink" title="Flink UI在Yarn下"></a>Flink UI在Yarn下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flink UI 在 Yarn下很多选线卡看不到详细信息，很正常，因为Yarn这个运行模式有的消息只能在Yarn上管理控制</span><br></pre></td></tr></table></figure><h3 id="Flink的时区问题"><a href="#Flink的时区问题" class="headerlink" title="Flink的时区问题"></a>Flink的时区问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flink的时间戳差了8个小时，可以用时间减去八个小时时差，生成一个减去8小时的列，作为watermark的时间戳。</span><br></pre></td></tr></table></figure><h3 id="Flink的心跳需求问题"><a href="#Flink的心跳需求问题" class="headerlink" title="Flink的心跳需求问题"></a>Flink的心跳需求问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用flink sql在实时计算当天凌晨截止到现在的累计数据的时候，计算步长是10分钟，如果这10分钟内没有新数据达到的话，现在的情况是这10分钟没有写记录，这就会造成业务查这个数据的时候需要找last value这种情形，设计一条方案让没有数据到达的时候也生成一条记录，这条记录的值就是last value。</span><br><span class="line"></span><br><span class="line">方案：</span><br><span class="line">往数据源发心跳数据。</span><br><span class="line">发送的数据格式和普通数据一样，只是这些数据不影响你的 agg 计算，比如 null 值。发送频率就根据需求去确定。</span><br></pre></td></tr></table></figure><h3 id="Flink避免重复劳动的一些方法"><a href="#Flink避免重复劳动的一些方法" class="headerlink" title="Flink避免重复劳动的一些方法"></a>Flink避免重复劳动的一些方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.写DDL+DML分别声明数据源和进行数据处理。</span><br><span class="line">2.groovy+ 规则引擎</span><br></pre></td></tr></table></figure><p>oppo：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gg3fk4uvm2j20j50b1wgo.jpg" alt="微信截图_20200624155221.png"></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gg3floj82tj20go0bw0v5.jpg" alt="FF36AEE6-1E6D-44da-80BB-9BD2FE8142D6.png"></p><h3 id="Flink配置参数"><a href="#Flink配置参数" class="headerlink" title="Flink配置参数"></a>Flink配置参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 开启 distinct agg 切分 </span><br><span class="line">table.optimizer.distinct-agg.split.enabled=true</span><br><span class="line"># 开启两阶段 即local-global 􏰝优化</span><br><span class="line">table.optimizer.agg-phase-strategy=TWO_PHASE</span><br><span class="line"># mini-batch 开启微批操作 </span><br><span class="line">table.exec.mini-batch.enabled=true</span><br><span class="line"># mini-batch的时间间隔，即作业需要额外忍受的延迟</span><br><span class="line">table.exec.mini-batch.allow-latency=5s</span><br><span class="line"># 一个节点中允许最多缓存的数据</span><br><span class="line">table.exec.mini-batch.size=5000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TableEnvironment tEnv = ...</span><br><span class="line"></span><br><span class="line">// access flink configuration</span><br><span class="line">Configuration configuration = tEnv.getConfig().getConfiguration();</span><br><span class="line">// set low-level key-value options</span><br><span class="line">configuration.setString(&quot;table.exec.mini-batch.enabled&quot;, &quot;true&quot;);</span><br><span class="line">configuration.setString(&quot;table.exec.mini-batch.allow-latency&quot;, &quot;5 s&quot;);</span><br><span class="line">configuration.setString(&quot;table.exec.mini-batch.size&quot;, &quot;5000&quot;);</span><br></pre></td></tr></table></figure><h3 id="Flink-GlobalWindow"><a href="#Flink-GlobalWindow" class="headerlink" title="Flink GlobalWindow"></a>Flink GlobalWindow</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function">def <span class="title">testJoin</span><span class="params">()</span>: Unit </span>=&#123;</span><br><span class="line">   val env = StreamExecutionEnvironment.getExecutionEnvironment</span><br><span class="line">   env.setParallelism(<span class="number">3</span>)</span><br><span class="line">   val person = env.fromElements((<span class="string">"1"</span>,<span class="string">"小张"</span>),(<span class="string">"2"</span>,<span class="string">"小刘"</span>),(<span class="string">"3"</span>,<span class="string">"小力"</span>),(<span class="string">"4"</span>,<span class="string">"小心"</span>))</span><br><span class="line">   val money = env.fromElements((<span class="string">"1"</span>,<span class="number">100</span>),(<span class="string">"2"</span>,<span class="number">200</span>),(<span class="string">"3"</span>,<span class="number">300</span>))</span><br><span class="line">   person.join(money)</span><br><span class="line">     .where(_._1)</span><br><span class="line">     .equalTo(_._1)</span><br><span class="line">     .window(GlobalWindows.create())</span><br><span class="line">     .apply((x,y) =&gt;&#123;</span><br><span class="line">       println( x+<span class="string">"==="</span>+y)</span><br><span class="line">       <span class="string">"xxx"</span></span><br><span class="line">      &#125;).print()</span><br><span class="line">   env.execute()</span><br><span class="line">   println(<span class="string">"end"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>无法运行，加个triggle(xxx)解决，默认是NeverTrigger</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">.window....</span><br><span class="line">.trigger(CountTrigger.of(1))</span><br><span class="line">.apply...</span><br></pre></td></tr></table></figure><h3 id="如何排查Kafka消息的异常"><a href="#如何排查Kafka消息的异常" class="headerlink" title="如何排查Kafka消息的异常"></a>如何排查Kafka消息的异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录住报错时的kafka offset，然后分阶段打印到控制台，再对比一下，把输出的格式分别调为Row.class 以前pojo类，或注释下一阶段代码，回放kafka 故障的offset数据，各个stream排查</span><br></pre></td></tr></table></figure><h3 id="MySQL的迁移"><a href="#MySQL的迁移" class="headerlink" title="MySQL的迁移"></a>MySQL的迁移</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--涉及到MySQL的迁移，我这边推荐少量数据的话使用MySQLDump.</span><br><span class="line">--还涉及到mysql安装在docker里的情况</span><br><span class="line">--mysqldump的用法</span><br><span class="line">    --备份所有数据库：</span><br><span class="line"></span><br><span class="line">    mysqldump -uroot -p --all-databases &gt; /backup/mysqldump/all.db</span><br><span class="line">    --备份指定数据库：</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p test &gt; /backup/mysqldump/test.db</span><br><span class="line">    --备份指定数据库指定表(多个表以空格间隔)</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p  mysql db event &gt; /backup/mysqldump/2table.db</span><br><span class="line">    --备份指定数据库排除某些表</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p test --ignore-table=test.t1 --ignore-table=test.t2 &gt; /backup/mysqldump/test2.db</span><br><span class="line">    --Docker进入mysql容器</span><br><span class="line">docker exec -it mysql1 bash //mysql1是我启动的mysql服务的name</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">--带docker的命令</span><br><span class="line">1.查看当前启动的mysql运行容器</span><br><span class="line"></span><br><span class="line">docker ps </span><br><span class="line"></span><br><span class="line">2.使用以下命令备份导出数据库中的所有表结构和数据</span><br><span class="line"></span><br><span class="line">docker exec -it  mysql mysqldump -uroot -p123456 paas_portal &gt; /cloud/sql/paas_portal.sql</span><br><span class="line">3.只导数据不导结构</span><br><span class="line"></span><br><span class="line">    mysqldump　-t　数据库名　-uroot　-p　&gt;　xxx.sql　</span><br><span class="line"></span><br><span class="line">docker exec -it mysql mysqldump -t -uroot -p123456 paas_portal &gt;/cloud/sql/paas_portal_dml.sql</span><br><span class="line">4.只导结构不导数据</span><br><span class="line"></span><br><span class="line">mysqldump　--opt　-d　数据库名　-u　root　-p　&gt;　xxx.sql　</span><br><span class="line"></span><br><span class="line">docker exec -it mysql mysqldump  --opt -d   -uroot -p123456 paas_portal &gt;/cloud/sql/paas_portal_ddl.sql</span><br><span class="line"></span><br><span class="line">5.导出特定表的结构</span><br><span class="line"></span><br><span class="line">mysqldump　-uroot　-p　-B　数据库名　--table　表名　&gt;　xxx.sql</span><br><span class="line"></span><br><span class="line">docker exec -it mysql mysqldump -uroot -p -B paas_portal --table user &gt; user.sql</span><br></pre></td></tr></table></figure><h3 id="远程调试Flink"><a href="#远程调试Flink" class="headerlink" title="远程调试Flink"></a>远程调试Flink</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gghbc3d8shj20le0jvtab.jpg" alt="TIM截图20200706160357.png"></p><p><a href="https://stackoverflow.com/questions/34816847/debugging-on-the-remote-cluster" target="_blank" rel="noopener">https://stackoverflow.com/questions/34816847/debugging-on-the-remote-cluster</a></p><h3 id="Log4J-和-slf4j联合使用"><a href="#Log4J-和-slf4j联合使用" class="headerlink" title="Log4J 和 slf4j联合使用"></a>Log4J 和 slf4j联合使用</h3><p>slf4j是什么？slf4j只是定义了一组日志接口，但并未提供任何实现，既然这样，为什么要用slf4j呢？log4j不是已经满足要求了吗？</p><p>是的，log4j满足了要求，但是，日志框架并不只有log4j一个，你喜欢用log4j，有的人可能更喜欢logback，有的人甚至用jdk自带的日志框架，这种情况下，如果你要依赖别人的jar，整个系统就用了两个日志框架，如果你依赖10个jar，每个jar用的日志框架都不同，岂不是一个工程用了10个日志框架，那就乱了！</p><p>如果你的代码使用slf4j的接口，具体日志实现框架你喜欢用log4j，其他人的代码也用slf4j的接口，具体实现未知，那你依赖其他人jar包时，整个工程就只会用到log4j日志框架，这是一种典型的门面模式应用，与jvm思想相同，我们面向slf4j写日志代码，slf4j处理具体日志实现框架之间的差异，正如我们面向jvm写java代码，jvm处理操作系统之间的差异，结果就是，一处编写，到处运行。况且，现在越来越多的开源工具都在用slf4j了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后，弄到slf4j与log4j的关联jar包，通过这个东西，将对slf4j接口的调用转换为对log4j的调用，不同的日志实现框架，这个转换工具不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>以及原来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="Log4J2的使用"><a href="#Log4J2的使用" class="headerlink" title="Log4J2的使用"></a>Log4J2的使用</h3><h4 id="Log4J2和Log4J1的比较"><a href="#Log4J2和Log4J1的比较" class="headerlink" title="Log4J2和Log4J1的比较"></a>Log4J2和Log4J1的比较</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>log4j是通过一个**.properties<strong>的文件作为主配置文件的，而现在的log4j 2则已经弃用了这种方式，采用的是</strong>.xml，.json或者.jsn**这种方式。</p><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>log4j只需要引入一个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>log4j 2则是需要2个核心</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><p>log4J.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#此句为定义名为stdout的输出端是哪种类型，可以是</span><br><span class="line">#org.apache.log4j.ConsoleAppender（控制台），</span><br><span class="line">#org.apache.log4j.FileAppender（文件），</span><br><span class="line">#org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span><br><span class="line">#org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</span><br><span class="line">#org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line"></span><br><span class="line">#此句为定义名为stdout的输出端的layout是哪种类型，可以是</span><br><span class="line">#org.apache.log4j.HTMLLayout（以HTML表格形式布局），</span><br><span class="line">#org.apache.log4j.PatternLayout（可以灵活地指定布局模式），</span><br><span class="line">#org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），</span><br><span class="line">#org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line"></span><br><span class="line">#如果使用pattern布局就要指定的打印信息的具体格式ConversionPattern，打印参数如下：</span><br><span class="line">#%m 输出代码中指定的消息</span><br><span class="line">#%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</span><br><span class="line">#%r 输出自应用启动到输出该log信息耗费的毫秒数</span><br><span class="line">#%c 输出所属的类目，通常就是所在类的全名</span><br><span class="line">#%t 输出产生该日志事件的线程名</span><br><span class="line">#%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”</span><br><span class="line">#%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式</span><br><span class="line">#比如：%d&#123;yyyy MMM dd HH:mm:ss,SSS&#125; 输出类似：2002年10月18日 22：10：28，921</span><br><span class="line">#%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。</span><br><span class="line">#[Log4JDemo]是log信息的开头，可以为任意字符，一般为项目简称。</span><br><span class="line">#log4j.appender.stdout.layout.ConversionPattern=[Log4JDemo] %p [%t] %C.%M(%L) | %m%n</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=[Log4JDemo] %p [%t] %C.%M(%L) | %m%n</span><br><span class="line"></span><br><span class="line">#设置日志文件</span><br><span class="line">log4j.appender.LogFile=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.LogFile.File=log4j.log</span><br><span class="line">log4j.appender.LogFile.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.LogFile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l  %m%n</span><br><span class="line"></span><br><span class="line">#此句为将等级为ALL的日志信息输出到stdout和LogFile这两个目的地</span><br><span class="line">#stdout和R的定义在下面的代码，可以任意起名</span><br><span class="line">#等级可分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</span><br><span class="line">#如果配置OFF则不打出任何信息</span><br><span class="line">#如果配置为INFO这样只显示INFO, WARN, ERROR的log信息，而DEBUG信息不会被显示，</span><br><span class="line">#log4j.rootCategory=ERROR,stdout,LogFile</span><br><span class="line">#log4j.rootCategory=ERROR,LogFile</span><br><span class="line">log4j.rootCategory=ERROR,stdout</span><br></pre></td></tr></table></figure><p>log4j2.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--先定义所有的appender--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--这个输出控制台的配置--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--输出日志的格式--&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"log"</span> <span class="attr">fileName</span>=<span class="string">"log/test.log"</span> <span class="attr">append</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileInfo"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/info.log"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">filePattern</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log"</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>        </span><br><span class="line">             <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100 MB"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileWarn"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/warn.log"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">filePattern</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"warn"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100 MB"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileError"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/error.log"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">filePattern</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"error"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100 MB"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.springframework"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.mybatis"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"all"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileInfo"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileWarn"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileError"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>log4j</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger LOGGER = Logger.getLogger(Test<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br></pre></td></tr></table></figure><p>log4j2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Level;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger(Test<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br></pre></td></tr></table></figure><h3 id="Spark-On-Yarn-结束任务的方式"><a href="#Spark-On-Yarn-结束任务的方式" class="headerlink" title="Spark On Yarn 结束任务的方式"></a>Spark On Yarn 结束任务的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、yarn app -kill  appid 丢数据或者多数据</span><br><span class="line">2、kill -15  pid        丢数据或者多数据</span><br><span class="line">3、监听http或hdfs目录方式     ok</span><br><span class="line">建议大家用第三种方式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们用的第一种 针对丢数据或者多数据 我们代码里把实时过来的数据checkpoint 下一次再跑的时候会去mysql里修改offset Kafka再读进来的数据和上次checkpoint的数据对比一下 去重</span><br></pre></td></tr></table></figure><h3 id="CharSequence"><a href="#CharSequence" class="headerlink" title="CharSequence"></a>CharSequence</h3><p>第一次见到这个CharSequence的时候感觉挺疑惑的，不知道为什么要有这个东西。这个CharSequence是String和Stringbuilder共同实现的接口类，在下面这种应用场景中，只有CharSequence是适用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">StringBuilder strbu = <span class="keyword">new</span> StringBuilder(<span class="string">"def"</span>);</span><br><span class="line"><span class="keyword">boolean</span> boo = <span class="keyword">true</span>;</span><br><span class="line">CharSequence cs = boo?str:strbu;</span><br></pre></td></tr></table></figure><h3 id="并发编程，创建多少个线程合适"><a href="#并发编程，创建多少个线程合适" class="headerlink" title="并发编程，创建多少个线程合适"></a>并发编程，创建多少个线程合适</h3><p>分为两种情况讨论，CPU密集型和 I/O密集型</p><p>在CPU密集型的程序中，理论上 线程数量 = CPU 核数（逻辑）就可以了，但是实际上，数量一般会设置为 CPU 核数（逻辑）+ 1，</p><blockquote><p>计算(CPU)密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。</p></blockquote><p>在I/O密集型程序的程序中，单核心线程数一般来说是这么设置的：</p><blockquote><p>最佳线程数 = (1/CPU利用率) = 1 + (I/O耗时/CPU耗时)</p></blockquote><p>多核心的线程数为：</p><blockquote><p>最佳线程数 = CPU核心数 * (1/CPU利用率) = CPU核心数 * (1 + (I/O耗时/CPU耗时))</p></blockquote><p>如果都是IO耗时的话，可以从纯理论上直接回答是2N或者2N+1</p><p>还有很多APM（Application Performance Manager）工具可以帮我们得到具体的数据比如 SkyWalking、CAT、zipkin</p><blockquote><p>假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s</p></blockquote><p>如何设计线程个数，使得可以在1s内处理完20个Transaction？</p><p>但是，但是，这是因为没有考虑到CPU数目。家里又没矿，一般服务器的CPU核数为16或者32，如果有80个线程，那么肯定会带来太多不必要的线程上下文切换开销（希望这句话你可以主动说出来），这就需要调优了，来做到最佳 balance</p><blockquote><p>计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？</p></blockquote><p>线程数 = 8 * (1 + 100/5) = 168 (个)</p><h3 id="Google-AutoValue"><a href="#Google-AutoValue" class="headerlink" title="Google AutoValue"></a>Google AutoValue</h3><p>Google的 AutoValue 用起来说实话不是特别方便，对于一些需要用到映射的支持也不是十分友好，总之一句话，在国内的生态下是不太适合使用的，虽然<code>EffectiveJava</code>的作者嗯吹这个组件。</p><p><a href="https://www.jianshu.com/p/e778e96fb751" target="_blank" rel="noopener">https://www.jianshu.com/p/e778e96fb751</a></p><p>这篇博客和AutoValue在Github上面自己的文档算是讲的比较好一点的文档。</p><h3 id="Idea-注释模板设置"><a href="#Idea-注释模板设置" class="headerlink" title="Idea 注释模板设置"></a>Idea 注释模板设置</h3><p><a href="https://blog.csdn.net/shadow_zed/article/details/80551460#commentBox" target="_blank" rel="noopener">https://blog.csdn.net/shadow_zed/article/details/80551460#commentBox</a></p><h3 id="Python中使用-join-替代-处理字符串"><a href="#Python中使用-join-替代-处理字符串" class="headerlink" title="Python中使用.join()替代+处理字符串"></a>Python中使用<code>.join()</code>替代<code>+</code>处理字符串</h3><p><a href="https://towardsdatascience.com/do-not-use-to-join-strings-in-python-f89908307273" target="_blank" rel="noopener">https://towardsdatascience.com/do-not-use-to-join-strings-in-python-f89908307273</a></p><h3 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h3><p>1.使用<code>CDN </code>等技术替代数据库存储。</p><p>2.存储选择特殊文件系统，比如S3、淘宝的TFS等等</p><p>数据库里面尽量只要写路径</p><h3 id="java的一些包的解释"><a href="#java的一些包的解释" class="headerlink" title="java的一些包的解释"></a>java的一些包的解释</h3><p><strong>PO(persistant object) 持久对象</strong><br>在o/r映射的时候出现的概念，如果没有o/r映射，没有这个概念存在了。通常对应数据模型(数据库),本身还有部分业务逻辑的处理。可以看成是与数据库 中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。</p><p><strong>VO(value object) 值对象</strong><br>通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递。</p><p><strong>TO(Transfer Object)，数据传输对象</strong><br>在应用程序不同tie(关系)之间传输的对象</p><p><strong>BO(business object) 业务对象</strong><br>从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</p><p><strong>POJO(plain ordinary java object)</strong> </p><p>简单无规则java对象<br>纯的传统意义的java对象。就是说在一些Object/Relation Mapping工具中，能够做到维护数据库表记录的persisent object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java Bean，只有属性字段及setter和getter方法。</p><p><strong>DAO(data access object) 数据访问对象</strong><br>是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使 用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO, 提供数据库的CRUD操作…</p><h3 id="IDEA2020-显示内存大小"><a href="#IDEA2020-显示内存大小" class="headerlink" title="IDEA2020 显示内存大小"></a>IDEA2020 显示内存大小</h3><p>双击shift 填入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show memory indicator</span><br></pre></td></tr></table></figure><p>在里面打开<code>ON</code></p><h3 id="Java程序结束前运行的代码"><a href="#Java程序结束前运行的代码" class="headerlink" title="Java程序结束前运行的代码"></a>Java程序结束前运行的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"repeat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当使用 kill pid 或者 kill -15 pid的时候这个部分是会执行后才关闭程序的</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关闭"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java8-try-…catch"><a href="#Java8-try-…catch" class="headerlink" title="Java8 try()…catch()"></a>Java8 try()…catch()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个FileWriter会自己关掉</span></span><br><span class="line"><span class="keyword">try</span>(FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>)) &#123;</span><br><span class="line">    fw.write(<span class="string">"test"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们使用try…catch()捕获异常的，如果遇到类似IO流的处理，要在finally部分关闭IO流，当然这个是JDK1.7之前的写法了；在JDK7优化后的<code>try-with-resource</code>语句，该语句确保了每个资源,在语句结束时关闭。所谓的资源是指在程序完成后，必须关闭的流对象。写在()里面的流对象对应的类都实现了自动关闭接口AutoCloseable。</p><h3 id="idea中设置maven的jvm参数"><a href="#idea中设置maven的jvm参数" class="headerlink" title="idea中设置maven的jvm参数"></a>idea中设置maven的jvm参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file-&gt;setting-&gt;Build,Execution,Deployment-&gt;Maven-&gt;Runner</span><br><span class="line">VM option栏设置jvm参数，-Xmx1g -XX:MaxMetaspaceSize=128m</span><br></pre></td></tr></table></figure><h3 id="命令行中设置maven的jvm参数"><a href="#命令行中设置maven的jvm参数" class="headerlink" title="命令行中设置maven的jvm参数"></a>命令行中设置maven的jvm参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 可以在mvn.cmd（linux中是mvn.sh或mvn）添加set MAVEN_OPTS=-Xmx1g -XX:MaxMetaspaceSize=128m</span><br><span class="line">2. 也可以添加MAVEN_OPTS环境变量</span><br></pre></td></tr></table></figure><h3 id="String-SubString"><a href="#String-SubString" class="headerlink" title="String SubString"></a>String SubString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">String Str = <span class="keyword">new</span> String(<span class="string">"www.runoob.com"</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"返回值 :"</span> );</span><br><span class="line">System.out.println(Str.substring(<span class="number">4</span>) );</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"返回值 :"</span> );</span><br><span class="line">System.out.println(Str.substring(<span class="number">4</span>, <span class="number">10</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回值 :runoob.com</span><br><span class="line">返回值 :runoob</span><br></pre></td></tr></table></figure><h3 id="通用的空间-地理空间ASL许可的开源Java库"><a href="#通用的空间-地理空间ASL许可的开源Java库" class="headerlink" title="通用的空间/地理空间ASL许可的开源Java库"></a>通用的空间/地理空间ASL许可的开源Java库</h3><p><em>Spatial4j</em></p><h3 id="IntegerCache"><a href="#IntegerCache" class="headerlink" title="IntegerCache"></a>IntegerCache</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gidwsbcl2aj20jn0k1ab1.jpg" alt="QzpcVXNlcnNcZmx5aG9cQXBwRGF0YVxSb2FtaW5nXERpbmdUYWxrXDExMzI4MDM2MF92MlxJbWFnZUZpbGVzXDIxODg5NzUyOFwxNTk5MTQ4OTI2NTQ3XzAwNjc2REI3LTEwMUYtNDFmNi04RDg1LTQxRDUxNEJENTZGMS5wbmc=.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1000</span>, b = <span class="number">1000</span>;</span><br><span class="line">    System.out.println(a == b);<span class="comment">//1</span></span><br><span class="line">    Integer c = <span class="number">100</span>, d = <span class="number">100</span>;</span><br><span class="line">    System.out.println(c == d);<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>false<br>true</p><p>因为存在这个IntegerCache，-128-127范围内是有Cache对象的，不会新生成。</p><h3 id="书单推荐"><a href="#书单推荐" class="headerlink" title="书单推荐"></a>书单推荐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">《Effective Java中文版》</span><br><span class="line">《实战Java虚拟机：JVM故障诊断与性能优化》</span><br><span class="line">《HotSpot实战》</span><br><span class="line">《实战Java高并发程序设计》</span><br><span class="line">《深入分析Java Web技术内幕》</span><br><span class="line">《大型网站技术架构 核心原理与案例分析》</span><br><span class="line">《大型网站系统与Java中间件实践》</span><br><span class="line">《从Paxos到ZooKeeper 分布式一致性原理与实践》</span><br><span class="line">《代码大全（第2版） 》</span><br><span class="line">《算法导论》</span><br><span class="line">《计算机程序设计艺术》</span><br><span class="line">《重构》</span><br><span class="line">《设计模式》</span><br><span class="line">《人月神话》</span><br><span class="line">《程序员修炼之道》</span><br></pre></td></tr></table></figure><h3 id="反射API"><a href="#反射API" class="headerlink" title="反射API"></a>反射API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.draft.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 反射</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-09-04 14:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefleactionAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"https://www.baidu.com"</span>);</span><br><span class="line">        String urlString = url.toExternalForm();</span><br><span class="line">        System.out.println(urlString);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"==============等价==============&gt;"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; type = Class.forName(<span class="string">"java.net.URL"</span>);</span><br><span class="line">        Constructor&lt;?&gt; constructor = type.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Object instance = constructor.newInstance(<span class="string">"https://www.baidu.com"</span>);</span><br><span class="line">        Method method = type.getMethod(<span class="string">"toExternalForm"</span>);</span><br><span class="line">        Object methodCallResult = method.invoke(instance);</span><br><span class="line"></span><br><span class="line">        System.out.println(methodCallResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的Java 反射API，还需要更深入的了解</p><h3 id="最详细的Anaconda安装步骤和注意点"><a href="#最详细的Anaconda安装步骤和注意点" class="headerlink" title="最详细的Anaconda安装步骤和注意点"></a>最详细的Anaconda安装步骤和注意点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/32925500</span><br></pre></td></tr></table></figure><h3 id="CUDA-Driver版本选型"><a href="#CUDA-Driver版本选型" class="headerlink" title="CUDA Driver版本选型"></a>CUDA Driver版本选型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#cuda-major-component-versions</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gihww4dllgj20zl0kldkg.jpg" alt="{291168FC-C79D-4F29-AE0B-DA3E3184D006}_20200907110920.jpg"></p><h3 id="CuDNN版本"><a href="#CuDNN版本" class="headerlink" title="CuDNN版本"></a>CuDNN版本</h3><p>CuDNN的版本是和CUDA版本对应，下载页面就能看到，安装十分简单，三个文件夹的文件和外面的一个文件，单独复制到已经安装好的CUDA文件夹中即可。</p><h3 id="Maven-阿里云插件仓库配置"><a href="#Maven-阿里云插件仓库配置" class="headerlink" title="Maven 阿里云插件仓库配置"></a>Maven 阿里云插件仓库配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-plugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="IDEA配置仓库最好用HTTPS"><a href="#IDEA配置仓库最好用HTTPS" class="headerlink" title="IDEA配置仓库最好用HTTPS"></a>IDEA配置仓库最好用HTTPS</h3><p>Win上有可能出现如下错误，mac上却没问题，佛了</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gilaolon3sj20n603n0wj.jpg" alt="QzpcVXNlcnNcQWRtaW5pc3RyYXRvclxBcHBEYXRhXFJvYW1pbmdcRGluZ1RhbGtcMzU1NTg3MDEyX3YyXEltYWdlRmlsZXNcMjE4ODk3NTI4XDE1OTk3MDA4MzA4MTBfNkQxRUYzMkItMURFMy00MjE1LThEODMtQ0M5ODMzOTdFMDY2LnBuZw==.png"></p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p><strong>五个常用框架</strong></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1giynphltjjj20jx0acdfu.jpg" alt="undefined"></p><p>1.spring framework<br>也就是我们经常说的spring框架，包括了ioc依赖注入，Context上下文、bean管理、springmvc等众多功能模块，其它spring项目比如spring boot也会依赖spring框架。</p><p>2.spring boot<br>它的目标是简化Spring应用和服务的创建、开发与部署，简化了配置文件，使用嵌入式web服务器，含有诸多开箱即用的微服务功能，可以和spring cloud联合部署。</p><p>Spring Boot的核心思想是约定大于配置，应用只需要很少的配置即可，简化了应用开发模式。</p><p>3.Spring Data<br>是一个数据访问及操作的工具集，封装了多种数据源的操作能力，包括：jdbc、Redis、MongoDB等。</p><p>4.Spring Cloud<br>是一套完整的微服务解决方案，是一系列不同功能的微服务框架的集合。Spring Cloud基于Spring Boot，简化了分布式系统的开发，集成了服务发现、配置管理、消息总线、负载均衡、断路器、数据监控等各种服务治理能力。比如sleuth提供了全链路追踪能力，Netflix套件提供了hystrix熔断器、zuul网关等众多的治理组件。config组件提供了动态配置能力，bus组件支持使用RabbitMQ、kafka、Activemq等消息队列，实现分布式服务之间的事件通信。</p><p>5.Spring Security<br>主要用于快速构建安全的应用程序和服务，在Spring Boot和Spring Security OAuth2的基础上，可以快速实现常见安全模型，如单点登录，令牌中继和令牌交换。你可以了解一下oauth2授权机制和jwt认证方式。oauth2是一种授权机制，规定了完备的授权、认证流程。JWT全称是JSON Web Token，是一种把认证信息包含在token中的认证实现，oauth2授权机制中就可以应用jwt来作为认证的具体实现方法。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1giynqh3y5rj20st0btmxe.jpg" alt="undefined"></p><p>本文涉及的流程与实现默认都是基于最新的5.x版本。</p><p>spring中的几个重要概念如下：</p><h4 id="1-IOC"><a href="#1-IOC" class="headerlink" title="1.IOC"></a>1.IOC</h4><p>IOC，就是控制反转，如最左边，拿公司招聘岗位来举例：</p><p>假设一个公司有产品、研发、测试等岗位。如果是公司根据岗位要求，逐个安排人选，如图中向下的箭头，这是正向流程。如果反过来，不用公司来安排候选人，而是由第三方猎头来匹配岗位和候选人，然后进行推荐，如图中向上的箭头，这就是控制反转。</p><p>在spring中，对象的属性是由对象自己创建的，就是正向流程；如果属性不是对象创建，而是由spring来自动进行装配，就是控制反转。这里的DI也就是依赖注入，就是实现控制反转的方式。正向流程导致了对象于对象之间的高耦合，IOC可以解决对象耦合的问题，有利于功能的复用，能够使程序的结构变得非常灵活。</p><h4 id="2-context上下文和bean"><a href="#2-context上下文和bean" class="headerlink" title="2.context上下文和bean"></a>2.context上下文和bean</h4><p>spring进行IOC实现时使用的有两个概念：context上下文和bean。</p><p>如中间图所示，所有被spring管理的、由spring创建的、用于依赖注入的对象，就叫做一个bean。Spring创建并完成依赖注入后，所有bean统一放在一个叫做context的上下文中进行管理。</p><h4 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3.AOP"></a>3.AOP</h4><p>AOP就是面向切面编程。如右面的图，一般程序执行流程是从controller层调用service层、然后service层调用DAO层访问数据，最后在逐层返回结果。</p><p>这个是图中向下箭头所示的按程序执行顺序的纵向处理。但是，一个系统中会有多个不同的服务，例如用户服务、商品信息服务等等，每个服务的controller层都需要验证参数，都需要处理异常，如果按照图中红色的部分，对不同服务的纵向处理流程进行横切，在每个切面上完成通用的功能，例如身份认证、验证参数、处理异常等等、这样就不用在每个服务中都写相同的逻辑了，这就是AOP思想解决的问题。</p><p>AOP以功能进行划分，对服务顺序执行流程中的不同位置进行横切，完成各服务共同需要实现的功能。</p><h3 id="Java加载properties的六种方式"><a href="#Java加载properties的六种方式" class="headerlink" title="Java加载properties的六种方式"></a>Java加载properties的六种方式</h3><p>Java加载properties文件的方式主要分为两大类：</p><p>一种是通过<code>import java.util.Properties</code>类中的<code>load(InputStream in)</code>方法加载；</p><p>另一种是通过<code>import java.util.ResourceBundle</code>类的<code>getBundle(String baseName)</code>方法加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.PropertyResourceBundle;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesUtil</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String basePath = <span class="string">"src/prop.properties"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String nickname = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">""</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 一、 使用java.util.Properties类的load(InputStream in)方法加载properties文件</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">      InputStream is = <span class="keyword">new</span> FileInputStream(basePath);</span><br><span class="line">      prop.load(is);</span><br><span class="line">      name = prop.getProperty(<span class="string">"username"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 二、 使用class变量的getResourceAsStream()方法</span></span><br><span class="line"><span class="comment">   * 注意：getResourceAsStream()读取路径是与本类的同一包下</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    InputStream is = PropertiesUtil<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">        .getResourceAsStream("/com/util/prop.properties");</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      prop.load(is);</span><br><span class="line">      name = prop.getProperty(<span class="string">"username"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 三、</span></span><br><span class="line"><span class="comment">   * 使用class.getClassLoader()所得到的java.lang.ClassLoader的getResourceAsStream()方法</span></span><br><span class="line"><span class="comment">   * getResourceAsStream(name)方法的参数必须是包路径+文件名+.后缀 否则会报空指针异常</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    InputStream is = PropertiesUtil<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span></span><br><span class="line">        .getResourceAsStream("com/util/prop.properties");</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      prop.load(is);</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 四、 使用java.lang.ClassLoader类的getSystemResourceAsStream()静态方法</span></span><br><span class="line"><span class="comment">   * getSystemResourceAsStream()方法的参数格式也是有固定要求的</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    InputStream is = ClassLoader</span><br><span class="line">        .getSystemResourceAsStream(<span class="string">"com/util/prop.properties"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      prop.load(is);</span><br><span class="line">      name = prop.getProperty(<span class="string">"username"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 五、 使用java.util.ResourceBundle类的getBundle()方法</span></span><br><span class="line"><span class="comment">   * 注意：这个getBundle()方法的参数只能写成包路径+properties文件名，否则将抛异常</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceBundle rb = ResourceBundle.getBundle(<span class="string">"com/util/prop"</span>);</span><br><span class="line">    password = rb.getString(<span class="string">"password"</span>);</span><br><span class="line">    <span class="keyword">return</span> password;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 六、 使用java.util.PropertyResourceBundle类的构造函数</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      InputStream is = <span class="keyword">new</span> FileInputStream(basePath);</span><br><span class="line">      ResourceBundle rb = <span class="keyword">new</span> PropertyResourceBundle(is);</span><br><span class="line">      nickname = rb.getString(<span class="string">"nickname"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> nickname;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"name1:"</span> + PropertiesUtil.getName1());</span><br><span class="line">    System.out.println(<span class="string">"name2:"</span> + PropertiesUtil.getName2());</span><br><span class="line">    System.out.println(<span class="string">"name3:"</span> + PropertiesUtil.getName3());</span><br><span class="line">    System.out.println(<span class="string">"name4:"</span> + PropertiesUtil.getName4());</span><br><span class="line">    System.out.println(<span class="string">"password:"</span> + PropertiesUtil.getName5());</span><br><span class="line">    System.out.println(<span class="string">"nickname:"</span> + PropertiesUtil.getName6());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPS第三方工具"><a href="#GPS第三方工具" class="headerlink" title="GPS第三方工具"></a>GPS第三方工具</h3><h4 id="GIS基本概念"><a href="#GIS基本概念" class="headerlink" title="GIS基本概念"></a>GIS基本概念</h4><ol><li>WKT(Well-known text)是开放地理空间联盟OGC（Open GIS Consortium ）制定的一种文本标记语言，用于表示矢量几何对象、空间参照系统及空间参照系统之间的转换。</li><li>WKB(well-known binary) 是WKT的二进制表示形式，解决了WKT表达方式冗余的问题，便于传输和在数据库中存储相同的信息</li><li>GeoJSON 一种JSON格式的Feature信息输出格式，它便于被JavaScript等脚本语言处理，OpenLayers等地理库便是采用GeoJSON格式。此外，TopoJSON等更精简的扩展格式</li></ol><h5 id="几何对象"><a href="#几何对象" class="headerlink" title="几何对象"></a>几何对象</h5><p>WKT可以表示的对象包括以下几种：</p><ul><li>Point, MultiPoint</li><li>LineString, MultiLineString</li><li>Polygon, MultiPolygon</li><li>GeometryCollection<ul><li>可以由多种Geometry组成，如：GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10)</li></ul></li></ul><table><thead><tr><th>Type</th><th>Shape</th><th>WKT</th><th>GeoJSON</th></tr></thead><tbody><tr><td>Point</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mlhtnkhj201f01f08k.jpg" alt="undefined"></td><td>POINT (30 10)</td><td>{ “type”: “Point”, “coordinates”: [30, 10] }</td></tr><tr><td>LineString</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mm3cj3lj201f01f0fv.jpg" alt="undefined"></td><td>LINESTRING (30 10, 10 30, 40 40)</td><td>{ “type”: “LineString”, “coordinates”: [ [30, 10], [10, 30], [40, 40] ] }</td></tr><tr><td>Polygon</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mn9522pj201f01f0n7.jpg" alt="undefined"></td><td>POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))</td><td>{ “type”: “Polygon”, “coordinates”: [ [[30, 10], [40, 40], [20, 40], [10, 20], [30, 10]] ] }</td></tr><tr><td>Polygon</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mntnasfj201f01fa9t.jpg" alt="undefined"></td><td>POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10),(20 30, 35 35, 30 20, 20 30))</td><td>{ “type”: “Polygon”, “coordinates”: [ [[35, 10], [45, 45], [15, 40], [10, 20], [35, 10]], [[20, 30], [35, 35], [30, 20], [20, 30]] ] }</td></tr><tr><td>MultiPoint</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mo9flxyj201f01f0b1.jpg" alt="undefined"></td><td>MULTIPOINT ((10 40), (40 30), (20 20), (30 10))</td><td>{ “type”: “MultiPoint”, “coordinates”: [ [10, 40], [40, 30], [20, 20], [30, 10] ] }</td></tr><tr><td>MultiPoint</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mo9flxyj201f01f0b1.jpg" alt="undefined"></td><td>MULTIPOINT (10 40, 40 30, 20 20, 30 10)</td><td>{ “type”: “MultiPoint”, “coordinates”: [ [10, 40], [40, 30], [20, 20], [30, 10] ] }</td></tr><tr><td>MultiLineString</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mqer9ahj201f01f0ge.jpg" alt="undefined"></td><td>MULTILINESTRING ((10 10, 20 20, 10 40),(40 40, 30 30, 40 20, 30 10))</td><td>{ “type”: “MultiLineString”, “coordinates”: [ [[10, 10], [20, 20], [10, 40]], [[40, 40], [30, 30], [40, 20], [30, 10]] ] }</td></tr><tr><td>MultiPolygon</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mqyv5g1j201f01f0sh.jpg" alt="undefined"></td><td>MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)),((15 5, 40 10, 10 20, 5 10, 15 5)))</td><td>{ “type”: “MultiPolygon”, “coordinates”: [ [ [[30, 20], [45, 40], [10, 40], [30, 20]] ], [ [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]] ] ] }</td></tr><tr><td>MultiPolygon</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mr4qybmj201f01fa9t.jpg" alt="undefined"></td><td>MULTIPOLYGON (((40 40, 20 45, 45 30, 40 40)),((20 35, 10 30, 10 10, 30 5, 45 20, 20 35),(30 20, 20 15, 20 25, 30 20)))</td><td>{ “type”: “MultiPolygon”, “coordinates”: [ [ [[40, 40], [20, 45], [45, 30], [40, 40]] ], [ [[20, 35], [10, 30], [10, 10], [30, 5], [45, 20], [20, 35]], [[30, 20], [20, 15], [20, 25], [30, 20]] ] ] }</td></tr></tbody></table><h4 id="WKB格式"><a href="#WKB格式" class="headerlink" title="WKB格式"></a>WKB格式</h4><p>WKB采用二进制进行存储，更方便于计算机处理，因此广泛运用于数据的传输与存储，以二位点Point(1 1)为例，</p><p>其WKB表达如下：</p><p>01 0100 0020 E6100000 000000000000F03F 000000000000F03F</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mtf7wtcj20i502sjrb.jpg" alt="undefined"></p><ol><li>byteOrder</li></ol><ul><li><p>表示编码方式，00为使用big-endian编码(XDR)，01为使用little-endian编码(NDR)。他们的不同仅限于在内存中放置字节的顺序，比如我们将0x1234abcd写入到以0×0000开始的内存中，则结果如下表：</p></li><li><table><thead><tr><th>Address</th><th>big-endian</th><th>little-endian</th></tr></thead><tbody><tr><td>0×0000</td><td>0x12</td><td>0xcd</td></tr><tr><td>0×0001</td><td>0x34</td><td>0xab</td></tr><tr><td>0×0002</td><td>0xab</td><td>0x34</td></tr><tr><td>0×0003</td><td>0xcd</td><td>0x12</td></tr></tbody></table></li></ul><ol start="2"><li>webTypd</li></ol><p>第二到第九字节对矢量数据基本信息进行了定义</p><ul><li>第二与第三个字节规定了矢量数据的类型，如例子中的0100代表Point；</li><li>第三与第四个字节规定了矢量数据的维数，如例子中的0020代表该点是二位的；</li><li>第五到第九个字节规定了矢量数据的空间参考SRID，如例子中的E6100000是4326的整数十六位进制表达</li></ul><ol start="3"><li>srid</li></ol><ul><li><em>第五到第九个字节规定了矢量数据的空间参考SRID，如例子中的E6100000是4326的整数十六位进制表达</em></li></ul><ol start="4"><li>structPoint</li></ol><ul><li><em>第十个字节开始，每16个字节就代表一个坐标对，如例子中的000000000000F03F是浮点型1的十六进制表达</em></li></ul><h4 id="JTS"><a href="#JTS" class="headerlink" title="JTS"></a>JTS</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ol><li><strong>JTS</strong>是加拿大的 Vivid Solutions公司做的一套开放源码的 Java API。它提供了一套空间数据操作的核心算法。为在兼容OGC标准的空间对象模型中进行基础的几何操作提供2D空间谓词API。</li></ol><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>表示Geometry对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.autonavi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.Coordinate;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.Geometry;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.GeometryCollection;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.GeometryFactory;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.LineString;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.LinearRing;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.Point;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.Polygon;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.MultiPolygon;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.MultiLineString;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.MultiPoint;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.io.ParseException;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.io.WKTReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeometryDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GeometryFactory geometryFactory = <span class="keyword">new</span> GeometryFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create a point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">createPoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Coordinate coord = <span class="keyword">new</span> Coordinate(<span class="number">109.013388</span>, <span class="number">32.715519</span>);</span><br><span class="line">        Point point = geometryFactory.createPoint( coord );</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create a point by WKT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">createPointByWKT</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        Point point = (Point) reader.read(<span class="string">"POINT (109.013388 32.715519)"</span>);</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create multiPoint by wkt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultiPoint <span class="title">createMulPointByWKT</span><span class="params">()</span><span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        MultiPoint mpoint = (MultiPoint) reader.read(<span class="string">"MULTIPOINT(109.013388 32.715519,119.32488 31.435678)"</span>);</span><br><span class="line">        <span class="keyword">return</span> mpoint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * create a line</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LineString <span class="title">createLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Coordinate[] coords  = <span class="keyword">new</span> Coordinate[] &#123;<span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>), <span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>)&#125;;</span><br><span class="line">        LineString line = geometryFactory.createLineString(coords);</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create a line by WKT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LineString <span class="title">createLineByWKT</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        LineString line = (LineString) reader.read(<span class="string">"LINESTRING(0 0, 2 0)"</span>);</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create multiLine </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultiLineString <span class="title">createMLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Coordinate[] coords1  = <span class="keyword">new</span> Coordinate[] &#123;<span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>), <span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>)&#125;;</span><br><span class="line">        LineString line1 = geometryFactory.createLineString(coords1);</span><br><span class="line">        Coordinate[] coords2  = <span class="keyword">new</span> Coordinate[] &#123;<span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>), <span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>)&#125;;</span><br><span class="line">        LineString line2 = geometryFactory.createLineString(coords2);</span><br><span class="line">        LineString[] lineStrings = <span class="keyword">new</span> LineString[<span class="number">2</span>];</span><br><span class="line">        lineStrings[<span class="number">0</span>]= line1;</span><br><span class="line">        lineStrings[<span class="number">1</span>] = line2;</span><br><span class="line">        MultiLineString ms = geometryFactory.createMultiLineString(lineStrings);</span><br><span class="line">        <span class="keyword">return</span> ms;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create multiLine by WKT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultiLineString <span class="title">createMLineByWKT</span><span class="params">()</span><span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        MultiLineString line = (MultiLineString) reader.read(<span class="string">"MULTILINESTRING((0 0, 2 0),(1 1,2 2))"</span>);</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create a polygon(多边形) by WKT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Polygon <span class="title">createPolygonByWKT</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        Polygon polygon = (Polygon) reader.read(<span class="string">"POLYGON((20 10, 30 0, 40 10, 30 20, 20 10))"</span>);</span><br><span class="line">        <span class="keyword">return</span> polygon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create multi polygon by wkt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultiPolygon <span class="title">createMulPolygonByWKT</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        MultiPolygon mpolygon = (MultiPolygon) reader.read(<span class="string">"MULTIPOLYGON(((40 10, 30 0, 40 10, 30 20, 40 10),(30 10, 30 0, 40 10, 30 20, 30 10)))"</span>);</span><br><span class="line">        <span class="keyword">return</span> mpolygon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create GeometryCollection  contain point or multiPoint or line or multiLine or polygon or multiPolygon</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GeometryCollection <span class="title">createGeoCollect</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        LineString line = createLine();</span><br><span class="line">        Polygon poly =  createPolygonByWKT();</span><br><span class="line">        Geometry g1 = geometryFactory.createGeometry(line);</span><br><span class="line">        Geometry g2 = geometryFactory.createGeometry(poly);</span><br><span class="line">        Geometry[] garray = <span class="keyword">new</span> Geometry[]&#123;g1,g2&#125;;</span><br><span class="line">        GeometryCollection gc = geometryFactory.createGeometryCollection(garray);</span><br><span class="line">        <span class="keyword">return</span> gc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create a Circle  创建一个圆，圆心(x,y) 半径RADIUS</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> RADIUS</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Polygon <span class="title">createCircle</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">final</span> <span class="keyword">double</span> RADIUS)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> SIDES = <span class="number">32</span>;<span class="comment">//圆上面的点个数</span></span><br><span class="line">        Coordinate coords[] = <span class="keyword">new</span> Coordinate[SIDES+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIDES; i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> angle = ((<span class="keyword">double</span>) i / (<span class="keyword">double</span>) SIDES) * Math.PI * <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">double</span> dx = Math.cos( angle ) * RADIUS;</span><br><span class="line">            <span class="keyword">double</span> dy = Math.sin( angle ) * RADIUS;</span><br><span class="line">            coords[i] = <span class="keyword">new</span> Coordinate( (<span class="keyword">double</span>) x + dx, (<span class="keyword">double</span>) y + dy );</span><br><span class="line">        &#125;</span><br><span class="line">        coords[SIDES] = coords[<span class="number">0</span>];</span><br><span class="line">        LinearRing ring = geometryFactory.createLinearRing( coords );</span><br><span class="line">        Polygon polygon = geometryFactory.createPolygon( ring, <span class="keyword">null</span> );</span><br><span class="line">        <span class="keyword">return</span> polygon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        GeometryDemo gt = <span class="keyword">new</span> GeometryDemo();</span><br><span class="line">        Polygon p = gt.createCircle(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//圆上所有的坐标(32个)</span></span><br><span class="line">        Coordinate coords[] = p.getCoordinates();</span><br><span class="line">        <span class="keyword">for</span>(Coordinate coord:coords)&#123;</span><br><span class="line">            System.out.println(coord.x+<span class="string">","</span>+coord.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="火星坐标系"><a href="#火星坐标系" class="headerlink" title="火星坐标系"></a>火星坐标系</h4><p>在谷歌还没有发布谷歌地图时，在GIS领域常见的坐标系主要有WGS84经纬度坐标、北京54坐标或西安80坐标等；但自从谷歌地图发布之后，其海量的高清卫星免费影像是让整个GIS领域为之震惊的，但同时也为安全问题带来了一定的隐患。为了对实际坐标进行加密，于是国测局研究了一套算法，凡是公开发布的商业互联网地图，一定要在此加密算法的基础上进行发布，这样一来地图的坐标就与实地的坐标不相符了，于是大家把这种坐标戏称为“火星坐标”，这里我们就针对这一坐标作一些更为详细的说明。</p><p>所有的电子地图、导航设备，都需要加入该保密插件。第一步，地图公司测绘地图，测绘完成后，送到国家测绘局，将真实坐标的电子地图，加密成“火星坐标”，这样的地图才是可以出版和发布的，然后才可以让GPS公司处理。第二步，所有的GPS公司，只要需要汽车导航的，需要用到导航电子地图的，都需要在软件中加入该保密算法，将COM口读出来的真实的坐标信号，加密转换成ZF要求的保密的坐标。这样，GPS导航仪和导航电子地图就可以完全匹配，GPS也就可以正常工作了。</p><p>GCJ02</p><p>GCJ-02是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统。</p><p>中文名:国家测量局02号标准</p><p>外文名:GCJ-02</p><p>它是一种对经纬度数据的加密算法，即加入随机的偏差。</p><p>国内出版的各种地图系统（包括电子形式），必须至少采用GCJ-02对地理位置进行首次加密。</p><p>综上所述，其实火星坐标系和GCJ-02是同一种事物，它是国家测量(绘)局制定的02号标准，是一种对经纬度坐标进行非线性的随机加偏算法。</p><p>为了响应国家制定的标准，国内所有在线地图服务商（如百度地图、高德地图、搜狗地图和SOSO地图等）和国外部分在线地图服务商(如谷歌地图、必应地图和雅虎地图等)都必须进行GCJ-02加密才对公众进行开放，这就是为什么大家在用地图时总是发现有偏移的原因。</p><p>GCJ-02只是一种坐标偏移标准（算法），对投影没有任何限制，如果再以投影为基础作细分</p><h3 id="PrototBuf"><a href="#PrototBuf" class="headerlink" title="PrototBuf"></a>PrototBuf</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj76dp6ma8j21jb0r2ab4.jpg" alt="undefined"></p><h3 id="IDEA莫名其妙每次自动生成变量都有final修饰符"><a href="#IDEA莫名其妙每次自动生成变量都有final修饰符" class="headerlink" title="IDEA莫名其妙每次自动生成变量都有final修饰符"></a>IDEA莫名其妙每次自动生成变量都有final修饰符</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj79tlhudbg20yc0eeqsg.gif" alt="undefined"></p><h3 id="FlinkKafka兼容性"><a href="#FlinkKafka兼容性" class="headerlink" title="FlinkKafka兼容性"></a>FlinkKafka兼容性</h3><table><thead><tr><th>Maven Dependency</th><th>Supported since</th><th>Consumer and  Producer Class name</th><th>Kafka version</th><th>Notes</th></tr></thead><tbody><tr><td>flink-connector-kafka-0.8_2.11</td><td>1.0.0</td><td>FlinkKafkaConsumer08 FlinkKafkaProducer08</td><td>0.8.x</td><td>Uses the <a href="https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+SimpleConsumer+Example" target="_blank" rel="noopener">SimpleConsumer</a> API of Kafka internally. Offsets are committed to ZK by Flink.</td></tr><tr><td>flink-connector-kafka-0.9_2.11</td><td>1.0.0</td><td>FlinkKafkaConsumer09 FlinkKafkaProducer09</td><td>0.9.x</td><td>Uses the new <a href="http://kafka.apache.org/documentation.html#newconsumerapi" target="_blank" rel="noopener">Consumer API</a> Kafka.</td></tr><tr><td>flink-connector-kafka-0.10_2.11</td><td>1.2.0</td><td>FlinkKafkaConsumer010 FlinkKafkaProducer010</td><td>0.10.x</td><td>This connector supports <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-32+-+Add+timestamps+to+Kafka+message" target="_blank" rel="noopener">Kafka messages with timestamps</a> both for producing and consuming.</td></tr><tr><td>flink-connector-kafka-0.11_2.11</td><td>1.4.0</td><td>FlinkKafkaConsumer011 FlinkKafkaProducer011</td><td>0.11.x</td><td>Since 0.11.x Kafka does not support scala 2.10. This connectorsupports <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-98+-+Exactly+Once+Delivery+and+Transactional+Messaging" target="_blank" rel="noopener">Kafka transactional messaging</a> to provide exactly once semantic for the producer.</td></tr><tr><td>flink-connector-kafka_2.11</td><td>1.7.0</td><td>FlinkKafkaConsumer FlinkKafkaProducer</td><td>&gt;= 1.0.0</td><td>This universal Kafka connector attempts to track the latest version of the Kafka client.The version of the client it uses may change between Flink releases.Modern Kafka clients are backwards compatible with broker versions 0.10.0 or later.However for Kafka 0.11.x and 0.10.x versions, we recommend using dedicatedflink-connector-kafka-0.11_2.11 and flink-connector-kafka-0.10_2.11 respectively.Attention: as of Flink 1.7 the universal Kafka connector is considered to be in a BETA status and might not be as stable as the 0.11 connector. In case of problems withthe universal connector, you can try to use flink-connector-kafka-0.11_2.11 which should be compatible with all of the Kafka versions starting from 0.11.</td></tr></tbody></table><h3 id="关于数据仓库数据中台数据湖的一部分图片"><a href="#关于数据仓库数据中台数据湖的一部分图片" class="headerlink" title="关于数据仓库数据中台数据湖的一部分图片"></a>关于数据仓库数据中台数据湖的一部分图片</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vv1ur3j20lr0afmyg.jpg" alt="2B5AE031-28F3-4273-96BA-AAA9D3A1A25E.png"><br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vuyywpj209b06sjro.jpg" alt="68C1B34D-B7F7-4026-ACDE-9C0C53A57F71.png"><br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vv0bgvj20jh092gm0.jpg" alt="365E67AF-D9E0-49f7-A847-7657EF3FFCAA.png"><br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vv15apj20m209z3zk.jpg" alt="788AA5A9-709B-471e-AB31-2AB8D79EEC14.png"><br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vv5fk0j20nl0d1afi.jpg" alt="5234F018-146E-4c51-97FA-6206F82EC8B6.png"><br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vv5hsqj20rn0i80w9.jpg" alt="1CAFEC39-30A9-4b51-9B16-1B9D11A3DD09.png"></p><p>元数据管理还有个普元元数据</p><h3 id="Mac版本的终端要走Proxy除了梯子还需要一个设置"><a href="#Mac版本的终端要走Proxy除了梯子还需要一个设置" class="headerlink" title="Mac版本的终端要走Proxy除了梯子还需要一个设置"></a>Mac版本的终端要走Proxy除了梯子还需要一个设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~ vim ~/.zshrc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># proxy list</span><br><span class="line">alias proxy=&apos;export all_proxy=socks5://127.0.0.1:1080&apos;</span><br><span class="line">alias unproxy=&apos;unset all_proxy&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~ source ~/.zshrc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">切换：</span><br><span class="line">~ proxy</span><br><span class="line">~ unproxy</span><br></pre></td></tr></table></figure><h3 id="无状态-和-有状态-的区别"><a href="#无状态-和-有状态-的区别" class="headerlink" title="无状态 和 有状态 的区别"></a>无状态 和 有状态 的区别</h3><p>在整个程序生态圈中，无状态的意思总是 不需要自己手动关闭，有状态的意识是 总是需要自己手动关闭</p><h3 id="Linux-Command"><a href="#Linux-Command" class="headerlink" title="Linux Command"></a>Linux Command</h3><h4 id="most-more-less"><a href="#most-more-less" class="headerlink" title="most + more + less"></a>most + more + less</h4><p><code>more</code>, <code>less</code> and <code>most</code> are three pagers, we can compare them this way:</p><blockquote><p><code>less</code> is more than <code>more</code>,<br><code>most</code> is more than <code>more</code>, aproximatly,<br><code>less</code> and <code>most</code> are different, none is better.</p></blockquote><h4 id="linux通过进程号查看运行文件目录"><a href="#linux通过进程号查看运行文件目录" class="headerlink" title="linux通过进程号查看运行文件目录"></a>linux通过进程号查看运行文件目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/&#123;进程号&#125;/cwd</span><br></pre></td></tr></table></figure><h4 id="CentOS查看版本"><a href="#CentOS查看版本" class="headerlink" title="CentOS查看版本"></a>CentOS查看版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl </span><br><span class="line"></span><br><span class="line">   Static hostname: datanode127</span><br><span class="line">         Icon name: computer-server</span><br><span class="line">           Chassis: server</span><br><span class="line">        Machine ID: abe6faef122d47c1a66436e7936b4301</span><br><span class="line">           Boot ID: 8010542f5e21440797d9e3fc669fb752</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-693.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br></pre></td></tr></table></figure><h4 id="文件目录大小常见的命令"><a href="#文件目录大小常见的命令" class="headerlink" title="文件目录大小常见的命令"></a>文件目录大小常见的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> flyhugh@MacBook-Pro-2  ~/Documents/Env  pwd</span><br><span class="line">/Users/flyhugh/Documents/Env</span><br><span class="line"> flyhugh@MacBook-Pro-2  ~/Documents/Env  ls</span><br><span class="line">apache-maven-3.6.3 brew_install.rb</span><br><span class="line"> flyhugh@MacBook-Pro-2  ~/Documents/Env  du -sh</span><br><span class="line">7.2G.</span><br><span class="line"> flyhugh@MacBook-Pro-2  ~/Documents/Env  df -h  </span><br><span class="line">Filesystem      Size   Used  Avail Capacity iused      ifree %iused  Mounted on</span><br><span class="line">/dev/disk1s5   466Gi   10Gi  180Gi     6%  488290 4882988630    0%   /</span><br><span class="line">devfs          187Ki  187Ki    0Bi   100%     646          0  100%   /dev</span><br><span class="line">/dev/disk1s1   466Gi  271Gi  180Gi    61% 2520713 4880956207    0%   /System/Volumes/Data</span><br><span class="line">/dev/disk1s4   466Gi  3.0Gi  180Gi     2%       4 4883476916    0%   /private/var/vm</span><br><span class="line">map auto_home    0Bi    0Bi    0Bi   100%       0          0  100%   /System/Volumes/Data/home</span><br><span class="line">/dev/disk1s3   466Gi  504Mi  180Gi     1%      54 4883476866    0%   /Volumes/Recovery</span><br></pre></td></tr></table></figure><h4 id="Linux生僻命令"><a href="#Linux生僻命令" class="headerlink" title="Linux生僻命令"></a>Linux生僻命令</h4><p>在两个文件夹之间来回切换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd -</span><br></pre></td></tr></table></figure><p>递归创建目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p</span><br></pre></td></tr></table></figure><h3 id="Win10网络问题汇总"><a href="#Win10网络问题汇总" class="headerlink" title="Win10网络问题汇总"></a>Win10网络问题汇总</h3><p>用无线网有个问题就是电脑开机时间久了 加上我使用科学上网频繁开关，导致网络会有错乱问题，在系统开了很多东西的情况下，直接重启，导致了网络错误，打开IDEA的时候出现了错误提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Internal error. Please refer to http://jb.gg/ide/critical-startup-errors</span><br><span class="line"></span><br><span class="line">java.net.BindException: Address already in use: bind</span><br><span class="line">    at java.base/sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">    at java.base/sun.nio.ch.Net.bind(Net.java:461)</span><br><span class="line">    at java.base/sun.nio.ch.Net.bind(Net.java:453)</span><br><span class="line">    at java.base/sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:227)</span><br><span class="line">    at io.netty.channel.socket.nio.NioServerSocketChannel.doBind(NioServerSocketChannel.java:132)</span><br><span class="line">    at io.netty.channel.AbstractChannel$AbstractUnsafe.bind(AbstractChannel.java:551)</span><br><span class="line">    at io.netty.channel.DefaultChannelPipeline$HeadContext.bind(DefaultChannelPipeline.java:1345)</span><br><span class="line">    at io.netty.channel.AbstractChannelHandlerContext.invokeBind(AbstractChannelHandlerContext.java:503)</span><br><span class="line">    at io.netty.channel.AbstractChannelHandlerContext.bind(AbstractChannelHandlerContext.java:488)</span><br><span class="line">    at io.netty.channel.DefaultChannelPipeline.bind(DefaultChannelPipeline.java:984)</span><br><span class="line">    at io.netty.channel.AbstractChannel.bind(AbstractChannel.java:247)</span><br><span class="line">    at io.netty.bootstrap.AbstractBootstrap$2.run(AbstractBootstrap.java:355)</span><br><span class="line">    at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)</span><br><span class="line">    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:416)</span><br><span class="line">    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:515)</span><br><span class="line">    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">    at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">    at java.base/java.lang.Thread.run(Thread.java:834)</span><br></pre></td></tr></table></figure><p>这个错误造成的原因就是<em>hypervisior(Windows 10的Hyper-V虚拟机)，把端口保留了</em></p><p>解决方法也很简单，<em>hypervisior</em>重新开关一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Disable hyper-v (which will required a couple of restarts)</span><br><span class="line">dism.exe /Online /Disable-Feature:Microsoft-Hyper-V</span><br><span class="line"></span><br><span class="line">When you finish all the required restarts, reserve the port you want so hyper-v doesn&apos;t reserve it back</span><br><span class="line">netsh int ipv4 add excludedportrange protocol=tcp startport=&lt;端口号&gt; numberofports=1</span><br><span class="line"></span><br><span class="line">Re-Enable hyper-V (which will require a couple of restart)</span><br><span class="line">dism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All</span><br></pre></td></tr></table></figure><p>实际使用中第一个命令执行完直接重启就行了。</p><h4 id="win10图形化查看端口占用工具"><a href="#win10图形化查看端口占用工具" class="headerlink" title="win10图形化查看端口占用工具"></a>win10图形化查看端口占用工具</h4><p><code>cports</code></p><h4 id="重置win10网络命令"><a href="#重置win10网络命令" class="headerlink" title="重置win10网络命令"></a>重置win10网络命令</h4><p><code>netsh winsock reset</code></p><h4 id="win10远程窗口大小不可调的问题"><a href="#win10远程窗口大小不可调的问题" class="headerlink" title="win10远程窗口大小不可调的问题"></a>win10远程窗口大小不可调的问题</h4><p>我的显示器分辨率比较高，两台显示器都是4K分辨率的，但是远程的时候默认是锁定1600 * 1200的</p><p>并且默认是窗口化的，无法调整大小，这个时候需要使用命令行配置一下远程窗口的分辨率</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstsc /w:<span class="number">2560</span> /h:<span class="number">1440</span> /f</span><br></pre></td></tr></table></figure><p>这个命令分别是长宽和全屏设置。</p><h4 id="给win10商店设置代理"><a href="#给win10商店设置代理" class="headerlink" title="给win10商店设置代理"></a>给win10商店设置代理</h4><p>最近发现。。。只要有一个好的代理服务器，win10的商店原来也是能随便打开的，这里介绍一下win10的商店的流量怎么走代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先通过 Win + R 快捷键打开「运行」窗口，输入「Regedit」打开注册表编辑器，然后定位到 HKEY_CURRENT_USER\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings，接着在左边的注册表项中找到你想解除网络隔离的应用，右边的 DisplayName 就是应用名称，而左边那一大串字符就是应用的 SID 值了。</span><br></pre></td></tr></table></figure><p>找到这个值之后，然后在cmd命令行中输入：</p><p><code>CheckNetIsolation.exe loopbackexempt -a -p=SID</code></p><p>这SID就是上面搜索到的，这样就行</p><h4 id="关于SSTap转发UDP的问题"><a href="#关于SSTap转发UDP的问题" class="headerlink" title="关于SSTap转发UDP的问题"></a>关于SSTap转发UDP的问题</h4><p>查看SSTap是否成功转发UDP需要用到一个工具，netcat，简称nc，使用这个工具，在命令行中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\nc64.exe <span class="literal">-u</span> ip <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>就可以像服务器发送UDP请求，然后在服务器上使用root用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump udp port 10000</span><br></pre></td></tr></table></figure><p>就可以查看转发日志</p><p>Tips：我在ubuntu上设置的ss-server 默认是不打开udp的端口的，需要在开启的时候手动打开。(加上 -u)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ss<span class="literal">-server</span> <span class="literal">-c</span> /etc/shadowsocks.json <span class="literal">-u</span></span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnp | grep 10000</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/ubuntu# netstat -lnp | grep 10000</span><br><span class="line">tcp        0      0 0.0.0.0:10000           0.0.0.0:*               LISTEN      25056/ss-server     </span><br><span class="line">udp        0      0 0.0.0.0:10000           0.0.0.0:*                           25056/ss-server</span><br></pre></td></tr></table></figure><p>如图可以看到端口已经开放了udp和tcp即可，udp是无状态的，不会显示LISTEN，这个是正确的。</p><p>最终结论：是服务器上的SSR没有开启UDP转发，默认是不转发UDP的，这个是有问题的。</p><h4 id="win10-访问墙外世界的最终办法："><a href="#win10-访问墙外世界的最终办法：" class="headerlink" title="win10 访问墙外世界的最终办法："></a>win10 访问墙外世界的最终办法：</h4><p>使用 <code>SSTap</code>这类软件，<code>SSTap</code>是比较简单的，复杂的软件会有流量分流等等功能。</p><p><code>SSTap</code>新建了一个虚拟网卡，所有的流量从新的虚拟网卡中转发出去，不用再考虑软件的流量进出口有没有被代理等等问题。</p><h4 id="Win下Chrome无法访问新浪外链地址"><a href="#Win下Chrome无法访问新浪外链地址" class="headerlink" title="Win下Chrome无法访问新浪外链地址"></a>Win下Chrome无法访问新浪外链地址</h4><p>拓展解决：</p><p><a href="https://chrome.google.com/webstore/detail/wbimgfix/bdhgcfmghkbbdmejdaadfdhhdjphogkp/related" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/wbimgfix/bdhgcfmghkbbdmejdaadfdhhdjphogkp/related</a></p><h4 id="云服务器通过转发windows的3389端口，实现远程对PC的访问"><a href="#云服务器通过转发windows的3389端口，实现远程对PC的访问" class="headerlink" title="云服务器通过转发windows的3389端口，实现远程对PC的访问"></a>云服务器通过转发windows的3389端口，实现远程对PC的访问</h4><p><a href="https://www.jianshu.com/p/939dd2f78399" target="_blank" rel="noopener">https://www.jianshu.com/p/939dd2f78399</a></p><p>使用了文中的方法，需要注意的方法不是很多，一个是和 <code>ssh</code> 配置有关的问题，最后采用的配置文件，我在最后贴出来(这种配置文件下可以使用root帐号登录)。配置完成后使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><p>重启服务。</p><p>登录用到的keygen需要在cygwin64的文件系统中单独保存，使用的并不是windows下面的路径。</p><p>我最终使用的命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=180 -i /home/key/id_rsa_oracle_2 root@#服务器IP# -p 22 -R #以后远程登录要使用的端口，不建议使用3389，为了安全#:127.0.0.1:3389 -fN</span><br></pre></td></tr></table></figure><p><code>ssh</code>配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>       $OpenBSD: sshd_config,v 1.100 2016/08/15 12:32:04 naddy Exp $</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> This is the sshd server system-wide configuration file.  See</span><br><span class="line"><span class="meta">#</span> sshd_config(5) for more information.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> This sshd was compiled with PATH=/usr/local/bin:/usr/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The strategy used for options in the default sshd_config shipped with</span><br><span class="line"><span class="meta">#</span> OpenSSH is to specify options with their default value where</span><br><span class="line"><span class="meta">#</span> possible, but leave them commented.  Uncommented options override the</span><br><span class="line"><span class="meta">#</span> default value.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> If you want to change the port on a SELinux system, you have to tell</span><br><span class="line"><span class="meta">#</span> SELinux about this change.</span><br><span class="line"><span class="meta">#</span> semanage port -a -t ssh_port_t -p tcp #PORTNUMBER</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Port 22</span><br><span class="line"><span class="meta">#</span>AddressFamily any</span><br><span class="line"><span class="meta">#</span>ListenAddress 0.0.0.0</span><br><span class="line"><span class="meta">#</span>ListenAddress ::</span><br><span class="line"></span><br><span class="line">HostKey /etc/ssh/ssh_host_rsa_key</span><br><span class="line"><span class="meta">#</span>HostKey /etc/ssh/ssh_host_dsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ed25519_key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Ciphers and keying</span><br><span class="line"><span class="meta">#</span>RekeyLimit default none</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Logging</span><br><span class="line"><span class="meta">#</span>SyslogFacility AUTH</span><br><span class="line">SyslogFacility AUTHPRIV</span><br><span class="line"><span class="meta">#</span>LogLevel INFO</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Authentication:</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>LoginGraceTime 2m</span><br><span class="line">PermitRootLogin yes</span><br><span class="line"><span class="meta">#</span>StrictModes yes</span><br><span class="line"><span class="meta">#</span>MaxAuthTries 6</span><br><span class="line"><span class="meta">#</span>MaxSessions 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2</span><br><span class="line"><span class="meta">#</span> but this is overridden so installations will only check .ssh/authorized_keys</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>AuthorizedPrincipalsFile none</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>AuthorizedKeysCommand none</span><br><span class="line"><span class="meta">#</span>AuthorizedKeysCommandUser nobody</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> For this to work you will also need host keys in /etc/ssh/ssh_known_hosts</span><br><span class="line"><span class="meta">#</span>HostbasedAuthentication no</span><br><span class="line"><span class="meta">#</span> Change to yes if you don't trust ~/.ssh/known_hosts for</span><br><span class="line"><span class="meta">#</span> HostbasedAuthentication</span><br><span class="line"><span class="meta">#</span>IgnoreUserKnownHosts no</span><br><span class="line"><span class="meta">#</span> Don't read the user's ~/.rhosts and ~/.shosts files</span><br><span class="line"><span class="meta">#</span>IgnoreRhosts yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> To disable tunneled clear text passwords, change to no here!</span><br><span class="line"><span class="meta">#</span>PasswordAuthentication yes</span><br><span class="line"><span class="meta">#</span>PermitEmptyPasswords no</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Change to no to disable s/key passwords</span><br><span class="line"><span class="meta">#</span>ChallengeResponseAuthentication yes</span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Kerberos options</span><br><span class="line"><span class="meta">#</span>KerberosAuthentication no</span><br><span class="line"><span class="meta">#</span>KerberosOrLocalPasswd yes</span><br><span class="line"><span class="meta">#</span>KerberosTicketCleanup yes</span><br><span class="line"><span class="meta">#</span>KerberosGetAFSToken no</span><br><span class="line"><span class="meta">#</span>KerberosUseKuserok yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> GSSAPI options</span><br><span class="line">GSSAPIAuthentication yes</span><br><span class="line">GSSAPICleanupCredentials no</span><br><span class="line"><span class="meta">#</span>GSSAPIStrictAcceptorCheck yes</span><br><span class="line"><span class="meta">#</span>GSSAPIKeyExchange no</span><br><span class="line"><span class="meta">#</span>GSSAPIEnablek5users no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Set this to 'yes' to enable PAM authentication, account processing,</span><br><span class="line"><span class="meta">#</span> and session processing. If this is enabled, PAM authentication will</span><br><span class="line"><span class="meta">#</span> be allowed through the ChallengeResponseAuthentication and</span><br><span class="line"><span class="meta">#</span> PasswordAuthentication.  Depending on your PAM configuration,</span><br><span class="line"><span class="meta">#</span> PAM authentication via ChallengeResponseAuthentication may bypass</span><br><span class="line"><span class="meta">#</span> the setting of "PermitRootLogin without-password".</span><br><span class="line"><span class="meta">#</span> If you just want the PAM account and session checks to run without</span><br><span class="line"><span class="meta">#</span> PAM authentication, then enable this but set PasswordAuthentication</span><br><span class="line"><span class="meta">#</span> and ChallengeResponseAuthentication to 'no'.</span><br><span class="line"><span class="meta">#</span> WARNING: 'UsePAM no' is not supported in Red Hat Enterprise Linux and may cause several</span><br><span class="line"><span class="meta">#</span> problems.</span><br><span class="line">UsePAM yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>AllowAgentForwarding yes</span><br><span class="line"><span class="meta">#</span>AllowTcpForwarding yes</span><br><span class="line">GatewayPorts yes</span><br><span class="line">X11Forwarding yes</span><br><span class="line"><span class="meta">#</span>X11DisplayOffset 10</span><br><span class="line"><span class="meta">#</span>X11UseLocalhost yes</span><br><span class="line"><span class="meta">#</span>PermitTTY yes</span><br><span class="line"><span class="meta">#</span>PrintMotd yes</span><br><span class="line"><span class="meta">#</span>PrintLastLog yes</span><br><span class="line"><span class="meta">#</span>TCPKeepAlive yes</span><br><span class="line"><span class="meta">#</span>UseLogin no</span><br><span class="line"><span class="meta">#</span>UsePrivilegeSeparation sandbox</span><br><span class="line"><span class="meta">#</span>PermitUserEnvironment no</span><br><span class="line"><span class="meta">#</span>Compression delayed</span><br><span class="line"><span class="meta">#</span>ClientAliveInterval 0</span><br><span class="line"><span class="meta">#</span>ClientAliveCountMax 3</span><br><span class="line"><span class="meta">#</span>ShowPatchLevel no</span><br><span class="line"><span class="meta">#</span>UseDNS yes</span><br><span class="line"><span class="meta">#</span>PidFile /var/run/sshd.pid</span><br><span class="line"><span class="meta">#</span>MaxStartups 10:30:100</span><br><span class="line"><span class="meta">#</span>PermitTunnel no</span><br><span class="line"><span class="meta">#</span>ChrootDirectory none</span><br><span class="line"><span class="meta">#</span>VersionAddendum none</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> no default banner path</span><br><span class="line"><span class="meta">#</span>Banner none</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Accept locale-related environment variables</span><br><span class="line">AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES</span><br><span class="line">AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT</span><br><span class="line">AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE</span><br><span class="line">AcceptEnv XMODIFIERS</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> override default of no subsystems</span><br><span class="line">Subsystem sftp  /usr/libexec/openssh/sftp-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Example of overriding settings on a per-user basis</span><br><span class="line"><span class="meta">#</span>Match User anoncvs</span><br><span class="line"><span class="meta">#</span>       X11Forwarding no</span><br><span class="line"><span class="meta">#</span>       AllowTcpForwarding no</span><br><span class="line"><span class="meta">#</span>       PermitTTY no</span><br><span class="line"><span class="meta">#</span>       ForceCommand cvs server</span><br></pre></td></tr></table></figure><p>这种访问方式有点过于笨重，后来采用了<code>frp</code>工具来实现了远程代理</p><p><a href="https://zhuanlan.zhihu.com/p/138092534" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/138092534</a></p><h3 id="BT下载-扔掉迅雷"><a href="#BT下载-扔掉迅雷" class="headerlink" title="BT下载 扔掉迅雷"></a>BT下载 扔掉迅雷</h3><ol><li><p>Aria2 <a href="https://github.com/aria2/aria2/releases" target="_blank" rel="noopener">下载</a>解压</p></li><li><p>配置文件 <a href="https://public.dm.files.1drv.com/y4mHts-RbjIeaCIbWaSVQjaReZIKjxzUxRsP5hKJ_a6K2rFcaw8ca4KGHFMDj6sUzcNyphWgE-toOwzGtm5EKkiJXjq1gsZNiRRyFQCKkciNSlRZaxdZVx3eSAJ77FM6E1gqxjbO1hJ8Cd8DTh7SmABzBsPr9JMFOVHiOtw1hqyySr5MrW2w3P6JTZa8KyVDlC_d209wxb6qTYxeC4TsxAev_mM52C3p4hgrZy61Tolrg5GHUdsMLv2u_MkiYAEjAPZ" target="_blank" rel="noopener">下载</a>解压</p></li><li><p>按照顺序使用管理员打开<img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210507190945.png"></p></li><li><p>默认的下载目录为<code>downloads</code>，可通过修改<code>aria2.conf</code>配置文件改变下载目录。</p></li><li><p>Aria2的没有自带下载面板的，因此需要自行下载第三方的面板。</p></li></ol><p>常用的<code>Aria2_Web</code>有<code>YAAW</code>、<code>webui-aria2</code>、<code>AriaNg</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YAAW：https://github.com/binux/yaaw/archive/master.zip</span><br><span class="line">AriaNg：https://github.com/mayswind/AriaNg/releases</span><br><span class="line">webui-aria2：https://github.com/ziahamza/webui-aria2/archive/master.zip</span><br></pre></td></tr></table></figure><p>我这里尝试使用<code>AriaNg</code>，下载下来直接点击那个网页就能使用，修改一下tracker</p><p><a href="https://trackerslist.com/#/zh?id=xiu2trackerslistcollection" target="_blank" rel="noopener">https://trackerslist.com/#/zh?id=xiu2trackerslistcollection</a></p><p>Tracker列表</p><h3 id="网络知识"><a href="#网络知识" class="headerlink" title="网络知识"></a>网络知识</h3><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>建立TCP需要三次握手才能建立（客户端发起SYN,服务端SYN+ACK,客户端ACK），</p><p>断开连接则需要四次握手（客户端和服务端都可以发起，FIN-ACK-FIN-ACK）。</p><p><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p><p>答：<br>   因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>SYN攻击：发送大量的SYN,导致服务端无法识别哪些是有效的</p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>RPC是指远程调用，两服务器A,B，A要调用B上的一个方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据</p><ol><li><p>通讯问题：在客户端和服务端建立TCP连接，远程调用的所有交换数据都在这个连接里传输。</p></li><li><p>解决寻址问题：IP及端口寻址，方法名</p></li><li><p>序列化（Serialize）：发生远程调用时，方法的参数需要通过底层的网络协议如TCP传送到服务器，由于网络协议是基于二进制的，内存中的参数值需要序列化成二进制的形式，通过寻址和传输序列化的二进制发送给服务器。</p></li><li><p>服务器反序列化：服务器收到请求后需要反序列化，恢复内存中的表达方式，然后找到对应的方法（寻址的一部分），进行本地调用。</p></li><li><p>返回值发送给客户端，这个部分也需要序列化和反序列化。</p></li></ol><p><strong>SOA</strong></p><p>采用一组服务的方式来构建一个应用，服务（hedwig、jsf、RESTful）独立部署在不同的进程中，不同服务通过一些轻量级交互机制来通信，例如RPC、HTTP等。服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。</p><p>RPC 的实现是基于SOA这样的一个架构 C/S模式 远程调用的通讯使用TCP 然后hedwig restful jsf这些就是不同的服务形式</p><p>**http协议和tcp/ip 协议的关系<br>**(1) http是应用层协议，tcp协议是传输层协议，ip协议是网络协议。<br>(2) IP协议主要解决网络路由和寻址问题<br>(3) tcp协议主要解决在IP层协议之上，如何可靠的传输数据，即接收端收到的数据包的大小和顺序，和发送端保持一致。tcp协议是可靠的面相连接的。</p><p><strong>1.   http协议是无状态的</strong>，指的是http协议对于事务处理没有记忆功能，客户端向服务端请求完数据之后，服务端不知道客户端是什么状态。</p><p><strong>2. http的长连接和短连接，本质上是tcp层的长连接和短连接：</strong></p><p>http 1.0 默认使用短连接，http 1.1 默认使用长连接，在使用的http协议，在响应头会加上 Connection:keep-alive</p><p><strong>3. RPC比http请求快的原因</strong>：http使用http协议，rpc使用tcp协议，比http少了应用层，表示层，会话层，这3层，rpc使用长连接，而长连接比短连接更节省资源，效率更高（每个连接的建立和释放都是需要资源和时间的）。</p><p><strong>TCP/IP</strong></p><p>是个协议组，可分为三个层次：<strong>网络层、传输层和应用层。</strong></p><p>在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。</p><p>在<strong>传输层中有TCP协议与UDP协议。</strong></p><p>在应用层有:TCP包括FTP、HTTP、TELNET、SMTP等协议</p><p><strong>UDP包括DNS、TFTP等协议</strong></p><p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。</p><p><strong>通信过程：</strong></p><p>主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。</p><p><strong>建立通信链路</strong></p><p>当<strong>客户端</strong>要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。</p><p>与之对应的<strong>服务端</strong>将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的TCP 连接。</p><p><strong>TCP短连接</strong></p><p>TCP短连接，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。因为一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作。短连接的优点是：<strong>管理起来比较简单，存在的连接都是有用的连接</strong>，不需要额外的控制手段。</p><p><strong>TCP长连接</strong></p><p>长连接，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p><strong>TCP保活功能</strong>，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资 源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段。客户主机必须处于以下4个状态之一：</p><p>1.客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</p><p>2.客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</p><p>3.客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</p><p>4.客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</p><p>从上面可以看出，TCP保活功能主要为探测长连接的存活状况，不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。</p><p>在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问 题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p><p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p><p><strong>HTTP长连接与短连接</strong></p><p><strong>长连接</strong>：client方与server方先建立连接，连接建立后不断开，然后再进行报文发送和接收。</p><p>这种方式下由于通讯连接一直存在。此种方式常用于P2P通信。</p><p><strong>短连接</strong>：Client方与server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。</p><p>此方式常用于一点对多点通讯。C/S通信。</p><p><strong>长连接和短连接异同</strong></p><p><strong>长连接：</strong>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。</p><p>每个TCP连接的建立都需要三次握手，每个TCP连接的断开要四次握手。</p><p>如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作后，下次操作时直接发送数据就可以了，不用再建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，频繁的socket创建也是对资源的浪费。</p><p><strong><em>\</em>短连接\</strong>：**web网站的http服务一般都用短连接。因为长连接对于服务器来说要耗费一定的资源。像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。</p><p><strong>发送接收方式</strong></p><p>1、异步：报文发送和接收是分开的，相互独立，互不影响的。这种方式又分两种情况：</p><p><strong>异步双工：</strong>接收和发送在同一个程序中，有两个不同的子进程分别负责发送和接送。</p><p><strong>异步单工：</strong>接送和发送使用两个不同的程序来完成。</p><p>2、同步：报文发送和接收是同步进行，即报文发送后等待接送返回报文。同步方式一般需要考虑超时问题，试想我们发送报文以后也不能无限等待啊，所以我们要设定一个等待时候。超过等待时间发送方不再等待读返回报文。直接通知超时返回。</p><p><strong>阻塞与非阻塞方式</strong></p><p>1、非阻塞方式：读函数不停的进行读动作，如果没有报文接收到，等待一段时间后超时返回，这种情况一般需要指定超时时间。</p><p>2、阻塞方式：如果没有接收到报文，则读函数一直处于等待状态，知道报文到达。</p><p><strong>及时通信与游戏的长短连接</strong></p><p>实际场合究竟需要使用短连接还是长连接，主要看实时性要求、数据流向和并发量这三个问题。</p><p><strong>长连接优点：</strong>节约TCP握手时间，可以保证高实时性，数据流向可以采用服务器端的主动推模式。<br><strong>长连接缺点</strong>：并发量不宜太高，持续占用服务端口（相对消耗资源）。</p><p>长连接、长轮询一般应用与WebIM、ChatRoom和一些需要及时交互的网站应用中。其真实案例有：WebQQ、Hi网页版、Facebook IM等。</p><p>1.现在游戏中的玩家与玩家之间的聊天无法实现实时性，而且系统有邮件或信息时也不能及时的通知玩家<br>—— 如果涉及到聊天的话，一般来说还是用长连接会更合适，否则大量时间浪费到握手上了；<br>—— 但是手机的网络长连接网络质量可能会比较撮，你需要严重考虑容错和重链机制。</p><p>2.客户端每隔几秒就会发送一个请求，这样服务器的压力岂不是很大？<br>—— 压力会比较大，关键是聊天往往对时间的要求很高，如果是团战的话，1秒内没看到信息，可能就会觉得完全受不了了；当然也看你聊天的场景如何，是群聊还是单聊，以后会不会发展为语音啥的；</p><p>NIO没有任何问题，大规模长连接处理的主流都是用NIO；而且也不是Java发明的，本身就是借助了操作系统的网络管理能力。</p><p><strong>http keep-alive与tcp keep-alive</strong>，不是同一回事，意图不一样。http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制</p><h3 id="Maven问题汇总"><a href="#Maven问题汇总" class="headerlink" title="Maven问题汇总"></a>Maven问题汇总</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- Execute the shell script to generate the spark build information. --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">target</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- windows 目录下修改成CMD Linux下面用的是Bash--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">exec</span> <span class="attr">executable</span>=<span class="string">"cmd"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"$&#123;project.basedir&#125;/../build/spark-build-info"</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"$&#123;project.build.directory&#125;/extra-resources"</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"$&#123;project.version&#125;"</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">exec</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的这个插件 antrun里面的命令在linux环境下使用bash没有问题，在linux环境下应该配置bash</p><h4 id="Maven手动添加Jar包之后没有加载"><a href="#Maven手动添加Jar包之后没有加载" class="headerlink" title="Maven手动添加Jar包之后没有加载"></a>Maven手动添加Jar包之后没有加载</h4><p>File-&gt;Setting-&gt;Maven-&gt;Repositories-&gt;Update（选择本地仓库的路径）</p><h3 id="Active-使用遇到的坑"><a href="#Active-使用遇到的坑" class="headerlink" title="Active 使用遇到的坑"></a>Active 使用遇到的坑</h3><p>线上activemq内存超过限制，导致生产者无法推送告警信息。Activemq重启，导致部分堆积数据丢失</p><p>考虑一下ActiveMQ的监控</p><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>RDB模式全栈快照，当内存比较大，访问比较频繁时（我们的设备实时信息是典形的写多读少，异于一般的写少读多的情况），刷新频率高，磁盘IO要求非常大。</p><p>AOF模式，文件体大，Rewrite时会有RDB类似的情况</p><p>AOF重写或是RDB进行Dump时都会fork子进程，当Redis使用物理内存过半时，会失败</p><h3 id="LinkedList等队列size"><a href="#LinkedList等队列size" class="headerlink" title="LinkedList等队列size()"></a>LinkedList等队列size()</h3><p>JDK自带队列size()需要遍历集合，如果集合数据比较大，且该函数比较频繁访问情况下，可能会有性能问题。并发接近万数量级慎用</p><p>（可以用Stopwatch监控程序每个步骤运行时间）</p><h3 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk86kqo1adj20fa09kq5t.jpg" alt="undefined"></p><h3 id="Flink问题汇总"><a href="#Flink问题汇总" class="headerlink" title="Flink问题汇总"></a>Flink问题汇总</h3><h4 id="Flink使用滑动窗口出现的一个问题"><a href="#Flink使用滑动窗口出现的一个问题" class="headerlink" title="Flink使用滑动窗口出现的一个问题"></a>Flink使用滑动窗口出现的一个问题</h4><p>使用滑动窗口保存checkpoint失败，日志里面没有错误日志，个别情况下在使用不同的时间语义会出现成功的情况。</p><h5 id="Flink数据写入了HDFS，Hive没有识别"><a href="#Flink数据写入了HDFS，Hive没有识别" class="headerlink" title="Flink数据写入了HDFS，Hive没有识别"></a>Flink数据写入了HDFS，Hive没有识别</h5><p>1.11版本，需要设置<code>sink.partition.commit</code>参数，分区表</p><h5 id="Flink-1-12-0编译密码："><a href="#Flink-1-12-0编译密码：" class="headerlink" title="Flink-1.12.0编译密码："></a>Flink-1.12.0编译密码：</h5><p><code>flink-runtime-web</code>工程有几个特点，</p><p>=&gt; 在网络OK，别的问题都没有的情况下，第一次编译成功，后面编译的话会报错（npm或者node.js被占用的错误），也就是说，只有第一次能编译成功。</p><h3 id="时空数据结构简介"><a href="#时空数据结构简介" class="headerlink" title="时空数据结构简介"></a>时空数据结构简介</h3><blockquote><p> 后面如果有时间的话 会把这部分独立出去重新整理一章</p></blockquote><p>所谓时空数据，顾名思义，包含了两个维度的信息：空间信息与时间信息。空间信息，以地理位置点最为基础，还包括线、多边形以及更为复杂的多维结构。最典型的时空数据，莫过于移动对象的轨迹点数据，如每隔5秒钟记录的车辆实时位置信息。这类数据，在物联网领域司空见惯，在可预见的未来，这类数据将会出现爆炸性的增长。</p><p>关于时空索引，这里，了解到的主流技术有R-Trees、Quad-Trees、K-D Trees以及Space Filling Curve这四种技术。</p><h4 id="RTree"><a href="#RTree" class="headerlink" title="RTree"></a>RTree</h4><p>R-Trees源自论文《R-Trees: A Dynamic Index Structure For Spatial Searching》，下面的图也源自此论文：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnmhkz89j20lj0hpmx9.jpg" alt="undefined"></p><p>R-Trees基于这样的思想设计：</p><p>每一个空间对象，如一个多边形区域，都存在一个最小的矩形，能够恰好包含此时空对象，如上图中的矩形R6所包含的弯月形区域。这个最小包围矩形被称之为MBR(Minimum Bounding Rectangle)。</p><p>多个相邻的矩形，可以被包含在一个更大的最小包围矩形中。如R6、R9以及R10三个矩形，可以被包含在R3中，而R11与R12则被包含在R4中。</p><p>继续迭代，总能找到若干个最大的区域，以一种树状的形式，将所有的时空对象给容纳进去，如上图中的R1, R2。这样，整个树状结构，呈现如下：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnn72zvnj20lq097jrc.jpg" alt="undefined"></p><p>从最小的矩形区域，到最大的矩形区域，就好比地图中的行政区域划分：村 -&gt; 县 -&gt; 市 -&gt; 省份。查询时，先从锁定的最大区域开始，逐级缩小比例尺后，就可找到最终的对象。如若将上图中的R1与R2理解成两个平级的”行政区域”，却又存在本质的区别：不同的行政区域，并不存在相互重叠，而R1与R2却可能是重叠的。</p><p>R-Trees的定义：</p><ol><li><p>每一个Leaf Node包含m到M个索引记录（Root节点除外）。</p></li><li><p>每一个索引记录是一个关于(I, tuple-identifier)的二元组信息，I是空间对象的最小包围矩形，而tuple-identifier用来描述空间对象本身。</p></li><li><p>每一个Non-leaf节点，包含m到M个子节点（Root节点除外）。</p></li><li><p>Non-leaf节点上的每一个数据元素，是一个(I, child-pointer)的二元组信息，child-pointer指向其中一个子节点，而I则是这个子节点上所有矩形的最小包围矩形。</p></li></ol><p>上图中，R3、R4以及R5，共同构成一个non-leaf节如点，R3指向包含元素R8，R9以及R10的子节点，这个指针就是child-pointer，而与R8，R9以及R10相关的最小包围矩形，就是I。</p><ol start="5"><li>Root节点至少包含两个子节点，除非它本身也是一个Leaf Node。</li><li>所有的Leaf Nodes都出现在树的同一层上。</li></ol><p>从定义上来看，R-Trees与B-Trees存在诸多类似：Root节点与Non-Leaf节点，均包含限定数量的子节点；所有的Leaf Nodes都出现在树的同一层上。这两种树也都是<strong>自平衡</strong>的。</p><p>前面也已经提到了，B-Trees主要用来存放一维排序的数据元素，而R-Tree存放的则是多维空间数据元素。从查询方式上来看，两者也存在显著的差异：B-Trees更擅长于数据点查，它的设计并不利于数据的范围查询。基于空间元素的查询，却以范围查询为主，而且往往需要对多个子树进行并行查询，例如，在地图上划定某一个区域，查询这个区域内有哪些公园，可能有多个子树都与划定的这个区域存在交集。从这一点看来，R-Tree的搜索性能其实并没有很好的保障。</p><p>R-Trees有多种变种，如R+-Trees，R*-Trees，X-Trees, M-Trees，BR-Trees等等，不再展开过多的介绍。</p><h4 id="Quad-Trees"><a href="#Quad-Trees" class="headerlink" title="Quad-Trees"></a>Quad-Trees</h4><p>HBase中的数据按照RowKey单维度排序组织，而我们现在却面临的是一个多维数据问题。因此，HBase如果想很好的支持时空数据的存储，需要引入时空索引技术。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnu0iuf9j20u20if0sm.jpg" alt="undefined"></p><p>上图中的A,B,C,E,F,G均为Point，以每一个Point作为中心点，可以将一个区间分成4个象限。</p><p>假设，先写入Point A，以A为中心，将整个区间分成了4个象限。</p><p>写入Point B，Point B位于A的东北象限中，同样，以B为中心，依然可以将A东北象限进一步细分为4个子象限。</p><p>写入Point C，Point C位于A的东南象限中，以C为中心，可以将A的东南象限细分成4个子象限。</p><p>…..</p><p>任何新写入的一个Point，总能找到一个某一个已存在的Point的子象限，来存放这个新的Point。</p><p>整个树状结构呈现如下：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnuq702mj210w0dqweg.jpg" alt="undefined"></p><p>可见，Quad-Trees有几个鲜明的特点：1. 对于非叶子节点，均包含4个子节点，对应4个面积不一的象限。2.<strong>不平衡，树的结构与数据的写入顺序直接相关</strong>。3.有空的Leaf Nodes，且所有的Leaf Nodes则是”参差不齐”的(并不一定都出现在树的同一层中)。4.数据既可能出现在分枝节点中，也可能出现在叶子节点中。</p><p>因为Quad-Trees存在诸多变种，为了有所区分，上面提到的最简单的这种Quad-Tree，被称之为Point Quad-Trees。还有一种典型的Quad-Trees，被称之为Point Region QuadTrees(简称为PR QuadTrees)：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnv4pghhj20jw0jvwed.jpg" alt="undefined"></p><p>PR Quad-Trees中，每一次迭代出来的4个象限，面积相同，且不依赖于用户数据Point作为分割点，或者说，<strong>数据分区与用户数据无关</strong>。每一个划分出来的子象限中，只允许存在一个Point。</p><p>与Point Quad-Trees相比，PR Quad-Trees允许两份不同的数据集，拥有相同的分区信息。但PR Quad-Trees存在的问题也明显：1. 两个相邻的Points，可能在树的Level高度上相隔甚远。2.两份数据集如果追求相同的分区信息，可能需要进行足够粒度的分割，这可能导致空间浪费。</p><h4 id="K-D-Trees"><a href="#K-D-Trees" class="headerlink" title="K-D Trees"></a>K-D Trees</h4><p>K-D Trees是一种针对高维点向量数据的索引结构，一棵简单的K-D Tree如下图所示(原图源自James Fogarty的”K-D Trees and Quad Trees”，但为了更直观，关于分区分割线的线条做了改动)：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnwwojz8j20qq0emdg0.jpg" alt="undefined"></p><p>与Quad Trees思想类似，K-D Trees也是将整个区间进行不断分割，不同之处在于，Quad Trees每一次迭代，将一个区间分割成四个象限，而K-D Trees则是分成左右或上下两个区间。如上图所示：S1把整个空间分成了左右两个区间，左侧区间中，又被S2横向分割成了上下两个区间，而S3又在S2的分割基础上，将下部分分割成了左右两个区间，….</p><h4 id="Space-Filling-Curve"><a href="#Space-Filling-Curve" class="headerlink" title="Space Filling Curve"></a>Space Filling Curve</h4><p>如果将一个完整的二维空间，分割成一个个大小相同的矩形，可以将Space Filling Curve简单理解为它是一种将所有的矩形区域用一条线”串”起来的方法，因”串”的方式不同，也就引申出了不同的Space Filling Curve算法。</p><p>比较典型的如Z-Order Curve：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvo2jc2z0j20hb0d5q38.jpg" alt="undefined"></p><p>再如Hilbert Curve:</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvo3097w9j20ha0d3dfx.jpg" alt="undefined"></p><p>GeoMesa使用了基于Z-order填充曲线的GeoHash空间索引技术， 并针对时间维度进行了扩展，具体分为: • Z2:空间，点索引 • Z3:时间+空间，点索引 • XZ2:空间，线\面索引 • XZ3:时间+空间，线\面索引。</p><p>为什么选择了RTree =&gt;</p><ul><li>原先的项目中选择<code>RTree</code></li><li>别的项目没有<code>RTree</code>这么成熟的工业库</li></ul><p><img src="C:\Users\liu.gaoming\AppData\Roaming\Typora\typora-user-images\image-20201120152806907.png" alt="image-20201120152806907"></p><ul><li><p><code>RTree</code>的优化方向比较好找</p></li><li><p><code>RTree</code>可以理解为<code>BTree</code>的多维版本，相对来说比较熟悉，此外R树还可以退化成一维，但是分割的线段存在重叠问题，效果不如<code>Btree</code>。</p></li></ul><h5 id="R树的操作"><a href="#R树的操作" class="headerlink" title="R树的操作"></a>R树的操作</h5><h6 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h6><p>R树的搜索操作很简单，跟B树上的搜索十分相似。它返回的结果是所有符合查找信息的记录条目。而输入是什么？输入不仅仅是一个范围了，它更可以看成是一个空间中的矩形。也就是说，我们输入的是一个搜索矩形。</p><h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><p>R树的插入操作也同B树的插入操作类似。当新的数据记录需要被添加入叶子结点时，若叶子结点溢出，那么我们需要对叶子结点进行分裂操作。显然，叶子结点的插入操作会比搜索操作要复杂。插入操作需要一些辅助方法才能够完成。<br>来看一下伪代码：</p><h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><p>R树的删除操作与B树的删除操作会有所不同，不过同B树一样，会涉及到压缩等操作。相信读者看完以下的伪代码之后会有所体会。R树的删除同样是比较复杂的，需要用到一些辅助函数来完成整个操作。</p><h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><ul><li>为了最小化内存使用可以针对数据类型优化–&gt;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rectangle r = Geometries.rectangle(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line"></span><br><span class="line">Rectangle r = Geometries.rectangle(<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span>);</span><br></pre></td></tr></table></figure><p>理论上这样使用RTree消耗的内存只有Double的一半。</p><ul><li>使用R-Tree的变种 R*-Tree，对数据结构进行了优化，并且同样存在成熟的常用项目 <code>RTee2</code> 可以使用。</li></ul><h3 id="Base4BigData-Version-1"><a href="#Base4BigData-Version-1" class="headerlink" title="Base4BigData(Version.1)"></a>Base4BigData(Version.1)</h3><h4 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h4><p>MapReduce产生的灵感来源于2004年Google发表的《MapReduce》论文中的大数据计算模型，用于大规模数据集（TB甚至PB级）的并行计算，利用分治策略，将计算过程分两个阶段，Map阶段和Reduce阶段，可谓是第一代大数据分布式计算引擎，为后来各类优秀的大数据计算引擎的出现提供了基础和可行性。</p><h5 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h5><p>MapReduce 1.x架构如下：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/640" alt="图片"></p><ol><li>客户端向<code>JobTracker</code>提交任务</li><li><code>JobTraker</code>将任务拆解为多个子任务，分配给<code>TaskTracker</code>执行</li><li><code>TaskTracker</code>定时与<code>JobTracker</code>保持心跳，汇报任务执行情况</li></ol><p>存在的问题：</p><ul><li>单点故障：一旦JobTracker出现故障，会导致任务无法提交和正常执行</li><li>JobTracker负载高：所有的任务的提交和分配以及资源管理都是由JobTracker控制，压力过于集中</li><li>场景有限制：只能运行MapReduce作业，可兼容性差</li></ul><p>为了解决MR v1的问题，MapReduce v2引入了资源管理器YARN (Yet Another Resource Negotiator)，即新一代的MapReduce 2.0。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230094755.png"></p><p>YARN中的重要角色及功能：</p><ol><li><p><strong>ResourceManager</strong>：资源管理节点（RM），对应MR v1的JobTracker</p></li><li><ol><li>负责处理来自客户端的提交的Job</li><li>启动Application Master管理任务</li><li>监控Application Master状态</li><li>为NodeManager分配资源（CPU、内存、磁盘、网络）</li></ol></li><li><p><strong>NodeManager</strong>：工作节点（NM），对应MR v1的TaskTracker</p></li><li><ol><li>管理节点container任务资源和运行情况</li><li>与ResourceManager保持通信，汇报自身的状态</li></ol></li><li><p><strong>Application Master</strong>：任务管理服务（AM），其实就是ResourceManager的小弟</p></li><li><ol><li>负责检查集群资源，申请mr程序所需资源</li><li>分配任务到相应的container容器执行</li><li>监控任务执行状态并向ResourceManager汇报任务执行情况</li></ol></li><li><p><strong>Container</strong>：YARN资源抽象，封装了节点上的资源，如内存、CPU、磁盘等</p></li></ol><p>YARN的优势：</p><ol><li>ResourceManager支持HA，解决了JobTracker单点故障的问题，提高集群可用性</li><li>实现资源管理和job管理分离，解决了JobTracker负载高的难题</li><li>提供Application Master负责监控所有的任务，解决了JobTracker集中管理监控的压力</li><li>高扩展性，不仅可以跑mr任务，还支持spark作业以及其他计算引擎任务</li><li>提高了资源的利用率</li></ol><h5 id="MapReduce核心计算阶段"><a href="#MapReduce核心计算阶段" class="headerlink" title="MapReduce核心计算阶段"></a>MapReduce核心计算阶段</h5><p>Mapper阶段：负责数据 的载入、解析、转换和过滤，map任务的输出被称为中间键和中间值 </p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230095256.png"></p><p>Reducer阶段：负责处理map任务输出结果，对map任务处理完的结果集进行排序、局部聚合计算再汇总结果</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230095337.png"></p><h5 id="MapReduce为什么慢？"><a href="#MapReduce为什么慢？" class="headerlink" title="MapReduce为什么慢？"></a>MapReduce为什么慢？</h5><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230095416.png"></p><ul><li>MapReduce是基于磁盘数据进行计算的</li><li>Shuffle过程进行一系列分区、排序，耗费大量时间</li><li>map计算结果频繁落盘</li><li>reduce任务通过磁盘获取数据，占用IO</li><li>spill会会产生大量的小文件，极大占用集群的资源</li><li>容错性差，错了就重头来过</li><li>MapReduce抽象层次低，只有map和reduce两种，处理数据效率较低</li></ul><p>因此MapReduce只适用于处理大规模离线数据，延时高。MapReduce的局限性推动了计算引擎技术的革新，Spark的出现是为了解决MapReduce计算慢的问题，随着数据量的指数增长，对数据处理效率有了更高的要求，我们需要在更短的时间内得到正确的结果。</p><h4 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h4><p>Apache Spark是用于大规模数据处理的统一分析计算引擎，最初诞生于加州大学伯克利分校的AMP Lab实验室。基于内存进行并行计算，通过使用最先进的DAG调度器、查询优化器和物理执行引擎，实现了批处理和流处理的高性能，与Hadoop MapReduce相比，运行在内存中的计算速度要快上100倍（实际上或许没有快这么多），但是可见spark是要比Hadoop MapReduce计算能力更强的计算引擎。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230095750.png"></p><h5 id="组件角色"><a href="#组件角色" class="headerlink" title="组件角色"></a>组件角色</h5><p>Spark由Spark Core、Spark SQL、Spark Streaming、MLib和GraphX四大组件构成 .</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230095825.png"></p><p>角色说明：</p><ul><li>Spark Core：spark的核心，将数据抽象为弹性分布式数据集（RDD），提供了分布式任务调度，RPC通信、序列化和压缩等特性，是内存计算的框架，用于离线计算</li><li>Spark SQL：基于Spark Core之上用于结构化数据建模和数据处理组件，实现交互式查询</li><li>Spark Streaming：利用Spark Core快速调度能力进行流式计算</li><li>MLib：是Spark上分布式机器学习框架，提供了大量的算法</li><li>GraphX：是Spark上的分布式图形处理框架，能进行高效的图计算</li></ul><h5 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h5><p>Spark是一个典型的master/slave主从架构，基于内存计算引擎，提供了多种缓存机制，将RDD 缓存到内存或者磁盘中，这种机制使得Spark可以进行迭代计算和数据共享，从而减少数据读取的IO开销，架构如下：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230100453.png"></p><ul><li><strong>Driver</strong>：初始化Spark运行环境，创建SparkContext上下文环境，是用户程序的入口，即main() 方法</li><li><strong>Cluster Manager</strong>：资源管理器，目前支持Standalone、YARN、Mesos和Kubernetes这几种模式，在Standalone模式中，Cluster Manager即为Master节点，控制整个集群</li><li><strong>Worker</strong>：spark计算节点，负责计算任务的管理，为task分配并启动Executor，定时向Cluster Manager汇报任务执行情况</li><li><strong>Executor</strong>：Spark Task工作的容器，是用户程序在worker节点上的一个进程，运行计算任务，负责数据的读取和写入，缓存中间数据</li></ul><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230100533.png"></p><ol><li>Driver驱动程序会初始化<code>SparkContext</code></li><li>初始化过程中会启动<code>DAGScheduler</code>和<code>TaskScheduler</code></li><li><code>TaskScheduler</code>通过后台进程向Master注册用户程序</li><li>Master收到注册请求之后会通知Worker为用户程序启动多个Executor容器</li><li>Executor反向<code>SparkContext</code>注册</li><li><code>SparkContext</code>将应用程序发给Executor</li><li><code>SparkContext</code>完成初始化，构建DAG，创建Job并且根据action操作划分Stage，形成<code>TaskSet</code>发送给<code>TaskScheduler</code>，最后发给Executor执行</li><li>运行完释放资源</li></ol><h5 id="Spark-为什么比MapReduce快"><a href="#Spark-为什么比MapReduce快" class="headerlink" title="Spark 为什么比MapReduce快"></a>Spark 为什么比MapReduce快</h5><ul><li>Spark相对于MapReduce减少了磁盘IO，没有太多中间结果落盘</li><li>Spark采用了多线程模型，基于线程池复用降低task线程的开销</li><li>spark提供了多种缓存策略，避免了重复计算</li><li>灵活的内存管理策略</li><li>Spark的DAG（有向无环图）算法</li><li>提供丰富的抽象方法，MapReduce只有map和reduce两种抽象</li><li>缓存和checkpoint，通过lineage实现高度容错性</li></ul><p>以上列举了spark比MapReduce快的部分特性，Spark的出现逐步取代了MapReduce成为新一代离线计算引擎的最佳选择，不仅如此，spark还提供了Spark Streaming组件作为流式计算引擎。</p><h4 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h4><p>Spark Streaming是Spark Core API的扩展，支持实时数据流的可伸缩、高吞吐量、容错流处理。支持多种数据源，数据可以从Kafka、Flume、HDFS、S3、Kinesis或TCP套接字等许多来源获取，并可以使用复杂的算法处理，这些算法由map、reduce、join和window等高级函数表达。最后，可以将处理过的数据推送到文件系统、数据库和实时仪表板中。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230102906.png"></p><h5 id="工作模型"><a href="#工作模型" class="headerlink" title="工作模型"></a>工作模型</h5><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230103446.png" alt="image-20201230103445976"></p><p>Spark Streaming基于micro batch方式的计算和处理流数据，提供了称为离散流或DStream的高级抽象，它表示连续的数据流。将接收到的数据流切分为多个独立的DStream，本质上也是一系列RDD，通过spark计算引擎进行计算。</p><h5 id="DStreams（Discretized-Streams）"><a href="#DStreams（Discretized-Streams）" class="headerlink" title="DStreams（Discretized Streams）"></a>DStreams（Discretized Streams）</h5><p>离散数据流是Spark Streaming提供的基本抽象，将待处理数据转变为连续不断的数据流，可以是外部数据源转换而来，也可以通过内部流之间的转换生成，从DStream的内部流模型可以看到Dstream就是由一系列的RDD组成。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230103618.png" alt="image-20201230103618209"></p><p>实际上，Dstream执行的操作都会转换为对底层RDD的操作。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230103652.png" alt="v"></p><p>Spark Streaming是怎么实现数据实时计算的呢？</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230103754.png" alt="image-20201230103754154"></p><p>当spark Streaming接收到数据后，会将数据流切分成多个批次，形成有界的数据集，设置时间间隔，当不同批次的数据进入窗口后会触发计算机制，通过Spark Core进行一系列tranformation和action操作，因为划分批次之后的数据比较小，实时计算得出结果。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230103843.png" alt="图片"></p><h5 id="为什么要用Spark-Streaming呢？"><a href="#为什么要用Spark-Streaming呢？" class="headerlink" title="为什么要用Spark Streaming呢？"></a>为什么要用Spark Streaming呢？</h5><p>从数据的边界来说，我们可以把数据分为有界数据和无界数据。顾名思义，有界数据是有范围的，一般来说与时间是强关联的，以历史数据最为典型。而无界数据就是难以限定范围的数据，会持续不断发生变化，最常见的场景就是实时数据流，看不到数据的尽头，一直在发生。</p><p>MapReduce和Spark SQL等框架只能进行离线计算，无法满足实时性要求高的业务场景，如购买商品后进行实时推荐、实时交易业务等等。而spark Streaming巧妙地将数据细分为多个微小的批次，依赖于spark计算引擎能做到准实时计算，不是真正意义上的实时计算，尽管如此，spark Streaming还是得到了业界的认可和广泛应用。</p><p>Spark Streaming优势：</p><ul><li>实时性：Spark Streaming 是一个实时计算框架，微批处理数据，延迟可以控制到秒级</li><li>高容错性：Spark Streaming底层依赖RDD lineage特性、缓存机制、checkpoint机制以及WAL预写日志，可以实现高度容错</li><li>高吞吐：相对于实时计算框架Storm吞吐量更高</li><li>一体化：依托spark生态，不仅能进行实时计算，还能应用于机器学习和Spark SQL场景</li></ul><p>对于大部分企业来说，秒级的延时是可以接受的，而且一个大数据项目通常会包含离线计算、交互式查询、数据分析、实时计算等模块，Spark Streaming毫无疑问是很好的选择。</p><h4 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h4><p>storm是一个真正的实时流计算引擎，相对于Spark Streaming的微批处理，storm则是来一条数据计算一条数据，延时可以控制到毫秒级。</p><h5 id="Storm架构"><a href="#Storm架构" class="headerlink" title="Storm架构"></a>Storm架构</h5><p>storm的架构与Hadoop相似，都是master/slave主从架构。</p><table><thead><tr><th>成员</th><th>Storm</th><th>Hadoop</th></tr></thead><tbody><tr><td>主节点</td><td>Nimbus</td><td>JobTracker</td></tr><tr><td>从节点</td><td>Supervisor</td><td>TaskTracker</td></tr><tr><td>计算模型</td><td>Spout / Bolt</td><td>Map / Reduce</td></tr><tr><td>应用程序</td><td>Topology</td><td>Job</td></tr><tr><td>工作进程</td><td>Worker</td><td>Child</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230104329.png" alt="图片"></p><p>Nimbus：master节点，负责提交任务，分配到supervisor的worker上，运行Topology上的Spout/Bolt任务</p><p>Zookeeper：协调节点，负责管理storm集群的元数据信息，比如heartbeat信息、集群状态和配置信息以及Nimbus分配的任务信息等</p><p>Supervisor：slave节点，负责管理运行在supervisor节点上的worker进程</p><h5 id="Storm工作流程"><a href="#Storm工作流程" class="headerlink" title="Storm工作流程"></a>Storm工作流程</h5><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230104612.png" alt="图片"></p><ol><li>客户端提交topology任务到Nimbus节点</li><li>Nimbus主节点将任务提交到zookeeper集群管理</li><li>Supervisor节点从Zookeeper集群获取任务信息</li><li>启动worker进程开始执行任务</li></ol><h5 id="Storm-Vs-Spark-Streaming"><a href="#Storm-Vs-Spark-Streaming" class="headerlink" title="Storm Vs Spark Streaming"></a>Storm Vs Spark Streaming</h5><p>用一个生动形象的生活场景来比喻Storm和Spark Streaming，Storm好比是手扶电梯，一直在运行，来一个人都会将他带上/下楼，而Spark Streaming更像是升降电梯，要装满一批人才开始启动。</p><ul><li>storm可以实现毫米级计算响应 VS Spark Streaming只能做到秒级响应</li><li>Storm吞吐量低 VS Spark Streaming吞吐量高</li></ul><table><thead><tr><th>Item</th><th>Storm</th><th>Spark Streaming</th></tr></thead><tbody><tr><td>Streaming Model</td><td>Native</td><td>Micro-Batch</td></tr><tr><td>Guarantees</td><td>At-Least-Once</td><td>Exactly-Once</td></tr><tr><td>Back Pressure</td><td>No</td><td>Yes</td></tr><tr><td>Latency</td><td>Very Low</td><td>Low</td></tr><tr><td>Throughput</td><td>Low</td><td>High</td></tr><tr><td>Fault Tolerance</td><td>Record ACKs</td><td>RDD Based CheckPoint</td></tr><tr><td>Stateful</td><td>No</td><td>Yes（DStream）</td></tr></tbody></table><h4 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h4><p>Apache Flink是一个分布式处理引擎，用于在<em>无边界和有边界</em>数据流上进行有状态的计算。Flink能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。现在Flink也是主流的实时流计算框架并且同时支持批处理，支持基于有状态的事件时间进行计算，成为大数据计算引擎的领头羊，大有盖过Spark风头之势。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230104908.png" alt="图片"></p><p>擅长处理有界（bounded）数据和无界（unbounded）数据，有界数据通常指的是离线历史数据，用于批处理，而无界数据指数据流有定义数据产生的开始，却无法定义数据何时结束，因此无界数据流通常说的就是实时流，用于实时计算。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230104939.png" alt="图片"></p><h5 id="架构-2"><a href="#架构-2" class="headerlink" title="架构"></a>架构</h5><p>Flink和Spark一样，也是主从架构，由JobManager和TaskManager组成</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230105021.png" alt="图片"></p><p>JobManager：主节点，负责处理客户端提交的Job，管理Job状态信息，调度分配集群任务，对完成的 Task 或执行失败做出反应、协调 checkpoint、并且协调从失败中恢复</p><p>TaskManager：从节点，负责管理节点上的资源，向JobManager汇报集群状态，执行计算JobManager分配的Task</p><p>Flink工作调度</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230105309.png" alt="img"></p><ol><li>用户提交Flink程序时，client会对程序进行预处理，构建Dataflow graph，封装成Job提交到JobManager</li><li>JobManager接收到client提交的Job，获取并管理Job的基本信息，构建DAG执行计划，通过Scheduler调度任务并分配到对应的TaskManager节点</li><li>TaskManager向JobManager注册，JobManager将Job分配到TaskManager执行，每个Task Slot代表着用来执行Task的资源，包括了内存、cpu等</li><li>TaskManager与JobManager保持心跳，定时汇报节点资源情况以及任务执行情况</li><li>JobManager将将任务执行的状态和结果反馈给客户端</li></ol><h5 id="Flink的优势"><a href="#Flink的优势" class="headerlink" title="Flink的优势"></a>Flink的优势</h5><ul><li>Flink支持实时计算，且基于内存管理，性能优越</li><li>具有高吞吐、低延迟、高性能的流处理特性</li><li>Flink与Hadoop生态高度融合</li><li>高度灵活的时间窗口语义</li><li>流批一体化，同时支持批处理和流计算</li><li>高容错，基于分布式快照（snapshot）和checkpoint检查点机制</li><li>具有反压（Backpressure）功能</li><li>支持有状态计算的Exactly-once语义</li><li>可以进行机器学习处理（FlinkML）、图分析（Gelly）、关系数据处理（FLink SQL）以及复杂事件处理（CEP）</li></ul><h4 id="Flink-VS-Storm-VS-Spark-Streaming"><a href="#Flink-VS-Storm-VS-Spark-Streaming" class="headerlink" title="Flink VS Storm VS Spark Streaming"></a>Flink VS Storm VS Spark Streaming</h4><table><thead><tr><th>Item</th><th>Flink</th><th>Storm</th><th>Spark Streaming</th></tr></thead><tbody><tr><td>Streaming Model</td><td>Native</td><td>Native</td><td>Micro-Batch</td></tr><tr><td>Guarantees</td><td>Exactly-Once</td><td>At-Least-Once</td><td>Exactly-Once</td></tr><tr><td>Back Pressure</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>Latency</td><td>Medium</td><td>Very Low</td><td>Low</td></tr><tr><td>Throughput</td><td>High</td><td>Low</td><td>High</td></tr><tr><td>Fault Tolerance</td><td>Checkouting</td><td>Record ACKs</td><td>RDD Based CheckPoint</td></tr><tr><td>Stateful</td><td>Yes（Operators）</td><td>No</td><td>Yes（DStream）</td></tr></tbody></table><h3 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h3><script src="https://gist.github.com/FlyMeToTheMars/43f8f342d907d1eba39d270324b3653f.js"></script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;笨猫不如烂笔头&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Interview" scheme="http://yoursite.com/categories/Interview/"/>
    
    
    <category term="PICKS" scheme="http://yoursite.com/tags/PICKS/"/>
    
  </entry>
  
  <entry>
    <title>朝花夕拾（三）</title>
    <link href="http://yoursite.com/2022/08/08/%E9%98%BF%E7%B1%B3%E8%AF%BA%E6%96%AF/"/>
    <id>http://yoursite.com/2022/08/08/%E9%98%BF%E7%B1%B3%E8%AF%BA%E6%96%AF/</id>
    <published>2022-08-07T19:22:39.000Z</published>
    <updated>2025-07-30T07:20:57.300Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>细节补充</p></blockquote><a id="more"></a> <h1 id="JS-amp-Tool-amp-Other"><a href="#JS-amp-Tool-amp-Other" class="headerlink" title="JS &amp; Tool &amp; Other"></a>JS &amp; Tool &amp; Other</h1><h2 id="VSCODE"><a href="#VSCODE" class="headerlink" title="VSCODE"></a>VSCODE</h2><p>插件搜索 @installed 可以查到已经安装的插件</p><p>自动格式化代码：<code>Shift + Alt + F</code></p><p>特别有用的正则：</p><p>1.删除A之后的所有字符用：A.*$</p><p>2.删除A之前的所有字符用：^([^s]*)A</p><p>####如果是其他字符就把A替换为其他字符</p><p>注释：如何是特殊字符注意转义</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;细节补充&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>朝花夕拾（二）</title>
    <link href="http://yoursite.com/2022/07/17/%E5%B0%B1%E6%98%AF%E8%AF%B4%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%92%8C%E4%BD%A0%E5%AF%B9%E8%AF%9D%E5%91%A2/"/>
    <id>http://yoursite.com/2022/07/17/%E5%B0%B1%E6%98%AF%E8%AF%B4%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%92%8C%E4%BD%A0%E5%AF%B9%E8%AF%9D%E5%91%A2/</id>
    <published>2022-07-17T06:00:46.000Z</published>
    <updated>2025-07-30T07:21:06.823Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>细节补充</p></blockquote><a id="more"></a> <h1 id="Anaconda-Navigator-amp-Pyhton-amp-脚本语言-amp-Others"><a href="#Anaconda-Navigator-amp-Pyhton-amp-脚本语言-amp-Others" class="headerlink" title="Anaconda Navigator &amp; Pyhton &amp; 脚本语言 &amp; Others"></a>Anaconda Navigator &amp; Pyhton &amp; 脚本语言 &amp; Others</h1><h2 id="Anaconda-Navigator-介绍-背景"><a href="#Anaconda-Navigator-介绍-背景" class="headerlink" title="Anaconda Navigator 介绍 / 背景"></a>Anaconda Navigator 介绍 / 背景</h2><h3 id="conda-anaconda-anaconda-navigator-pip-virtualenv区别"><a href="#conda-anaconda-anaconda-navigator-pip-virtualenv区别" class="headerlink" title="conda anaconda anaconda-navigator pip virtualenv区别"></a>conda anaconda anaconda-navigator pip virtualenv区别</h3><ul><li><p>Anaconda是一个包含180+的科学包及其依赖项的发行版本。其包含的科学包包括：conda, numpy, scipy, ipython notebook等。</p></li><li><p>conda是包及其依赖项和环境的管理工具。</p></li><li><p>pip是用于安装和管理软件包的包管理器。</p></li><li><p>virtualenv：用于创建一个<strong>独立的</strong>Python环境的工具。</p></li><li><p>“Anaconda-Navigator”中已经包含“Jupyter Notebook”、“Jupyterlab”、“Qtconsole”和“Spyder”。</p></li></ul><h3 id="conda基础操作"><a href="#conda基础操作" class="headerlink" title="conda基础操作"></a>conda基础操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">创建环境 conda create -n envname python=xxx</span><br><span class="line"></span><br><span class="line">删除环境 conda remove -n envname --all</span><br><span class="line"></span><br><span class="line">进入环境 conda activate envname (old version: source activate xxx)</span><br><span class="line"></span><br><span class="line">离开环境 conda deactivate (old version: source deactivate)</span><br><span class="line"></span><br><span class="line">列出所有环境 conda info -e #这里列出环境的同时会列出该环境的绝对路径</span><br></pre></td></tr></table></figure><h4 id="conda参数"><a href="#conda参数" class="headerlink" title="conda参数"></a>conda参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">conda install -y 覆盖提示，默认yes</span><br><span class="line"></span><br><span class="line">The following NEW packages will be INSTALLED:</span><br><span class="line"></span><br><span class="line">    libgfortran:     1.0-0             </span><br><span class="line">    numpy:           1.10.2-py27_0     </span><br><span class="line">    openblas:        0.2.14-3          </span><br><span class="line">    pandas:          0.17.1-np110py27_0</span><br><span class="line">    python-dateutil: 2.4.2-py27_0      </span><br><span class="line">    pytz:            2015.7-py27_0     </span><br><span class="line">    six:             1.10.0-py27_0     </span><br><span class="line"></span><br><span class="line">Proceed ([y]/n)? y</span><br><span class="line">等于提前输入了这个y</span><br><span class="line"></span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">conda install -c 这个c的意思是channel，也就是指定了下载通道，在出现某些网络问题的情况下可以换一个下载源就这个意思</span><br><span class="line"></span><br><span class="line">-------------------</span><br></pre></td></tr></table></figure><h4 id="conda-install-和-pip-install-的区别"><a href="#conda-install-和-pip-install-的区别" class="headerlink" title="conda install 和 pip install 的区别"></a>conda install 和 pip install 的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip只能安装python包，而conda可以安装由任何语言编写的包</span><br><span class="line">pip不能创建虚拟环境，需要借助另外的包，例如virtualenv,而conda可以创建虚拟环境。</span><br><span class="line">pip是按照python时自带的，而conda需要安装anaconda才能用。</span><br></pre></td></tr></table></figure><p>具体区别可以在找个官网上找到 <a href="https://www.anaconda.com/blog/understanding-conda-and-pip" target="_blank" rel="noopener">https://www.anaconda.com/blog/understanding-conda-and-pip</a></p><h4 id="conda更新"><a href="#conda更新" class="headerlink" title="conda更新"></a>conda更新</h4><p>很多时候打不开可能也是因为要更新了</p><p>管理员运行            <code>conda prompt</code><br>然后                        <code>conda update anaconda-navigator</code></p><p>第三步                    <code>anaconda-navigator --reset</code></p><p>第四步                    <code>conda update anaconda-client</code></p><p>第五步                    <code>conda update -f anaconda-client</code></p><h2 id="Jupyter-Book"><a href="#Jupyter-Book" class="headerlink" title="Jupyter Book"></a>Jupyter Book</h2><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><p>端口 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认8888 值得一提的是如果同时开启jupyter book和jupyterlab需要小心端口冲突</span><br></pre></td></tr></table></figure><p>快捷键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快捷键这里不过多介绍，因为我本身就是远程到windows机器上 `等待补充`</span><br></pre></td></tr></table></figure><p>显示多行输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jupyter Book默认只显示一行输出，要想显示多行输出,需要添加如下代码</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">'all'</span></span><br></pre></td></tr></table></figure><p>简易命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不必离开Jupyter笔记本来执行Shell命令，而是可以在命令开头使用感叹号(!)。例如，您可以安装软件包。</span><br><span class="line">!pip install matplotlib</span><br></pre></td></tr></table></figure><p>大量魔术命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">魔术命令（magic commands）是有助于提高生产率的特殊命令。您可能最熟悉下面的魔术命令，该命令让Notebook渲染Python Matplotlib创建的图表。</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">％pwd ＃打印当前工作目录</span><br><span class="line">％cd ＃更改工作目录</span><br><span class="line">％ls ＃显示当前目录中的内容</span><br><span class="line">％load [在此处插入Python文件名] ＃将代码加载到Jupyter Notebook</span><br><span class="line">％store [在此处插入变量]  ＃这使您可以传递Jupyter Notebooks之间的变量</span><br><span class="line">％who  ＃使用它列出所有变量</span><br><span class="line">%lsmagic # 查看完整的魔术命令列表</span><br></pre></td></tr></table></figure><p>记录单元格运行时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br></pre></td></tr></table></figure><p>显示函数文档</p><p><code>shift + tab</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在Jupyter Book里面查看这个Book后面的Python版本的命令</span><br><span class="line">import sys</span><br><span class="line">sys.version</span><br></pre></td></tr></table></figure><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 照例来个 Hello World 先</span></span><br><span class="line">print(<span class="string">"Hello, Jupyter Book"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印 Python 中的所有关键字</span></span><br><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">print(keyword.kwlist)</span><br></pre></td></tr></table></figure><p>[‘False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘async’, ‘await’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’, ‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 幂运算</span></span><br><span class="line"><span class="number">1.01</span> ** <span class="number">365</span></span><br><span class="line"><span class="comment"># 乘法运算符和字符串的混合使用</span></span><br><span class="line">print(<span class="string">'-------'</span> * <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 除法运算</span></span><br><span class="line"><span class="number">10</span> / <span class="number">20</span></span><br><span class="line"><span class="comment"># 取整运算</span></span><br><span class="line"><span class="number">9</span> // <span class="number">2</span> <span class="comment"># 取整</span></span><br></pre></td></tr></table></figure><p>37.78343433288728</p><p><code>----------------------------------------------------------------------</code></p><p>0.5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(<span class="string">"多行注释"</span>)</span><br></pre></td></tr></table></figure><p><code>&#39;\n多行注释\n&#39;</code></p><p><code>多行注释</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照是否是数字型类可以把python里面的类型分为两类，数字型和非数字型。</span></span><br><span class="line"><span class="comment"># 数字类型分为 int float bool complex(复数型)，非数字型分为 字符串、列表、元组、字典。（这四种非数字型类型其实都可以看为容器或者序列）</span></span><br><span class="line"><span class="comment"># 判定类型 python 3 取消了python 2里面的长整形的概念</span></span><br><span class="line">account = <span class="number">1101</span></span><br><span class="line">print(type(account))</span><br></pre></td></tr></table></figure><p><code>&lt;class &#39;int&#39;&gt;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bool 类型 参与计算 True 是 1， false 是 0</span></span><br><span class="line"><span class="comment"># input() 输入的总是String类型</span></span><br><span class="line">inputStr = input(<span class="string">"记录输入"</span>)</span><br></pre></td></tr></table></figure><p>记录输入 （内容 ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python类型强制转换 强制把123字符串转换成了int</span></span><br><span class="line">type(int(<span class="string">"123"</span>))</span><br></pre></td></tr></table></figure><p>int</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化字符串</span></span><br><span class="line"><span class="comment"># %s 字符串</span></span><br><span class="line">name = <span class="string">"demo"</span></span><br><span class="line">print(<span class="string">"我的名字叫 %s"</span> % name)</span><br><span class="line"><span class="comment"># %d 有符号十进制整数 %09d 的意思是如果没有get到9位的话，就用0补全，如果get到了 不进行别的多余操作</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">print(<span class="string">"学号是 %09d"</span> % num)</span><br><span class="line"><span class="comment"># %f 取舍同上 %.2f 的意思是取小数点后两位，没有的话0补全</span></span><br><span class="line">price = <span class="number">8.5</span></span><br><span class="line">weight = <span class="number">7.5</span></span><br><span class="line">money = price * weight</span><br><span class="line">print(<span class="string">"苹果单价 %.2f元/斤 ,购买了 %.3f斤，需要支付%.4f元"</span> % (price,weight,money))</span><br><span class="line">scale = <span class="number">0.8</span></span><br><span class="line">print(<span class="string">"数据比例是 %.2f%%"</span> % (scale * <span class="number">100</span>)) <span class="comment"># 此处内部的括号如果省略的话，是另一种效果 --&gt; 字符串 * 100</span></span><br></pre></td></tr></table></figure><p>我的名字叫 demo<br>学号是 000000001<br>苹果单价 8.50元/斤 ,购买了 7.500斤，需要支付63.7500元<br>数据比例是 80.00%</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断条件 没有括号 使用 and 和 or 作为逻辑判断连接符号 而不像Java里面的 &amp; 和 | 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if not </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># elif =&gt; else if in Java</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行if条件：</span></span><br><span class="line"><span class="comment"># if ((player == 1 and b == 2))</span></span><br><span class="line"><span class="comment">#      or (...)</span></span><br><span class="line"><span class="comment">#      or (...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># break 和 continue</span></span><br><span class="line"><span class="comment"># break: 某一天剑满足时，退出循环，不再执行后续重复的代码</span></span><br><span class="line"><span class="comment"># continue: 某一条件满足时，不执行后续重复的代码</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.randint(<span class="number">10</span>,<span class="number">20</span>) <span class="comment"># 10 &lt;= n &lt;= 20</span></span><br></pre></td></tr></table></figure><p>16</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 赋值运算符</span></span><br><span class="line"><span class="comment"># =     +=    -=    *=    /=    //=    %=    **=</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在控制台输出</span></span><br><span class="line"><span class="comment"># 1. 定义一个计数器变量，从数字1开始，循环会比较方便</span></span><br><span class="line">row = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.开始循环</span></span><br><span class="line"><span class="keyword">while</span> row &lt;= <span class="number">5</span>:</span><br><span class="line">    print(<span class="string">"*"</span> * row)</span><br><span class="line">    row += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print 详解</span></span><br><span class="line">print() <span class="comment"># &lt;=&gt; print("内容",end="换行符")</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 经典 99 乘法表</span></span><br><span class="line">row = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> row &lt;= <span class="number">9</span>:</span><br><span class="line">    col = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> col &lt;= row:</span><br><span class="line">        print(<span class="string">"%d * %d = %d"</span> % (col, row, col * row ), end = <span class="string">"\t"</span>)</span><br><span class="line">        col += <span class="number">1</span></span><br><span class="line">    row += <span class="number">1</span></span><br><span class="line">    print(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><p>1 * 1 = 1<br>1 * 2 = 2    2 * 2 = 4<br>1 * 3 = 3    2 * 3 = 6    3 * 3 = 9<br>1 * 4 = 4    2 * 4 = 8    3 * 4 = 12    4 * 4 = 16<br>1 * 5 = 5    2 * 5 = 10    3 * 5 = 15    4 * 5 = 20    5 * 5 = 25<br>1 * 6 = 6    2 * 6 = 12    3 * 6 = 18    4 * 6 = 24    5 * 6 = 30    6 * 6 = 36<br>1 * 7 = 7    2 * 7 = 14    3 * 7 = 21    4 * 7 = 28    5 * 7 = 35    6 * 7 = 42    7 * 7 = 49<br>1 * 8 = 8    2 * 8 = 16    3 * 8 = 24    4 * 8 = 32    5 * 8 = 40    6 * 8 = 48    7 * 8 = 56    8 * 8 = 64<br>1 * 9 = 9    2 * 9 = 18    3 * 9 = 27    4 * 9 = 36    5 * 9 = 45    6 * 9 = 54    7 * 9 = 63    8 * 9 = 72    9 * 9 = 81    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiple_table</span><span class="params">()</span>:</span></span><br><span class="line">    row = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> row &lt;= <span class="number">9</span>:</span><br><span class="line">        col = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> col &lt;= row:</span><br><span class="line">            print(<span class="string">"%d * %d = %d"</span> % (col, row, col * row ), end = <span class="string">"\t"</span>)</span><br><span class="line">            col += <span class="number">1</span></span><br><span class="line">        row += <span class="number">1</span></span><br><span class="line">        print(<span class="string">""</span>)</span><br><span class="line">        </span><br><span class="line">multiple_table()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数注释的说明</span></span><br><span class="line"><span class="comment"># 1. 注释写在方法名下面  2. 方法的第一排要和上面最后一行有两行空白的距离 3.pycharm中，鼠标放在方法名上，Ctrl+Q就可以调出注释。</span></span><br></pre></td></tr></table></figure><p>1 * 1 = 1<br>1 * 2 = 2    2 * 2 = 4<br>1 * 3 = 3    2 * 3 = 6    3 * 3 = 9<br>1 * 4 = 4    2 * 4 = 8    3 * 4 = 12    4 * 4 = 16<br>1 * 5 = 5    2 * 5 = 10    3 * 5 = 15    4 * 5 = 20    5 * 5 = 25<br>1 * 6 = 6    2 * 6 = 12    3 * 6 = 18    4 * 6 = 24    5 * 6 = 30    6 * 6 = 36<br>1 * 7 = 7    2 * 7 = 14    3 * 7 = 21    4 * 7 = 28    5 * 7 = 35    6 * 7 = 42    7 * 7 = 49<br>1 * 8 = 8    2 * 8 = 16    3 * 8 = 24    4 * 8 = 32    5 * 8 = 40    6 * 8 = 48    7 * 8 = 56    8 * 8 = 64<br>1 * 9 = 9    2 * 9 = 18    3 * 9 = 27    4 * 9 = 36    5 * 9 = 45    6 * 9 = 54    7 * 9 = 63    8 * 9 = 72    9 * 9 = 81    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_2_num</span><span class="params">(num1,num2)</span>:</span></span><br><span class="line">    result = num1 + num2</span><br><span class="line">    print(<span class="string">"%d + %d = %d"</span> % (num1,num2,result))</span><br><span class="line"></span><br><span class="line">sum_2_num(<span class="number">50</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>50 + 20 = 70</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pyc文件：python的编译后文件，浏览程序目录里面会有一个 __pycache__ 的目录，里面会有pyc为后缀的文件，就是编译后文件。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># List 是使用最频繁的数据类型，对应别的语言中的数组。</span></span><br><span class="line"><span class="comment"># 专门用于存储一串信息</span></span><br><span class="line"><span class="comment"># 列表用 [] 定义，数据之间使用 , 分隔</span></span><br><span class="line"><span class="comment"># 列表的索引从 0 开始  --&gt; index</span></span><br><span class="line"></span><br><span class="line">lname_list = []</span><br><span class="line"><span class="comment"># 增加</span></span><br><span class="line"><span class="comment"># 列表自带了很多的方法，</span></span><br><span class="line"><span class="comment"># 列表.insert(索引) 在指定位置插入数据</span></span><br><span class="line"><span class="comment"># 列表.append(数据) 在末尾追加数据</span></span><br><span class="line"><span class="comment"># 列表.extend(列表2) 将列表2 的数据追加到列岛</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line"><span class="comment"># 列表[索引] = 数据 修改指定索引的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="comment"># del 列表[索引] 删除指定索引的数据</span></span><br><span class="line"><span class="comment"># 列表.remove[数据] 删除第一个出现的指定数据</span></span><br><span class="line"><span class="comment"># 列表.pop 删除末尾数据</span></span><br><span class="line"><span class="comment"># 列表.pop(索引) 删除指定索引数据</span></span><br><span class="line"><span class="comment"># 列表.clear 清空列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计</span></span><br><span class="line"><span class="comment"># len(列表) 列表长度</span></span><br><span class="line"><span class="comment"># 列表.count(数据) 数据在列表中出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line"><span class="comment"># 列表.sort() 生序排序</span></span><br><span class="line"><span class="comment"># 列表.sort(reverse=True) 降序排序</span></span><br><span class="line"><span class="comment"># 列表.reverse() 逆序、反转</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># List之遍历</span></span><br><span class="line"><span class="comment"># 类比 Java 里面的 foreach </span></span><br><span class="line"><span class="comment"># 语法形式：</span></span><br><span class="line"><span class="comment"># for 别名 in List:</span></span><br><span class="line"><span class="comment"># 理论上List是可以存储不同类型的数据的, 习惯上 使用元组保存不同类型的数据，使用List保存相同类型的数据</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元组 Tuple</span></span><br><span class="line"><span class="comment"># 元组的元素不能修改</span></span><br><span class="line"><span class="comment"># 使用（）定义，索引从0开始</span></span><br><span class="line">info_tuple = (<span class="string">"zhangsan"</span>,<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混淆点 定义只有一个变量的元组 需要加上一个逗号</span></span><br><span class="line">single_tuple = (<span class="number">5</span>)</span><br><span class="line">type(single_tuple)  <span class="comment">#int</span></span><br><span class="line">single_tuple = (<span class="number">5</span>,)</span><br><span class="line">type(single_tuple) <span class="comment"># tuple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是如果是定义一个空的元祖的话，我们只需要定义一个括号即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化字符串 % 后面的本质上就是一个元组， 使用元组来拼接一个新的字符串效果相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List 和 Tuple 的转换 List(元组) 可以把元组转换成List，使用tuple(列表)可以把列表转换成元组</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典 dictionary 使用 &#123;&#125; 定义，类似于 Map</span></span><br><span class="line"><span class="comment"># 字典无序 List有序    字典的key必须是不可变类型</span></span><br><span class="line"><span class="comment"># 值可以是任何数据类型，键只能使用字符串、数字或者元组</span></span><br><span class="line">xiaoming = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">"gender"</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">"height"</span>: <span class="number">1.75</span>,</span><br><span class="line">    <span class="string">"weight"</span>: <span class="number">75.6</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(xiaoming)</span><br><span class="line">print(xiaoming[<span class="string">"name"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加 / 修改</span></span><br><span class="line">xiaoming[<span class="string">"age"</span>] = <span class="number">10</span>  <span class="comment"># 如果这个值得没有的话，就会新建</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 pop</span></span><br><span class="line">xiaoming.pop(<span class="string">"age"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并字典 update</span></span><br><span class="line">zidian = &#123;<span class="string">"key"</span>: <span class="string">"value"</span>&#125;</span><br><span class="line">zidian.update(xiaoming)</span><br><span class="line">print(zidian)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空 clear</span></span><br><span class="line">zidian.clear()</span><br><span class="line">print(zidian)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> xiaoming:</span><br><span class="line">    print(<span class="string">"%s - %s"</span> % (k, xiaoming[k]))</span><br></pre></td></tr></table></figure><p>{‘name’: ‘小明’, ‘age’: 18, ‘gender’: True, ‘height’: 1.75, ‘weight’: 75.6}<br>小明</p><p>10</p><p>{‘key’: ‘value’, ‘name’: ‘小明’, ‘gender’: True, ‘height’: 1.75, ‘weight’: 75.6}<br>{}<br>name - 小明<br>gender - True<br>height - 1.75<br>weight - 75.6</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line"><span class="comment"># 单引号和双引号都能定义字符串 但是单引号不推荐</span></span><br><span class="line">str1 = <span class="string">"hello python"</span></span><br><span class="line">print(str1[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> str1:</span><br><span class="line">    print(k)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 统计长度</span></span><br><span class="line">print(len(str1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计出现次数</span></span><br><span class="line">print(str1.count(<span class="string">"o"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某个字符串出现的位置 (第一个字母出现的index)</span></span><br><span class="line">print(str1.index(<span class="string">"o"</span>))</span><br></pre></td></tr></table></figure><p>h<br>h<br>e<br>l<br>l<br>o</p><p>p<br>y<br>t<br>h<br>o<br>n<br>12<br>2<br>4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串切片 List和tuple也能切片 字典不能切片</span></span><br><span class="line">num_str = <span class="string">"0123456789"</span></span><br><span class="line"></span><br><span class="line">num_str[<span class="number">2</span>:<span class="number">6</span>] <span class="comment"># index 2 - 5 含头不含尾    '2345'</span></span><br><span class="line"></span><br><span class="line">num_str[<span class="number">2</span>:] <span class="comment"># index 2 到末尾'23456789'</span></span><br><span class="line"></span><br><span class="line">num_str[:<span class="number">6</span>] <span class="comment"># 开始 -&gt; index 6 之前的所有char, 前6位'012345'</span></span><br><span class="line"></span><br><span class="line">num_str[:] <span class="comment"># 全部'0123456789'</span></span><br><span class="line"></span><br><span class="line">num_str[::<span class="number">2</span>] <span class="comment"># 从头开始 步长为1取值'02468'</span></span><br><span class="line"></span><br><span class="line">num_str[<span class="number">1</span>::<span class="number">2</span>] <span class="comment"># 从index = 1 开始 步长为1取值'13579'</span></span><br><span class="line"></span><br><span class="line">num_str[<span class="number">2</span>:<span class="number">-1</span>] <span class="comment"># 负数代表从后面往前'2345678'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串逆序 *</span></span><br><span class="line">num_str[<span class="number">-1</span>::<span class="number">-1</span>]<span class="comment"># '9876543210'</span></span><br><span class="line">num_str[::<span class="number">-1</span>]<span class="comment"># '9876543210'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公共方法 </span></span><br><span class="line"><span class="comment"># len() # 容器内元素个数</span></span><br><span class="line"><span class="comment"># del() # del 有两种方式 还有一种是作为关键字</span></span><br><span class="line"><span class="comment"># max() # 返回容器中元素的最大值</span></span><br><span class="line"><span class="comment"># min() # 返回容器中元素的最小值</span></span><br><span class="line"><span class="comment"># cmp() # python 3 中取消了这个函数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运算符在高级类型中的作用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># + 合并 ： 字符串 列表 元组</span></span><br><span class="line"><span class="comment"># * 重复 ： 字符串 列表 元组</span></span><br><span class="line"><span class="comment"># in 判断是否存在: 字符串 列表 元组 字典</span></span><br><span class="line"><span class="comment"># not in 和上面对应</span></span><br><span class="line"><span class="comment"># &gt; &gt;= == &lt; &lt;= 元素比较 ：字符串 列表 元组</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完整 for 循环</span></span><br><span class="line"><span class="comment"># 也就是 for 下面 跟了 一个 else ， 如果for循环没有被break打断就会执行else里面的内容，如果被break打断了 ，就不会执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用场景： 迭代遍历 所需要的数据类型，查找某个元素，如果存在，整体退出循环，如果不存在，在整体循环结束后，进行统一的操作。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 查看内存地址</span></span><br><span class="line"><span class="comment"># id()</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可变和不可变类型</span></span><br><span class="line"><span class="comment"># 区分标准是 内存中的数据能否修改</span></span><br><span class="line"><span class="comment"># 可变类型只有两个就是 列表和字典 ，可变类型的数据变化是通过方法来实现的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可变类型 被函数里面修改的时候（并不是创建新的内存使用，而是修改内存里面的数据），虽然是通过参数传入的，但是原值还是会被修改，不可变类型并不会</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为Python是解释型语言 所以在Python中原则上不允许直接修改全局变量的值，如果在函数中对全局变量进行复制操作的话，Python会自己创造一个局部变量</span></span><br><span class="line"><span class="comment"># 所以在这个地方对全局变量进行的修改操作时无效操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是，凡事无绝对，如果一定想要在函数里面修改全局变量的话，我们会在变量前面加上一个Global，这样就不会在函数中重新创建这个局部变量了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了避免全局变量和局部变量在明明的时候出现混淆，一般来说习惯上会在全局变量命名的时候前缀加上一个g_或者gl_</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果函数返回的类型是元组，我们的小括号可以省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># return (temp, wetness)</span></span><br><span class="line"><span class="comment"># return temp, wetness  # 小括号可以省略</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python中特有的交换两个值的方式</span></span><br><span class="line">a = <span class="number">6</span></span><br><span class="line">b = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">a,b = (b,a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缺省参数 具有默认值的参数就叫做缺省参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在函数里面定义形参的时候直接写 gender = True ，默认就是True的意思</span></span><br><span class="line">num_list = [<span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment"># 默认就是升序排序，因为这种需求更多</span></span><br><span class="line">num_list.sort()</span><br><span class="line">print(num_list)  <span class="comment"># 4,5,7,9</span></span><br><span class="line"><span class="comment"># 只有当降序排序时，才需要传递reverse参数</span></span><br><span class="line">num_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(num_list)  <span class="comment"># 9,7,5,4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺省参数后面不能再跟参数</span></span><br></pre></td></tr></table></figure><p>case：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202207282238360.png" alt="image-20220728223807310"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多值参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num, *nums, **numss)</span>:</span></span><br><span class="line">    print(num)</span><br><span class="line">    print(nums)</span><br><span class="line">    print(numss)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 习惯上 多值参数里面，我们使用*args表示元组，使用*kwargs表示键值对参数</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo(1,2,3,4, age=18)</span><br></pre></td></tr></table></figure><p>1<br>(2, 3, 4)<br>{‘age’: 18}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拆包 字典和元组作为参数传进参数的时候会变成一个整体传入，我们为了拆解这个参数，在传入参数的时候，根据他们的类型在前面 添加一个 * 或者两个 *</span></span><br><span class="line"></span><br><span class="line">run(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(a,*args)</span>:</span></span><br><span class="line">    <span class="comment">#第一个参数传给了a</span></span><br><span class="line">    print(a) <span class="comment"># 1</span></span><br><span class="line">    <span class="comment"># args是一个元组，里面是2和3两个参数</span></span><br><span class="line">    print(args) <span class="comment"># (2,3)</span></span><br><span class="line">    <span class="comment"># *args是将这个元组中的元素依次取出来</span></span><br><span class="line">    print(<span class="string">"对args拆包"</span>)</span><br><span class="line">    print(*args) <span class="comment"># *args 相当于 a,b = args 结果是 2 3</span></span><br><span class="line">    print(<span class="string">"将未拆包的数据传给run1"</span>)</span><br><span class="line">    run1(args) <span class="comment"># 输出元组 ((2,3),) 对元组进行拆包 (2,3)</span></span><br><span class="line">    print(<span class="string">"将拆包后的数据传给run1"</span>)</span><br><span class="line">    run1(*args) <span class="comment"># 输出元组 (2,3) 对元组进行拆包  2 3</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run1</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(<span class="string">"输出元组"</span>)</span><br><span class="line">    print(args)</span><br><span class="line">    print(<span class="string">"对元组进行拆包"</span>)</span><br><span class="line">    print(*args)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我对装包，拆包的理解是 参数中的*/**是装包，在函数内部使用这个*的意思就是拆包</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(**kwargs)</span>:</span><span class="comment">#传来的 key = value 类型的实参会映射成kwargs里面的键和值</span></span><br><span class="line">       <span class="comment"># kwargs是一个字典，将未命名参数以键值对的形式</span></span><br><span class="line">       print(kwargs)</span><br><span class="line">       print(<span class="string">"对kwargs拆包"</span>)</span><br><span class="line">       <span class="comment">#  此处可以把**kwargs理解成对字典进行了拆包，&#123;"a":1,"b":2&#125;的kwargs字典又</span></span><br><span class="line">       <span class="comment"># 被拆成了a=1,b=2传递给run1,但是**kwargs是不能像之前*args那样被打印出来看的</span></span><br><span class="line">       run1(**kwargs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run1</span><span class="params">(a,b)</span>:</span> <span class="comment">#此处的参数名一定要和字典的键的名称一致</span></span><br><span class="line">      print(a,b)</span><br><span class="line"> </span><br><span class="line">run(a=<span class="number">1</span>,b=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>{‘a’: 1, ‘b’: 2}<br>对kwargs拆包<br>1 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OOP 面向对象</span></span><br><span class="line"><span class="comment"># 通用方法：dir(对象) 能够把对象里面所有能调用的方法都调用出来</span></span><br><span class="line"><span class="comment"># 添加属性 Python特有的方法，先把对象创建出来，然后直接使用 .属性名 就可以为这个对象添加新的属性，这种方式虽然简单，但是是不推荐的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象初始化</span></span><br><span class="line"><span class="comment"># 当使用类名创建对象时，会自动执行以下操作</span></span><br><span class="line"><span class="comment"># 1. 为对象在内存中分配空间 -- 创建对象</span></span><br><span class="line"><span class="comment"># 2.为对象的属性设置初始值 -- 初始化方法 int</span></span><br><span class="line"><span class="comment"># 这个初始化方法就是 __intit__方法 ，是对象的内置方法</span></span><br><span class="line"><span class="comment"># __init__方法是专门用来定义一个类有哪些属性的方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">__init__方法是专门用来定义一个类具有哪些属性的</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, new_name)</span>:</span></span><br><span class="line">        print(<span class="string">"初始化"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 属性</span></span><br><span class="line">        self.name = new_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 爱吃鱼"</span> % self.name)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># __del__</span></span><br><span class="line">    <span class="comment"># 对象被销毁前执行的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 我去了"</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 必须返回字符串 类似于Java的toString方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># print("我是小猫 %s" % self.name) 错误示例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是小猫 %s"</span> % self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用类名()创建对象的时候，会自动调用初始化方法__init__</span></span><br><span class="line">tom = Cat(<span class="string">"TomDemo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用__init__方法内部使用self.属性名 = 属性的初始化值 就可以定义属性</span></span><br><span class="line"><span class="comment"># 定义属性之后，再使用Cat类创建的对象，都会拥有该属性</span></span><br><span class="line">print(tom.name)</span><br><span class="line">tom.eat()</span><br><span class="line"></span><br><span class="line"><span class="comment"># del 销毁是在一个python文件即将运行到结尾的时候</span></span><br><span class="line">print(tom)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 能够自动的将一堆括号内部的代码链接在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果里面的del方法的位置我完全没有看懂，这个坑以后再填，花了点时间没有整明白</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">身份运算符</span></span><br><span class="line"><span class="string">is      is是判断两个标示符是不是引用同一个对象</span></span><br><span class="line"><span class="string">is not  is not 是判断两个表示服是不是引用不用对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">is 与 == 的区别</span></span><br><span class="line"><span class="string">is用于判断两个变量引用对象是否为同一个</span></span><br><span class="line"><span class="string">==用于判断引用变量的值是否相等</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>初始化<br>TomDemo 我去了<br>TomDemo<br>TomDemo 爱吃鱼<br>我是小猫 TomDemo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 封装 继承 多态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"吃"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"喝"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"跑"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"睡"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wangcai = Animal()</span><br><span class="line"></span><br><span class="line">wangcai.eat() <span class="comment">#吃</span></span><br><span class="line">wangcai.drink() <span class="comment">#喝</span></span><br><span class="line">wangcai.run() <span class="comment">#跑</span></span><br><span class="line">wangcai.sleep() <span class="comment">#睡</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类拥有父类的所有方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"汪汪叫"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wangwang = Dog()</span><br><span class="line"></span><br><span class="line">wangwang.eat() <span class="comment">#吃</span></span><br><span class="line">wangwang.drink() <span class="comment">#喝</span></span><br><span class="line">wangwang.run() <span class="comment">#跑</span></span><br><span class="line">wangwang.sleep() <span class="comment">#睡</span></span><br><span class="line">wangwang.bark() <span class="comment">#汪汪叫</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoTianQuan</span><span class="params">(Dog)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我会飞"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">"我是啸天犬"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用父类的bark方法</span></span><br><span class="line">        super().bark()</span><br><span class="line">        <span class="comment"># Python2.0 如果要实现上面的功能，有点复杂 代码如下</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Dog.bark(self)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">"aafsdwaerwgybds"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有没有括号 对Python来说 说法很大</span></span><br><span class="line">xtq = XiaoTianQuan()</span><br><span class="line">xtq.bark() <span class="comment">#我是哮天犬 汪汪叫</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="comment"># 属性在init方法中定义 使用__(两个下划线)定义的属性是私有属性，无法被子类访问</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.num1 = <span class="number">100</span></span><br><span class="line">        self.__num2 = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"私有方法 %d %d"</span> % (self.num1, self.__num2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在子类的对象方法中不能访问父类的私有属性和方法</span></span><br><span class="line">        <span class="comment"># 但是可以通过调用父类的共有方法间接调用父类的公有属性和方法</span></span><br><span class="line">        print(<span class="string">"访问父类的私有属性 %d"</span> % self.__num2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = B() <span class="comment"># &lt;__main__.B object at 0x0000020EA7593BE0&gt;</span></span><br><span class="line">print(b)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">在外界不能直接访问对象的私有属性，调用方法</span></span><br><span class="line"><span class="string">print(b.__num2)</span></span><br><span class="line"><span class="string">b.__test()</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(b.num1) <span class="comment">#100</span></span><br><span class="line">b.demo() <span class="comment"># 'B' object has no attribute '_B__num2'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"test 方法"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"demo 方法"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(C, D)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子类对象</span></span><br><span class="line">e = E()</span><br><span class="line">e.test() </span><br><span class="line">e.demo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应该避免两个父类汇总存在同名的属性和方法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">python中多继承两个父类出现相同的方法 属性名的时候</span></span><br><span class="line"><span class="string">使用MRO选择执行顺序的</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(E.__mro__) </span><br><span class="line"><span class="comment"># (&lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class 'object'&gt;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">新式类 以Object为基类的对象</span></span><br><span class="line"><span class="string">旧式类 不以Object为基类的对象</span></span><br><span class="line"><span class="string">两者在多继承时 会影响到方法的搜索顺序</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>test 方法<br>demo 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 私有属性 / 方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">secret</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 的年龄是 %d"</span> %</span><br><span class="line">              (self.name,</span><br><span class="line">               self.__age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaofang = Woman(<span class="string">"小芳"</span>)</span><br><span class="line"><span class="comment"># 私有属性不能直接调用 但是Python中没有真正的私有属性和方法 可以使用下面第二行的代码调用</span></span><br><span class="line">print(xiaofang.__age) <span class="comment"># 报错，因为不能直接调用</span></span><br><span class="line">print(xiaofang._Woman__age) <span class="comment"># 18</span></span><br><span class="line">xiaofang.secret() <span class="comment"># 小芳 的年龄是 18</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类的结构</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">__init__ 为对象初始化</span></span><br><span class="line"><span class="string">实例方法(self)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">类对象     模版 只有一个</span></span><br><span class="line"><span class="string">实例对象    可以有很多个</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_tool_count</span><span class="params">(cls)</span>:</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">"工具对象的数量 %d"</span> % cls.count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工具对象</span></span><br><span class="line">tool1 = Tool(<span class="string">"斧头"</span>)</span><br><span class="line">tool2 = Tool(<span class="string">"榔头"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用类方法</span></span><br><span class="line">Tool.show_tool_count() <span class="comment"># 工具对象的数量 2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单例</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">python 中的self和cls一句话描述：self是类（Class）实例化对象，cls就是类（或子类）本身，取决于调用的是那个类。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">__new__</span></span><br><span class="line"><span class="string">为对象分配空间</span></span><br><span class="line"><span class="string">返回对象的引用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">python获得了对象的引用后，将引用作为第一个参数，传递给__init__方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">重写__new__方法的代码非常固定 如下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建对象时，new方法会被自动调用</span></span><br><span class="line">        print(<span class="string">"创建对象，分配空间"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为对象分配空间</span></span><br><span class="line">        instance = super().__new__(cls)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回对象的引用</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"播放器初始化"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">player = MusicPlayer()</span><br><span class="line">print(player) <span class="comment"># 每次都指向内存中不同的位置</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    单例：让类创建的对象，在系统中只哦与唯一的一个实例</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(<span class="string">"--------完整单例-------"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleMusicPlayer</span><span class="params">(object)</span>:</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    init_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1 判断类属性是否是空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 2 调用父类方法，为第一个对象分配空间</span></span><br><span class="line">            cls.instance = super().__new__(cls)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回类属性保存的对象引用</span></span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1 判断是否执行过初始化动作</span></span><br><span class="line">        <span class="keyword">if</span> SingleMusicPlayer.init_flag:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果没有初始化过</span></span><br><span class="line">        print(<span class="string">"初始化播放器"</span>)</span><br><span class="line"></span><br><span class="line">        SingleMusicPlayer.init_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">player1 = SingleMusicPlayer()</span><br><span class="line">print(player1)</span><br><span class="line"></span><br><span class="line">player2 = SingleMusicPlayer()</span><br><span class="line">print(player2) <span class="comment"># 和上面相同的地址</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异常</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">try:</span></span><br><span class="line"><span class="string">    尝试执行的代码</span></span><br><span class="line"><span class="string">except:</span></span><br><span class="line"><span class="string">    出现错误的处理</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = int(input(<span class="string">"请输入一个整数："</span>))</span><br><span class="line"></span><br><span class="line">    result = <span class="number">8</span> / num</span><br><span class="line"></span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="comment"># 错误的处理代码</span></span><br><span class="line">    print(<span class="string">"请输入正确的整数"</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">"请输入正确的整数"</span>)</span><br><span class="line"><span class="comment">#     捕获未知错误</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(<span class="string">"未知错误 %s"</span> % result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 没有异常的时候才会执行的,这个else出现的位置和Java并不是一脉相承的，他这个else针对的是except</span></span><br><span class="line">    print(<span class="string">"尝试成功"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 总是会执行的代码</span></span><br><span class="line">    print(<span class="string">"总是会执行"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">异常的传递</span></span><br><span class="line"><span class="string">python 会把异常一直向上传递</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(input(<span class="string">"输入整数："</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> demo1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(demo2())</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">ValueError                                Traceback (most recent call last)</span></span><br><span class="line"><span class="string">Input In [2], in &lt;cell line: 47&gt;()</span></span><br><span class="line"><span class="string">     43 def demo2():</span></span><br><span class="line"><span class="string">     44     return demo1()</span></span><br><span class="line"><span class="string">---&gt; 47 print(demo2())</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Input In [2], in demo2()</span></span><br><span class="line"><span class="string">     43 def demo2():</span></span><br><span class="line"><span class="string">---&gt; 44     return demo1()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Input In [2], in demo1()</span></span><br><span class="line"><span class="string">     39 def demo1():</span></span><br><span class="line"><span class="string">---&gt; 40     return int(input("输入整数："))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ValueError: invalid literal for int() with base 10: 'dsf'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">from package import sth</span></span><br><span class="line"><span class="string">from package import *</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有倒入的模块 没有缩进的部分都会被执行一次</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">__name__的用法</span></span><br><span class="line"><span class="string">如果需要测试模块 就增加一个条件判断</span></span><br><span class="line"><span class="string">这样增加了判断之后，在作为被包倒入的时候 下面的代码不会执行</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">模版</span></span><br><span class="line"><span class="string"># 导入模块</span></span><br><span class="line"><span class="string"># 定义全局变量</span></span><br><span class="line"><span class="string"># 定义类</span></span><br><span class="line"><span class="string"># 定义函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def main():</span></span><br><span class="line"><span class="string">    # ...</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string"># 根据__name__判断是否执行下方代码</span></span><br><span class="line"><span class="string">if __name__ == "__main__"</span></span><br><span class="line"><span class="string">    main()</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Package</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">包是一个包含多个模块的特殊目录</span></span><br><span class="line"><span class="string">目录下有一个特殊的文件 __init__.py</span></span><br><span class="line"><span class="string">包名的命名方式和变量名一直，小写字母+_</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">好处</span></span><br><span class="line"><span class="string">使用import 包名 可以一次性倒入包中所有的模块</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在__init__.py文件中用</span></span><br><span class="line"><span class="string">from . import 模块名</span></span><br><span class="line"><span class="string">制定外部文件需要倒入的模块</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">发布模块</span></span><br><span class="line"><span class="string">三步</span></span><br><span class="line"><span class="string">1. 创建setup.py</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">发布</span></span><br><span class="line"><span class="string">固定模版：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">from distutils.core import setup</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 多值的字典参数，setup是一个函数</span></span><br><span class="line"><span class="string">setup(name="Hello",  # 包名</span></span><br><span class="line"><span class="string">      version="1.0",  # 版本</span></span><br><span class="line"><span class="string">      description="a simple example",  # 描述信息</span></span><br><span class="line"><span class="string">      long_description="简单的模块发布例子",  # 完整描述信息</span></span><br><span class="line"><span class="string">      author="FlyHugh",  # 作者</span></span><br><span class="line"><span class="string">      author_email="flyhobo@live.com",  # 作者邮箱</span></span><br><span class="line"><span class="string">      url="flymetothemars.github.io",  # 主页</span></span><br><span class="line"><span class="string">      py_modules=["hello.request",</span></span><br><span class="line"><span class="string">                  "hello.response"])  # 记录包中包中包含的所有模块</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第二步</span></span><br><span class="line"><span class="string">构建</span></span><br><span class="line"><span class="string">python3 setup.py build</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第三步</span></span><br><span class="line"><span class="string">python3 setup.py sdist</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">安装</span></span><br><span class="line"><span class="string">tar zxvf 解压</span></span><br><span class="line"><span class="string">sudo python3 setup.py install</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然后打开python3运行即可</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 文件指针</span></span><br><span class="line"><span class="comment"># 文件指针标记从哪个位置开始读取数据，第一次打开文件时，通常文件指针会指向文件的开始位置</span></span><br><span class="line"><span class="comment"># 当执行了 read 方法后，文件指针对移动到 读取内容的末尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也就是说 </span></span><br><span class="line"><span class="comment"># 第一次读取了之后，文件指针移动到了文件末尾，再次调用不会读取到任何内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># f = open("文件名","访问方式")</span></span><br><span class="line"><span class="comment"># r w a r+ w+ a+ 具体见百度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">python操作文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">open 打开文件 返回文件对象</span></span><br><span class="line"><span class="string">read 文件内容读取到内存</span></span><br><span class="line"><span class="string">write 将内容写入文件</span></span><br><span class="line"><span class="string">close 关闭文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">文件指针</span></span><br><span class="line"><span class="string">open()方法有两个参数 第二个参数制定的是打开的方式</span></span><br><span class="line"><span class="string">存在r w a r+ w+ a+这些方式 用str格式传入</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">readline 按行读取</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">小文件复制</span></span><br><span class="line"><span class="string">file_read = open("README")</span></span><br><span class="line"><span class="string">file_write = open("README[复件]","w")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">text = file_read.read()</span></span><br><span class="line"><span class="string">file_write.write(text)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">file_read.close()</span></span><br><span class="line"><span class="string">file_write.close()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">复制大文件 用readline</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">倒入 import os</span></span><br><span class="line"><span class="string">rename 重命名</span></span><br><span class="line"><span class="string">remove 删除</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">listdir 目录列表</span></span><br><span class="line"><span class="string">mkdir 创建目录</span></span><br><span class="line"><span class="string">rmdir 删除目录</span></span><br><span class="line"><span class="string">getcwd 获取当前目录</span></span><br><span class="line"><span class="string">chdir 修改工作目录</span></span><br><span class="line"><span class="string">path.isdir 判断是否是文件</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">python2.x 默认ASCII编码</span></span><br><span class="line"><span class="string">    python2 使用 </span></span><br><span class="line"><span class="string">    # *-* coding:utf-8 *-*</span></span><br><span class="line"><span class="string">    来指定编码格式</span></span><br><span class="line"><span class="string">python3.x 默认使用UTF-8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eval 函数 -- 将字符串当成有效的表达式 来求值 并 返回计算结果</span></span><br></pre></td></tr></table></figure><h3 id="python包"><a href="#python包" class="headerlink" title="python包"></a>python包</h3><p>众所周知，pyhton之所以能够流行火爆起来，他的各种开箱即用的工具包是一个很大的原因，我这里会把我能接触到的各种工具包陆陆续续的填上来。</p><p><strong>pdf2pptx</strong></p><p>用来把pdf转换成pptx的一个工具，会把每次做成一个单独的pptx，我唯一注意到的一个问题是，低一点的python版本可能不支持（大概3.6）3.8是随便能够安装使用的。</p><p>使用的时候命令也很简单<code>pdf2pptx demo.pdf</code>即可，文件最后会存放在同目录中。</p><h3 id="Python随机随到的一些问题，那你妈逼随机就这么容易随到的啊"><a href="#Python随机随到的一些问题，那你妈逼随机就这么容易随到的啊" class="headerlink" title="Python随机随到的一些问题，那你妈逼随机就这么容易随到的啊"></a>Python随机随到的一些问题，那你妈逼随机就这么容易随到的啊</h3><h4 id="anaconda代理问题"><a href="#anaconda代理问题" class="headerlink" title="anaconda代理问题"></a>anaconda代理问题</h4><p>设置代理的方法：找到位置在path-for-install目录下<code>.condarc</code>文件,添加Http和Https的代理，这里默认本地cfw</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_servers:</span><br><span class="line">  http: http://127.0.0.1:7890</span><br><span class="line">  https: http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>如果有密码的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_servers:</span><br><span class="line">    http: http://user:password@xxxx:8080</span><br><span class="line">    https: https://user:password@xxxx:8080</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anaconda 并不能被Clash4Windows在Tun模式下代理，虽然不知道原因(后续知道了会在这补上)，anaconda只能在配置了proxy之后才能被代理流量</span><br></pre></td></tr></table></figure><h4 id="python和Clash4windows的冲突问题"><a href="#python和Clash4windows的冲突问题" class="headerlink" title="python和Clash4windows的冲突问题"></a>python和Clash4windows的冲突问题</h4><p>现象: 和pip有关的几乎一切指令都会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ProxyError(&apos;Cannot connect to proxy.&apos;, OSError(0, &apos;Error&apos;))&apos;: /simple</span><br><span class="line">/gitpython/</span><br><span class="line">WARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ProxyError(&apos;Cannot connect to proxy.&apos;, OSError(0, &apos;Error&apos;))&apos;: /simple</span><br><span class="line">/gitpython/</span><br></pre></td></tr></table></figure><p>ts：</p><p>遇到这种问题那肯定是直接debug走起，首先用文本搜索到抛这个错的函数，然后在嫌疑语句上都打上断，我们就能找到罪魁祸首：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202207272251191.png" alt="image-20220727225126154"></p><p>同时发现windwos中原生的python环境并没有这个问题，于是和venv外没问题的老版pip一比较，很容易就能发现不对劲：选中的那两行在老版是不存在的</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202207272255356.png" alt="image-20220727225518321"></p><p>有了这个额外信息，我们很容易就能找到这个 <a href="https://github.com/pypa/pip/issues/9190" target="_blank" rel="noopener">Support for web proxies is broken in pip 20.3 · Issue #9190 · pypa/pip (github.com)</a> 来说明问题，2016年底，curl加入了这个把https协议前缀另加解释与定义的联盟：<a href="https://daniel.haxx.se/blog/2016/11/26/https-proxy-with-curl/" target="_blank" rel="noopener">HTTPS proxy with curl | daniel.haxx.se</a>，而urllib3显然也跟上了这个脚步：</p><p>因为前缀设置了 <code>tls_in_tls_required</code> 之后，urllib3会企图把这个代理服务器看作一个套了tls的http CONNECT代理。<br>但是问题是，我并没有设置 <code>https://</code> 前缀的代理服务器，这个行为是什么神奇的情况呢？<br>继续向下追，找到如何获取代理的：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202207272257907.png" alt="image-20220727225732878"></p><p>确实，env里面没有proxy，那按照windows的习俗找找注册表也情有可原对吧？<br>这个函数的内部实现是这样：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202207272258043.png" alt="image-20220727225820001"></p><p>看红框的行为是不是好像很眼熟？IE的代理设置似乎就是这样的？</p><p>不，并不是一样的，因为IE的代理设置把HTTPS（在<code>zh-MS</code>方言里叫安全）代理定义为支持 <code>CONNECT</code> 动词的HTTP代理，尽管很久以来人们都是这样用的，但是当它前面出现一个协议前缀的时候就不一样了。</p><p>因为clash for windows打开系统代理的代理配置看起来并没有写明了protocol：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202207272304641.png" alt="image-20220727230459589"></p><p>所以首先，<strong>我们的py会根据IE时代的约定俗成把这样一个没有指明protocol的proxy url自动补全三种协议</strong>，<strong>然后再按照约定俗成的行为为https请求使用https_proxy</strong>，<strong>最后在一个http代理上试图开tls</strong>。</p><p>这个配置在IE时代行为会是正常的，在现代的库中行为也是正常的，但是对于这样一个混杂了两种行为的库，模糊不清就成了问题。<br>上面的截图并不是urllib3的，而是 属于py自己的标准库urllib的，也算是urllib3开发人员的思想和urllib的历史遗留实现冲突了吧。</p><p>似乎此问题在新版Python中的报错信息会变成 <code>There was a problem confirming the ssl certificate: HTTPSConnection Pool(host=&#39;pypi.org&#39;, port=443): Max retries exceeded with url: /simple/plotly/ (Caused by SSLError(SSLEOFError(8, &#39;EOF  occurred in violation of protocol (_ssl.c:1123)&#39;)))</code> 或者类似的错误。</p><p>在后续的版本更新中，CFW解决了Specify Protocol解决了部分此问题，但是解决的并不是很好，启用Specify Protocol会导致只设置http代理，https无代理。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202207272315756.png" alt="image-20220727231553719"></p><p>可以看到如果只是单纯地把注册表项的内容由 <code>127.0.0.1:7890</code>改为<code>http://127.0.0.1:7890</code>的话，urllib只会返回一个只有一个key也就是<code>http</code>的代理dict。<br>这时候从pip的请求调用链往上找，可以看到负责决定使用这个dict中那个代理的代码是 <code>requests/utils.py</code>的<code>select_proxy</code>函数：</p><p>因为红框中的部分的限制，当你请求<code>https://pypi.org</code>的时候，只有key为<code>https</code>/<code>https://pypi.org</code>/<code>all</code>/<code>all://pypi.org</code>的代理会被使用，上面那个<code>http</code>的代理自然也就不会被使用。<br>BTW，因为这个代码是requests库的，这也就意味着在Windows平台上Clash for Windows的系统代理不会影响到大部分py应用的http请求。<br>而正确的做法是什么呢？让我们在IE中设置上代理，然后看一看它给出的行为：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202207272318518.png" alt="image-20220727231825488"></p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202207272318059.png" alt="image-20220727231841031"></p><p>同时，因为urllib中还存在代理的类型推测代码，所以正确的设置应该是：<br><code>http=http://127.0.0.1:7890;https=http://127.0.0.1:7891</code></p><h4 id="python和解释性语言"><a href="#python和解释性语言" class="headerlink" title="python和解释性语言"></a>python和解释性语言</h4><p><a href="https://blog.csdn.net/balabalamerobert/article/details/1649490" target="_blank" rel="noopener">https://blog.csdn.net/balabalamerobert/article/details/1649490</a></p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>诞生时间：javascript 诞生于 1995年</p><p>诞生目的：处理服务器端语言负责的一些输入验证操作</p><p>javascript组成部分：ECMAScript（核心） DOM (文档对象模型) BOM（浏览器对象模型）</p><h4 id="简介-amp-基本概念"><a href="#简介-amp-基本概念" class="headerlink" title="简介 &amp; 基本概念"></a>简介 &amp; 基本概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;元素</span><br><span class="line">属性(参数)：</span><br><span class="line">async：可选。表示应该立即下载脚本，但不妨碍页面中的其他操作。只对外部文件有效</span><br><span class="line">charset：可选。通过src属性指定代码的字符集。大部分浏览器都会忽略他的值，很少有人用</span><br><span class="line">defer:可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本有效</span><br><span class="line">language:已废弃。原来用于表示编写代码的脚本语言</span><br><span class="line">src:可选。表示包含要执行的外部文件</span><br><span class="line">type:可选。可以看成是language的替代属性 虽然text/javascript 和 text/ecmascript都不</span><br><span class="line">推荐使用，但大部分开发者依然使用。默认值为text/javascript</span><br><span class="line"></span><br><span class="line">注意事项</span><br><span class="line">在使用&lt;script&gt;嵌入javascript代码时，不要在代码中任何地方出现&lt;/script&gt;字符串</span><br><span class="line">如果要使用要通过转义字符&quot;/&quot; 可以解决</span><br><span class="line"></span><br><span class="line">&lt;noscript&gt;元素</span><br><span class="line">触发条件</span><br><span class="line">浏览器不支持脚本</span><br><span class="line">浏览器支持脚本，但脚本被禁用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">ECMAScript的语法大量借鉴了C及其他类C语言的语法</span><br><span class="line"></span><br><span class="line">严格区分大小写</span><br><span class="line">标识符</span><br><span class="line">第一个字符必须是一个字母、下划线或一个美元符号</span><br><span class="line">其他字符可以是字母、下划线、美元符号或数字</span><br><span class="line"></span><br><span class="line">数据类型</span><br><span class="line">undefined 只有一个值就是undefined。在使用变量但未对其加以初始化时，</span><br><span class="line">这个变量的值就是undefined</span><br><span class="line"></span><br><span class="line">null 从逻辑角度来看，null值表示一个空对象指针，这也是typeof操作符</span><br><span class="line">检测null时会返回Object的原因，如果定义的变量将用于保存对象，那么最好</span><br><span class="line">将该变量初始化为null而不是其他值</span><br><span class="line"></span><br><span class="line">boolean</span><br><span class="line">number</span><br><span class="line">string</span><br><span class="line">object</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof 操作符</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'bbb'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>) <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">0</span>) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'aaa'</span>) <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> func) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'____________________________'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 很明显typeof不能判断 null array object</span></span><br><span class="line"><span class="comment">* 常用判断方法 使用下面的判断方法可以详细的判断种类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(any).slice(<span class="number">8</span>, <span class="number">-1</span>).toLocaleLowerCase()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(type(<span class="literal">undefined</span>)) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(type(<span class="literal">null</span>)) <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(type(<span class="literal">true</span>)) <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(type(<span class="number">0</span>)) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(type(<span class="string">'aaa'</span>)) <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(type(arr)) <span class="comment">// array</span></span><br><span class="line"><span class="built_in">console</span>.log(type(obj)) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(type(func)) <span class="comment">// function</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* object的通用属性和方法</span><br><span class="line">* construct:保存着用于创建当前对象的函数</span><br><span class="line">* hasOwnProperty(propertyName):用于检查给定属性在当前对象实例中（而不是</span><br><span class="line">* 在实例的原型中）是否存在。其中作为参数的属性名（propertyName）必须以字</span><br><span class="line">* 符串形式指定</span><br><span class="line">* isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型</span><br><span class="line">* propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用for-in</span><br><span class="line">* 语句来枚举</span><br><span class="line">* toLocaleString(): 返回对象字符串表示，改字符串与执行环境的地区对应</span><br><span class="line">* toString() 返回对象字符串表示</span><br><span class="line">* valueOf():返回对象字符串、数值或布尔表示。通常与toString()方法的返回值相同</span><br><span class="line">* */</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型和引用类型的值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 基本类型值：简单的数据段（undefined null Boolean number String）</span></span><br><span class="line"><span class="comment">* 引用类型值：由多个值构成的对象（object array function）</span></span><br><span class="line"><span class="comment">* 引用类型的值是保存在内存中的对象。与其他语言不同，javascript不容许</span></span><br><span class="line"><span class="comment">* 直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象</span></span><br><span class="line"><span class="comment">* 时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是</span></span><br><span class="line"><span class="comment">* 按引用访问的。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制变量的值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 复制基本类型的值是相互独立的互不影响</span></span><br><span class="line"><span class="comment">* 复制引用类型的值实际上是复制一个指针，复制结束后，实际上是引用的</span></span><br><span class="line"><span class="comment">* 同一个对象。因此改变其中一个变量就会影响另一个变量</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递参数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数</span></span><br><span class="line"><span class="comment">* 内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的</span></span><br><span class="line"><span class="comment">* 传递如同基本类型变量的复制一样，而引用类型也是一样</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = addTen(count);</span><br><span class="line"><span class="comment">// 没有改变外部的count</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count, result)<span class="comment">//20 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">'testName'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line">setName(person)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// testName</span></span><br><span class="line"><span class="comment">// 修改了外部的person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 证明为按值传递 整个过程有点子复杂，和我以前使用的java完全不同，person2传入函数setName2之后，obj和person2同时指向同一个堆内存位置--&gt;person2的位置，首先修改了name属性，重新指定obj之后，obj和person2指向的位置不再相同，这个时候修改obj并不会修改person2的属性，所以最终属性定格在了testName，这里面有个思维误区就是obj等于person2，并不相等。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName2</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">'testName'</span></span><br><span class="line">    obj = &#123;&#125;</span><br><span class="line">    obj.name = <span class="string">'changeName'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;&#125;</span><br><span class="line">setName2(person2)</span><br><span class="line"><span class="built_in">console</span>.log(person2.name) <span class="comment">// testName</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*基本类型 typeof （undefined string boolean）</span></span><br><span class="line"><span class="comment">*引用类型 可以根据原型链或调用对象的toString()方法来判断</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">var</span> u;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>]</span><br><span class="line"><span class="keyword">var</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s); <span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">//boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> u); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o); <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// instanceof</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="变量-amp-作用-amp-内存问题"><a href="#变量-amp-作用-amp-内存问题" class="headerlink" title="变量 &amp; 作用 &amp; 内存问题"></a>变量 &amp; 作用 &amp; 内存问题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行环境及作用域</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 执行环境（execution context，简称环境）</span></span><br><span class="line"><span class="comment">* 执行环境定义了变量或函数有权访问的其他数据，决定了他们</span></span><br><span class="line"><span class="comment">* 各自的行为。每个执行环境都有一个与之关联的变量对象，环</span></span><br><span class="line"><span class="comment">* 境中定义的所有变量和函数都保存在这个对象中。但我们不能</span></span><br><span class="line"><span class="comment">* 访问它，解析器会在后台调用它</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 延长作用域链</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  虽然执行环境的类型只有两种-全局和局部，但还是有其他方法来延长作用域链。</span></span><br><span class="line"><span class="comment">*  这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对</span></span><br><span class="line"><span class="comment">*  象会在代码执行后移除。有两种情况下会发生这种现象。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* try-catch 语句的catch块</span></span><br><span class="line"><span class="comment">* width语句</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这两个语句都会在作用域链的前端添加一个变量对象。对width语句来说，会将指定</span></span><br><span class="line"><span class="comment">* 的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含</span></span><br><span class="line"><span class="comment">* 的是被抛出的错误对象的声明</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有块级作用域（es6后不是这样了）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* javascript 没有块级作用域经常会导致理解上的困惑。在其他类C的语言中，由花括</span></span><br><span class="line"><span class="comment">* 号封闭的代码块都有自己的作用域，因而支持根据条件来定义变量</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(color) <span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 很明显花括号没有自己的作用域</span></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> color2 = <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console.log(color2) // Error color2 is not define</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'for var'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//for 也没有自己的作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; i &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'for let'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console.log(j) // Error j is not define</span></span><br><span class="line"><span class="comment">// 用let定义的变量在花括号内有自己的作用域,而var的没有</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用var声明的变量会自动被添加到最近的环境中。在函数内部，最近的</span></span><br><span class="line"><span class="comment">* 环境就是函数的局部环境，如果初始化变量没有使用var声明，该变量</span></span><br><span class="line"><span class="comment">* 会自动被添加到全局环境</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 在编写javaScript代码的过程中，不申明而直接初始化变量是一个常见</span></span><br><span class="line"><span class="comment">* 的错误做法，因为这样可能会导致意外。在严格模式下未经声明的变量</span></span><br><span class="line"><span class="comment">* 会导致错误</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询标识符</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该</span></span><br><span class="line"><span class="comment">* 标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给</span></span><br><span class="line"><span class="comment">* 定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，</span></span><br><span class="line"><span class="comment">* 变量就绪。如果在局部标识符中没有找到该变量名，则继续沿作用域链向上</span></span><br><span class="line"><span class="comment">* 搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局变量环境中</span></span><br><span class="line"><span class="comment">* 也没有找到这个标识符，则意味着该变量尚未声明。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> color3 = <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> color3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getColor()) <span class="comment">//blue</span></span><br><span class="line"><span class="comment">// 局部环境中没有color3 的标识符，则在他的上级环境中寻找（也就是全局环境）</span></span><br><span class="line"><span class="comment">// 返回了全局环境中的color3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> color4 = <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color4 = <span class="string">'red'</span></span><br><span class="line">    <span class="keyword">return</span> color4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getColor2()) <span class="comment">// red</span></span><br><span class="line"><span class="comment">// 直接返回了局部环境的color4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  注意 变量查询也不是没有代价的。很明显，访问局部变量要比访问全局更快，因为</span></span><br><span class="line"><span class="comment">*  不用向上搜索作用域链。</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 垃圾收集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  标记清除（最常用） （标记变量的不同状态，去除无用变量）</span></span><br><span class="line"><span class="comment">*  引用计数（计算变量引用次数，引用次数为0，清除该变量）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理内存</span></span><br><span class="line"><span class="comment">// 由于安全考虑浏览器可分配内存比桌面应用内存要少，为了性能，执行环境只保存</span></span><br><span class="line"><span class="comment">// 必要数据。一旦数据不在用就将值设为null(一般用于全局环境)</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object 类型</span></span><br><span class="line"><span class="comment">// 第一种创建方式</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">'tom'</span></span><br><span class="line">person.age = <span class="number">29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name: <span class="string">'tom'</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="built_in">console</span>.log(person2[<span class="string">'name'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(person2.name)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> color2 = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测数组 instanceof isArray()</span></span><br><span class="line"><span class="built_in">console</span>.log(color <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(color)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换方法</span></span><br><span class="line"><span class="built_in">console</span>.log(color2.toString()) <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(color2.toLocaleString()) <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(color2.valueOf()) <span class="comment">//['red','blue','green']</span></span><br><span class="line"><span class="built_in">console</span>.log(color2) <span class="comment">//['red','blue','green']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString 和 toLocaleString</span></span><br><span class="line"><span class="keyword">var</span> person3 = &#123;</span><br><span class="line">    toLocaleString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'toLocaleString3'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'toString3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person4 = &#123;</span><br><span class="line">    toLocaleString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'toLocaleString4'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'toString4'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person5 = [person3, person4]</span><br><span class="line"><span class="built_in">console</span>.log(person5)</span><br><span class="line"><span class="built_in">console</span>.log(person5.toString()) <span class="comment">//toString3,toString4</span></span><br><span class="line"><span class="built_in">console</span>.log(person5.toLocaleString()) <span class="comment">//toLocaleString3,toLocaleString4</span></span><br><span class="line"><span class="comment">// 分别调用了数组元素的toString 和toLocaleString</span></span><br></pre></td></tr></table></figure><p>toString和toLocalString还有另外一个valueOf的区别有点细，详细参考这个<a href="https://www.cnblogs.com/zhangyinhua/p/9480867.html#:~:text=toString()%EF%BC%9A%E6%8A%8ADate%20%E5%AF%B9%E8%B1%A1,%E6%A0%B9%E6%8D%AE%E6%9C%AC%E5%9C%B0%E8%A7%84%E5%88%99%E6%A0%BC%E5%BC%8F%E5%8C%96%E3%80%82" target="_blank" rel="noopener">网页</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈方法（push() 和 pop()）</span></span><br><span class="line"><span class="keyword">var</span> colors = []</span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">'red'</span>, <span class="string">'green'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">// 2</span></span><br><span class="line">count = colors.push(<span class="string">'black'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop()</span><br><span class="line"><span class="built_in">console</span>.log(item) <span class="comment">// black</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列方法（push() shift()） shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 注意： 此方法改变数组的长度！ 提示: 移除数组末尾的元素可以使用pop() 方法。</span></span><br><span class="line"><span class="keyword">var</span> colors2 = []</span><br><span class="line"><span class="keyword">var</span> count2 = colors2.push(<span class="string">'red'</span>, <span class="string">'green'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count2) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count2 = colors2.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count2) <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item2 = colors.shift()</span><br><span class="line"><span class="built_in">console</span>.log(item2) <span class="comment">//red</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重排序方法</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(values.reverse()) <span class="comment">// [ 5, 4, 3, 2, 1 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values2 = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(values2.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line">&#125;)) <span class="comment">// [ 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// splice (删除 插入 替换)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置方法（indexOf()和lastIndexOf()）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* every(): 对数组中的每一项运行给定函数，如果该函数每一项都返回true，则返回true</span></span><br><span class="line"><span class="comment">* filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组</span></span><br><span class="line"><span class="comment">* forEach():对数组中的每一项运行给定函数，这个方法没有返回值</span></span><br><span class="line"><span class="comment">* map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</span></span><br><span class="line"><span class="comment">* some():对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* reduce()</span></span><br><span class="line"><span class="comment">* reduceRight()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">var</span> values3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> sum = values3.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">//10</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Date 比较大小</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Data 的 toString() 和 valueOf() 不同浏览器返回不同</span></span><br><span class="line"><span class="comment">* Data类型的valueOf()方法不返回字符串，而是返回日期的毫秒表示，</span></span><br><span class="line"><span class="comment">* 因此，可以方便比较日期值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">9</span>)</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(date1 &gt; date2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(date1 &lt; date2) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 这为比较日期提供了极大的方便</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期格式化方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* toDateString() 以特定于实现的格式显示星期几、月、日和年</span></span><br><span class="line"><span class="comment">* toTimeString()                    ...时、分、秒和时区</span></span><br><span class="line"><span class="comment">* toLocaleDateString() 以特定于地区的格式显示星期几、月、日和年</span></span><br><span class="line"><span class="comment">* toLocaleTimeString() 以特定于实现的格式显示时、分、秒</span></span><br><span class="line"><span class="comment">* toUTSString() 以特定实现的格式显示时、分、秒</span></span><br><span class="line"><span class="comment">* toLocaleString()和toString()方法一样不同浏览器显示不同不能使用</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期、时间组件方法</span></span><br><span class="line"><span class="comment">// &#123;Year Month（0-11） Date（1-31） Day(星期) Hours（0-23） Minutes（0-59） Seconds Milliseconds&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* getTime() 返回日期的毫秒数；与valueOf()方法返回的值相同</span></span><br><span class="line"><span class="comment">* setTime(毫秒) 以毫秒设置日期，会改变整个日期</span></span><br><span class="line"><span class="comment">* getFullYear() 取得4位数的年份（2018而非仅07）</span></span><br><span class="line"><span class="comment">* getUTCFullYear</span></span><br><span class="line"><span class="comment">* ... 其他类似</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegExp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式 var expression = / pattern /flags(pattern 模式 正则表达式 flag 标志)</span></span><br><span class="line"><span class="comment">// g：global 全局模式 应用于所有字符串，而非匹配的第一项就停止</span></span><br><span class="line"><span class="comment">// i:表示不区分大小写</span></span><br><span class="line"><span class="comment">// m:表示多行模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RegExp 实例属性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* global： 布尔值，表示是否设置了g标志</span></span><br><span class="line"><span class="comment">* ignoreCase: 布尔值，表示是否设置了i标志</span></span><br><span class="line"><span class="comment">* lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从0算起</span></span><br><span class="line"><span class="comment">* multiline：布尔值，表示是否设置了m标志</span></span><br><span class="line"><span class="comment">* source：正则表达式的字符串表示</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//RegExp 实例方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* exec() 返回第一个匹配项的数组</span></span><br><span class="line"><span class="comment">* text() 返回布尔值</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function 类型</span></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  function sum (num1,num2)&#123; return num1 + num2 &#125; （函数声明式）</span></span><br><span class="line"><span class="comment">*  var sum = function (num1,num2)&#123;return num1 + num2&#125; （函数表达式）</span></span><br><span class="line"><span class="comment">*  var sum = new Function("num1","num2","return num1 + num2")(不推荐)</span></span><br><span class="line"><span class="comment">*  函数是对象，函数名是指针</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum2(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> autoHerSum = sum2</span><br><span class="line"><span class="built_in">console</span>.log(autoHerSum(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">sum2 = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(autoHerSum(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 函数名是指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 也可以同时使用函数声明和函数表达式 var sum = function sum() &#123;&#125;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someFunction(someArgument)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = callSomeFunction(add10, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello,"</span> + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = callSomeFunction(getGreeting, <span class="string">'Nicholas'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// Hello,Nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个函数内返回另一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName]</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObject</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里相当于重写了toString方法</span></span><br><span class="line">CreateObject.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;name:<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>,age:<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>&#125;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> object1 = <span class="keyword">new</span> CreateObject(<span class="string">'Zachary'</span>, <span class="number">28</span>)</span><br><span class="line"><span class="keyword">var</span> object2 = <span class="keyword">new</span> CreateObject(<span class="string">'Nicholas'</span>, <span class="number">29</span>)</span><br><span class="line"><span class="keyword">var</span> data = [object1, object2]</span><br><span class="line"><span class="comment">// 这里引用到了上面的createComparisonFunction，其实很像是把函数式编程分开写了，仅此而已</span></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">'name'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(data.toString())</span><br><span class="line">data.sort(createComparisonFunction(<span class="string">'age'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(data.toString())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数内部属性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 函数内部，有两个特殊的对象：arguments 和 this。</span></span><br><span class="line"><span class="comment">* arguments(类数组对象)：保存函数参数</span></span><br><span class="line"><span class="comment">* 该对象还有一个名叫callee的属性，改属性是一个指针，指向拥有这个arguments</span></span><br><span class="line"><span class="comment">* 对象的函数</span></span><br><span class="line"><span class="comment">* this:函数执行的环境对象</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// arguments.callee</span></span><br><span class="line"><span class="comment">// 经典的阶乘函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">10</span>)) <span class="comment">// 3628800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写有点不好 就是函数名和函数体耦合在了一起</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial2</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial2(<span class="number">10</span>))</span><br><span class="line"><span class="comment">// 将函数名解耦</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this</span></span><br><span class="line"><span class="keyword">var</span> color5 = <span class="string">'red'</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    color5: <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor() <span class="comment">// red</span></span><br><span class="line">o.sayColor = sayColor</span><br><span class="line">o.sayColor() <span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注意：函数名仅仅是一个包含指针的变量而已。因此，即使是在不同的</span></span><br><span class="line"><span class="comment">* 环境中执行，全局的sayColor与o.sayColor指向的仍然是同一个函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数属性和方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* length:表示函数希望接收的命名参数的个数</span></span><br><span class="line"><span class="comment">* prototype</span></span><br><span class="line"><span class="comment">* prototype上的属性是不可被枚举的（for-in-无法发现）</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// call 与 apply</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum4</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum4.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) <span class="comment">// arguments（类数组）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum4.apply(<span class="keyword">this</span>, [num1, num2]) <span class="comment">// 数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum3</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum4.call(<span class="keyword">this</span>, num1, num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callSum3(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call 和 apply作用一样，只是参数的形式不一样</span></span><br></pre></td></tr></table></figure><h5 id="js的连续赋值"><a href="#js的连续赋值" class="headerlink" title="js的连续赋值"></a>js的连续赋值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">//undefined </span></span><br><span class="line"><span class="built_in">console</span>.log(b.x) <span class="comment">//Object &#123;n: 2&#125;</span></span><br></pre></td></tr></table></figure><p>首先是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;n:1&#125;; </span><br><span class="line">var b = a;</span><br></pre></td></tr></table></figure><p>在这里a指向了一个对象{n:1}（我们姑且称它为对象A），</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208160538009.png" alt="image-20220816053812942"></p><p>b指向了a所指向的对象，也就是说，在这时候a和b都是指向对象A的,</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208160538657.png" alt="image-20220816053832601"></p><p>接着继续看下一行非常重要的代码：<code>a.x = a = {n: 2}</code>，这句话也是关键所在，根据js引擎语法解析，会先去<strong>从左到右寻找有没有未声明的变量</strong>，如果有就把该变量提升至作用域顶部并声明该变量。那么恭喜js引擎他找到a.x这个属性没有声明，那么他会在{n: 1}这个内存区声明一个x属性等待赋值！</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208160539058.png" alt="image-20220816053909000"></p><p>接着按照从左到右的寻找变量顺序运行，<code>a = {n: 2};</code>，运行以后a的指向变成了一个新地址。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208160539164.png" alt="image-20220816053942097"></p><p>ok，接下来是最关键的一步，解析变量/变量名是从左往右的，但是运行的时候实际顺序是从右往左的，这个时候原先的a.x已经改变了表达方式，如图上的红圈，这个部分是a.x，而不是这个栈内存中的a指针所指向的地方，js里面很多东西讲的都是值本身，而非指针，所以最后的结果也并不难以理解了。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本的包装类型，特殊的引用类型（Boolean、Number、String）</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="string">'some text'</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1, s2) <span class="comment">// some text me text</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 想象成</span></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'some text'</span>)</span><br><span class="line"><span class="keyword">var</span> s4 = s1.substring(<span class="number">2</span>)</span><br><span class="line">s3 = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(s3, s4) <span class="comment">// null 'me text' </span></span><br><span class="line"><span class="comment">// 引用类型和基本包装类型的主要区别就是对象的生存期。使用new操作符创建</span></span><br><span class="line"><span class="comment">// 的引用类型的实例，在执行流离开当前作用域之前一直都保存在内存中。而自</span></span><br><span class="line"><span class="comment">// 动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即销</span></span><br><span class="line"><span class="comment">// 毁。这意味着我们不能在运行时为基本类型值添加属性和方法 eg</span></span><br><span class="line"><span class="keyword">var</span> s5 = <span class="string">'some text'</span>;</span><br><span class="line">s5.color = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(s5.color) <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object 构造函数也会像工厂方法一样，根据传入值的类型放回相应基本包装实例</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">'some text'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Boolean 类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Boolean 类型与布尔值对应的引用类型。要创建Boolean对象，就可以像下面这样</span></span><br><span class="line"><span class="comment">* 调用Boolean构造函数并传入true或false</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> BooleanObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="built_in">console</span>.log(falseObject)<span class="comment">//boolean对象 Boolean &#123;false&#125; 打印出来是[Boolean: false]</span></span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span> <span class="comment">// 对象会转换为true</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> falseValue = <span class="literal">false</span></span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// Boolean对象容易造成误解</span></span><br><span class="line"><span class="comment">// 理解基本类型的布尔值和Boolean对象的区别非常重要，建议永远不要使用Boolean对象</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Number是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向</span></span><br><span class="line"><span class="comment">* 中传递对应的数值</span></span><br><span class="line"><span class="comment">* 与Boolean类型一样，Number类型也重写了valueOf()、toLocaleString()和toString()</span></span><br><span class="line"><span class="comment">* 重写后的valueOf()方法返回对象表示基本类型的数值，另外两个方法返回字符串形式的</span></span><br><span class="line"><span class="comment">* 数值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// Number 的方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* toFixed() 指定的小数返回数值的字符串表示</span></span><br><span class="line"><span class="comment">* toExponent() 返回指数表示法（e表示法）</span></span><br><span class="line"><span class="comment">* toPrecision() 参数表示数值的所有数字的位数（不包括指数部分）</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* String类型是字符串对象的包装类型</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 字符串方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* charAt() 以单字符字符串的形式放回给定位置的那个字符 可以用str[1]</span></span><br><span class="line"><span class="comment">* 代替</span></span><br><span class="line"><span class="comment">* charCodeAt() 以单字符字符串的形式放回给定位置的那个字符的字符编码</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串操作方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* concat 拼接字符串可用+代替</span></span><br><span class="line"><span class="comment">* slice()</span></span><br><span class="line"><span class="comment">* substr()</span></span><br><span class="line"><span class="comment">* substring()</span></span><br><span class="line"><span class="comment">* 效果类似参数不同</span></span><br><span class="line"><span class="comment">* slice substring 第一第二各参数分别表示起始和结束位置</span></span><br><span class="line"><span class="comment">* substr 第二各参数表示返回的字符个数</span></span><br><span class="line"><span class="comment">* slice substr substring 都不会改变原字符串</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 字符串位置方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* indexOf(从开头向结尾搜索放回-1或字符位置)</span></span><br><span class="line"><span class="comment">* lastIndexOf（从结尾向开头搜索返回-1或字符位置）</span></span><br><span class="line"><span class="comment">* 第二各参数可以表示从哪个位置搜索</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// trim() 创建字符串副本，删除前后所有空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小写转换</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* toLowerCase() 转小写</span></span><br><span class="line"><span class="comment">* toLocaleLowerCase() 根据本地语言转小写</span></span><br><span class="line"><span class="comment">* toUpperCase() 转大写</span></span><br><span class="line"><span class="comment">* toLocaleUpperCase() 根据本地语言转大写</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串的模式匹配方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* match() 返回数组 与调用RegExp对象的exec()方法并传递本例中的字符串</span></span><br><span class="line"><span class="comment">* 作为参数的到的结果一样</span></span><br><span class="line"><span class="comment">* search() 返回字符串中的第一个匹配项的索引；如果没有找到匹配项则返回</span></span><br><span class="line"><span class="comment">* -1否则返回位置，search方法始终是从字符串的开头向后查找</span></span><br><span class="line"><span class="comment">* replace() 替换 根据正则表达式替换字符串，如果要全局替换要在正则表达式</span></span><br><span class="line"><span class="comment">* 中加入g标志</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* . 在[.]中匹配.字符即\.在此之外匹配所有元素</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 特殊字符序列</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* $$  $</span></span><br><span class="line"><span class="comment">* $&amp;  匹配整个模式的子字符串。与RegExp.lastMatch的值相同</span></span><br><span class="line"><span class="comment">* $'  匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同</span></span><br><span class="line"><span class="comment">* $`  匹配的子字符串之后的子字符串。RegExp.rightContext的值相同</span></span><br><span class="line"><span class="comment">* $n  匹配第n个捕获的子字符串，其中n等于0-9。如果正则表达式中没有</span></span><br><span class="line"><span class="comment">* 定义捕获组，则使用空字符串</span></span><br><span class="line"><span class="comment">* $nn 匹配第nn个捕获的子字符串，其中n等于01-99。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'cat,bat,sat,fat'</span></span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">'word($`)'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// replace 可以通过第二各参数进行更精细的操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, pos, originalText</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"&lt;"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;lt"</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"&gt;"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;gt"</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"&amp;"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;amp"</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"\""</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;quot"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(htmlEscape(<span class="string">'&lt;p class="greeting"&gt;hello world!&lt;/p&gt;'</span>))</span><br><span class="line"><span class="comment">// &amp;ltp class=&amp;quotgreeting&amp;quot&amp;gthello world!&amp;lt/p&amp;gt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split() 基于指定分隔符将一个字符串分割成多个子字符串，并将结果</span></span><br><span class="line"><span class="comment">// 放到一个数组中 ，可接受第二个参数指定数组的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span></span><br><span class="line"><span class="built_in">console</span>.log(colorText.split(<span class="string">','</span>)) <span class="comment">// ["red","blue","green","yellow"]</span></span><br><span class="line"><span class="built_in">console</span>.log(colorText.split(<span class="string">','</span>, <span class="number">2</span>)) <span class="comment">// ["red","blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(colorText.split(<span class="regexp">/[^\,]+/</span>)) <span class="comment">// ["", ",", ",", ",", ""]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// localeCompare() 方法 比较两个字符串返回下列值中的一个</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果子字符串在字母表中应该排在子字符串之前，则返回一个负数（大多数情况</span></span><br><span class="line"><span class="comment">* 是-1，具体值要视情况而定）</span></span><br><span class="line"><span class="comment">* 如果子字符串等于子字符串，则返回0</span></span><br><span class="line"><span class="comment">* 如果字符创在字母表中应该排在子字符串之后，则返回一个正数（大多数情况是</span></span><br><span class="line"><span class="comment">* 1，具体视情况而定）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">var</span> stringValue = <span class="string">'yellow'</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">'brick'</span>)) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">'yellow'</span>)) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">'zoo'</span>)) <span class="comment">//-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fromCharCode() //接收一或多个字符编码，然后将他们换成一个字符串。从本质</span></span><br><span class="line"><span class="comment">// 上看这个方法与charCodeAt()执行的是相反的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Global对象</span></span><br><span class="line"><span class="comment">// URL编码方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* encodeURL()  主要用于整个url</span></span><br><span class="line"><span class="comment">* encodeURLComponent() 对url中的一部分进行转码</span></span><br><span class="line"><span class="comment">* 将url转换为浏览器可识别的字符串</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 一般来说，我们使用encodeURLComponent()方法要比使用encodeURL要多，因为常见</span></span><br><span class="line"><span class="comment">* 是处理url的一部分</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 相对的</span></span><br><span class="line"><span class="comment">* decodeURL() 和decodeURLComponent() 是对上面的两种方法进行解码</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// eval()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 能够解释代码字符串的能力非常强大，但也非常危险。因此使用eval()时必须极为谨慎，</span></span><br><span class="line"><span class="comment">* 特别是在用他执行用户输入数据的情况下。否则可能会有恶意用户输入威胁你的站点或</span></span><br><span class="line"><span class="comment">* 应用程序安全的代码（即所谓的代码注入）</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Math 对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Math.E         自然对数的底数</span></span><br><span class="line"><span class="comment">* Math.LN10      10的自然对数</span></span><br><span class="line"><span class="comment">* Math.LN2       2的自然对数</span></span><br><span class="line"><span class="comment">* Math.LOG2E     以2为底e的对数</span></span><br><span class="line"><span class="comment">* Math.LOG10E    以10为底e的对数</span></span><br><span class="line"><span class="comment">* Math.PI        PI的值</span></span><br><span class="line"><span class="comment">* Math.SQRT1_2   1/2的平方根</span></span><br><span class="line"><span class="comment">* Math.SQRT2     2的平方根</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 最大值与最小值</span></span><br><span class="line"><span class="comment">// min() 和 max() 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 舍入方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Math.ceil() 向上舍入  25.9 -&gt; 26 25.5-&gt; 26 25.1 -&gt;26</span></span><br><span class="line"><span class="comment">* Math.floor() 向下舍入 25.9 -&gt; 25 25.5 -&gt;25 25.1 -&gt;25</span></span><br><span class="line"><span class="comment">* Math,round() 四舍五入</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// random() 方法 返回[0,1)之间的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取[min,max]之间的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectFrom</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> choices = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(selectFrom(<span class="number">2</span>, <span class="number">10</span>))<span class="comment">// [2,10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Math.abs(num)  绝对值</span></span><br><span class="line"><span class="comment">* Math.exp(num)  Math.E的num次幂</span></span><br><span class="line"><span class="comment">* Math.log(num)  num的自然对数</span></span><br><span class="line"><span class="comment">* Math.log(num,power) num 的power次幂</span></span><br><span class="line"><span class="comment">* math.sqrt(num) num的平方根</span></span><br><span class="line"><span class="comment">* Math.acos(x)  x的反余弦值</span></span><br><span class="line"><span class="comment">* Math.asin(x)  x的反正弦</span></span><br><span class="line"><span class="comment">* Math.atan(x)  x的反正切</span></span><br><span class="line"><span class="comment">* Math.atan2(y,x)  y/x的反正切</span></span><br><span class="line"><span class="comment">* Math.cos(x)  x的余弦</span></span><br><span class="line"><span class="comment">* Math.sin(x)  x的正弦</span></span><br><span class="line"><span class="comment">* Math.tan(x)  x的正切</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>虽然说在JavaScript编程语言中，<strong>函数是第一公民</strong>，但是JavaScript不仅支持函数式编程，也支持面向对象编程。JavaScript对象设计成了一组属性的无序集合，由key和value组成，key为一个标识符名称，而value可以是任意类型的值，当函数作为对象的属性值时，这个函数就可以称之为对象的方法。</p><h5 id="1-JavaScript创建对象的方式"><a href="#1-JavaScript创建对象的方式" class="headerlink" title="1.JavaScript创建对象的方式"></a>1.JavaScript创建对象的方式</h5><blockquote><p>一般地，常用于创建对象的方式有两种，早期经常使用Object类，通过new关键字来创建一个对象，有点类似于Java中创建对象，后来为了方便就直接使用对象字面量的方式来创建对象了，用法更为简洁。</p></blockquote><ul><li><p>使用<code>Object</code>类创建对象；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">// 创建一个空对象</span></span><br><span class="line"><span class="comment">// 往对象中添加属性</span></span><br><span class="line">obj.name = <span class="string">'curry'</span></span><br><span class="line">obj.age = <span class="number">30</span></span><br></pre></td></tr></table></figure></li><li><p>使用对象字面量创建对象；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接往&#123;&#125;添加键值对</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'curry'</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-对象属性操作的控制"><a href="#2-对象属性操作的控制" class="headerlink" title="2.对象属性操作的控制"></a>2.对象属性操作的控制</h5><blockquote><p>对象创建出来后，如何对该对象进行操作控制呢？这里涉及到一个很重要的方法：Object.defineProperty()。</p></blockquote><h6 id="2-1-Object-defineProperty"><a href="#2-1-Object-defineProperty" class="headerlink" title="2.1.Object.defineProperty()"></a>2.1.Object.defineProperty()</h6><blockquote><p>该方法可以在对象上定义一个新的属性，也可修 改对象现有属性，并将该对象返回。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><p>接收三个参数：</p><ul><li>obj：指定操作的对象；</li><li>prop：指定需要定义或修改的属性名称；</li><li>description：定义或修改的属性描述符；</li></ul><h6 id="2-2-属性描述符的分类"><a href="#2-2-属性描述符的分类" class="headerlink" title="2.2.属性描述符的分类"></a>2.2.属性描述符的分类</h6><blockquote><p>什么是属性描述符？顾名思义就是对对象中的属性进行描述，简单来说就是给对象某个属性指定一些规则。属性描述符主要分为<strong>数据属性描述符</strong>和<strong>存取属性描述符</strong>两种类型。</p></blockquote><p>对于属性描述符中的属性是否两者都可以设置呢？其实数据和存取属性描述符两者是有区别，下面的表格统计了两者可用和不可用的属性：</p><table><thead><tr><th align="left">属性</th><th align="left">configurable</th><th align="left">enumerable</th><th align="left">value</th><th align="left">writable</th><th align="left">get</th><th align="left">set</th></tr></thead><tbody><tr><td align="left">数据属性描述符</td><td align="left">可以</td><td align="left">可以</td><td align="left">可以</td><td align="left">可以</td><td align="left">不可以</td><td align="left">不可以</td></tr><tr><td align="left">存取属性描述符</td><td align="left">可以</td><td align="left">可以</td><td align="left">不可以</td><td align="left">不可以</td><td align="left">可以</td><td align="left">可以</td></tr></tbody></table><p>那么为什么有些属性可以用，有些属性又不能用呢？因为数据属性描述符和存取属性描述符所担任的角色不一样，下面就来详细介绍一下，它们两者的区别。</p><h6 id="2-3-数据属性描述符"><a href="#2-3-数据属性描述符" class="headerlink" title="2.3.数据属性描述符"></a>2.3.数据属性描述符</h6><blockquote><p>从上面的表格可以知道，数据属性描述符可以使用configurable、enumerable、value、writable。而这就是数据属性描述符的四个特性。</p></blockquote><ul><li><strong>Configurable</strong>：表示是否可以通过delete删除对象属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符。当通过<code>new Object()</code>或者字面量的方式创建对象时，其中的属性的<code>configurable</code>默认为<code>true</code>，当通过属性描述符定义一个属性时，其属性的<code>configurable</code>默认为<code>false</code>。</li><li><strong>Enumerable</strong>：表示是否可以通过for-in或者Object.keys()返回该属性。当通过<code>new Object()</code>或者字面量的方式创建对象时，其中的属性的<code>enumerable</code>默认为<code>true</code>，当通过属性描述符定义一个属性时，其属性的<code>enumerable</code>默认为<code>false</code>。</li><li><strong>Writable</strong>：表示是否可以修改属性的值。当通过<code>new Object()</code>或者字面量的方式创建对象时，其中的属性的<code>writable</code>性描述符定义一个属性时，其属性的<code>writable</code>默认为<code>false</code>。</li><li><strong>Value</strong>：属性的value值，读取属性时会返回该值，修改属性时会对其进行修改。（默认：undefined）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'curry'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'age'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// age属性是否可以删除，默认false</span></span><br><span class="line">  enumerable: <span class="literal">false</span>, <span class="comment">// age属性是否可以枚举，默认false</span></span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// age属性是否可以写入（修改），默认false</span></span><br><span class="line">  value: <span class="number">30</span> <span class="comment">// age属性的值，默认undefined</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当configurable为false，age属性是不可被删除的</span></span><br><span class="line"><span class="keyword">delete</span> obj.age</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; name: 'curry', age: 30 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当writable为false，age属性的值是不可被修改的</span></span><br><span class="line">obj.age = <span class="number">18</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; name: 'curry', age: 30 &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果将enumerable修改为false，age属性是不可以被遍历出来的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key) <span class="comment">// name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-4-存取属性描述符"><a href="#2-4-存取属性描述符" class="headerlink" title="2.4.存取属性描述符"></a>2.4.存取属性描述符</h6><blockquote><p>存取属性描述符可以使用configurable、enumerable、get、set。在获取对象某个属性值时，可以通过get来拦截，在设置对象某个属性值时，可以通过set来拦截。configurable和enumerable的用法和特性跟数据属性描述符一样。</p></blockquote><ul><li><strong>Get</strong>：获取属性时会执行的函数。（默认undefined）</li><li><strong>Set</strong>：设置属性时会执行的函数。（默认undefined）</li></ul><p>get和set的使用场景：</p><ul><li><p>隐藏某一个私有属性，不希望直接被外界使用和赋值。如下代码<code>_age</code>表示不想直接被外界使用，外界就可以通过使用<code>age</code>的set和get来访问设置<code>_age</code>了。</p></li><li><p>如果希望截获某一个属性它访问和设置值的过程。（Vue2的响应式原理就在这）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'curry'</span>,</span><br><span class="line">  _age: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这里的this是指向obj对象的</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'age'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'age属性被访问了'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._age</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'age属性被设置了'</span>)</span><br><span class="line">    <span class="keyword">this</span>._age = newValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.age <span class="comment">// age属性被访问了</span></span><br><span class="line">obj.age = <span class="number">18</span> <span class="comment">// age属性被设置了</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="2-5-同时给多个属性定义属性描述符"><a href="#2-5-同时给多个属性定义属性描述符" class="headerlink" title="2.5.同时给多个属性定义属性描述符"></a>2.5.同时给多个属性定义属性描述符</h6><blockquote><p>上面使用<code>Object.defineProperty()</code>方法都是给单个属性进行定义描述符，想要一次性定义多个属性，那么就可以使用<code>Object.defineProperties()</code>方法了。写法如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">'curry'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  age: &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._age</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">      <span class="keyword">this</span>._age = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="3-Object中常用的方法"><a href="#3-Object中常用的方法" class="headerlink" title="3.Object中常用的方法"></a>3.Object中常用的方法</h5><blockquote><p>上面介绍了Object中<code>defineProperty</code>和<code>defineProperties</code>两个方法。其实Object中还有很多方法，下面介绍一些常用的。</p></blockquote><ul><li><p>获取对象的属性描述符：</p><ul><li>获取单个属性：<code>Object.getOwnPropertyDescriptor</code>；</li><li>获取所有属性：<code>Object.getOwnPropertyDescriptors</code>；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'curry'</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'age'</span>)) <span class="comment">// &#123; value: 30, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    name: &#123;</span></span><br><span class="line"><span class="comment">      value: 'curry',</span></span><br><span class="line"><span class="comment">      writable: true,</span></span><br><span class="line"><span class="comment">      enumerable: true,</span></span><br><span class="line"><span class="comment">      configurable: true</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    age: &#123; value: 30, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.preventExtensions()</code>：禁止对象扩展新属性，给一个对象添加新的属性会失败（在严格模式下会报错）。</p></li><li><p><code>Object.seal()</code>：将对象密封起来，不允许配置和删除属性。（实际还是调用<code>preventExtensions</code>，并且将现有属性的<code>configurable</code>设置为<code>false</code>）</p></li><li><p><code>Object.freeze()</code>：将对象冻结起来，不允许修改对象现有属性。（实际上是调用seal，并且将现有属性的<code>writable</code>设置为<code>false</code>）</p></li></ul><h5 id="4-JavaScript创建多个对象"><a href="#4-JavaScript创建多个对象" class="headerlink" title="4.JavaScript创建多个对象"></a>4.JavaScript创建多个对象</h5><blockquote><p>上面提到的创建对象的方式仅适用于创建单个对象适用，如果有多个对象比较类似，那么一个个创建必然是很麻烦的，如何批量创建对象呢？JavaScript也给我们提供了一些方案。</p></blockquote><h6 id="4-1-方案一：工厂函数"><a href="#4-1-方案一：工厂函数" class="headerlink" title="4.1.方案一：工厂函数"></a>4.1.方案一：工厂函数</h6><blockquote><p>如果我们不想在创建对象时做重复的工作，那么就可以定义一个函数为我们去做这些重复性的工作，我们只需要将属性对应的值传入函数即可。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置对应属性值</span></span><br><span class="line">  obj.name = name</span><br><span class="line">  obj.age = age</span><br><span class="line">  <span class="comment">// 公共方法共用</span></span><br><span class="line">  obj.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.namename&#125;</span>, I'm <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将对象返回</span></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = createObj(<span class="string">'curry'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> obj2 = createObj(<span class="string">'kobe'</span>, <span class="number">24</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj1) <span class="comment">// &#123; name: 'curry', age: 30, sayHello: [Function (anonymous)] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">// &#123; name: 'kobe', age: 24, sayHello: [Function (anonymous)] &#125;</span></span><br><span class="line">obj1.sayHello() <span class="comment">// My name is undefined, I'm 30 years old.</span></span><br><span class="line">obj2.sayHello() <span class="comment">// My name is undefined, I'm 24 years old.</span></span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：创建出来的对象全是通过字面量创建的，获取不到对象真实的类型。</p><h6 id="4-2-方案二：构造函数"><a href="#4-2-方案二：构造函数" class="headerlink" title="4.2.方案二：构造函数"></a>4.2.方案二：构造函数</h6><p><strong>（1）什么是构造函数？</strong></p><ul><li>构造函数也称之为构造器（constructor），通常是我们在创建对象时会调用的函数；</li><li>在其他面向对象的编程语言里面，构造函数是存在于类中的一个方法，称之为构造方法；</li><li>如果一个普通的函数被使用<strong>new操作符来调用</strong>了，那么这个函数就称之为是一个构造函数；</li><li>一般规定构造函数的函数名首字母大写；</li></ul><p><strong>（2）new操作符调用函数的作用</strong></p><blockquote><p>当一个函数被new操作符调用了，默认会进行如下几部操作：</p></blockquote><ul><li>在内存中创建一个<strong>新的对象</strong>（空对象）；</li><li>这个对象内部的**[[prototype]]属性<strong>会被赋值为该</strong>构造函数的prototype属性**；</li><li>构造函数内部的this，会<strong>指向创建出来的新对象</strong>；</li><li>执行函数的<strong>内部代码</strong>（函数体代码）；</li><li>如果构造函数没有返回<strong>对象</strong>，则默认返回创建出来的新对象。</li></ul><p><strong>（3）构造函数创建对象的过程</strong></p><ul><li>通过构造函数创建的对象就真实的类型了，如下所示的Person类型；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, I'm <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">'curry'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person(<span class="string">'kobe'</span>, <span class="number">24</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1) <span class="comment">// Person &#123; name: 'curry', age: 30, sayHello: [Function (anonymous)] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2) <span class="comment">// Person &#123; name: 'kobe', age: 24, sayHello: [Function (anonymous)] &#125;</span></span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：在每次使用new创建新对象时，会重新给每个对象创建新的属性，包括对象中方法，实际上，对象中的方法是可以共用的，消耗了不必要的内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h6 id="4-3-方案三：原型-构造函数"><a href="#4-3-方案三：原型-构造函数" class="headerlink" title="4.3.方案三：原型+构造函数"></a>4.3.方案三：原型+构造函数</h6><blockquote><p>在了解该方案之前，需要先简单的认识一下何为原型。</p></blockquote><p><strong>（1）对象的原型</strong></p><blockquote><p>JavaScript中每个对象都有一个特殊的内置属性[[prototype]]（我们称之为<strong>隐式原型</strong>），这个特殊的属性指向另外一个对象。那么这个属性有什么用呢?</p></blockquote><ul><li>前面介绍了，当我们通过对象的key来获取对应的value时，会触发对象的get操作；</li><li>首先，get操作会先查看该对象自身是否有对应的属性，如果有就找到并返回其值；</li><li>如果在对象自身没有找到该属性就会去对象的[[prototype]]这个内置属性中查找；</li></ul><p>那么对象的[[prototype]]属性怎么获取呢？主要有两种方法：</p><ul><li>通过对象的<code>__proto__</code>属性访问；</li><li>通过<code>Object.getPrototypeOf()</code>方法获取；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'curry'</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj))</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208161155310.png" alt="img"></p><p><strong>（2）函数的原型</strong></p><blockquote><p>所有的函数都有一个prototype属性，并且只有函数才有这个属性。前面提到了new操作符是如何在内存中创建一个对象，并给我们返回创建出来的对象，其中第二步<strong>这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性</strong>。将代码与图结合，来看一下具体的过程。</p></blockquote><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p1 = new Person(&apos;curry&apos;, 30)</span><br><span class="line">const p2 = new Person(&apos;kobe&apos;, 24)</span><br><span class="line">// 验证：对象(p1\p2)内部的[[prototype]]属性(__proto__)会被赋值为该构造函数(Person)的prototype属性；</span><br><span class="line">console.log(p1.__proto__ === Person.prototype) // true</span><br><span class="line">console.log(p2.__proto__ === Person.prototype) // true</span><br></pre></td></tr></table></figure><p>内存表现：</p><ul><li>p1和p2的原型都指向Person函数的prototype原型；</li><li>其中还有一个constructor属性，默认原型上都会有这个属性，并且指向当前的函数对象；</li></ul><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208161156642.png" alt="img"></p><p><strong>（3）结合对象和函数的原型，创建对象</strong></p><blockquote><p>先简单的总结一下：</p></blockquote><ul><li>前面使用构造函数创建对象的缺点是对象中的方法不能共用；</li><li>对象的属性可以通过[[prototype]]隐式原型进行查找；</li><li>构造函数创建出来的对象[[prototype]]与构造函数prototype指向同一个对象（同一个地址空间）；</li><li>那么我们可以将普通的属性放在构造函数的内部，将方法放在构造函数的原型上，当查找方法时，就都会去到构造函数的原型上，从而实现方法共用；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, I'm <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old.`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">'curry'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person(<span class="string">'kobe'</span>, <span class="number">24</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h6 id="4-4-其他"><a href="#4-4-其他" class="headerlink" title="4.4.其他"></a>4.4.其他</h6><p>创建对象的模式还有许许多多，包括不限于<code>动态原型模式</code>、<code>寄生构造函数模式</code>、<code>稳妥构造函数模式</code>、``</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>原型模式是一种设计模式，那么为什么要在JavaScript这章里面单独拿出来讲呢，因为js可以归纳为是一门基于原型的面向对象语言。基于原型这个概念是深入进js的基因的，所以在这里单独开一章。</p><p>简单地说，<em>JavaScript 是基于原型的语言</em>。当我们调用一个对象的属性时，如果对象没有该属性，JavaScript 解释器就会从对象的原型对象上去找该属性，如果原型上也没有该属性，那就去找原型的原型，直到最后返回null为止，null没有原型。这种属性查找的方式被称为原型链（prototype chain）。</p><h5 id="JavaScript原型-amp-原型链"><a href="#JavaScript原型-amp-原型链" class="headerlink" title="JavaScript原型 &amp; 原型链"></a>JavaScript原型 &amp; 原型链</h5><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208160424300.png" alt="preview"></p><p>首先来一个总纲，总纲里面包括了原型/原型链的所有内容，然后我们把图拆解。</p><ul><li>想要弄清楚原型和原型链，这几个属性必须要搞清楚，<code>__proto__</code>、<code>prototype</code>、 <code>constructor</code>。</li><li>其次你要知道js中对象和函数的关系，函数其实是对象的一种。</li><li>最后你要知道函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个函数，那它只是一个普通的函数，下面我们让这个函数变得不普通</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="comment">//这时这个Parent就不是普通的函数了，它现在是一个构造函数。因为通过new关键字调用了它</span></span><br><span class="line"><span class="comment">//创建了一个Parent构造函数的实例 p1</span></span><br></pre></td></tr></table></figure><p>我们再引出一个概念，开始说过了要想清楚原型就要先搞清楚这三个属性，<code>__proto__</code>、<code>prototype</code>、 <code>constructor</code>。</p><ul><li>我们记住两点</li></ul><p>1.<code>__proto__</code>、 <code>constructor</code>属性是对象所独有的；<br>2.<code>prototype</code>属性是函数独有的；<br>3.上面说过js中函数也是对象的一种，那么函数同样也有属性<code>__proto__</code>、 <code>constructor</code>；</p><p>下面开始进入正题，我将上面的一张图拆分成3张图，分别讲解对应的3个属性。</p><h6 id="1-prototype属性"><a href="#1-prototype属性" class="headerlink" title="1.prototype属性"></a>1.prototype属性</h6><p>为了方便举例，我们在这模拟一个场景，父类比作师父，子类比作徒弟。师父收徒弟，<br>徒弟还可以收徒弟。徒弟可以得到师父传授的武功，然后徒弟再传给自己的徒弟。<br>师父想要传授给徒弟们的武功就放到“prototype”这个琅琊福地中。徒弟徒孙们就去这里学习武功。</p><p>prototype属性可以看成是一块特殊的存储空间，存储了供“徒弟”、“徒孙”们使用的方法和属性。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208160428119.png" alt="preview"></p><p>它是函数独有的属性，从图中可以看到它从一个函数指向另一个对象，代表这个对象是这个函数的原型对象，这个对象也是当前函数所创建的实例的原型对象。<br><code>prototype</code>设计之初就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了<code>prototype</code>我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（prototype）。那些不需要共享的才创建在构造函数中。<br>继续引用上面的代码，当我们想为通过Parent实例化的所有实例添加一个共享的属性时，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.prototype.name = <span class="string">"我是原型属性，所有实例都可以读取到我"</span>;</span><br></pre></td></tr></table></figure><p>这就是原型属性，当然你也可以添加原型方法。那问题来了，<code>p1</code>怎么知道他的原型对象上有这个方法呢，往下看↓↓↓</p><h6 id="2-proto属性"><a href="#2-proto属性" class="headerlink" title="2.proto属性"></a>2.proto属性</h6><p>__proto__属性相当于通往prototype（“琅琊福地”）唯一的路（指针）<br>让“徒弟”、“徒孙” 们找到自己“师父”、“师父的师父” 提供给自己的方法和属性</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208160429727.png" alt="preview"></p><p><code>__proto__</code>属性是对象（包括函数）独有的。从图中可以看到<code>__proto__</code>属性是从一个对象指向另一个对象，即从一个对象指向该对象的原型对象（也可以理解为父对象）。显然它的含义就是告诉我们一个对象的原型对象是谁。<br>prototype篇章我们说到，<code>Parent.prototype</code>上添加的属性和方法叫做原型属性和原型方法，该构造函数的实例都可以访问调用。那这个构造函数的原型对象上的属性和方法，怎么能和构造函数的实例联系在一起呢，就是通过<code>__proto__</code>属性。每个对象都有<code>__proto__</code>属性，该属性指向的就是该对象的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.__proto__ === Parent.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>__proto__</code>通常称为隐式原型，<code>prototype</code>通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。<br>我们之前也说过<code>__proto__</code>属性是对象（包括函数）独有的，那么<code>Parent.prototype</code>也是对象，那它有隐式原型么？又指向谁？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>可以看到，构造函数的原型对象上的隐式原型对象指向了Object的原型对象。那么Parent的原型对象就继承了Object的原型对象。由此我们可以验证一个结论，万物继承自Object.prototype。这也就是为什么我们可以实例化一个对象，并且可以调用该对象上没有的属性和方法了。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们并没有在Parent中定义任何方法属性，但是我们可以调用</span></span><br><span class="line">p1.toString();<span class="comment">//hasOwnProperty 等等的一些方法</span></span><br></pre></td></tr></table></figure><p>我们可以调用很多我们没有定义的方法，这些方法是哪来的呢？现在引出原型链的概念，当我们调用<code>p1.toString()</code>的时候，先在<code>p1</code>对象本身寻找，没有找到则通过<code>p1.__proto__</code>找到了原型对象<code>Parent.prototype</code>，也没有找到，又通过<code>Parent.prototype.__proto__</code>找到了上一层原型对象Object.prototype。在这一层找到了toString方法。返回该方法供<code>p1</code>使用。<br>当然如果找到Object.prototype上也没找到，就在<code>Object.prototype.__proto__</code>中寻找，但是<code>Object.prototype.__proto__ === null</code>所以就返回undefined。这就是为什么当访问对象中一个不存在的属性时，返回undefined了。</p><h6 id="3-constructor属性"><a href="#3-constructor属性" class="headerlink" title="3.constructor属性"></a>3.constructor属性</h6><p>constructor属性是让“徒弟”、“徒孙” 们知道是谁创造了自己，这里可不是“师父”啊<br>而是自己的父母，父母创造了自己，父母又是由上一辈人创造的，……追溯到头就是Function() 【女娲】。</p><hr><p>补丁：上面的说法严格来讲并不正确，明显在逻辑上有一些不通顺的地方，那是因为：constructor属性本质上只有prototype对象才有，也就是说<code>构造函数.prototype.contructor === 该构造函数</code>，实例对象之所以会有是只是通过<code>_proto</code>继承来自其构造函数的原型对象。</p><p>所以p1 =&gt; Parent() =&gt; Function()这里的contructor属性应该用虚线表示，注明来自继承得来。</p><p>可以通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.hasOwnProperty(<span class="string">'constructor'</span>) <span class="comment">// false</span></span><br><span class="line">Parent.prototype.hasOwnProperty(<span class="string">'constructor'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>得到验证。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208160431060.png" alt="preview"></p><p>constructor是对象才有的属性，从图中看到它是从一个对象指向一个函数的。指向的函数就是该对象的构造函数。每个对象都有构造函数，好比我们上面的代码<code>p1</code>就是一个对象，那<code>p1</code>的构造函数是谁呢？我们打印一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1.constructor); <span class="comment">// ƒ Parent()&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>通过输出结果看到，很显然是Parent函数。我们有说过函数也是对象，那Parent函数是不是也有构造函数呢？显然是有的。再次打印下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Parent.constructor); <span class="comment">// ƒ Function() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><p>通过输出看到Parent函数的构造函数是Function()，这点也不奇怪，因为我们每次定义函数其实都是调用了new Function()，下面两种效果是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'msg'</span>,<span class="string">'alert(msg)'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    alert(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们再回来看下，再次打印Function.constructor</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.constructor); <span class="comment">// ƒ Function() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><p>可以看到Function函数的构造函数就是本身了，那我们也就可以说Function是所有函数的根构造函数。<br>到这里我们已经对constructor属性有了一个初步的认识，它的作用是从一个对象指向一个函数，这个函数就是该对象的构造函数。通过栗子我们可以看到，<code>p1</code>的<code>constructor</code>属性指向了<code>Parent</code>，那么<code>Parent</code>就是<code>p1</code>的构造函数。同样<code>Parent</code>的<code>constructor</code>属性指向了<code>Function</code>，那么<code>Function</code>就是<code>Parent</code>的构造函数，然后又验证了<code>Function</code>就是根构造函数。</p><p>脑筋急转弯之 存在没有原型的对象吗？使用<code>Objetct.create(null)</code>可以创建出没有原型的对象。</p><h6 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h6><p>ok，上面的比喻是为了初学者能够方便的理解原型和原型链，下面梳理一下流程。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208170956321.png" alt="img"></p><p>在这个过程里面，关于prototype我觉得有两个理解含义，在箭头上面的<code>prototype</code>有点类似于<code>.prototype指针</code>的意思，而<code>Person.prototype</code>毫无疑问就是常规意义上的原型对象。</p><h6 id="5-使用习惯"><a href="#5-使用习惯" class="headerlink" title="5.使用习惯"></a>5.使用习惯</h6><p>关于构造函数，咱们引入一些使用习惯：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funcion A(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">// 实例基本属性 (该属性，强调私有，不共享)</span></span><br><span class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>]; <span class="comment">// 实例引用属性 (该属性，强调私用，不共享)</span></span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 实例引用属性 (该属性，强调复用，需要共享)</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：数组和方法都属于‘实例引用属性’，但是数组强调私有、不共享的。方法需要复用、共享。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：在构造函数中，一般很少有数组形式的引用属性，大部分情况都是：基本属性 + 方法。</span></span><br></pre></td></tr></table></figure><p>原型对象的使用习惯</p><blockquote><p>原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。并且所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。而实例有很多份，且实例属性和方法是独立的。</p><p>在构造函数中：为了属性(实例基本属性)的私有性、以及方法(实例引用属性)的复用、共享。我们提倡：</p></blockquote><ul><li>将属性封装在构造函数中</li><li>将方法定义在原型对象上</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">funcion A(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">// (该属性，强调私有，不共享)</span></span><br><span class="line">&#125;</span><br><span class="line">A.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 定义在原型对象上的方法 (强调复用，需要共享)</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐的写法</span></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐的原因：（原因和上面连续赋值的例子很像）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'John'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 此时可以正常调用</span></span><br><span class="line">person.say();<span class="comment">//Hello,John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果换成另一种表达方式</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'John'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">    Person.prototype = &#123;</span><br><span class="line">        say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Hello,'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 此时无法正常调用 原因很简单，在给Person.prototype重新赋值的时候，person的_proto_并不会跟着Person.prototype一起指向新值，所以在下面调用say，是访问不到的，同样属于是原型里面的知识点。</span></span><br><span class="line">    person.say();<span class="comment">//person.say is not a function</span></span><br></pre></td></tr></table></figure><h5 id="JS继承"><a href="#JS继承" class="headerlink" title="JS继承"></a>JS继承</h5><blockquote><p>js中的继承有多种方式，大体上就是两种，一种是基于原型链覆盖的形式、一种是对象冒充也就是通过改变this指向。支持多继承，通过原型链可以一直往上找。</p></blockquote><h6 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getX = <span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.y = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型继承 Child通过原型链可以找到Parent中的私有属性和Parent.prototype中的公有属性</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent;</span><br><span class="line">Child.prototype.getY = <span class="function"><span class="keyword">function</span> <span class="title">getY</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child;</span><br></pre></td></tr></table></figure><p>优点：父类方法可以复用</p><p>缺点：</p><p>1.父类所有的引用类型数据（对象，数组）会被子类共享，更改一个子类的数据，其他数据会受到影响，一直变化。</p><p>2.子类实例不能给父类构造函数传参</p><h6 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2.构造函数继承"></a>2.构造函数继承</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'小明'</span></span><br><span class="line">    <span class="keyword">this</span>.eats = [<span class="string">'苹果'</span>]</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.get = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Person.prototype上的方法"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu1 = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="built_in">console</span>.log(stu1.name);</span><br><span class="line"><span class="built_in">console</span>.log(stu1.eats);</span><br><span class="line">stu1.getName();</span><br><span class="line">stu1.get(); <span class="comment">// 报错 提示没有这种方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stu1)</span><br></pre></td></tr></table></figure><p>这种情况下，在Child的构造函数中，使用<code>Parent.call(this)</code>直接调用了Parent的“构造函数”，这里是要突出这个引号，原因是其实只调用了这个函数，严格意义上并不能称之为构造函数，在JS中只有创建了实例的函数才能叫构造函数，但是在此例中并没有构造实例，也就造成了一个问题——因为并没有构造实例，并不会触发<code>Parent.prototype</code>,所以是没法调用到上面的<code>getX</code>的。</p><p>这种方式的优点是 父类的引用类型不会被子类共享，不会互相影响。</p><p>缺点是不能访问父类的原型属性（因为父类的原型属性根本没被创造出来）</p><h6 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'小明'</span></span><br><span class="line">    <span class="keyword">this</span>.eats = [<span class="string">'苹果'</span>]</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.get = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Person.prototype上的方法"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu1 = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="built_in">console</span>.log(stu1.name);</span><br><span class="line"><span class="built_in">console</span>.log(stu1.eats);</span><br><span class="line">stu1.getName();</span><br><span class="line">stu1.get();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stu1)</span><br></pre></td></tr></table></figure><p>这种方式相当于是上面两种的合体，这种方式在第二种的前提上，真正的把父类的对象创建了，所以自然也就会调用到父类的原型对象。也能用到里面的方法。</p><p>但是这个里面也会有一个缺点。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208181015479.png" alt="image-20220818101558357"></p><p>可以看到，只需要一份的数据，在这种继承模式下，会分别在父类和子类里面都有一份，虽然能满足需求但是性能会比较差一点。</p><h6 id="4-寄生组合继承"><a href="#4-寄生组合继承" class="headerlink" title="4.寄生组合继承"></a>4.寄生组合继承</h6><p>细推上面那种方式，想知道父类里面的重复数据是哪里来的，其实就是父类在创建对象的过程中，<code>Student.prototype = new Person();</code>这里把Person对象创建出来重新加载了一次。如果这个Person构造函数中没有属性的话（只有父类的原型对象有），其实是满足我们要求的。</p><p>考虑到这，那么有没有办法能够忽略到父类构造函数中属性的方法呢？</p><p>有的，使用解几何题中常见的手段——辅助线（中间函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'小明'</span></span><br><span class="line">    <span class="keyword">this</span>.eats = [<span class="string">'苹果'</span>]</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.get = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Person.prototype上的方法"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Student.prototype = new Person();</span></span><br><span class="line"><span class="keyword">const</span> Fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Fn.prototype = Person.prototype</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Fn()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu1 = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="built_in">console</span>.log(stu1.name);</span><br><span class="line"><span class="built_in">console</span>.log(stu1.eats);</span><br><span class="line">stu1.getName();</span><br><span class="line">stu1.get();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stu1)</span><br></pre></td></tr></table></figure><p>使用Fn指向Person的原型对象，然后新建一个Fn，这样就相当于构建了一个没有属性的父类，等效的。</p><p>理论上是比较优秀的方案。</p><h6 id="5-ES6自带继承"><a href="#5-ES6自带继承" class="headerlink" title="5.ES6自带继承"></a>5.ES6自带继承</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>()&#123;</span><br><span class="line"><span class="keyword">this</span>.x=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">getX()&#123;</span><br><span class="line">retrun <span class="keyword">this</span>.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>()&#123;</span><br><span class="line"><span class="keyword">super</span>();<span class="comment">//类似于call继承super(100,200) 相当于把Parent中的constructor执行，传递了100和200</span></span><br><span class="line"><span class="keyword">this</span>.y=<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">getY()&#123;</span><br><span class="line">retrun <span class="keyword">this</span>.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是更新之后，语言自己给出的解决方案。添加了一些class extend等新概念。</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> functionName2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式: JavaScript 函数可以通过一个表达式定义,函数表达式可以存储在变量中：</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a * b&#125;;</span><br><span class="line"><span class="comment">// 在函数表达式存储在变量后，变量也可作为一个函数使用：</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a * b&#125;;</span><br><span class="line"><span class="keyword">var</span> z = x(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数表达式存储在变量后，变量也可作为一个函数使用：</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a * b&#125;;</span><br><span class="line"><span class="keyword">var</span> z = x(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数同样可以通过内置的 JavaScript 函数构造器（Function()）定义。</span></span><br><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"return a * b"</span>);</span><br><span class="line"><span class="keyword">var</span> x = myFunction(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数提升（Hoisting） 函数可以在声明之前调用 使用表达式定义函数时无法提升。</span></span><br><span class="line">myFunction(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自调用函数</span></span><br><span class="line"><span class="comment">函数表达式可以 "自调用"。</span></span><br><span class="line"><span class="comment">自调用表达式会自动调用。</span></span><br><span class="line"><span class="comment">如果表达式后面紧跟 () ，则会自动调用。</span></span><br><span class="line"><span class="comment">不能自调用声明的函数。</span></span><br><span class="line"><span class="comment">通过添加括号，来说明它是一个函数表达式：*/</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">"Hello!!"</span>;      <span class="comment">// 我将调用自己</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="comment">/*(参数1, 参数2, …, 参数N) =&gt; &#123; 函数声明 &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(参数1, 参数2, …, 参数N) =&gt; 表达式(单一)</span></span><br><span class="line"><span class="comment">相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125; */</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">// arguments.callee 指向正在执行的函数的指针</span></span><br><span class="line"><span class="comment">// 求阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式下不能访问arguments.callee 从而出错</span></span><br><span class="line"><span class="keyword">var</span> factorial2 = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 有权访问另一个函数作用域中的变量函数</span></span><br><span class="line"><span class="comment">* 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。</span></span><br><span class="line"><span class="comment">* 过度使用闭包会导致内存占用过多</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数可以访问由函数内部定义的变量，如：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数也可以访问函数外部定义的变量，如：</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后面一个实例中， a 是一个 全局 变量。</span></span><br><span class="line"><span class="comment">在web页面中全局变量属于 window 对象</span></span><br><span class="line"><span class="comment">全局变量可应用于页面上的所有脚本。</span></span><br><span class="line"><span class="comment">在第一个实例中， a 是一个 局部 变量。</span></span><br><span class="line"><span class="comment">局部变量只能用于定义它函数内部。对于其他的函数或脚本代码是不可用的。</span></span><br><span class="line"><span class="comment">全局和局部变量即便名称相同，它们也是两个不同的变量。修改其中一个，不会影响另一个的值。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器困境</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 计数器现在为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*计数器数值在执行 add() 函数时发生变化。</span></span><br><span class="line"><span class="comment">但问题来了，页面上的任何脚本都能改变计数器，即便没有调用 add() 函数。</span></span><br><span class="line"><span class="comment">如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值：*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 本意是想输出 3, 但事与愿违，输出的都是 1 !</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JavaScript 内嵌函数可以解决该问题。</span></span><br><span class="line"><span class="comment">/*所有函数都能访问全局变量。  </span></span><br><span class="line"><span class="comment">实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域。</span></span><br><span class="line"><span class="comment">JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。</span></span><br><span class="line"><span class="comment">该实例中，内嵌函数 plus() 可以访问父函数的 counter 变量：*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params"></span>) </span>&#123;counter += <span class="number">1</span>;&#125;</span><br><span class="line">    plus();    </span><br><span class="line">    <span class="keyword">return</span> counter; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果我们能在外部访问 plus() 函数，这样就能解决计数器的困境。</span></span><br><span class="line"><span class="comment">我们同样需要确保 counter = 0 只执行一次。</span></span><br><span class="line"><span class="comment">我们需要闭包。(closures)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 计数器为 3, 变量 add 指定了函数自我调用的返回字值。自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。计数器受匿名函数的作用域保护，只能通过 add 方法修改。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于this对象</span></span><br><span class="line"><span class="comment">// 在闭包中使用this对象也可能会导致一些问题。this对象是在运行时基于函数的执行</span></span><br><span class="line"><span class="comment">// 环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用</span></span><br><span class="line"><span class="comment">// 时，this等于那个对象。不过匿名函数的执行环境具有全局性，因此其this对象通常</span></span><br><span class="line"><span class="comment">// 指向window</span></span><br></pre></td></tr></table></figure><p>…</p><h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><p> Browser Object Model</p><p>BOM的解释是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOM即浏览器对象模型。</span><br><span class="line">BOM提供了独立于内容 而与浏览器窗口进行交互的对象；</span><br><span class="line">由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window；</span><br><span class="line">BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性；</span><br><span class="line">BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分。</span><br></pre></td></tr></table></figure><p>使用BOM，开发者可以操控浏览器显示页面之外的部分。而它最独特的地方，就是问题最多的地方，激素它唯一一个没有相关标注的javascript实现。总体来说，BOM主要针对的是浏览器窗口和子窗口，但是通常会把任何特定于浏览器的扩展都归于在BOM的范畴内。下面是一些拓展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">弹出新浏览器窗口的能力。</span><br><span class="line">移动、缩放和关闭浏览器窗口的详近信息。</span><br><span class="line">navigator对象，提供关于浏览器的详尽信息。</span><br><span class="line">location对象，提供浏览器加载页面的详尽信息。</span><br><span class="line">screen对象，提供关于用户屏幕分辨率的详尽信息。</span><br><span class="line">performance对象，提供浏览器内存占用、导航行为和时间统计的详尽信息。</span><br><span class="line">对cookie的支持。</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果页面中包含框架（frame），则每个框架都拥有自己的window对象，并且保存在frames集合中</span></span><br><span class="line"><span class="comment">* 在frames集合中，可以通过数值索引（从0开开始，从左到右，从上到下）或者框架名来访问相应</span></span><br><span class="line"><span class="comment">* 的window对象。每个window对象都有一个name属性，其中包含框架名称。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口位置（screenLeft，screenTop）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* moveTo()接收新位置</span></span><br><span class="line"><span class="comment">* moveBy()接收的是水平和垂直方向上移动的像素数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 窗口大小</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 不同浏览器之间的差异性</span></span><br><span class="line"><span class="comment">* IE9+，Safari和Firefox中，outerWidth，outHeight，返回浏览器窗口本身的尺寸。Opera中，这</span></span><br><span class="line"><span class="comment">* 两个属性的值表示视图容器（Opera中单个标签页对应的浏览器窗口）的大小。innerWidth和</span></span><br><span class="line"><span class="comment">* innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。在Chrome中，outerWidth、</span></span><br><span class="line"><span class="comment">* outerHeight与innerWidth、innerHeight返回相同的值，即视口大小（viewport）大小而非浏览</span></span><br><span class="line"><span class="comment">* 器窗口大小</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* IE、Firefox,Safari,Opera,和Chrome中document.documentElement.clientWidth 和 document.</span></span><br><span class="line"><span class="comment">* documentElement.clientHeight中保存了页面视口信息。在ie6中，这些属性必须在标准模式下才</span></span><br><span class="line"><span class="comment">* 有效。如果是混杂模式，就必须通过document.body.clientWidth和document.body.clientHeight</span></span><br><span class="line"><span class="comment">* 取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentElement还是document。</span></span><br><span class="line"><span class="comment">* body中的clientWidth和clientHeight属性都可以获取视口的大小</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 获取页面视口大小</span></span><br><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth !== <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode === <span class="string">"CSS1Compat"</span>) &#123;<span class="comment">//是否处于标准模式</span></span><br><span class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在移动端：视口信息保存在document.body.clientWidth和document.body.clientHeight中</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 调整浏览器窗口大小</span></span><br><span class="line"><span class="comment">* resizeTo() 接收浏览器窗口的新宽度和新高度</span></span><br><span class="line"><span class="comment">* resizeBy() 接收新窗口与原窗口的宽高差值</span></span><br><span class="line"><span class="comment">* moveTo() 移动位置</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导航和打开窗口</span></span><br><span class="line"><span class="comment">// 弹出窗口 window.open()（大多数浏览器会屏蔽窗口弹框）</span></span><br><span class="line"><span class="comment">// 安全限制</span></span><br><span class="line"><span class="comment">// 弹出窗口屏蔽程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 间歇调用和超时调用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 间歇调用：setInterval(function()&#123;&#125;,time)</span></span><br><span class="line"><span class="comment">* 超时调用：setTimeout(function()&#123;&#125;,time)</span></span><br><span class="line"><span class="comment">* 清除：clearInterval(intervalId) clearTimeout(timer)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 间歇和超时调用的代码都是在全局作用域中执行的，因此函数中的this的值在非严格</span></span><br><span class="line"><span class="comment">* 模式下指向window对象，在严格模式下是undefined</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统对话框</span></span><br><span class="line"><span class="comment">// alert()(提示文本、确认) confirm()（提示文本、取消、确定） prompt(文本、输</span></span><br><span class="line"><span class="comment">// 入框、取消、确认)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// location 对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* location对象的所有属性</span></span><br><span class="line"><span class="comment">* hash  '#contents' 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，</span></span><br><span class="line"><span class="comment">* 则返回空字符串</span></span><br><span class="line"><span class="comment">* host  'www.wrox.com:80' 返回服务器名称和端口号（如果有）</span></span><br><span class="line"><span class="comment">* hostname  'www.wrox.com' 返回不带端口号的服务名称</span></span><br><span class="line"><span class="comment">* href  'http:/www.wrox.com' 返回当前加载页面的完整URL。而location对象的toString（）</span></span><br><span class="line"><span class="comment">* 方法也返回这个值</span></span><br><span class="line"><span class="comment">* pathname '/WileyCDA/'  返回URL中的目录和（或）文件名</span></span><br><span class="line"><span class="comment">* port  '8080'  返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串</span></span><br><span class="line"><span class="comment">* protocol  'http'  返回页面使用的协议。通常是http：或https:</span></span><br><span class="line"><span class="comment">* search  '?q=javascript'  返回URL的查询字符串。这个字符串以问号开头</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//查询字符串并去掉开头的问号</span></span><br><span class="line">    <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>),</span><br><span class="line">        <span class="comment">// 保存数据的对象</span></span><br><span class="line">        args = &#123;&#125;,</span><br><span class="line">        <span class="comment">//取得每一项</span></span><br><span class="line">        items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</span><br><span class="line">        item = <span class="literal">null</span>,</span><br><span class="line">        name = <span class="literal">null</span>,</span><br><span class="line">        value = <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">//在for循环中使用</span></span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = items.length;</span><br><span class="line">    <span class="comment">//逐个将每一项添加到args对象中</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">        item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">        name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (name.length) &#123;</span><br><span class="line">            args[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置操作</span></span><br><span class="line"><span class="comment">// location.assign()</span></span><br><span class="line"><span class="comment">// location.href</span></span><br><span class="line"><span class="comment">// window.location</span></span><br><span class="line"><span class="comment">// location.replace() 浏览器位置改变，但不会在历史记录中生成新记录。所以跳转后不能后退</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// navigator 用于检测浏览器类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// screen 对象表明客户端的能力</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// history 对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*history.go()可以在历史记录中任意跳转</span></span><br><span class="line"><span class="comment">*history.back() 后退</span></span><br><span class="line"><span class="comment">* history.forward() 前进</span></span><br><span class="line"><span class="comment">* history.length 历史记录的数量</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><h4 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 能力检测</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在实际开发中，应该讲能力检测作为确定下一步解决方案的依据，而不是用它来判断浏览器</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 怪癖检测</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代理检测</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代理字符串检测技术（navigator.userAgent）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> browser=&#123;</span><br><span class="line">    versions:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> u = navigator.userAgent, app = navigator.appVersion;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            trident: u.indexOf(<span class="string">'Trident'</span>) &gt; <span class="number">-1</span>, <span class="comment">//IE内核</span></span><br><span class="line">            presto: u.indexOf(<span class="string">'Presto'</span>) &gt; <span class="number">-1</span>, <span class="comment">//opera内核</span></span><br><span class="line">            webKit: u.indexOf(<span class="string">'AppleWebKit'</span>) &gt; <span class="number">-1</span>, <span class="comment">//苹果、谷歌内核</span></span><br><span class="line">            gecko: u.indexOf(<span class="string">'Gecko'</span>) &gt; <span class="number">-1</span> &amp;&amp; u.indexOf(<span class="string">'KHTML'</span>) == <span class="number">-1</span>,<span class="comment">//火狐内核</span></span><br><span class="line">            mobile: !!u.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>), <span class="comment">//是否为移动终端</span></span><br><span class="line">            ios: !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">//ios终端</span></span><br><span class="line">            android: u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Linux'</span>) &gt; <span class="number">-1</span>, <span class="comment">//android终端或者uc浏览器</span></span><br><span class="line">            iPhone: u.indexOf(<span class="string">'iPhone'</span>) &gt; <span class="number">-1</span> , <span class="comment">//是否为iPhone或者QQHD浏览器</span></span><br><span class="line">            iPad: u.indexOf(<span class="string">'iPad'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否iPad</span></span><br><span class="line">            webApp: u.indexOf(<span class="string">'Safari'</span>) == <span class="number">-1</span>, <span class="comment">//是否web应该程序，没有头部与底部</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;(),</span><br><span class="line">    language:(navigator.browserLanguage || navigator.language).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line">alert(<span class="built_in">JSON</span>.stringify(browser));</span><br><span class="line"><span class="keyword">if</span> (browser.versions.mobile) &#123;<span class="comment">//判断是否是移动设备打开。browser代码在下面</span></span><br><span class="line">    <span class="keyword">var</span> ua = navigator.userAgent.toLowerCase();<span class="comment">//获取判断用的对象</span></span><br><span class="line">    <span class="keyword">if</span> (ua.match(<span class="regexp">/MicroMessenger/i</span>) === <span class="string">"micromessenger"</span>) &#123;</span><br><span class="line">        <span class="comment">//在微信中打开</span></span><br><span class="line">        alert(<span class="string">"微信"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ua.match(<span class="regexp">/QQ/i</span>) === <span class="string">"qq"</span>)&#123;</span><br><span class="line">        alert(<span class="string">"qq"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ua.match(<span class="regexp">/WeiBo/i</span>) === <span class="string">"weibo"</span>) &#123;</span><br><span class="line">        <span class="comment">//在新浪微博客户端打开</span></span><br><span class="line">        alert(<span class="string">"新浪微博客户端"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (browser.versions.ios) &#123;</span><br><span class="line">        <span class="comment">//是否在IOS浏览器打开</span></span><br><span class="line">        alert(<span class="string">"ios"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(browser.versions.android)&#123;</span><br><span class="line">        <span class="comment">//是否在安卓浏览器打开</span></span><br><span class="line">        alert(<span class="string">"安卓浏览器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//否则就是PC浏览器打开</span></span><br><span class="line">    alert(<span class="string">"pc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。</p><p><strong>HTML DOM</strong> 模型被构造为<strong>对象</strong>的树：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/202208191115526.png" alt="image-20220819111052132"></p><p>通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML。</p><ul><li>JavaScript 能够改变页面中的所有 HTML 元素</li><li>JavaScript 能够改变页面中的所有 HTML 属性</li><li>JavaScript 能够改变页面中的所有 CSS 样式</li><li>JavaScript 能够对页面中的所有事件做出反应</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM（文档对象模型）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 是针对HTML和XML文档的一个API（应用程序编程接口）。dom描绘了一个层次化的节点树，允许开发人员</span></span><br><span class="line"><span class="comment">* 添加、移除和修改页面的某一部分。dom脱胎于DHTML（动态HTML）。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// node类型</span></span><br><span class="line"><span class="comment">// nodeType</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Node.ELEMENT_NODE (1)</span></span><br><span class="line"><span class="comment">Node.ATTRIBUTE_NODE (2)</span></span><br><span class="line"><span class="comment">Node.TEXT_NODE (3)</span></span><br><span class="line"><span class="comment">Node.CDATA_SECTION_NODE (4)</span></span><br><span class="line"><span class="comment">Node.ENTITY_REFERENCE_NODE (5)</span></span><br><span class="line"><span class="comment">Node.ENTITY_NODE (6)</span></span><br><span class="line"><span class="comment">Node.PROCESSING_INSTRUCTION_NODE (7)</span></span><br><span class="line"><span class="comment">Node.COMMENT_NODE (8)</span></span><br><span class="line"><span class="comment">Node.DOCUMENT_NODE (9)</span></span><br><span class="line"><span class="comment">Node.DOCUMENT_TYPE_NODE (10)</span></span><br><span class="line"><span class="comment">Node.DOCUMENT_FRAGMENT_NODE (11)</span></span><br><span class="line"><span class="comment">Node.NOTATION_NODE (12)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// nodeName(标签名) nodeValue（null）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// node 节点之间的关系</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* parentNode 父节点</span></span><br><span class="line"><span class="comment">* childNodes 子节点</span></span><br><span class="line"><span class="comment">* firstChild 第一个子节点</span></span><br><span class="line"><span class="comment">* lastChild  最后一个子节点</span></span><br><span class="line"><span class="comment">* nextSibling 下一个子节点</span></span><br><span class="line"><span class="comment">* previousSibling 上一个子节点</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* hasChildNodes()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作节点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* appendChild() 向childNodes列表的末尾添加一个节点</span></span><br><span class="line"><span class="comment">* insertBefore() 要插入的节点和作为参照的节点如果参照节点为null则和appendChild()一样</span></span><br><span class="line"><span class="comment">* replaceChild() 替换节点</span></span><br><span class="line"><span class="comment">* removeChild() 移除节点</span></span><br><span class="line"><span class="comment">* cloneNode() 复制节点</span></span><br><span class="line"><span class="comment">* normalize() 处理文档树中的文本节点</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Document</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* nodeType 9</span></span><br><span class="line"><span class="comment">* nodeName #document</span></span><br><span class="line"><span class="comment">* nodeValue null</span></span><br><span class="line"><span class="comment">* parentNode null</span></span><br><span class="line"><span class="comment">* ownerDocument null</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 文档信息</span></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* document.getElementById() 通过ID</span></span><br><span class="line"><span class="comment">* document.getElementsByTagName() 通过标签名</span></span><br><span class="line"><span class="comment">* document.getElementByName() 通过name属性值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM一致性检测</span></span><br><span class="line"><span class="comment">// 文档写入</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* write()</span></span><br><span class="line"><span class="comment">* writeln()</span></span><br><span class="line"><span class="comment">* open()</span></span><br><span class="line"><span class="comment">* close()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Element</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* nodeType:1</span></span><br><span class="line"><span class="comment">* nodeName的值为元素的标签名</span></span><br><span class="line"><span class="comment">* nodeValue null</span></span><br><span class="line"><span class="comment">* parentNode Document 或 Element</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">//  html 元素</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* id,元素文档中的唯一标识符</span></span><br><span class="line"><span class="comment">* title,有关元素的附加说明信息</span></span><br><span class="line"><span class="comment">* lang,元素内容的语言代码，很少使用</span></span><br><span class="line"><span class="comment">* dir,语言的方向，很少使用</span></span><br><span class="line"><span class="comment">* className,与元素的class特性对应，即为元素指定Css类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 取得特性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*getAttribute()</span></span><br><span class="line"><span class="comment">*setAttribute()</span></span><br><span class="line"><span class="comment">*removeAttribute()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建元素</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* document.createElement()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素的子节点（childNodes）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// text类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* nodeType 3</span></span><br><span class="line"><span class="comment">* nodeName #text</span></span><br><span class="line"><span class="comment">* nodeValue 节点所包含的文本</span></span><br><span class="line"><span class="comment">* parentNode Element</span></span><br><span class="line"><span class="comment">* appendData(text) 将text添加到节点末尾</span></span><br><span class="line"><span class="comment">* deleteData（offset，count）从offset指定位置删除count个字符</span></span><br><span class="line"><span class="comment">* insertData（offset,text）在offset指定的位置插入text</span></span><br><span class="line"><span class="comment">* replaceData（offset，count，text）用text替换从offset指定位置到offset+count为止处的文本</span></span><br><span class="line"><span class="comment">* splitText(offset) 从offset指定位置将当前文本节点分成两个文本节点</span></span><br><span class="line"><span class="comment">* substringData(offset,count) 提取从offset指定位置开始到offset+count为止处的字符串</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 创建文本节点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* document.createTextNode()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范化文本节点（normalize()）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将所有文本节点合并成一个节点，结果节点的nodeValue等于合并前每个文本节点的nodeValue值拼</span></span><br><span class="line"><span class="comment">* 起来的值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割文本节点 （splitText()） 与 normalize()相反</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Comment 类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* nodeType 8</span></span><br><span class="line"><span class="comment">* nodeName #comment</span></span><br><span class="line"><span class="comment">* nodeValue 注释的内容</span></span><br><span class="line"><span class="comment">* parentNode Document或Element</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 创建 document.createComment()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CDATASection 类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* nodeType 4</span></span><br><span class="line"><span class="comment">* nodeName #cdata-section</span></span><br><span class="line"><span class="comment">* nodeValue CDATA 区域的内容</span></span><br><span class="line"><span class="comment">* parentNode 可能是Document 或 Element</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DocumentType类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* nodeType 10</span></span><br><span class="line"><span class="comment">* nodeName doctype的名称</span></span><br><span class="line"><span class="comment">* nodeValue null</span></span><br><span class="line"><span class="comment">* parentNode Document</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DocumentFragment 类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* nodeType 11</span></span><br><span class="line"><span class="comment">* nodeName #document-fragment</span></span><br><span class="line"><span class="comment">* nodeValue null</span></span><br><span class="line"><span class="comment">* parentNode null</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 document.createDocumentFragment()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Attr类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* nodeType 2</span></span><br><span class="line"><span class="comment">* nodeName 特性的名称</span></span><br><span class="line"><span class="comment">* nodeValue 特性的值</span></span><br><span class="line"><span class="comment">* parentNode null</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 创建 document.createAttribute()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 不建议直接访问特性节点。实际上，使用getAttribute(),setAttribute()和removeAttribute()</span></span><br><span class="line"><span class="comment">* 方法远比操作特性节点方便</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM操作技术</span></span><br><span class="line"><span class="comment">// 动态添加脚本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    script.src = url;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 动态添加代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        script.appendChild(<span class="built_in">document</span>.createTextNode(code));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">        script.text = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 动态添加样式表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyles</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">    link.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line">    link.type = <span class="string">"text/css"</span>;</span><br><span class="line">    link.href = url;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br><span class="line">    head.appendChild(link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 动态添加css</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyleString</span>(<span class="params">css</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</span><br><span class="line">    style.type = <span class="string">"text/css"</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">        style.styleSheet.cssText = css;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br><span class="line">    head.appendChild(style);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果专门针对IE编写代码，务必小心使用styleSheet.cssText属性。在重用同一个&lt;style&gt;元素</span></span><br><span class="line"><span class="comment">* 并再次设置这个属性时，有可能会导致浏览器奔溃。同样，将cssText属性设置为空字符串也可</span></span><br><span class="line"><span class="comment">* 能导致浏览器奔溃</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作表格</span></span><br><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">html 创建</span></span><br><span class="line"><span class="comment">&lt;table border="1" width="100%"&gt;</span></span><br><span class="line"><span class="comment">    &lt;tbody&gt;</span></span><br><span class="line"><span class="comment">        &lt;tr&gt;</span></span><br><span class="line"><span class="comment">            &lt;td&gt;Cell 1,1&lt;/td&gt;</span></span><br><span class="line"><span class="comment">            &lt;td&gt;Cell 2,1&lt;/td&gt;</span></span><br><span class="line"><span class="comment">        &lt;/tr&gt;</span></span><br><span class="line"><span class="comment">        &lt;tr&gt;</span></span><br><span class="line"><span class="comment">            &lt;td&gt;Cell 1,2&lt;/td&gt;</span></span><br><span class="line"><span class="comment">            &lt;td&gt;Cell 2,2&lt;/td&gt;</span></span><br><span class="line"><span class="comment">        &lt;/tr&gt;</span></span><br><span class="line"><span class="comment">    &lt;/tbody&gt;</span></span><br><span class="line"><span class="comment">&lt;/table&gt;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 核心dom创建</span></span><br><span class="line"><span class="comment">//创建 table</span></span><br><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">"table"</span>);</span><br><span class="line">table.border = <span class="string">'1'</span>;</span><br><span class="line">table.width = <span class="string">"100%"</span>;</span><br><span class="line"><span class="comment">//创建 tbody</span></span><br><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">"tbody"</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 第一行</span></span><br><span class="line"><span class="keyword">var</span> row1 = <span class="built_in">document</span>.createElement(<span class="string">"tr"</span>);</span><br><span class="line">tbody.appendChild(row1);</span><br><span class="line"><span class="keyword">var</span> cell1_1 = <span class="built_in">document</span>.createElement(<span class="string">"td"</span>);</span><br><span class="line">cell1_1.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 1,1"</span>));</span><br><span class="line">row1.appendChild(cell1_1);</span><br><span class="line"><span class="keyword">var</span> cell2_1 = <span class="built_in">document</span>.createElement(<span class="string">"td"</span>);</span><br><span class="line">cell2_1.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 2,1"</span>));</span><br><span class="line">row1.appendChild(cell2_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 第二行</span></span><br><span class="line"><span class="keyword">var</span> row2 = <span class="built_in">document</span>.createElement(<span class="string">"tr"</span>);</span><br><span class="line">tbody.appendChild(row2);</span><br><span class="line"><span class="keyword">var</span> cell1_2 = <span class="built_in">document</span>.createElement(<span class="string">"td"</span>);</span><br><span class="line">cell1_2.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 1,2"</span>));</span><br><span class="line">row2.appendChild(cell1_2);</span><br><span class="line"><span class="keyword">var</span> cell2_2= <span class="built_in">document</span>.createElement(<span class="string">"td"</span>);</span><br><span class="line">cell2_2.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 2,2"</span>));</span><br><span class="line">row2.appendChild(cell2_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将表格添加到文档主体中</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(table);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTMLDOM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 为table元素添加的属性和方法</span></span><br><span class="line"><span class="comment">* caption &lt;caption&gt;元素的指针</span></span><br><span class="line"><span class="comment">* tBodies 是一个&lt;tbody&gt;元素的HTMLCollection</span></span><br><span class="line"><span class="comment">* tFoot tfoot元素指针</span></span><br><span class="line"><span class="comment">* tHead thead元素指针</span></span><br><span class="line"><span class="comment">* rows 表格中所有行的HTMLCollection</span></span><br><span class="line"><span class="comment">* createThead() 创建thead</span></span><br><span class="line"><span class="comment">* createTFoot() 创建tfoot</span></span><br><span class="line"><span class="comment">* createCaption() 创建caption</span></span><br><span class="line"><span class="comment">* deleteThead() 删除thead</span></span><br><span class="line"><span class="comment">* deleteTFoot() 删除tfood</span></span><br><span class="line"><span class="comment">* deleteRow(pos) 删除指定位置行</span></span><br><span class="line"><span class="comment">* insertRow(pos) 向rows集合中的指定位置插入一行</span></span><br><span class="line"><span class="comment">* 为tbody元素添加的属性和方法</span></span><br><span class="line"><span class="comment">* rows 保存着tbody元素中行的HTMLCollection</span></span><br><span class="line"><span class="comment">* deleteRow(pos) 删除指定行</span></span><br><span class="line"><span class="comment">* insertRow(pos) 向rows集合中的指定位置插入一行，返回对新插入的引用</span></span><br><span class="line"><span class="comment">* 为tr元素添加的属性和方法</span></span><br><span class="line"><span class="comment">* cells 保存这tr元素中单元格的HTMLCollection</span></span><br><span class="line"><span class="comment">* deleteCell(pos) ...</span></span><br><span class="line"><span class="comment">* insertCell(pos) ...</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// HTMLDOM</span></span><br><span class="line"><span class="comment">//创建 table</span></span><br><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">"table"</span>);</span><br><span class="line">table.border = <span class="number">1</span>;</span><br><span class="line">table.width = <span class="string">"100%"</span>;</span><br><span class="line"><span class="comment">//创建 tbody</span></span><br><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">"tbody"</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line"></span><br><span class="line">tbody.insertRow(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 1,1"</span>));</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 2,1"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line">tbody.insertRow(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 1,2"</span>));</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 2,2"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将表格添加到文档主体中</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(table);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用NodeList</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* NodeList、NameNodeMap、HTMLCollection这3个都是动态的；换句话来说，每当文档结构发生变化</span></span><br><span class="line"><span class="comment">* 时，他们都会得到跟新。因此，他们始终会保存这最新、最准确的信息</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 迭代NodeList</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>),</span><br><span class="line">    i,</span><br><span class="line">    len,</span><br><span class="line">    div;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>, len=divs.length; i &lt; len; i++)&#123;</span><br><span class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择符API</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> querySelector(selector) 接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹</span></span><br><span class="line"><span class="comment"> 配元素，返回null</span></span><br><span class="line"><span class="comment"> querySelectorAll(selector) 接收一个CSS选择符，返回一个NodeList的实例，没有匹配NodeList就</span></span><br><span class="line"><span class="comment"> 是空的</span></span><br><span class="line"><span class="comment"> matchesSelector(selector) 接收一个CSS选择符，如果调用元素与选择符匹配则返回true否则返回</span></span><br><span class="line"><span class="comment"> false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素遍历</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对于元素间的空格，IE9以及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这</span></span><br><span class="line"><span class="comment">* 样就导致了使用childNodes和firstChild等属性时的行为不一致。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* childElementCount 返回子元素（不包括文本节点和注释）的个数</span></span><br><span class="line"><span class="comment">* firstElementChild 指向第一个子元素：firstChild 元素版</span></span><br><span class="line"><span class="comment">* lastElementChild 指向最后一个子元素；lastChild 元素版</span></span><br><span class="line"><span class="comment">* previousElementSibling 前一个同辈元素 previousSibling 元素版</span></span><br><span class="line"><span class="comment">* nextElementSibling 后一个同辈元素 nextSibling 元素版</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与类相关的扩充</span></span><br><span class="line"><span class="comment">// 通过class名获取NodeList</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* getElementsByClassName() 接收一个参数，包含一个或多个类名的字符串，返回带有指定类的所有</span></span><br><span class="line"><span class="comment">* 元素的NodeList。传入多个类名时，类名的先后不重要</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// classList</span></span><br><span class="line"><span class="comment">// 在没有classList之前</span></span><br><span class="line"><span class="comment">//删除"user"</span></span><br><span class="line"><span class="comment">//首先 取得类名字符串并拆分成数组</span></span><br><span class="line"><span class="keyword">var</span> classNames = div.className.split(<span class="regexp">/\s+/</span>);</span><br><span class="line"><span class="comment">//找到要删的类名</span></span><br><span class="line"><span class="keyword">var</span> pos = <span class="number">-1</span>,</span><br><span class="line">    i,</span><br><span class="line">    len;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>, len=classNames.length; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (classNames[i] === <span class="string">"user"</span>)&#123;</span><br><span class="line">        pos = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除类名</span></span><br><span class="line">classNames.splice(i,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//把剩下的类名拼成字符串并重新设置</span></span><br><span class="line">div.className = classNames.join(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 使用classList</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* add(value) 将指定字符串添加到列表中。如果已存在就不添加了</span></span><br><span class="line"><span class="comment">* contains(value) 是否存在给定的值 返回 true或false</span></span><br><span class="line"><span class="comment">* remove(value) 从列表中删除给定的字符串</span></span><br><span class="line"><span class="comment">* toggle(value) 如果列表中已存在给定的值，删除它；不存在添加它</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">div.classList.remove(<span class="string">"disabled"</span>);</span><br><span class="line">div.classList.add(<span class="string">"current"</span>);</span><br><span class="line">div.classList.toggle(<span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 焦点管理</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* document.activeElement</span></span><br><span class="line"><span class="comment">* focus()</span></span><br><span class="line"><span class="comment">* document.hsaFocus()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTMLDocument的变化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* readyState 属性 loading 正在加载文档 complete 已加载完毕文档</span></span><br><span class="line"><span class="comment">* compatMode 兼容模式 CSS1Compat 标准模式 BackCompat 混杂模式</span></span><br><span class="line"><span class="comment">* head 属性</span></span><br><span class="line"><span class="comment">* charset 字符集属性</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据属性</span></span><br><span class="line"><span class="comment">// &lt;div id="myDiv" data-appId="12345" data-myname="Nicholas"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"><span class="comment">//获取自定义属性的值</span></span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appId;</span><br><span class="line"><span class="keyword">var</span> myName = div.dataset.myname;</span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">div.dataset.appId = <span class="number">23456</span>;</span><br><span class="line">div.dataset.myname = <span class="string">"Michael"</span>;</span><br><span class="line"><span class="comment">//是否存在mynamez值</span></span><br><span class="line"><span class="keyword">if</span> (div.dataset.myname)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + div.dataset.myname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入标记</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* innerHTML</span></span><br><span class="line"><span class="comment">* outerHtml</span></span><br><span class="line"><span class="comment">* insertAdjacentHTML 接收两各参数 插入位置和HTML文本 第一个参数必须是下面参数之一</span></span><br><span class="line"><span class="comment">*   beforebegin 在元素之前插入一个紧邻的同辈元素</span></span><br><span class="line"><span class="comment">*   afterbegin 在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素</span></span><br><span class="line"><span class="comment">*   beforeend  在当前元素之下插入一个新的子元素或在第一个子元素之后再插入新的子元素</span></span><br><span class="line"><span class="comment">*   afterend 在当前元素之后插入一个紧邻的同辈元素</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scrollIntoView() true</span></span><br><span class="line"><span class="comment">// document.forms[0].scrollIntoView();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档模式</span></span><br><span class="line"><span class="comment">// &lt;meta http-equiv="X-UA-Compatible" content="IE=IEVersion"&gt;</span></span><br><span class="line"><span class="comment">// IEVersion 可以是 任意IE版本浏览器如7,8,9</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 强制IE用某种模式渲染</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// children 属性</span></span><br><span class="line"><span class="comment">// contains() 方法 判断一个节点是否包含另一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入文本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* innerText</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* innerText和textContent返回的内容并不完全一样。innerText会忽略行内样式和脚本，</span></span><br><span class="line"><span class="comment">* 而textContent则会像返回其他文本一样返回行内的样式和脚本代码。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* outerText 属性 作用范围扩大到了调用它的节点，其他和innerText一样</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* scrollIntoViewIfNeeded(alignCenter)  （Safari，chrome）</span></span><br><span class="line"><span class="comment">* scrollByLines(lineCount) （Safari，chrome）</span></span><br><span class="line"><span class="comment">* scrollByPages(pageCount) （Safari，chrome）</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dom 变化</span></span><br><span class="line"><span class="comment">// 访问元素的样式</span></span><br><span class="line"><span class="comment">// style</span></span><br><span class="line"><span class="comment">// dom 2 添加的属性和方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* cssText 访问style特性中的css代码</span></span><br><span class="line"><span class="comment">* length css属性个数</span></span><br><span class="line"><span class="comment">* parentRule 表示CSS信息的CSSRule对象</span></span><br><span class="line"><span class="comment">* getPropertyCSSValue(propertyName) 返回包含给定属性的CSSValue对象</span></span><br><span class="line"><span class="comment">* getPropertyPriority(propertyName) 如果给定了！important返回important 否则返回空字符串</span></span><br><span class="line"><span class="comment">* getPropertyValue(propertyName) 给定属性的字符串值</span></span><br><span class="line"><span class="comment">* item(index) 返回给定位置的CSS属性名称</span></span><br><span class="line"><span class="comment">* removeProperty(propertyName) 从样式中删除给定属性</span></span><br><span class="line"><span class="comment">*  setProperty(propertyName,value,priority) 将给定属性设置为相应的值，并加上优先级标志</span></span><br><span class="line"><span class="comment">*  （important 或一个空字符串）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getComputedStyle() 获取style和从css中设置的样式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作样式表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏移量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* offsetHeight()(边框、内边距、内容)</span></span><br><span class="line"><span class="comment">* offsetWidth()</span></span><br><span class="line"><span class="comment">* offsetLeft()</span></span><br><span class="line"><span class="comment">* offsetTop()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 所有这些偏移量属性都是只读的，而且每次访问都要重新计算。因此尽量避免重复访问这些值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户区大小</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* clientWidth(内容+内边距)</span></span><br><span class="line"><span class="comment">* clientHeight</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewport</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode === <span class="string">"BackCompat"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            width: <span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">            height: <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">            height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与偏移量相似，客户区打小也是只读的，每次访问要重新计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动大小（包含滚动内容的元素大小）隐藏部分也包含在内</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* scrollHeight()</span></span><br><span class="line"><span class="comment">* scrollWidth()</span></span><br><span class="line"><span class="comment">* scrollLeft() 改变滚动位置</span></span><br><span class="line"><span class="comment">* scrollTop()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 文档总高度</span></span><br><span class="line"><span class="keyword">var</span> docHeight = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollHeight,</span><br><span class="line">    <span class="built_in">document</span>.documentElement.clientHeight);</span><br><span class="line"><span class="keyword">var</span> docWidth = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollWidth,</span><br><span class="line">    <span class="built_in">document</span>.documentElement.clientWidth);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素大小（跨浏览器）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBoundingClientRect</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">    <span class="keyword">var</span> scrollLeft = <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">    <span class="keyword">if</span> (element.getBoundingClientRect) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.offset != <span class="string">"number"</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">            temp.style.cssText = <span class="string">"position:absolute;left:0;top:0;"</span>;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(temp);</span><br><span class="line">            <span class="built_in">arguments</span>.callee.offset = -temp.getBoundingClientRect().top - scrollTop;</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(temp);</span><br><span class="line">            temp = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> rect = element.getBoundingClientRect();</span><br><span class="line">        <span class="keyword">var</span> offset = <span class="built_in">arguments</span>.callee.offset;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            left: rect.left + offset,</span><br><span class="line">            right: rect.right + offset,</span><br><span class="line">            top: rect.top + offset,</span><br><span class="line">            bottom: rect.bottom + offset</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> actualLeft = getElementLeft(element);</span><br><span class="line">        <span class="keyword">var</span> actualTop = getElementTop(element);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            left: actualLeft - scrollLeft,</span><br><span class="line">            right: actualLeft + element.offsetWidth - scrollLeft,</span><br><span class="line">            top: actualTop - scrollTop,</span><br><span class="line">            bottom: actualTop + element.offsetHeight - scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="comment">// document.createNodeIterator()</span></span><br><span class="line"><span class="comment">// NodeIterator</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* root 想作为搜索起点的树中的节点</span></span><br><span class="line"><span class="comment">* whatToShow:表示要访问哪些节点的数字代码</span></span><br><span class="line"><span class="comment">* filter:是一个NodeFilter对象，或者表示应该接受还是拒绝特定节点的函数</span></span><br><span class="line"><span class="comment">* entityReferenceExpansion：布尔值是否要扩展实体引用</span></span><br><span class="line"><span class="comment">* whatToShow：参数是一个位掩码 常量类容定义在NodeFilter中</span></span><br><span class="line"><span class="comment">*   NodeFilter.SHOW_ALL 所有节点</span></span><br><span class="line"><span class="comment">*   NodeFilter.SHOW_ELEMENT 元素节点</span></span><br><span class="line"><span class="comment">*   NodeFilter.SHOW_ATTRIBUTE 特性节点 dom不能使用</span></span><br><span class="line"><span class="comment">*   NodeFilter.SHOW_TEXT 文本节点</span></span><br><span class="line"><span class="comment">*   NodeFilter.SHOW_COMMENT 注释节点</span></span><br><span class="line"><span class="comment">*   NodeFilter.SHOW_DOCUMENT 文档节点</span></span><br><span class="line"><span class="comment">*   NodeFilter.SHOW_DOCUMENT_TYPE 文档类型节点</span></span><br><span class="line"><span class="comment">*   nextNode()</span></span><br><span class="line"><span class="comment">*   previousNode()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 插入测试dom</span></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div id="div1"&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;List item 1&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;List item 2&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;List item 3&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = html</span><br><span class="line"><span class="comment">/*var root = document</span></span><br><span class="line"><span class="comment">var filter = &#123;</span></span><br><span class="line"><span class="comment">    acceptNode: function(node)&#123;</span></span><br><span class="line"><span class="comment">        return node.tagName.toLowerCase() === "p" ?</span></span><br><span class="line"><span class="comment">            NodeFilter.FILTER_ACCEPT :</span></span><br><span class="line"><span class="comment">                NodeFilter.FILTER_SKIP;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">var iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT,</span></span><br><span class="line"><span class="comment">    filter, false);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">console.log(iterator.nextNode())</span></span><br><span class="line"><span class="comment">console.log(iterator.previousNode())*/</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>)</span><br><span class="line"><span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, <span class="literal">null</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> node = iterator.nextNode()</span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.tagName)</span><br><span class="line">    node = iterator.nextNode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeWalker</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* parentNode()</span></span><br><span class="line"><span class="comment">* firstChild()</span></span><br><span class="line"><span class="comment">* lastChild()</span></span><br><span class="line"><span class="comment">* nextSibling()</span></span><br><span class="line"><span class="comment">* previousSibling()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span><br><span class="line"><span class="keyword">var</span> walker = <span class="built_in">document</span>.createTreeWalker(div2, NodeFilter.SHOW_ELEMENT,</span><br><span class="line">    <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">walker.firstChild(); <span class="comment">// 到p</span></span><br><span class="line">walker.nextSibling(); <span class="comment">// 到ul</span></span><br><span class="line"><span class="keyword">var</span> node2 = walker.firstChild(); <span class="comment">// 第一个li</span></span><br><span class="line"><span class="keyword">while</span> (node2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node2.tagName); <span class="comment">//输出标签名</span></span><br><span class="line">    node2 = walker.nextSibling();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom中的范围</span></span><br><span class="line"><span class="comment">// 检测 是否支持dom2</span></span><br><span class="line"><span class="keyword">var</span> supportsRange = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"Range"</span>, <span class="string">"2.0"</span>);</span><br><span class="line"><span class="keyword">var</span> alsoSupportsRange = (<span class="keyword">typeof</span> <span class="built_in">document</span>.createRange === <span class="string">"function"</span>);</span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="comment">// var range = document.createRange();</span></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* startContainer 包含范围的起点</span></span><br><span class="line"><span class="comment">* startOffset 范围在startContainer中起点的偏移量</span></span><br><span class="line"><span class="comment">* endContainer 包含范围终点的节点</span></span><br><span class="line"><span class="comment">* endOffset 范围在endContainer中终点的偏移量</span></span><br><span class="line"><span class="comment">* commonAncestorContainer startContainer、endContainer共同祖先在文档树中位置最深的那个</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用都没范围实现简单选择</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* selectNode() 整个节点</span></span><br><span class="line"><span class="comment">* selectNodeContents() 节点的子节点</span></span><br><span class="line"><span class="comment">* 接收一个dom节点，用节点中的信息填充范围</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange(),</span><br><span class="line">range2 = <span class="built_in">document</span>.createRange();</span><br><span class="line">range1.selectNode(div2)</span><br><span class="line">range2.selectNodeContents(div2)</span><br><span class="line"><span class="built_in">console</span>.log(range1,range2)</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* setStartBefore(refNode)</span></span><br><span class="line"><span class="comment">* setStartAfter(refNode)</span></span><br><span class="line"><span class="comment">* setEndBefore(refNode)</span></span><br><span class="line"><span class="comment">* setEndAfter(refNode)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用dom范围实现复杂选择</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  setStart()</span></span><br><span class="line"><span class="comment">*  setEnd()</span></span><br><span class="line"><span class="comment">*  接收节点和偏移量值，setStart节点变成startContainer 偏移量变成startOffset  setEnd类似</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作DOM范围中的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* deleteContents() 删除</span></span><br><span class="line"><span class="comment">* extractContents() 删除并返回删除值</span></span><br><span class="line"><span class="comment">* cloneContents() 创建对象复本</span></span><br><span class="line"><span class="comment">* insertNode() 插入</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 折叠DOM范围</span></span><br><span class="line"><span class="comment">//  collapse()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较DOM范围</span></span><br><span class="line"><span class="comment">// compareBoundaryPoints()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  Range.START_TO_START(0)</span></span><br><span class="line"><span class="comment">*  Range.START_TO_END(1)</span></span><br><span class="line"><span class="comment">*  Range.END_TO_END(2)</span></span><br><span class="line"><span class="comment">*  Range.END_TO_START(3)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制DOM范围</span></span><br><span class="line"><span class="comment">//  cloneRange()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除DOM范围</span></span><br><span class="line"><span class="comment">// detach()</span></span><br></pre></td></tr></table></figure><h3 id="javascript-资料"><a href="#javascript-资料" class="headerlink" title="javascript 资料"></a>javascript 资料</h3><p>现代JavaScript教程 <a href="https://zh.javascript.info/" target="_blank" rel="noopener">https://zh.javascript.info/</a></p><h2 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h2><h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><p>windows</p><p>快捷键：</p><p>多行注释/取消：<code>shift + alt + a</code></p><p>单行注释/取消：<code>ctrl + /</code></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;细节补充&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Interview" scheme="http://yoursite.com/categories/Interview/"/>
    
    
    <category term="PICKS" scheme="http://yoursite.com/tags/PICKS/"/>
    
  </entry>
  
  <entry>
    <title>Dawn Dew-light Collected at Dusk 4 Basic Knowledge</title>
    <link href="http://yoursite.com/2021/06/22/Dawn-Dew-light-Collected-at-Dusk-4-Basic-Knowledge/"/>
    <id>http://yoursite.com/2021/06/22/Dawn-Dew-light-Collected-at-Dusk-4-Basic-Knowledge/</id>
    <published>2021-06-21T23:45:56.000Z</published>
    <updated>2025-07-30T07:21:56.493Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>硬件相关</p></blockquote><a id="more"></a> <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h2><h3 id="芯片工作的原理"><a href="#芯片工作的原理" class="headerlink" title="芯片工作的原理"></a>芯片工作的原理</h3><p>芯片工作的原理简单图示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622170319.png" alt="image-20210622170319444"></p><p>图灵机在计算科学有两个巨大的贡献：</p><p>1.清楚地定义了计算机能力的边界，也就是可计算理论。</p><p>2.定义了计算机由哪些部分组成，程序又是如何执行的。</p><h3 id="图灵机的构造"><a href="#图灵机的构造" class="headerlink" title="图灵机的构造"></a>图灵机的构造</h3><p>想要学懂程序执行的原理，就要从图灵机说起了。它在计算机科学方面有两个巨大的贡献：</p><p>第一，它清楚地定义了计算机能力的边界，也就是可计算理论；</p><p>第二，它定义了计算机由哪些部分组成，程序又是如何执行的。</p><p>我们先来看一看图灵机的内部构造：</p><p>图灵机拥有一条无限长的纸带，纸带上是一个格子挨着一个格子，格子中可以写字符，你可以把纸带看作内存，而这些字符可以看作是内存中的数据或者程序。</p><p>图灵机有一个读写头，读写头可以读取任意格子上的字符，也可以改写任意格子的字符。</p><p>读写头上面的盒子里是一些精密的零件，包括图灵机的存储、控制单元和运算单元。</p><h3 id="图灵机如何执行程序"><a href="#图灵机如何执行程序" class="headerlink" title="图灵机如何执行程序"></a>图灵机如何执行程序</h3><p>首先，我们将“11、15、+” 分别写入纸带上的 3 个格子（现在纸带上的字符串是11、15、 +)，然后将读写头先停在 11 对应的格子上。</p><p>接下来，图灵机通过读写头读入 11 到它的存储设备中（这个存储设备也叫作图灵机的状态）。图灵机没有说读写头为什么可以识别纸带上的字符，而是假定读写头可以做到这点。</p><p>然后读写头向右移动一个格，用同样的方法将 15 读入图灵机的状态中。现在图灵机的状态中有两个连续的数字，11 和 15。</p><p>接下来重复上面的过程，会读到一个+号。下面我详细说一下这个运算流程：</p><p>读写头读到一个 + 号 ；</p><p>然后将 + 号传输给控制单元 ；</p><p>控制单元发现是一个 + 号，所以没有存入状态中。因为 + 号是一个我们预设的控制符（指令），它的作用是加和目前状态。因此，控制单元识别出是控制符，并通知运算单元工作；</p><p>运算单元从状态中读入 11、15 并进行计算，将结果 26 存储到状态；</p><p>运算单元将结果回传给控制单元；</p><p>控制单元将结果传输给读写头。</p><p>读写头向右移动，将结果 26 写入纸带。</p><p>这样，我们就通过图灵机计算出了 11+15 的值。不知道你有没有发现，图灵机构造的这一台机器，主要功能就是读写纸带然后计算；纸带中有数据、也有控制字符（也就是指令），这个设计和我们今天的计算机是一样的。</p><p>图灵通过数学证明了，一个问题如果可以拆解成图灵机的可执行步骤，那问题就是可计算的。另一方面，图灵机定义了计算机的组成以及工作原理，但是没有给出具体的实现。</p><h3 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h3><p>具体的实现是 1945 年冯诺依曼和其他几位科学家在著名的 101 页报告中提出的。报告遵循了图灵机的设计，并提出用电子元件构造计算机，约定了用二进制进行计算和存储，并且将计算机结构分成以下 5 个部分：</p><p>​    输入设备；</p><p>​    输出设备；</p><p>​    内存；</p><p>​    中央处理器；</p><p>​    总线。</p><p>这个模型也被称为冯诺依曼模型，下面我们具体来看看这 5 部分的作用。</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。存储的数据单位是一个二进制位，英文是 bit。最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。</p><p>我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。</p><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>冯诺依曼模型中 CPU 负责控制和计算。为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。</p><p>如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；</p><p>如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。</p><p>这里的 32 和 64，称作 CPU 的位宽。</p><p>为什么 CPU 要这样设计呢？ 因为一个 byte 最大的表示范围就是 0~255。比如要计算 20000*50，就超出了byte 最大的表示范围了。因此，CPU 需要支持多个 byte 一起计算。当然，CPU 位数越大，可以计算的数值就越大。但是在现实生活中不一定需要计算这么大的数值。比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。</p><h4 id="控制单元和逻辑运算单元"><a href="#控制单元和逻辑运算单元" class="headerlink" title="控制单元和逻辑运算单元"></a>控制单元和逻辑运算单元</h4><p>CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。具体的工作原理我们在指令部分给大家分析。</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>CPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。这种存储就是寄存器。寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。</p><p>寄存器中有一部分是可供用户编程用的，比如用来存加和指令的两个参数，是通用寄存器。</p><p>还有一部分寄存器有特殊的用途，叫作特殊寄存器。比如程序指针，就是一个特殊寄存器。它存储了 CPU 要执行的下一条指令所在的内存地址。注意，程序指针不是存储了下一条要执行的指令，此时指令还在内存中，程序指针只是存储了下一条指令的地址。</p><p>下一条要执行的指令，会从内存读入到另一个特殊的寄存器中，这个寄存器叫作指令寄存器。指令被执行完成之前，指令都存储在这里。</p><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。总线分成 3 种：</p><p>一种是地址总线，专门用来指定 CPU 将要操作的内存地址。</p><p>还有一种是数据总线，用来读写内存中的数据。</p><p>当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。</p><p>最后一种总线叫作控制总线，用来发送和接收关键信号，比如后面我们会学到的中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，这也需要控制总线。</p><h4 id="输入、输出设备"><a href="#输入、输出设备" class="headerlink" title="输入、输出设备"></a>输入、输出设备</h4><p>输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。</p><h3 id="冯诺依曼模型的几个问题："><a href="#冯诺依曼模型的几个问题：" class="headerlink" title="冯诺依曼模型的几个问题："></a>冯诺依曼模型的几个问题：</h3><h5 id="1-线路位宽问题"><a href="#1-线路位宽问题" class="headerlink" title="1.线路位宽问题"></a>1.线路位宽问题</h5><p>第一个问题是，你可能会好奇数据如何通过线路传递。其实是通过操作电压，低电压是 0，高电压是 1。</p><p>如果只有一条线路，每次只能传递 1 个信号，因为你必须在 0,1 中选一个。比如你构造高高低低这样的信号，其实就是 1100，相当于你传了一个数字 10 过去。大家注意，这种传递是相当慢的，因为你需要传递 4 次。</p><p>这种一个 bit 一个 bit 发送的方式，我们叫作串行。如果希望每次多传一些数据，就需要增加线路，也就是需要并行。</p><p>如果只有 1 条地址总线，那每次只能表示 0-1 两种情况，所以只能操作 2 个内存地址；如果有 10 条地址总线，一次就可以表示 210 种情况，也就是可以操作 1024 个内存地址；如果你希望操作 4G 的内存，那么就需要 32 条线，因为 232 是 4G。</p><p>到这里，你可能会问，那我串行发送行不行？当然也不是不行，只是速度会很慢，因为每多增加一条线路速度就会翻倍。</p><h5 id="2-64-位和-32-位的计算"><a href="#2-64-位和-32-位的计算" class="headerlink" title="2. 64 位和 32 位的计算"></a>2. 64 位和 32 位的计算</h5><p>第二个问题是，CPU 的位宽会对计算造成什么影响？</p><p>我们来看一个具体场景：要用 32 位宽的 CPU，加和两个 64 位的数字。</p><p>32 位宽的 CPU 控制 40 位宽的地址总线、数据总线工作会非常麻烦，需要双方制定协议。 因此通常 32 位宽 CPU 最多操作 32 位宽的地址总线和数据总线。</p><p>因此必须把两个 64 位数字拆成 2 个 32 位数字来计算，这样就需要一个算法，比如用像小时候做加法竖式一样，先加和两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位。</p><p>而 64 位的 CPU 就可以一次读入 64 位的数字，同时 64 位的 CPU 内部的逻辑计算单元，也支持 64 位的数字进行计算。但是你千万不要仅仅因为位宽的区别，就认为 64 位 CPU 性能比 32 位高很多。</p><p>要知道大部分应用不需要计算超过 32 位的数字，比如你做一个电商网站，用户的金额通常是 10 万以下的，而 32 位有符号整数，最大可以到 20 亿。所以这样的计算在 32 位还是 64 位中没有什么区别。</p><p>还有一点要注意，32 位宽的 CPU 没办法控制超过 32 位的地址总线、数据总线工作。比如说你有一条 40 位的地址总线（其实就是 40 条线），32 位的 CPU 没有办法一次给 40 个信号，因为它最多只有 32 位的寄存器。因此 32 位宽的 CPU 最多操作 232 个内存地址，也就是 4G 内存地址。</p><h3 id="程序的执行过程"><a href="#程序的执行过程" class="headerlink" title="程序的执行过程"></a>程序的执行过程</h3><p>当 CPU 执行程序的时候：</p><p>1.首先，CPU 读取 PC 指针指向的指令，将它导入指令寄存器。具体来说，完成读取指令这件事情有 3 个步骤：</p><p>步骤 1：CPU 的控制单元操作地址总线指定需要访问的内存地址（简单理解，就是把 PC 指针中的值拷贝到地址总线中）。</p><p>步骤 2：CPU 通知内存设备准备数据（内存设备准备好了，就通过数据总线将数据传送给 CPU）。</p><p>步骤 3：CPU 收到内存传来的数据后，将这个数据存入指令寄存器。</p><p>完成以上 3 步，CPU 成功读取了 PC 指针指向指令，存入了指令寄存器。</p><p>2.然后，CPU 分析指令寄存器中的指令，确定指令的类型和参数。<br>3.如果是计算类型的指令，那么就交给逻辑运算单元计算；如果是存储类型的指令，那么由控制单元执行。<br>4.PC 指针自增，并准备获取下一条指令。</p><blockquote><p>比如在 32 位的机器上，指令是 32 位 4 个字节，需要 4 个内存地址存储，因此 PC 指针会自增 4。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181145.png" alt="image-20210622181145576"></p></blockquote><p>了解了程序的执行过程后，我还有一些问题想和大家一起讨论：</p><p>内存虽然是一个随机存取器，但是我们通常不会把指令和数据存在一起，这是为了安全起见。具体的原因我会在模块四进程部分展开讲解，欢迎大家在本课时的留言区讨论起来，我会结合你们留言的内容做后续的课程设计。</p><p>程序指针也是一个寄存器，64 位的 CPU 会提供 64 位的寄存器，这样就可以使用更多内存地址。特别要说明的是，64 位的寄存器可以寻址的范围非常大，但是也会受到地址总线条数的限制。比如和 64 位 CPU 配套工作的地址总线只有 40 条，那么可以寻址的范围就只有 1T，也就是 240。</p><p>从 PC 指针读取指令、到执行、再到下一条指令，构成了一个循环，这个不断循环的过程叫作CPU 的指令周期，下面我们会详细讲解这个概念。</p><h3 id="详解-a-11-15-的执行过程"><a href="#详解-a-11-15-的执行过程" class="headerlink" title="详解 a = 11 + 15 的执行过程"></a>详解 a = 11 + 15 的执行过程</h3><p>上面我们了解了基本的程序执行过程，接下来我们来看看如果用冯诺依曼模型执行a=11+15是一个怎样的过程。</p><p>我们再 Review 下这个问题：程序员写的程序a=11+15是字符串，CPU 不能执行字符串，只能执行指令。所以这里需要用到一种特殊的程序——编译器。编译器的核心能力是翻译，它把一种程序翻译成另一种程序语言。</p><p>这里，我们需要编译器将程序员写的程序翻译成 CPU 认识的指令（指令我们认为是一种低级语言，我们平时书写的是高级语言）。你可以先跟我完整地学完操作系统，再去深入了解编译原理的内容。</p><p>下面我们来详细阐述 a=11+15 的执行过程：</p><p>1.编译器通过分析，发现 11 和 15 是数据，因此编译好的程序启动时，会在内存中开辟出一个专门的区域存这样的常数，这个专门用来存储常数的区域，就是数据段，如下图所示：</p><p>11 被存储到了地址 0x100；</p><p>15 被存储到了地址 0x104；</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181044.png" alt="image-20210622181044065"></p><p>2.编译器将a=11+15转换成了 4 条指令，程序启动后，这些指令被导入了一个专门用来存储指令的区域，也就是正文段。如上图所示，这 4 条指令被存储到了 0x200-0x20c 的区域中：</p><p>0x200 位置的 load 指令将地址 0x100 中的数据 11 导入寄存器 R0；</p><p>0x204 位置的 load 指令将地址 0x104 中的数据 15 导入寄存器 R1；</p><p>0x208 位置的 add 指令将寄存器 R0 和 R1 中的值相加，存入寄存器 R2；</p><p>0x20c 位置的 store 指令将寄存器 R2 中的值存回数据区域中的 0x1108 位置。</p><p>3.具体执行的时候，PC 指针先指向 0x200 位置，然后依次执行这 4 条指令。</p><p>这里还有几个问题要说明一下：</p><p>变量 a 实际上是内存中的一个地址，a 是给程序员的助记符。</p><p>为什么 0x200 中代表加载数据到寄存器的指令是 0x8c000100，我们会在下面详细讨论。</p><p>不知道细心的同学是否发现，在上面的例子中，我们每次操作 4 个地址，也就是 32 位，这是因为我们在用 32 位宽的 CPU 举例。在 32 位宽的 CPU 中，指令也是 32 位的。但是数据可以小于 32 位，比如可以加和两个 8 位的字节。</p><p>关于数据段和正文段的内容，会在模块四进程和线程部分继续讲解。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>接下来我会带你具体分析指令的执行过程。</p><p>在上面的例子中，load 指令将内存中的数据导入寄存器，我们写成了 16 进制：0x8c000100，拆分成二进制就是：</p><p>这里大家还是看下图，需要看一下才能明白。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181222.png" alt="image-20210622181222780"></p><p>最左边的 6 位，叫作操作码，英文是 OpCode，100011 代表 load 指令；</p><p>中间的 4 位 0000是寄存器的编号，这里代表寄存器 R0；</p><p>后面的 22 位代表要读取的地址，也就是 0x100。</p><p>所以我们是把操作码、寄存器的编号、要读取的地址合并到了一个 32 位的指令中。</p><p>我们再来看一条求加法运算的 add 指令，16 进制表示是 0x08048000，换算成二进制就是：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181253.png" alt="image-20210622181253269"></p><p>最左边的 6 位是指令编码，代表指令 add；</p><p>紧接着的 4 位 0000 代表寄存器 R0；</p><p>然后再接着的 4 位 0001 代表寄存器 R1；</p><p>再接着的 4 位 0010 代表寄存器 R2；</p><p>最后剩下的 14 位没有被使用。</p><p>构造指令的过程，叫作指令的编码，通常由编译器完成；解析指令的过程，叫作指令的解码，由 CPU 完成。由此可见 CPU 内部有一个循环：</p><p>首先 CPU 通过 PC 指针读取对应内存地址的指令，我们将这个步骤叫作 Fetch，就是获取的意思。</p><p>CPU 对指令进行解码，我们将这个部分叫作 Decode。</p><p>CPU 执行指令，我们将这个部分叫作 Execution。</p><p>CPU 将结果存回寄存器或者将寄存器存入内存，我们将这个步骤叫作 Store。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181321.png" alt="image-20210622181321836"></p><p>上面 4 个步骤，我们叫作 CPU 的指令周期。CPU 的工作就是一个周期接着一个周期，周而复始。</p><h3 id="指令的类型"><a href="#指令的类型" class="headerlink" title="指令的类型"></a>指令的类型</h3><p>通过上面的例子，你会发现不同类型（不同 OpCode）的指令、参数个数、每个参数的位宽，都不一样。而参数可以是以下这三种类型：</p><ol><li><p>寄存器；</p></li><li><p>内存地址；</p></li><li><p>数值（一般是整数和浮点）。</p></li></ol><p>当然，无论是寄存器、内存地址还是数值，它们都是数字。</p><p>指令从功能角度来划分，大概有以下 5 类：</p><ol><li><p>I/O 类型的指令，比如处理和内存间数据交换的指令 store/load 等；再比如将一个内存地址的数据转移到另一个内存地址的 mov 指令。</p></li><li><p>计算类型的指令，最多只能处理两个寄存器，比如加减乘除、位运算、比较大小等。</p></li><li><p>跳转类型的指令，用处就是修改 PC 指针。比如编程中大家经常会遇到需要条件判断+跳转的逻辑，比如 if-else，swtich-case、函数调用等。</p></li><li><p>信号类型的指令，比如发送中断的指令 trap。</p></li><li><p>闲置 CPU 的指令 nop，一般 CPU 都有这样一条指令，执行后 CPU 会空转一个周期。</p></li></ol><p>指令还有一个分法，就是寻址模式，比如同样是求和指令，可能会有 2 个版本：</p><ol><li><p>将两个寄存器的值相加的 add 指令。</p></li><li><p>将一个寄存器和一个整数相加的 addi 指令。</p></li></ol><p>另外，同样是加载内存中的数据到寄存器的 load 指令也有不同的寻址模式：</p><ol><li><p>比如直接加载一个内存地址中的数据到寄存器的指令la，叫作直接寻址。</p></li><li><p>直接将一个数值导入寄存器的指令li，叫作寄存器寻址。</p></li><li><p>将一个寄存器中的数值作为地址，然后再去加载这个地址中数据的指令lw，叫作间接寻址。</p></li></ol><p>因此寻址模式是从指令如何获取数据的角度，对指令的一种分类，目的是给编写指令的人更多选择。</p><p>了解了指令的类型后，我再强调几个细节问题：</p><ol><li><p>关于寻址模式和所有的指令，只要你不是嵌入式开发人员，就不需要记忆，理解即可。</p></li><li><p>不同 CPU 的指令和寄存器名称都不一样，因此这些名称也不需要你记忆。</p></li><li><p>有几个寄存器在所有 CPU 里名字都一样，比如 PC 指针、指令寄存器等。</p></li></ol><h3 id="指令的执行速度"><a href="#指令的执行速度" class="headerlink" title="指令的执行速度"></a>指令的执行速度</h3><p>之前我们提到过 CPU 是用石英晶体产生的脉冲转化为时钟信号驱动的，每一次时钟信号高低电平的转换就是一个周期，我们称为时钟周期。CPU 的主频，说的就是时钟信号的频率。比如一个 1GHz 的 CPU，说的是时钟信号的频率是 1G。</p><p>到这里你可能会有疑问：是不是每个时钟周期都可以执行一条指令？其实，不是的，多数指令不能在一个时钟周期完成，通常需要 2 个、4 个、6 个时钟周期。</p><h3 id="64-位和-32-位比较有哪些优势？"><a href="#64-位和-32-位比较有哪些优势？" class="headerlink" title="64 位和 32 位比较有哪些优势？"></a>64 位和 32 位比较有哪些优势？</h3><p>优势 1：64 位 CPU 可以执行更大数字的运算，这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显。</p><p>优势 2：64 位 CPU 可以寻址更大的内存空间</p><p>如果 32 位/64 位说的是程序，那么说的是指令是 64 位还是 32 位的。32 位指令在 64 位机器上执行，困难不大，可以兼容。 如果是 64 位指令，在 32 位机器上执行就困难了。因为 32 位指令在 64 位机器执行的时候，需要的是一套兼容机制；但是 64 位指令在 32 位机器上执行，32 位的寄存器都存不下指令的参数。</p><p>操作系统也是一种程序，如果是 64 位操作系统，也就是操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上。</p><h3 id="for-循环如何被执行"><a href="#for-循环如何被执行" class="headerlink" title="for 循环如何被执行"></a>for 循环如何被执行</h3><p>首先，我们来看 for 循环是如何实现的。</p><p>下面是一个求 1 加到 100 的 Java 程序，请你思考如何将它转换为指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">  s+=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过思考，如果按照顺序执行上面的程序，则需要很多指令，因为 for 循环可以执行 1 次，也可以执行 100W 次，还可以执行无数次。因此，指令的设计者提供了一种 <code>jump</code> 类型的指令，让你可以在程序间跳跃，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">  jump loop</span><br></pre></td></tr></table></figure><p>这就实现了一个无限循环，程序执行到 <code>jumploop</code> 的时候，就会跳回 <code>loop</code> 标签。</p><p>用这种方法，我们可以将 <code>for</code> 循环用底层的指令实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># var i = 1, s = 0</span><br><span class="line"></span><br><span class="line"># 对应 Java 代码，我们首先将 1 和 0 存储到两个地址</span><br><span class="line"># 这两个地址我们用 $i 和 $s 表示</span><br><span class="line">store #1 -&gt; $i // 将数字 1 存入i的地址</span><br><span class="line">store #0 -&gt; $s // 将数字 0 存入 s 的地址</span><br><span class="line"></span><br><span class="line"># 接下来循环要开始了，我们在这里预留一个 loop 标签</span><br><span class="line"># loop 是一个自定义标签，它代表指令的相对位置</span><br><span class="line"># 后续我们可以用 jump 指令跳转回这个位置实现循环</span><br><span class="line">loop: # 循环标签</span><br><span class="line"></span><br><span class="line"># for ... i &lt;= 100</span><br><span class="line"># 接下来我们开始实现循环控制</span><br><span class="line"># 我们先首先 i &lt;= 100的比较</span><br><span class="line"></span><br><span class="line"># 我们先将变量 i 的地址，也就是 $i 导入寄存器 R0</span><br><span class="line">load $i -&gt; R0</span><br><span class="line"></span><br><span class="line"># 然后我们用 cmp 比较指令 R0 和数字 100</span><br><span class="line">cmp R0 #100 // 比较 R0 和数字 100</span><br><span class="line"></span><br><span class="line"># 注意指令不会有返回值，它会进行计算，然后改变机器的状态（也就是寄存器）</span><br><span class="line"># 比较后，有几个特殊的寄存器会保存比较结果</span><br><span class="line"># 然后我们用 ja（jump above）, 如果比较结果 R0 比 100 大</span><br><span class="line"># 那么我们就跳转到 end 标签，实现循环的跳出</span><br><span class="line">ja end </span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"># 如果 R0&lt;=100，那么ja end 没有生效，这时我们处理 s+=i</span><br><span class="line"># 首先我们把变量 s 所在地址的数据导入寄存器 R1</span><br><span class="line">load $s -&gt; R1</span><br><span class="line"></span><br><span class="line"># 然后我们把寄存器R0和R1加和，把结果存储寄存器 R2</span><br><span class="line">add R0 R1 R2 </span><br><span class="line"></span><br><span class="line"># 这时，我们把寄存器 R2 的值存入变量 s 所在的地址</span><br><span class="line">store R2 -&gt; $s</span><br><span class="line"></span><br><span class="line"># 刚才我们完成了一次循环</span><br><span class="line"># 我们还需要维护变量 i 的自增</span><br><span class="line"># 现在 i 的值在 R0 中，我们首先将整数 1 叠加到 R0 上</span><br><span class="line">add R0 #1 R0</span><br><span class="line"></span><br><span class="line"># 再把 R0 的值存入i所在的内存地址</span><br><span class="line">store R0 -&gt; $i</span><br><span class="line"></span><br><span class="line"># 这时我们的循环体已经全部执行完成，我们需要调转回上面 loop 标签所在的位置</span><br><span class="line"># 继续循环</span><br><span class="line">jump loop</span><br><span class="line">nop</span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>Tips:</p><ol><li>jump 指令直接操作 PC 指针，但是很多 CPU 会抢先执行下一条指令，因此通常我们在 jump 后面要跟随一条 nop 指令，让 CPU 空转一个周期，避免 jump 下面的指令被执行。<strong>是不是到了微观世界，和你所认识的程序还不太一样</strong>？</li><li>上面我写指令的时候用到了 add/store 这些指令，它们叫作助记符，是帮助你记忆的。整体这段程序，我们就称作汇编程序。</li><li>因为不同的机器助记符也不一样，所以你不用太关注我用的是什么汇编语言，也不用去记忆这些指令。当你拿到指定芯片的时候，直接去查阅芯片的说明书就可以了。</li><li>虽然不同 CPU 的指令不一样，但也是有行业标准的。现在使用比较多的是 RISC（精简指令集）和 CISC（复杂指令集）。比如目前Inte 和 AMD 家族主要使用 CISC 指令集，ARM 和 MIPS 等主要使用RISC 指令集。</li></ol><h3 id="条件控制程序"><a href="#条件控制程序" class="headerlink" title="条件控制程序"></a>条件控制程序</h3><p>条件控制程序有两种典型代表，一种是 <code>if-else</code> ，另一种是 <code>switch-case</code> 。 总体来说， <code>if-else</code> 翻译成指令，是比较简单的，你需要用跳转指令和比较指令处理它的跳转逻辑。</p><p>当然，它们的使用场景不同，这块我不展开了。在这里我主要想跟你说说，它们的内部实现是不一样的。<code>if-else</code> 是一个自上向下的执行逻辑， <code>switch-case</code>是一种精确匹配算法。比如你有 1000 个 case，如果用 <code>if-else</code> 你需要一个个比较，最坏情况下需要比较 <code>999</code> 次；而如果用 <code>switch-case</code> ，就不需要一个个比较，通过算法就可以直接定位到对应的<code>case</code> 。</p><p>举个具体的例子，比如一个根据数字返回星期的程序。如果用<code>if-else</code>，那么你需要这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(week == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"周一"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"周二"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用 <code>switch-case</code> 的逻辑，你可能会这样计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跳转位置=当前PC + 4*(week * 2 - 1)</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>了解了循环和条件判断，我们再来看看函数是如何被执行的。函数的执行过程必须深入到底层，也会涉及一种叫作栈的数据结构。</p><p>下面是一段 C 程序，传入两个参数，然后返回两个参数的和：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我先不说具体的解决方案，希望你可以先自己思考。其实到这里，你已经学了不少知识了。下面我们一起分析一下，一种思考的方向是：</p><ol><li>通过观察，我们发现函数的参数 a,b 本质是内存中的数据，因此需要给它们分配内存地址。</li><li>函数返回值也是内存中的数据，也就是返回值也需要分配内存地址。</li><li>调用函数其实就是跳转到函数体对应的指令所在的位置，因此函数名可以用一个标签，调用时，就用 <code>jump</code> 指令跟这个标签。</li></ol><p>比如上面函数进行了<code>a+b</code>的运算，我们可以这样构造指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 首先我们定义一个叫作add的标签</span><br><span class="line">add:</span><br><span class="line"></span><br><span class="line"># 然后我们将a和b所在地址中的数据都导入寄存器</span><br><span class="line">load $a -&gt; R0</span><br><span class="line">load $b -&gt; R1</span><br><span class="line"></span><br><span class="line"># 然后我们将寄存器求和，并将结果回写到返回地址</span><br><span class="line">add R0 R1 R2</span><br><span class="line">store R2 -&gt; $r</span><br></pre></td></tr></table></figure><p>当我们需要调用这个函数的时候，我们就构造下面这样的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump add</span><br></pre></td></tr></table></figure><p>细心的同学可能已经发现，这里有 2 个问题还没有解决：</p><ol><li>参数如何传递给函数？</li><li>返回值如何传递给调用者？</li></ol><p>为了解决这 2 个问题，我们就需要用到前面提到的一个叫作栈的数据结构。栈的英文是 Stack，意思是码放整齐的一堆东西。首先在调用方，我们将参数传递给栈；然后在函数执行过程中，我们从栈中取出参数。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082138.png" alt="image-20210623082138584"></p><p>函数执行过程中，先将执行结果写入栈中，然后在返回前把之前压入的参数出栈，调用方再从栈中取出执行结果。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082207.png" alt="image-20210623082207315"></p><p>将参数传递给 Stack 的过程，叫作压栈。取出结果的过程，叫作出栈。栈就好像你书桌上的一摞书，压栈就是把参数放到书上面，出栈就是把顶部的书拿下来。</p><p>因为栈中的每个数据大小都一样，所以在函数执行的过程中，我们可以通过参数的个数和参数的序号去计算参数在栈中的位置。</p><p>接下来我们来看看函数执行的整体过程：假设要计算 11 和 15 的和，我们首先在内存中开辟一块单独的空间，也就是栈。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082232.png" alt="image-20210623082232407"></p><p>就如前面所讲，栈的使用方法是不断往上堆数据，所以需要一个栈指针（Stack Pointer， SP）指向栈顶（也就是下一个可以写入的位置）。每次将数据写入栈时，就把数据写到栈指针指向的位置，然后将 SP 的值增加。</p><p>为了提高效率，我们通常会用一个特殊的寄存器来存储栈指针，这个寄存器就叫作 Stack Pointer，在大多数芯片中都有这个特殊的寄存器。一开始，SP 指向 0x100 位置，而 0x100 位置还没有数据。</p><ul><li><strong>压栈参数11</strong></li></ul><p>接下来我们开始传参，我们先将 11 压栈，之所以称作压栈（ Push)，就好像我们把数据 11 堆在内存中一样。模拟压栈的过程是下面两条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store #11 -&gt; $SP // 将11存入SP指向的地址0x100</span><br><span class="line"></span><br><span class="line">add SP, 4, SP  // 栈指针增加4（32位机器）</span><br></pre></td></tr></table></figure><p>第一条 store 指令将 SP 寄存器指向的内存地址设置为常数 11。</p><p>第二条指令将栈指针自增 4。</p><p>这里用美元符号代表将 11 存入的是 SP 寄存器指向的内存地址，这是一次间接寻址。存入后，栈指针不是自增 1 而是自增了 4，因为我在这里给你讲解时，用的是一个 32 位宽的 CPU 。如果是 64 位宽的 CPU，那么栈指针就需要自增 8。</p><p>压栈完成后，内存变成下图中所示的样子。11 被写入内存，并且栈指针指向了 0x104 位置。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082618.png" alt="image-20210623082618231"></p><ul><li><strong>压栈参数15</strong></li></ul><p>然后我们用同样的方法将参数 15 压栈。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082709.png" alt="image-20210623082709576"></p><p>压栈后，11 和 15 都被放入了对应的内存位置，并且栈指针指向了 0x108。</p><ul><li><strong>将返回值压栈</strong></li></ul><p>接下来，我们将返回值压栈。到这里你可能会问，返回值还没有计算呢，怎么就压栈了？其实这相当于一个占位，后面我们会改写这个地址。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082802.png" alt="image-20210623082802255"></p><ul><li><strong>调用函数</strong></li></ul><p>当我们完成了上面的压栈后，就开始调用函数，一种简单的做法是用 jump 指令直接跳转到函数的标签，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump add</span><br></pre></td></tr></table></figure><p>这个时候，要加和在栈中的数据 11 和 15，我们可以利用 SP 指针寻找数据。11 距离当前 SP 指针差 3 个位置，15 距离 SP 指针差 2 个位置。这种寻址方式是一种复合的寻址方式，是间接 + 偏移量寻址。</p><p>我们可以用下面的代码完成将 11 和 15 导入寄存器的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load $(SP - 12) -&gt; R0</span><br><span class="line">load $(SP - 8) -&gt; R1</span><br></pre></td></tr></table></figure><p>然后进行加和，将结果存入 R2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load R0 R1 R2</span><br></pre></td></tr></table></figure><p>最后我们可以再次利用数学关系将结果写入返回值所在的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store R2 -&gt; $(SP-4)</span><br></pre></td></tr></table></figure><p>上面我们用到了一种间接寻址的方式来进行加和运算，也就是利用 SP 中的地址做加减法操作内存。</p><p>经过函数调用的结果如下图所示，运算结果 26 已经被写入了返回值的位置：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623084951.png" alt="image-20210623084951620"></p><ul><li><strong>发现-解决问题</strong></li></ul><p>一个好的解决方案，也会面临问题。现在我们就遇到了麻烦：</p><ol><li>函数计算完成，这时应该跳转回去。可是我们没有记录函数调用前 PC 指针的位置，因此这里需要改进，我们需要存储函数调用前的 PC 指针方便调用后恢复。</li><li>栈不可以被无限使用，11和 15 作为参数，计算出了结果 26，那么它们就可以清空了。如果用调整栈指针的方式去清空，我们就会先清空 26。此时就会出现顺序问题，因此我们需要调整压栈的顺序。</li></ol><p>具体顺序你可以看下图。首先，我们将函数参数和返回值换位，这样在清空数据的时候，就会先清空参数，再清空返回值。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085008.png" alt="image-20210623085008446"></p><p>然后我们在调用函数前，还需要将返回地址压栈。这样在函数计算完成前，就能跳转回对应的返回地址。翻译成指令，就是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 压栈返回值</span><br><span class="line">add SP, 4  -&gt; SP </span><br><span class="line"></span><br><span class="line"># 计算返回地址</span><br><span class="line"># 我们需要跳转到清理堆栈那行，也就是16行</span><br><span class="line">MOV PC+4*(参数个数*2+1) -&gt; SP</span><br><span class="line"></span><br><span class="line"># 压栈参数的程序</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"># 执行函数，计算返回值</span><br><span class="line">call function</span><br><span class="line"></span><br><span class="line"># 清理堆栈</span><br><span class="line">add SP, -(参数个数+1)*4， SP</span><br></pre></td></tr></table></figure><h3 id="递归函数如何被执行"><a href="#递归函数如何被执行" class="headerlink" title="递归函数如何被执行"></a>递归函数如何被执行</h3><p>我们刚刚使用了栈解决了函数的调用问题。但是这个方案究竟合不合理，还需要用更复杂的情况来验证。</p><p>如下所示，我们给出一个递归函数，请你判断是否可以用上面的方法执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum(int n)&#123;</span><br><span class="line">  if(n == 1) &#123;return 1;&#125;</span><br><span class="line">  return n + sum(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的时候，我们每次执行函数都形成一个如下所示的栈结构：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085105.png" alt="image-20210623085105798"></p><p>比如执行 sum(100)，我们就会形成一个复杂的栈，第一次调用 n = 100，第二次递归调用 n = 99：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085438.png" alt="image-20210623085438298"></p><p>它们堆在了一起，就形成了一个很大的栈，简化一下就是这样的一个模型，如下所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085453.png" alt="image-20210623085453807"></p><p>到这里，递归消耗了更多空间，但是也保证了中间计算的独立性。当递归执行到 100 次的时候，就会执行下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(n == 1) &#123;return 1;&#125;</span><br></pre></td></tr></table></figure><p>于是触发第 99 次递归执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return 2 + sum(1) // sum(1) = 1</span><br></pre></td></tr></table></figure><p>上面程序等价于<code>return 3</code>，接着再触发第 98 次递归的执行，然后是第 97 次，最终触发到第一次函数调用返回结果。</p><p>由此可见，栈这种结构同样适合递归的计算。事实上，计算机编程语言就是用这种结构来实现递归函数。</p><h3 id="类型（class）如何实现"><a href="#类型（class）如何实现" class="headerlink" title="类型（class）如何实现"></a>类型（class）如何实现</h3><p>按照我们之前已经学习到的知识：</p><ul><li>变量是一个内存地址，所以只需要分配内存就好了；</li><li>循环控制可以用跳转加判断实现；</li><li>条件控制也可以用跳转加判断实现，只不过如果是 <code>switch-case</code> 还需要一定的数学计算；</li><li>函数调用需要压栈参数、返回值和返回地址。</li></ul><p>最后，我们来说说类型是如何实现的，也就是很多语言都支持的 class 如何被翻译成指令。其实 class 实现非常简单，首先一个 class 会分成两个部分，一部分是数据（也称作属性），另一部分是函数（也称作方法）。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085618.png" alt="image-20210623085618557"></p><p>class 有一个特殊的方法叫作构造函数，它会为 class 分配内存。构造函数执行的时候，开始扫描类型定义中所有的属性和方法。</p><ul><li>如果遇到属性，就为属性分配内存地址；</li><li>如果遇到方法，方法本身需要存到正文段（也就是程序所在的内存区域），再将方法的值设置为方法指令所在的内存地址。</li></ul><p>当我们调用一个 class 方法的时候，本质上是执行了一个函数，因此和函数调用是一致的：</p><ol><li>首先把返回值和返回地址压栈；</li><li>然后压栈参数；</li><li>最后执行跳转。</li></ol><p>这里有一个小问题，有时候 class 的方法会用到<code>this</code> ，这其实并不复杂，你仔细想想， <code>this</code>指针不就是构造函数创建的一个指向 class 实例的地址吗？那么，有一种简单的实现，就是我们可以把 <code>this</code> 作为函数的第一个参数压栈。这样，类型的函数就可以访问类型的成员了，而类型也就可以翻译成指令了。</p><p>下面我们做一个简单的总结：</p><ol><li>我们写的程序需要翻译成指令才能被执行，在前面中我们提到过，这个翻译工具叫作编译器。</li><li>平时你编程做的事情，用机器指令也能做，所以从计算能力上来说它们是等价的，最终这种计算能力又和图灵机是等价的。如果一个语言的能力和图灵机等价，我们就说这个语言是图灵完备的语言。现在市面上的绝大多数语言都是图灵完备的语言，但也有一些不是，比如 HTML、正则表达式和 SQL 等。</li><li>我们通过汇编语言构造高级程序；通过高级程序构造自己的业务逻辑，这些都是工程能力的一种体现。</li></ol><p><strong>一个程序语言如果不支持递归函数的话，该如何实现递归算法？</strong></p><ul><li>我们需要用到一个栈（其实用数组就可以）；</li><li>我们还需要一个栈指针，支持寄存器的编程语言能够直接用寄存器，而不支持直接用寄存器的编程语言，比如 Java，我们可以用一个变量；</li><li>然后我们可以实现压栈、出栈的操作，并按照上面学习的函数调用方法操作我们的栈。</li></ul><h3 id="为什么会有存储器分级策略？"><a href="#为什么会有存储器分级策略？" class="headerlink" title="为什么会有存储器分级策略？"></a>为什么会有存储器分级策略？</h3><p>要想弄清楚存储器分级策略。</p><p>首先，你要弄清楚，“我们希望存储器是什么样子的”，也就是“我们的需求是什么”？</p><p>然后，你要弄清楚，我们的需求有哪些“实现约束”。</p><p>从需求上讲，我们希望存储器速度快、体积小、空间大、能耗低、散热好、断电数据不丢失。但在现实中，我们往往无法把所有需求都实现。</p><p>下面我们举几个例子，带你深入体会一下，比如：</p><ul><li>如果一个存储器的体积小，那它存储空间就会受到制约。</li><li>如果一个存储器电子元件密度很大，那散热就会有问题。因为电子元件都会产生热能，所以电子元件非常集中的 CPU，就需要单独的风扇或者水冷帮助电子元件降温。</li><li>如果一个存储器离 CPU 较远，那么在传输过程中必然会有延迟，因此传输速度也会下降。</li></ul><p>这里你可能会有疑问，因为在大多数人的认知里，光速是很快的，而信号又是以光速传输的。既然光速这么快，那信号的延迟应该很小才对。但事实并不是这样，比如时钟信号是 1GHz 的 CPU，1G 代表 10 个亿，因此时钟信号的一个周期是 1/10 亿秒。而光的速度是 3×10 的 8 次方米每秒，就是 3 亿米每秒。所以在一个周期内，光只能前进 30 厘米。</p><p>你看！虽然在宏观世界里光速非常快，但是到计算机世界里，光速并没有像我们认知中的那么快。所以即使元件离 CPU 的距离稍微远了一点，运行速度也会下降得非常明显。</p><p>你可能还会问，那干吗不把内存放到 CPU 里？</p><p>如果你这么做的话，除了整个电路散热和体积会出现问题，服务器也没有办法做定制内存了。也就是说 CPU 在出厂时就决定了它的内存大小，如果你想换更大的内存，就要换 CPU，而组装定制化是你非常重要的诉求，这肯定是不能接受的。</p><p>此外，在相同价格下，一个存储器的速度越快，那么它的能耗通常越高。能耗越高，发热量越大。</p><p>因此，我们上面提到的需求是不可能被全部满足的，除非将来哪天存储技术有颠覆性的突破。</p><h3 id="存储器分级策略"><a href="#存储器分级策略" class="headerlink" title="存储器分级策略"></a>存储器分级策略</h3><p>既然我们不能用一块存储器来解决所有的需求，那就必须把需求分级。</p><p>一种可行的方案，就是根据数据的使用频率使用不同的存储器：高频使用的数据，读写越快越好，因此用最贵的材料，放到离 CPU 最近的位置；使用频率越低的数据，我们放到离 CPU 越远的位置，用越便宜的材料。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623092917.png" alt="image-20210623092917007"></p><p>具体来说，通常我们把存储器分成这么几个级别：</p><ol><li>寄存器；</li><li>L1-Cache；</li><li>L2-Cache；</li><li>L3-Cahce；</li><li>内存；</li><li>硬盘/SSD。</li></ol><h4 id="寄存器（Register）"><a href="#寄存器（Register）" class="headerlink" title="寄存器（Register）"></a>寄存器（Register）</h4><p>寄存器紧挨着 CPU 的控制单元和逻辑计算单元，它所使用的材料速度也是最快的。就像我们前面讲到的，存储器的速度越快、能耗越高、产热越大，而且花费也是最贵的，因此数量不能很多。</p><p>寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定字节（byte）的数据。比如：</p><ul><li>32 位 CPU 中大多数寄存器可以存储 4 个字节；</li><li>64 位 CPU 中大多数寄存器可以存储 8 个字节。</li></ul><p>寄存机的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写。比如一条要在 4 个周期内完成的指令，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，那 4 个周期就可能无法完成这条指令了。</p><h4 id="L1-Cache"><a href="#L1-Cache" class="headerlink" title="L1-Cache"></a>L1-Cache</h4><p>L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低。通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2~4 个 CPU 时钟周期。</p><h4 id="L2-Cache"><a href="#L2-Cache" class="headerlink" title="L2-Cache"></a>L2-Cache</h4><p>L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远。它的大小比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10~20 个 CPU 周期。</p><h4 id="L3-Cache"><a href="#L3-Cache" class="headerlink" title="L3-Cache"></a>L3-Cache</h4><p>L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远。大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。L3 缓存大小也是看型号的，比如 i9 CPU 有 512KB L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。</p><h4 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h4><p>内存的主要材料是半导体硅，是插在主板上工作的。因为它的位置距离 CPU 有一段距离，所以需要用总线和 CPU 连接。因为内存有了独立的空间，所以体积更大，造价也比上面提到的存储器低得多。现在有的个人电脑上的内存是 16G，但有些服务器的内存可以到几个 T。内存速度大概在 200~300 个 CPU 周期之间。</p><h4 id="SSD-和硬盘"><a href="#SSD-和硬盘" class="headerlink" title="SSD 和硬盘"></a>SSD 和硬盘</h4><p>SSD 也叫固态硬盘，结构和内存类似，但是它的优点在于断电后数据还在。内存、寄存器、缓存断电后数据就消失了。内存的读写速度比 SSD 大概快 10~1000 倍。以前还有一种物理读写的磁盘，我们也叫作硬盘，它的速度比内存慢 100W 倍左右。因为它的速度太慢，现在已经逐渐被 SSD 替代。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623093020.png" alt="image-20210623093020389"></p><p>当 CPU 需要内存中某个数据的时候，如果寄存器中有这个数据，我们可以直接使用；如果寄存器中没有这个数据，我们就要先查询 L1 缓存；L1 中没有，再查询 L2 缓存；L2 中没有再查询 L3 缓存；L3 中没有，再去内存中拿。</p><h3 id="缓存条目结构"><a href="#缓存条目结构" class="headerlink" title="缓存条目结构"></a>缓存条目结构</h3><p>上面我们介绍了存储器分级结构大概有哪些存储以及它们的特点，接下来还有一些缓存算法和数据结构的设计困难要和你讨论。比如 CPU 想访问一个内存地址，那么如何检查这个数据是否在 L1- 缓存中？换句话说，缓存中的数据结构和算法是怎样的？</p><p>无论是缓存，还是内存，它们都是一个线性存储器，也就是数据一个挨着一个的存储。如果我们把内存想象成一个只有 1 列的表格，那么缓存就是一个多列的表格，这个表格中的每一行叫作一个缓存条目。</p><h4 id="方案-1"><a href="#方案-1" class="headerlink" title="方案 1"></a>方案 1</h4><p>缓存本质上是一个 Key-Value 的存储，它的 Key 是内存地址，值是缓存时刻内存地址中的值。我们先思考一种简单的方案，一个缓存条目设计 2 列：</p><ol><li>内存的地址；</li><li>缓存的值。</li></ol><p>CPU 读取到一个内存地址，我们就增加一个条目。当我们要查询一个内存地址的数据在不在 L1- 缓存中的时候，可以遍历每个条目，看条目中的内存地址是否和查询的内存地址相同。如果相同，我们就取出条目中缓存的值。</p><p>这个方法需要遍历缓存中的每个条目，因此计算速度会非常慢，在最坏情况下，算法需要检查所有的条目，所以这不是一个可行的方案。</p><h4 id="方案-2"><a href="#方案-2" class="headerlink" title="方案 2"></a>方案 2</h4><p>其实很多优秀的方案，往往是从最笨的方案改造而来的。现在我们已经拥有了一个方案，但是这个方案无法快速确定一个内存地址缓存在哪一行。因此我们想要找到一个更好的方法，让我们看到一个内存地址，就能够快速知道它在哪一行。</p><p>这里，我们可以用一个数学的方法。比如有 1000 个内存地址，但只有 10 个缓存条目。内存地址的编号是 0、1、2、3，…，999，缓存条目的编号是 0~9。我们思考一个内存编号，比如 701，然后用数学方法把它映射到一个缓存条目，比如 701 整除 10，得到缓存条目 1。</p><p>用这种方法，我们每次拿到一个内存地址，都可以快速确定它的缓存条目；然后再比较缓存条目中的第一列内存地址和查询的内存地址是否相同，就可以确定内存地址有没有被缓存。</p><p>延伸一下，这里用到了一种类似哈希表的方法：<code>地址 % 10</code>，其实就构成了一个简单的哈希函数。</p><h3 id="指令的预读"><a href="#指令的预读" class="headerlink" title="指令的预读"></a>指令的预读</h3><p>接下来我们讨论下指令预读的问题。</p><p>之前我们学过，CPU 顺序执行内存中的指令，CPU 执行指令的速度是非常快的，一般是 2<del>6 个 CPU 时钟周期；这节课，我们学习了存储器分级策略，发现内存的读写速度其实是非常慢的，大概有 200</del>300 个时钟周期。</p><p>不知道你发现没有？这也产生了一个非常麻烦的问题：CPU 其实是不能从内存中一条条读取指令再执行的，如果是这样做，那每执行一条指令就需要 200~300 个时钟周期了。</p><p>那么，这个问题如何处理呢？</p><p>这里我再多说一句，你在做业务开发 RPC 调用的时候，其实也会经常碰到这种情况，远程调用拖慢了整体执行效率，下面我们一起讨论这类问题的解决方案。</p><p>一个解决办法就是 CPU 把内存中的指令预读几十条或者上百条到读写速度较快的 L1- 缓存中，因为 L1- 缓存的读写速度只有 2~4 个时钟周期，是可以跟上 CPU 的执行速度的。</p><p>这里又产生了另一个问题：如果数据和指令都存储在 L1- 缓存中，如果数据缓存覆盖了指令缓存，就会产生非常严重的后果。因此，L1- 缓存通常会分成两个区域，一个是指令区，一个是数据区。</p><p>与此同时，又出现了一个问题，L1- 缓存分成了指令区和数据区，那么 L2/L3 需不需要这样分呢？其实，是不需要的。因为 L2 和 L3，不需要协助处理指令预读的问题。</p><h3 id="缓存的命中率"><a href="#缓存的命中率" class="headerlink" title="缓存的命中率"></a>缓存的命中率</h3><p>接下来，还有一个重要的问题需要解决。就是 L1/L2/L3 加起来，缓存的命中率有多少？</p><p>所谓命中就是指在缓存中找到需要的数据。和命中相反的是穿透，也叫 miss，就是一次读取操作没有从缓存中找到对应的数据。</p><p>据统计，L1 缓存的命中率在 80% 左右，L1/L2/L3 加起来的命中率在 95% 左右。因此，CPU 缓存的设计还是相当合理的。只有 5% 的内存读取会穿透到内存，95% 都能读取到缓存。 这也是为什么程序语言逐渐取消了让程序员操作寄存器的语法，因为缓存保证了很高的命中率，多余的优化意义不大，而且很容易出错。</p><h3 id="缓存置换问题"><a href="#缓存置换问题" class="headerlink" title="缓存置换问题"></a>缓存置换问题</h3><p>最后的一个问题，比如现在 L1- 缓存条目已经存满了，接下来 CPU 又读了内存，需要把一个新的条目存到 L1- 缓存中，既然有一个新的条目要进来，那就有一个旧的条目要出去。所以，这个时候我们就需要用一个算法去计算哪个条目应该被置换出去。这个问题叫作缓存置换问题。有关缓存置换问题，我会在 “21 | 进程的调度：进程调度都有哪些方法？”中和你讨论。</p><p><strong>SSD、内存和 L1 Cache 相比速度差多少倍</strong>？</p><p><strong>【解析】</strong> 因为内存比 SSD 快 10<del>1000 倍，L1 Cache 比内存快 100 倍左右。因此 L1 Cache 比 SSD 快了 1000</del>100000 倍。所以你有没有发现 SSD 的潜力很大，好的 SSD 已经接近内存了，只不过造价还略高。</p><p>这个问题告诉我们，不同的存储器之间性能差距很大，构造存储器分级很有意义，分级的目的是要构造缓存体系。</p><p><strong>存不存在一个通用函数判断另一个函数是否会停止？</strong></p><p>假设存在一个函数willStop, 它只有一个参数func，willStop可以判断任意函数func是否会停止。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623094007.png" alt="image-20210623094007708"></p><p>存在这么一个悖论，所以这个问题是不可计算问题。</p><p><strong>假设一个维维数组，总共有1M个条目，如果我们要遍历这个二维数组，应该逐行遍历还是逐列遍历？</strong><br>首先要知道，二维数组在内存中的排列情况，</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623095415.png" alt="image-20210623095414990"></p><p>本质上还是一位数组的一个状态，只不过每行是连续的，由多个连续内存拼接在一起。</p><p>当CPU遍历二维数组的时候，存在一个预读取的操作，我们按行读取的话，会利用这个机制，并且，当我们在读取内存地址比较跳跃的数据的时候，会触发CPU的一个分页操作，更加增加了开销，降低了效率。</p><p>这里我比较好奇，就用Java实现了一个两种不同的遍历方式，逻辑比较简陋，属于是够用就好，结果一起附上。</p><script src="https://gist.github.com/FlyMeToTheMars/6a3559806787435bfe6ae64a73a2aeb1.js"></script><h3 id="什么是-Shell-和-Bash"><a href="#什么是-Shell-和-Bash" class="headerlink" title="什么是 Shell 和 Bash"></a>什么是 Shell 和 Bash</h3><p>在我们学习 Linux 指令之前，先来说一下什么是 Shell？Shell 把我们输入的指令，传递给操作系统去执行，所以 Shell 是一个命令行的用户界面。</p><p>早期程序员没有图形界面用，就用 Shell。而且图形界面制作成本较高，不能实现所有功能，因此今天的程序员依然在用 Shell。</p><p>你平时还经常会看到一个词叫作bash（Bourne Again Shell），它是用 Shell 组成的程序。这里的 Bourne 是一个人名，Steve Bourne 是 bash 的发明者。</p><h3 id="几种常见的文件类型"><a href="#几种常见的文件类型" class="headerlink" title="几种常见的文件类型"></a>几种常见的文件类型</h3><p>另一方面，Linux 下的目录也是一种文件；但是文件也不只有目录和可执行文件两种。常见的文件类型有以下 7 种:</p><ol><li>普通文件（比如一个文本文件）；</li><li>目录文件（目录也是一个特殊的文件，它用来存储文件清单，比如<code>/</code>也是一个文件）；</li><li>可执行文件（上面的<code>rm</code>就是一个可执行文件）；</li><li>管道文件（我们会在 07 课时讨论管道文件）；</li><li>Socket 文件（我们会在模块七网络部分讨论 Socket 文件）；</li><li>软链接文件（相当于指向另一个文件所在路径的符号）；</li><li>硬链接文件（相当于指向另一个文件的指针，关于软硬链接我们将在模块六文件系统部分讨论）。</li></ol><p>你如果使用<code>ls -F</code>就可以看到当前目录下的文件和它的类型。比如下面这种图：</p><ol><li>* 结尾的是可执行文件；</li><li>= 结尾的是 Socket 文件；</li><li>@ 结尾的是软链接；</li><li>| 结尾的管道文件；</li><li>没有符号结尾的是普通文件；</li><li>/ 结尾的是目录。</li></ol><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112258.png" alt="image-20210623112257938"></p><p><strong>more</strong></p><p><code>more</code>可以帮助我们读取文件，但不需要读取整个文件到内存中。本身<code>more</code>的定位是一个阅读过滤器，比如你在<code>more</code>里除了可以向下翻页，还可以输入一段文本进行搜索。</p><p><strong>less</strong></p><p><code>less</code>是一个和<code>more</code>功能差不多的工具，打开<code>man</code>能够看到<code>less</code>的介绍上写着自己是<code>more</code>的反义词（opposite of more）。这样你可以看出<code>linux</code>生态其实也是很自由的一个生态，在这里创造工具也可以按照自己的喜好写文档。<code>less</code>支持向上翻页，这个功能<code>more</code>是做不到的。所以现在<code>less</code>用得更多一些。</p><p><strong>head/tail</strong></p><p><code>head</code>和<code>tail</code>是一组，它们用来读取一个文件的头部 N 行或者尾部 N 行。比如一个线上的大日志文件，当线上出了 bug，服务暂停的时候，我们就可以用<code>tail -n 1000</code>去查看最后的 1000 行日志文件，寻找导致服务异常的原因。</p><p>另一个比较重要的用法是，如果你想看一个实时的<code>nginx</code>日志，可以使用<code>tail -f 文件名</code>，这样你会看到用户的请求不断进来。查一下<code>man</code>，你会发现<code>-f</code>是 follow 的意思，就是文件追加的内容会跟随输出到标准输出流。</p><p><strong>grep</strong></p><p>有时候你需要查看一个指定<code>ip</code>的nginx日志，或者查看一段时间内的<code>nginx</code>日志。如果不想用<code>less</code>和<code>more</code>进入文件中去查看，就可以用<code>grep</code>命令。Linux 的文件命名风格都很短，所以也影响了很多人，比如之前我看到过一个大牛的程序，变量名从来不超过 5 个字母，而且都有意义。</p><p>grep 这个词，我们分成三段来看，是 g|re|p。</p><ul><li>g 就是 global，全局；</li><li>re 就是 regular expression，正则表达式；</li><li>p 就是 pattern，模式。</li></ul><p>所以这个指令的作用是通过正则表达式全局搜索一个文件找到匹配的模式。我觉得这种命名真的很牛，软件命名也是一个世纪难题，grep这个名字不但发音不错，而且很有含义，又避免了名字过长，方便记忆。</p><p>下面我们举两个例子看看 grep 的用法：</p><ul><li>例 1：查找 ip 地址</li></ul><p>我们可以通过<code>grep</code>命令定位某个<code>ip</code>地址的用户都做了什么事情，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112408.png" alt="image-20210623112408158"></p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112429.png" alt="image-20210623112429600"></p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112440.png" alt="image-20210623112440021"></p><p><strong>man 指令</strong>：相当于指令手册</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong><em>什么是进程？</em></strong></p><p>*<strong>可以回答：进程是应用的执行副本；而不要回答进程是操作系统分配资源的最小单位。前者是定义，后者是作用**</strong>。*</p><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a><strong>ps</strong></h4><p>如果你要看当前的进程，可以用<code>ps</code>指令。p 代表 processes，也就是进程；s 代表 snapshot，也就是快照。所谓快照，就是像拍照一样。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623113721.png" alt="image-20210623113721850"></p><p><strong>TTY</strong>：TTY 这个概念是一个历史的概念，过去用来传递信息，现在已经被传真、邮件、微信等取代。</p><p>操作系统上的 TTY 是一个输入输出终端的概念，比如用户打开 bash，操作系统就为用户分配了一个输入输出终端。没有加任何参数的<code>ps</code>只显示在同一个 TTY 的进程。</p><p>如果想看到所有的进程，可以用<code>ps -e</code>，<code>-e</code>没有特殊含义，只是为了和<code>-A</code>区分开。我们通常不直接用<code>ps -e</code>而是用<code>ps -ef</code>，这是因为<code>-f</code>可以带上更多的描述字段，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623114108.png" alt="image-20210623114107889"></p><ul><li>UID 指进程的所有者；</li><li>PID 是进程的唯一标识；</li><li>PPID 是进程的父进程 ID；</li><li>C 是 CPU 的利用率（就是 CPU 占用）；</li><li>STIME 是开始时间；</li><li>TTY 是进程所在的 TTY，如果没有 TTY 就是 ？号；</li><li>TIME；</li><li>CMD 是进程启动时的命令，如果不是一个 Shell 命令，而是用方括号括起来，那就是系统进程或者内核过程。</li></ul><p>另外一个用得比较多的是<code>ps aux</code>，它和<code>ps -ef</code>能力差不多，但是是 BSD 风格的。就是加州伯克利分校研发的 Unix 分支版本的衍生风格，这种风格其实不太好描述，我截了一张图，你可以体会一下：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623114328.png" alt="image-20210623114328257"></p><p>在 BSD 风格中有些字段的叫法和含义变了。</p><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>另外还有一个和<code>ps</code>能力差不多，但是显示的不是快照而是实时更新数据的<code>top</code>指令。因为自带的<code>top</code>显示的内容有点少， 所以我喜欢用一个叫作<code>htop</code>的指令，是需要额外安装的。</p><h3 id="管道（Pipeline）"><a href="#管道（Pipeline）" class="headerlink" title="管道（Pipeline）"></a>管道（Pipeline）</h3><p>现管道（Pipeline）的作用是在命令和命令之间，传递数据。比如说一个命令的结果，就可以作为另一个命令的输入。我们了解了进程，所以这里说的命令就是进程。更准确地说，管道在进程间传递数据。</p><h4 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><p>每个进程拥有自己的标准输入流、标准输出流、标准错误流。</p><p>这几个标准流说起来很复杂，但其实都是文件。</p><ul><li>标准输入流（用 0 表示）可以作为进程执行的上下文（进程执行可以从输入流中获取数据）。</li><li>标准输出流（用 1 表示）中写入的结果会被打印到屏幕上。</li><li>如果进程在执行过程中发生异常，那么异常信息会被记录到标准错误流（用 2 表示）中。</li></ul><p><strong>重定向</strong></p><p>我们执行一个指令，比如<code>ls -l</code>，结果会写入标准输出流，进而被打印。这时可以用重定向符将结果重定向到一个文件，比如说<code>ls -l &gt; out</code>，这样<code>out</code>文件就会有<code>ls -l</code>的结果；而屏幕上也不会再打印<code>ls -l</code>的结果。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623163858.png" alt="image-20210623163857940"></p><p>具体来说<code>&gt;</code>符号叫作覆盖重定向；<code>&gt;&gt;</code>叫作追加重定向。<code>&gt;</code>每次都会把目标文件覆盖，<code>&gt;&gt;</code>会在目标文件中追加。经过这样的操作后，每次执行程序日志就不会被覆盖了。</p><p>另外还有一种情况，比如我们输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls1 &gt; out</span><br></pre></td></tr></table></figure><p>结果并不会存入<code>out</code>文件，因为<code>ls1</code>指令是不存在的。结果会输出到标准错误流中，仍然在屏幕上。这里我们可以把标准错误流也重定向到标准输出流，然后再重定向到文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls1 &amp;&gt; out</span><br></pre></td></tr></table></figure><p>这个写法等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls1 &gt; out 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h4 id="管道的作用和分类"><a href="#管道的作用和分类" class="headerlink" title="管道的作用和分类"></a>管道的作用和分类</h4><p>有了进程和重定向的知识，接下来我们梳理下管道的作用。管道（Pipeline）将一个进程的输出流定向到另一个进程的输入流，就像水管一样，作用就是把这两个文件接起来。如果一个进程输出了一个字符 X，那么另一个进程就会获得 X 这个输入。</p><p><strong>管道和重定向很像，但是管道是一个连接一个进行计算，重定向是将一个文件的内容定向到另一个文件，这二者经常会结合使用</strong>。</p><p>Linux 中的管道也是文件，有两种类型的管道：</p><ol><li>匿名管道（Unnamed Pipeline），这种管道也在文件系统中，但是它只是一个存储节点，不属于任何一个目录。说白了，就是没有路径。</li><li>命名管道（Named Pipeline），这种管道就是一个文件，有自己的路径。</li></ol><h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>管道具有 FIFO（<strong>First In First Out</strong>），FIFO 和排队场景一样，先排到的先获得。所以先流入管道文件的数据，也会先流出去传递给管道下游的进程。</p><h3 id="使用场景分析"><a href="#使用场景分析" class="headerlink" title="使用场景分析"></a>使用场景分析</h3><p>接下来我们以多个场景举例帮助你深入学习管道。</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>比如我们用<code>ls</code>，希望按照文件名排序倒序，可以使用匿名管道，将<code>ls</code>的结果传递给<code>sort</code>指令去排序。你看，这样<code>ls</code>的开发者就不用关心排序问题了。</p><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>另一个比较常见的场景是去重，比如有一个字典文件，里面都是词语。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>如果我们想要去重可以使用<code>uniq</code>指令，<code>uniq</code>指令能够找到文件中相邻的重复行，然后去重。但是我们上面的文件重复行是交替的，所以不可以直接用<code>uniq</code>，因此可以先<code>sort</code>这个文件，然后利用管道将<code>sort</code>的结果重定向到<code>uniq</code>指令。指令如下：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623164748.png" alt="image-20210623164748417"></p><h4 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h4><p>有时候我们想根据正则模式筛选对应的内容。比如说我们想找到项目文件下所有文件名中含有<code>Spring</code>的文件。就可以利用<code>grep</code>指令，操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ | grep Spring</span><br></pre></td></tr></table></figure><p><code>find ./</code>递归列出当前目录下所有目录中的文件。<code>grep</code>从<code>find</code>的输出流中找出含有<code>Spring</code>关键字的行。</p><p>如果我们希望包含<code>Spring</code>但不包含<code>MyBatis</code>就可以这样操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ | grep Spring | grep -v MyBatis</span><br></pre></td></tr></table></figure><p><code>grep -v</code>是匹配不包含 MyBatis 的结果。</p><h4 id="数行数"><a href="#数行数" class="headerlink" title="数行数"></a>数行数</h4><p>还有一个比较常见的场景是数行数。比如你写了一个 Java 文件想知道里面有多少行，就可以使用<code>wc -l</code>指令，如下所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623164924.png" alt="image-20210623164923942"></p><p>但是如果你想知道当前目录下有多少个文件，可以用<code>ls | wc -l</code>，如下所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623164950.png" alt="image-20210623164950862"></p><p><strong>接下来请你思考一个问题：我们如何知道当前</strong><code>java</code><strong>的项目目录下有多少行代码</strong>？</p><p>提示一下。你可以使用下面这个指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -i <span class="string">".java"</span> ./ | wc -l</span><br></pre></td></tr></table></figure><h4 id="中间结果"><a href="#中间结果" class="headerlink" title="中间结果"></a>中间结果</h4><p>管道一个接着一个，是一个计算逻辑。有时候我们想要把中间的结果保存下来，这就需要用到<code>tee</code>指令。<code>tee</code>指令从标准输入流中读取数据到标准输出流。</p><p><code>tee</code>还有一个能力，就是自己利用这个过程把输入流中读取到的数据存到文件中。比如下面这条指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -i <span class="string">"*.java"</span> | tee JavaList | grep Spring</span><br></pre></td></tr></table></figure><p>这句指令的意思是从当前目录中找到所有含有 Spring 关键字的 Java 文件。tee 本身不影响指令的执行，但是 tee 会把 find 指令的结果保存到 JavaList 文件中。</p><p><code>tee</code>这个执行就像英文字母中的 T 一样，连通管道两端，下面又开了口。这个开口，在函数式编程里面叫作副作用。</p><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p><code>xargs</code>指令从标准数据流中构造并执行一行行的指令。<code>xargs</code>从输入流获取字符串，然后利用空白、换行符等切割字符串，在这些字符串的基础上构造指令，最后一行行执行这些指令。</p><p>举个例子，如果我们重命名当前目录下的所有 .a 的文件，想在这些文件前面加一个前缀<code>prefix_</code>。比如说<code>x.a</code>文件需要重命名成<code>prefix_x.a</code>，我们就可以用<code>xargs</code>指令构造模块化的指令。</p><p>现在我们有<code>x.a``y.a``z.a</code>三个文件，然后使用下图中的指令构造我们需要的指令：：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165424.png" alt="image-20210623165424707"></p><ul><li>我们用<code>ls</code>找到所有的文件；</li><li><code>-I</code>参数是查找替换符，这里我们用<code>GG</code>替代<code>ls</code>找到的结果；<code>-I GG</code>后面的字符串 GG 会被替换为<code>x.a``x.b</code>或<code>x.z</code>；</li><li><code>echo</code>是一个在命令行打印字符串的指令。使用<code>echo</code>主要是为了安全，帮助我们检查指令是否有错误。</li></ul><p>我们用<code>xargs</code>构造了 3 条指令。这里我再多讲一个词，叫作样板代码。如果你没有用<code>xargs</code>指令，而是用一条条<code>mv</code>指令去敲，这样就构成了样板代码。</p><p>最后去掉 echo，就是我们想要的结果，如下所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165523.png" alt="image-20210623165523353"></p><h3 id="管道文件"><a href="#管道文件" class="headerlink" title="管道文件"></a>管道文件</h3><p>上面我们花了较长的一段时间讨论匿名管道，用<code>|</code>就可以创造和使用。匿名管道也是利用了文件系统的能力，是一种文件结构。当你学到模块六文件系统的内容，会知道匿名管道拥有一个自己的<code>inode</code>，但不属于任何一个文件夹。</p><p>还有一种管道叫作命名管道（Named Pipeline）。命名管道是要挂到文件夹中的，因此需要创建。用<code>mkfifo</code>指令可以创建一个命名管道，下面我们来创建一个叫作<code>pipe1</code>的命名管道，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165554.png" alt="image-20210623165554555"></p><p>命名管道和匿名管道能力类似，可以连接一个输出流到另一个输入流，也是 First In First Out。</p><p>当执行<code>cat pipe1</code>的时候，你可以观察到，当前的终端处于等待状态。因为我们<code>cat pipe1</code>的时候<code>pipe1</code>中没有内容。</p><p>如果这个时候我们再找一个终端去写一点东西到<code>pipe</code>中，比如说:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"XXX"</span> &gt; pipe1</span><br></pre></td></tr></table></figure><p>这个时候，<code>cat pipe1</code>就会返回，并打印出<code>xxx</code>，如下所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165746.png" alt="image-20210623165745970"></p><p>我们可以像上图那样演示这段程序，在<code>cat pipe1</code>后面增加了一个<code>&amp;</code>符号。这个<code>&amp;</code>符号代表指令在后台执行，不会阻塞用户继续输入。然后我们通过<code>echo</code>指令往<code>pipe1</code>中写入东西，接着就会看到<code>xxx</code>被打印出来。</p><p><strong>xargs 的作用</strong></p><p>xargs 将标准输入流中的字符串分割成一条条子字符串，然后再按照我们自己想要的方式构建成一条条指令，大大拓展了 Linux 指令的能力。</p><h3 id="权限抽象"><a href="#权限抽象" class="headerlink" title="权限抽象"></a>权限抽象</h3><p><strong>首先，我们先来说说用户和组</strong>。Linux 是一个多用户平台，允许多个用户同时登录系统工作。Linux 将用户抽象成了账户，账户可以登录系统，比如通过输入登录名 + 密码的方式登录；也可以通过证书的方式登录。</p><p>但为了方便分配每个用户的权限，Linux 还支持组 <strong>（Group）账户</strong>。组账户是多个账户的集合，组可以为成员们分配某一类权限。每个用户可以在多个组，这样就可以利用组给用户快速分配权限。</p><p>组的概念有点像微信群。一个用户可以在多个群中。比如某个组中分配了 10 个目录的权限，那么新建用户的时候可以将这个用户增加到这个组中，这样新增的用户就不必再去一个个目录分配权限。</p><p>而每一个微信群都有一个群主，<strong>Root 账户也叫作超级管理员</strong>，就相当于微信群主，它对系统有着完全的掌控。一个超级管理员可以使用系统提供的全部能力。</p><p>此外，Linux 还对<strong>文件</strong>进行了权限抽象（<strong>注意目录也是一种文件</strong>）。Linux 中一个文件可以设置下面 3 种权限：</p><ol><li>读权限（r）：控制读取文件。</li><li>写权限（w）：控制写入文件。</li><li>执行权限（x）：控制将文件执行，比如脚本、应用程序等。</li></ol><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623181121.png" alt="image-20210623181121589"></p><p>然后每个文件又可以从 3 个维度去配置上述的 3 种权限：</p><ol><li>用户维度。每个文件可以所属 1 个用户，用户维度配置的 rwx 在用户维度生效；</li><li>组维度。每个文件可以所属 1 个分组，组维度配置的 rwx 在组维度生效；</li><li>全部用户维度。设置对所有用户的权限。</li></ol><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623181158.png" alt="image-20210623181158847"></p><p>因此 Linux 中文件的权限可以用 9 个字符，3 组<code>rwx</code>描述：第一组是用户权限，第二组是组权限，第三组是所有用户的权限。然后用<code>-</code>代表没有权限。比如<code>rwxrwxrwx</code>代表所有维度可以读写执行。<code>rw--wxr-x</code>代表用户维度不可以执行，组维度不可以读取，所有用户维度不可以写入。</p><p>通常情况下，如果用<code>ls -l</code>查看一个文件的权限，会有 10 个字符，这是因为第一个字符代表的是文件类型。我们在 06 课时讲解“几种常见的文件类型”时提到过，有管道文件、目录文件、链接文件等等。<code>-</code>代表普通文件、<code>d</code>代表目录、<code>p</code>代表管道。</p><h4 id="问题一：初始权限问题"><a href="#问题一：初始权限问题" class="headerlink" title="问题一：初始权限问题"></a><strong>问题一：初始权限问题</strong></h4><p>一个文件创建后，文件的所属用户会被设置成创建文件的用户。谁创建谁拥有，这个逻辑很顺理成章。但是文件的组又是如何分配的呢？</p><p>这里 Linux 想到了一个很好的办法，就是为每个用户创建一个同名分组。</p><p>比如说<code>zhang</code>这个账户创建时，会创建一个叫作<code>zhang</code>的分组。<code>zhang</code>登录之后，工作分组就会默认使用它的同名分组<code>zhang</code>。如果<code>zhang</code>想要切换工作分组，可以使用<code>newgrp</code>指令切换到另一个工作分组。因此，被创建文件所属的分组是当时用户所在的工作分组，如果没有特别设置，那么就属于用户所在的同名分组。</p><p>再说下文件的权限如何？文件被创建后的权限通常是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rw-rw-r--</span><br></pre></td></tr></table></figure><p>也就是用户、组维度不可以执行，所有用户可读。</p><h4 id="问题二：公共执行文件的权限"><a href="#问题二：公共执行文件的权限" class="headerlink" title="问题二：公共执行文件的权限"></a><strong>问题二：公共执行文件的权限</strong></h4><p>前面提到过可以用<code>which</code>指令查看<code>ls</code>指令所在的目录，我们发现在<code>/usr/bin</code>中。然后用<code>ls -l</code>查看<code>ls</code>的权限，可以看到下图所示：</p><ul><li>第一个<code>-</code>代表这是一个普通文件，后面的 rwx 代表用户维度可读写和执行；</li><li>第二个<code>r-x</code>代表组维度不可读写；</li><li>第三个<code>r-x</code>代表所有用户可以读和执行；</li><li>后两个<code>root</code>，第一个代表所属用户，第二个代表所属分组。</li></ul><p><strong>如果一个文件设置为不可读，但是可以执行，那么结果会怎样？</strong></p><p>答案当然是不可以执行，无法读取文件内容自然不可以执行。</p><h4 id="问题三：执行文件"><a href="#问题三：执行文件" class="headerlink" title="问题三：执行文件"></a><strong>问题三：执行文件</strong></h4><p>在 Linux 中，如果一个文件可以被执行，则可以直接通过输入文件路径（相对路径或绝对路径）的方式执行。如果想执行一个不可以执行的文件，Linux 则会报错。</p><p>当用户输入一个文件名，如果没有指定完整路径，Linux 就会在一部分目录中查找这个文件。你可以通过<code>echo $PATH</code>看到 Linux 会在哪些目录中查找可执行文件，<code>PATH</code>是 Linux 的环境变量。</p><h4 id="问题四：可不可以都-root"><a href="#问题四：可不可以都-root" class="headerlink" title="问题四：可不可以都 root"></a><strong>问题四：可不可以都 root</strong></h4><p>不可以</p><p>下面我们就来说说 root 的危害。</p><p>举个例子，你有一个 MySQL 进程执行在 root（最大权限）账户上，如果有黑客攻破了你的 MySQL 服务，获得了在 MySQL 上执行 SQL 的权限，那么，你的整个系统就都暴露在黑客眼前了。这会导致非常严重的后果。</p><p>黑客可以利用 MySQL 的 Copy From Prgram 指令为所欲为，比如先备份你的关键文件，然后再删除他们，并要挟你通过指定账户打款。如果执行最小权限原则，那么黑客即便攻破我们的 MySQL 服务，他也只能获得最小的权限。当然，黑客拿到 MySQL 权限也是非常可怕的，但是相比拿到所有权限，这个损失就小多了。</p><hr><p><strong>内核</strong>是操作系统连接硬件、提供最核心能力的程序。</p><p>内核提供操作硬件、磁盘、内存分页、进程等最核心的能力，并拥有直接操作全部内存的权限，因此内核不能把自己的全部能力都提供给用户，而且也不能允许用户通过<code>shell</code>指令进行系统调用。Linux 下内核把部分进程需要的系统调用以 C 语言 API 的形式提供出来。部分系统调用会有权限检查，比如说设置系统时间的系统调用。</p><h3 id="权限架构思想"><a href="#权限架构思想" class="headerlink" title="权限架构思想"></a>权限架构思想</h3><p>优秀的权限架构主要目标是让系统安全、稳定且用户、程序之间相互制约、相互隔离。这要求权限系统中的权限划分足够清晰，分配权限的成本足够低。</p><p>因此，优秀的架构，应该遵循最小权限原则（Least Privilege）。权限设计需要保证系统的安全和稳定。比如：每一个成员拥有的权限应该足够的小，每一段特权程序执行的过程应该足够的短。对于安全级别较高的时候，还需要成员权限互相牵制。比如金融领域通常登录线上数据库需要两次登录，也就是需要两个密码，分别掌握在两个角色手中。这样即便一个成员出了问题，也可以保证整个系统安全。</p><p>同样的，每个程序也应该减少权限，比如说只拥有少量的目录读写权限，只可以进行少量的系统调用。</p><h3 id="权限划分"><a href="#权限划分" class="headerlink" title="权限划分"></a>权限划分</h3><p>此外，权限架构思想还应遵循一个原则，权限划分边界应该足够清晰，尽量做到相互隔离。Linux 提供了用户和分组。当然 Linux 没有强迫你如何划分权限，这是为了应对更多的场景。通常我们服务器上重要的应用，会由不同的账户执行。比如说 Nginx、Web 服务器、数据库不会执行在一个账户下。现在随着容器化技术的发展，我们甚至希望每个应用独享一个虚拟的空间，就好像运行在一个单独的操作系统中一样，让它们互相不用干扰。</p><h4 id="分级保护"><a href="#分级保护" class="headerlink" title="分级保护"></a>分级保护</h4><p>因为内核可以直接操作内存和 CPU，因此非常危险。驱动程序可以直接控制摄像头、显示屏等核心设备，也需要采取安全措施，比如防止恶意应用开启摄像头盗用隐私。通常操作系统都采取一种环状的保护模式。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623184936.png" alt="image-20210623184936622"></p><p>如上图所示，内核在最里面，也就是 Ring 0。 应用在最外面也就是 Ring 3。驱动在中间，也就是 Ring 1 和 Ring 2。对于相邻的两个 Ring，内层 Ring 会拥有较高的权限，可以改变外层的 Ring；而外层的 Ring 想要使用内层 Ring 的资源时，会有专门的程序（或者硬件）进行保护。</p><p>比如说一个 Ring3 的应用需要使用内核，就需要发送一个系统调用给内核。这个系统调用会由内核进行验证，比如验证用户有没有足够的权限，以及这个行为是否安全等等。</p><p><strong>权限包围（Privilege Bracking）</strong></p><p>之前我们讨论过，当 MySQL 跑在 root 权限时，如果 MySQLl 被攻破，整个机器就被攻破了。因此我们所有应用都不要跑在 root 上。如果所有应用都跑在普通账户下，那么就会有临时提升权限的场景。比如说安装程序可能需要临时拥有管理员权限，将应用装到<code>/usr/bin</code>目录下。</p><p>Linux 提供了权限包围的能力。比如一个应用，临时需要高级权限，可以利用交互界面（比如让用户输入 root 账户密码）验证身份，然后执行需要高级权限的操作，然后马上恢复到普通权限工作。这样做可以减少应用在高级权限的时间，并做到专权专用，防止被恶意程序利用。</p><h3 id="用户分组指令"><a href="#用户分组指令" class="headerlink" title="用户分组指令"></a>用户分组指令</h3><p>上面我们讨论了 Linux 权限的架构，接下来我们学习一些具体的指令。</p><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>如果想查看当前用户的分组可以使用<code>groups</code>指令。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185115.png" alt="image-20210623185115808"></p><p>上面指令列出当前用户的所有分组。第一个是同名的主要分组，后面从<code>adm</code>开始是次级分组。</p><p>我先给你介绍两个分组，其他分组你可以去查资料：</p><ul><li>adm 分组用于系统监控，比如<code>/var/log</code>中的部分日志就是 adm 分组。</li><li>sudo 分组用户可以通过 sudo 指令提升权限。</li></ul><p>如果想查看当前用户，可以使用<code>id</code>指令，如下所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185149.png" alt="image-20210623185149343"></p><ul><li>uid 是用户 id；</li><li>gid 是组 id；</li><li>groups 后面是每个分组和分组的 id。</li></ul><p>如果想查看所有的用户，可以直接看<code>/etc/passwd</code>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185353.png" alt="image-20210623185352703"></p><p><code>/etc/passwd</code>这个文件存储了所有的用户信息，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185407.png" alt="image-20210623185407518"></p><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>创建用户用<code>useradd</code>指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd foo</span><br></pre></td></tr></table></figure><p>sudo 原意是 superuser do，后来演变成用另一个用户的身份去执行某个指令。如果没有指定需要 sudo 的用户，就可以像上面那样，以超级管理员的身份。因为 useradd 需要管理员身份。这句话执行后，会进行权限提升，并弹出输入管理员密码的输入界面。</p><h4 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a><strong>创建分组</strong></h4><p>创建分组用<code>groupadd</code>指令。下面指令创建一个叫作<code>hello</code>的分组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd hello</span><br></pre></td></tr></table></figure><h4 id="为用户增加次级分组"><a href="#为用户增加次级分组" class="headerlink" title="为用户增加次级分组"></a>为用户增加次级分组</h4><p>组分成主要分组（Primary Group）和次级分组（Secondary Group）。主要分组只有 1 个，次级分组可以有多个。如果想为用户添加一个次级分组，可以用<code>usermod</code>指令。下面指令将用户<code>foo</code>添加到<code>sudo</code>分组，从而<code>foo</code>拥有了<code>sudo</code>的权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G sudo foo</span><br></pre></td></tr></table></figure><p><code>-a</code>代表append，<code>-G</code>代表一个次级分组的清单， 最后一个<code>foo</code>是账户名。</p><h4 id="修改用户主要分组"><a href="#修改用户主要分组" class="headerlink" title="修改用户主要分组"></a>修改用户主要分组</h4><p>修改主要分组还是使用<code>usermod</code>指令。只不过参数是小写的<code>-g</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -g somegroup foo</span><br></pre></td></tr></table></figure><h3 id="文件权限管理指令"><a href="#文件权限管理指令" class="headerlink" title="文件权限管理指令"></a>文件权限管理指令</h3><p>接下来我们学习文件管理相关的指令。</p><h4 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h4><p>我们可以用<code>ls -l</code>查看文件的权限，相关内容在本课时前面已经介绍过了。</p><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p>可以用<code>chmod</code>修改文件权限，<code>chmod</code>（ change file mode bits），也就是我们之前学习的 rwx，只不过 rwx 在 Linux 中是用三个连在一起的二进制位来表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置foo可以执行</span></span><br><span class="line">chmod +x ./foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不允许foo执行</span></span><br><span class="line">chmod -x ./foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以同时设置多个权限</span></span><br><span class="line">chmod +rwx ./foo</span><br></pre></td></tr></table></figure><p>因为<code>rwx</code>在 Linux 中用相邻的 3 个位来表示。比如说<code>111</code>代表<code>rwx</code>，<code>101</code>代表<code>r-x</code>。而<code>rwx</code>总共有三组，分别是用户权限、组权限和全部用户权限。也就是可以用<code>111111111</code> 9 个 1 代表<code>rwxrwxrwx</code>。又因为<code>111</code>10 进制是 7，因此当需要一次性设置用户权限、组权限和所有用户权限的时候，我们经常用数字表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置rwxrwxrwx (111111111 -&gt; 777)</span></span><br><span class="line">chmod 777 ./foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置rw-rw-rw-(110110110 -&gt; 666)</span></span><br><span class="line">chmod 666 ./foo</span><br></pre></td></tr></table></figure><h4 id="修改文件所属用户"><a href="#修改文件所属用户" class="headerlink" title="修改文件所属用户"></a>修改文件所属用户</h4><p>有时候我们需要修改文件所属用户，这个时候会使用<code>chown</code>指令。 下面指令修改<code>foo</code>文件所属的用户为<code>bar</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown bar ./foo</span><br></pre></td></tr></table></figure><p>还有一些情况下，我们需要同时修改文件所属的用户和分组，比如我们想修改<code>foo</code>的分组位<code>g</code>，用户为<code>u</code>，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown g.u ./foo</span><br></pre></td></tr></table></figure><p><strong>简述 Linux 权限划分的原则？</strong></p><p>老规矩，请你先在脑海里构思下给面试官的表述，并把你的思考写在留言区，然后再来看我接下来的分析。</p><p><strong>【解析】</strong> Linux 遵循最小权限原则。</p><ol><li>每个用户掌握的权限应该足够小，每个组掌握的权限也足够小。实际生产过程中，最好管理员权限可以拆分，互相牵制防止问题。</li><li>每个应用应当尽可能小的使用权限。最理想的是每个应用单独占用一个容器（比如 Docker），这样就不存在互相影响的问题。即便应用被攻破，也无法攻破 Docker 的保护层。</li><li>尽可能少的<code>root</code>。如果一个用户需要<code>root</code>能力，那么应当进行权限包围——马上提升权限（比如 sudo），处理后马上释放权限。</li><li>系统层面实现权限分级保护，将系统的权限分成一个个 Ring，外层 Ring 调用内层 Ring 时需要内层 Ring 进行权限校验。</li></ol><h3 id="远程操作指令"><a href="#远程操作指令" class="headerlink" title="远程操作指令"></a>远程操作指令</h3><p>远程操作指令用得最多的是<code>ssh</code>，<code>ssh</code>指令允许远程登录到目标计算机并进行远程操作和管理。还有一个比较常用的远程指令是<code>scp</code>，<code>scp</code>帮助我们远程传送文件。</p><h4 id="ssh（Secure-Shell）"><a href="#ssh（Secure-Shell）" class="headerlink" title="ssh（Secure Shell）"></a>ssh（Secure Shell）</h4><p>有一种场景需要远程登录一个 Linux 系统，这时我们会用到<code>ssh</code>指令。比如你想远程登录一台机器，可以使用<code>ssh user@ip</code>的方式。</p><h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><p>另一种场景是我需要拷贝一个文件到远程，这时可以使用<code>scp</code>指令，如下图，我使用<code>scp</code>指令将本地计算机的一个文件拷贝到了 ubuntu 虚拟机用户的家目录中。</p><p>比如从<code>u1</code>拷贝家目录下的文件<code>a.txt</code>到<code>u2</code>。家目录有一个简写，就是用<code>~</code>。</p><p>输入 scp 指令之后会弹出一个提示，要求输入密码，系统验证通过后文件会被成功拷贝。</p><h3 id="查看本地网络状态"><a href="#查看本地网络状态" class="headerlink" title="查看本地网络状态"></a>查看本地网络状态</h3><p>如果你想要了解本地的网络状态，比较常用的网络指令是<code>ifconfig</code>和<code>netstat</code>。</p><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>当你想知道本地<code>ip</code>以及本地有哪些网络接口时，就可以使用<code>ifconfig</code>指令。你可以把一个网络接口理解成一个网卡，有时候虚拟机会装虚拟网卡，虚拟网卡是用软件模拟的网卡。</p><p>比如：VMware 为每个虚拟机创造一个虚拟网卡，通过虚拟网卡接入虚拟网络。当然物理机也可以接入虚拟网络，它可以通过虚拟网络向虚拟机的虚拟网卡上发送信息。</p><p>下图是我的 ubuntu 虚拟机用 ifconfig 查看网络接口信息。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192452.png" alt="image-20210623192452089"></p><p>可以看到我的这台 ubuntu 虚拟机一共有 2 个网卡，ens33 和 lo。<code>lo</code>是本地回路（local lookback），发送给<code>lo</code>就相当于发送给本机。<code>ens33</code>是一块连接着真实网络的虚拟网卡。</p><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>另一个查看网络状态的场景是想看目前本机的网络使用情况，这个时候可以用<code>netstat</code>。</p><p><strong>默认行为</strong></p><p>不传任何参数的<code>netstat</code>帮助查询所有的本地 socket，下图是<code>netstat | less</code>的结果。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192516.png" alt="image-20210623192516557"></p><p>如上图，我们看到的是 socket 文件。socket 是网络插槽被抽象成了文件，负责在客户端、服务器之间收发数据。当客户端和服务端发生连接时，客户端和服务端会同时各自生成一个 socket 文件，用于管理这个连接。这里，可以用<code>wc -l</code>数一下有多少个<code>socket</code>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192542.png" alt="image-20210623192541989"></p><p>这里没有找到连接中的<code>tcp</code>，因为我们这台虚拟机当时没有发生任何的网络连接。因此我们尝试从机器<code>u2</code>（另一台机器）ssh 登录进<code>u1</code>，再看一次：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192608.png" alt="image-20210623192608861"></p><p>如上图所示，可以看到有一个 TCP 连接了。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192721.png" alt="image-20210623192721531"></p><p><strong>查看端口占用</strong></p><p>还有一种非常常见的情形，我们想知道某个端口是哪个应用在占用。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192734.png" alt="image-20210623192734416"></p><p>这里我们看到 22 端口被 sshd，也就是远程登录模块被占用了。<code>-n</code>是将一些特殊的端口号用数字显示，<code>-t</code>是指看 TCP 协议，<code>-l</code>是只显示连接中的连接，<code>-p</code>是显示程序名称。</p><h3 id="网络测试"><a href="#网络测试" class="headerlink" title="网络测试"></a>网络测试</h3><p>当我们需要测试网络延迟、测试服务是否可用时，可能会用到<code>ping</code>和<code>telnet</code>指令。</p><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>想知道本机到某个网站的网络延迟，就可以使用<code>ping</code>指令。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192758.png" alt="image-20210623192757989"></p><p><code>ping</code>一个网站需要使用 ICMP 协议。因此你可以在上图中看到 icmp 序号。 这里的时间<code>time</code>是往返一次的时间。<code>ttl</code>叫作 time to live，是封包的生存时间。就是说，一个封包从发出就开始倒计时，如果途中超过 128ms，这个包就会被丢弃。如果包被丢弃，就会被算进丢包率。</p><p>另外<code>ping</code>还可以帮助我们看到一个网址的 IP 地址。 通过网址获得 IP 地址的过程叫作 DNS Lookup（DNS 查询）。<code>ping</code>利用了 DNS 查询，但是没有显示全部的 DNS 查询结果。</p><h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><p>有时候我们想知道本机到某个 IP + 端口的网络是否通畅，也就是想知道对方服务器是否在这个端口上提供了服务。这个时候可以用<code>telnet</code>指令。 如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192836.png" alt="image-20210623192836203"></p><p>如上图所示，第 5 行的<code>GET</code> 和第 6 行的<code>HOST</code>是我输入的。 拉勾网返回了一个 301 永久跳转。这是因为拉勾网尝试把<code>http</code>协议链接重定向到<code>https</code>。</p><h3 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h3><p>我们排查网络故障时想要进行一次 DNS Lookup，想知道一个网址 DNS 的解析过程。这个时候有多个指令可以用。</p><h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><p>host 就是一个 DNS 查询工具。比如我们查询拉勾网的 DNS，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192908.png" alt="image-20210623192908805"></p><p>我们看到拉勾网 <a href="http://www.lagou.comw/" target="_blank" rel="noopener">www.lagou.com</a> 是一个别名，它的原名是 lgmain 开头的一个域名，这说明拉勾网有可能在用 CDN 分发主页（关于 CDN，我们《计算机网络》专栏见）。</p><p>上图中，可以找到 3 个域名对应的 IP 地址。</p><p>如果想追查某种类型的记录，可以使用<code>host -t</code>。比如下图我们追查拉勾的 AAAA 记录，因为拉勾网还没有部署 IPv6，所以没有找到。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192934.png" alt="image-20210623192934697"></p><h4 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h4><p><code>dig</code>指令也是一个做 DNS 查询的。不过<code>dig</code>指令显示的内容更详细。下图是<code>dig</code>拉勾网的结果。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623193000.png" alt="image-20210623193000544"></p><p>从结果可以看到<a href="http://www.lagou.c/" target="_blank" rel="noopener">www.lagou.com</a> 有一个别名，用 CNAME 记录定义 lgmain 开头的一个域名，然后有 3 条 A 记录，通常这种情况是为了均衡负载或者分发内容。</p><h3 id="HTTP-相关"><a href="#HTTP-相关" class="headerlink" title="HTTP 相关"></a>HTTP 相关</h3><p>最后我们来说说<code>http</code>协议相关的指令。</p><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>如果要在命令行请求一个网页，或者请求一个接口，可以用<code>curl</code>指令。<code>curl</code>支持很多种协议，比如 LDAP、SMTP、FTP、HTTP 等。</p><p>我们可以直接使用 curl 请求一个网址，获取资源，比如我用 curl 直接获取了拉勾网的主页，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623193037.png" alt="image-20210623193037525"></p><p>如果只想看 HTTP 返回头，可以使用<code>curl -I</code>。</p><p>另外<code>curl</code>还可以执行 POST 请求，比如下面这个语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">'&#123;"x" : 1&#125;'</span> -H <span class="string">"Content-Type: application/json"</span> -X POST http://localhost:3000/api</span><br></pre></td></tr></table></figure><p>curl在向<code>localhost:3000</code>发送 POST 请求。<code>-d</code>后面跟着要发送的数据， -<code>X</code>后面是用到的 HTTP 方法，<code>-H</code>是指定自定义的请求头。</p><h3 id="如何查看一个域名有哪些-NS-记录？"><a href="#如何查看一个域名有哪些-NS-记录？" class="headerlink" title="如何查看一个域名有哪些 NS 记录？"></a><strong>如何查看一个域名有哪些 NS 记录？</strong></h3><p><strong>【解析】</strong> host 指令提供了一个<code>-t</code>参数指定需要查找的记录类型。我们可以使用<code>host -t ns {网址}</code>。另外 dig 也提供了同样的能力。如果你感兴趣，还可以使用<code>man</code>对系统进行操作。</p><h3 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h3><p>在 Linux 上安装程序大概有 2 种思路：</p><ol><li>直接编译源代码；</li><li>使用包管理器。</li></ol><p>受开源运动影响，Linux 上很多软件都可以拿到源代码，这也是 Linux 能取得成功的一个重要原因。接下来我们先尝试用包管理器安装应用，然后再用一个实战的例子，教你如何编译安装<code>nginx</code>。</p><h3 id="包管理器使用"><a href="#包管理器使用" class="headerlink" title="包管理器使用"></a>包管理器使用</h3><p>Linux 下的应用程序多数以软件包的形式发布，用户拿到对应的包之后，使用包管理器进行安装。说到包管理器，就要提到<code>dpkg</code>和<code>rpm</code>。</p><p>我们先说说包。 Linux 下两大主流的包就是<code>rpm</code>和<code>dpkg</code>。</p><p><code>dpkg</code>（debian package），是<code>linux</code>一个主流的社区分支开发出来的。社区就是开源社区，有很多世界顶级的程序员会在社区贡献代码，比如 github。一般衍生于<code>debian</code>的 Linux 版本都支持<code>dpkg</code>，比如<code>ubuntu</code>。</p><p><code>rpm</code>（redhatpackage manager）。在正式讲解之前，我们先来聊聊 RedHat 这家公司。</p><p>RedHat 是一个做 Linux 的公司，你可以把它理解成一家“保险公司”。 很多公司购买红帽的服务，是为了给自己的业务上一个保险。以防万一哪天公司内部搞不定 Linux 底层，或者底层有 Bug，再或者底层不适合当下的业务发展，需要修改等问题，红帽的工程师都可以帮企业解决。</p><p>再比如，RedHat 收购了JBoss，把 JBoss 改名为 WildFly。 像 WildFly 这种工具更多是面向企业级，比如没有大量研发团队的企业会更倾向使用成熟的技术。RedHat 公司也有自己的 Linux，就叫作 RedHat。RedHat 系比较重要的 Linux 有 RedHat/Fedora 等。</p><p>无论是<code>dpkg</code>还是<code>rpm</code>都抽象了自己的包格式，就是以<code>.dpkg</code>或者<code>.rpm</code>结尾的文件。</p><p><code>dpkg</code>和<code>rpm</code>也都提供了类似的能力：</p><ul><li>查询是否已经安装了某个软件包；</li><li>查询目前安装了什么软件包；</li><li>给定一个软件包，进行安装；</li><li>删除一个安装好的软件包。</li></ul><p>关于<code>dpkg</code>和<code>rpm</code>的具体用法，你可以用<code>man</code>进行学习。接下来我们聊聊<code>yum</code>和<code>apt</code>。</p><h4 id="自动依赖管理"><a href="#自动依赖管理" class="headerlink" title="自动依赖管理"></a>自动依赖管理</h4><p>Linux 是一个开源生态，因此工具非常多。工具在给用户使用之前，需要先打成<code>dpkg</code>或者<code>rpm</code>包。 有的时候一个包会依赖很多其他的包，而<code>dpkg</code>和<code>rpm</code>不会对这种情况进行管理，有时候为了装一个包需要先装十几个依赖的包，过程非常艰辛！因此现在多数情况都在用<code>yum</code>和<code>apt</code>。</p><p><strong>yum</strong></p><p>你可能会说，我不用<code>yum</code>也不用<code>apt</code>，我只用<code>docker</code>。首先给你一个连击 666，然后我还是要告诉你，如果你做<code>docker</code>镜像，那么还是要用到<code>yum</code>和<code>apt</code>，因此还是有必要学一下。</p><p><code>yum</code>的全名是 Yellodog Updator，Modified。 看名字就知道它是基于<code>Yellodog Updator</code>这款软件修改而来的一个工具。<code>yum</code>是 Python 开发的，提供的是<code>rpm</code>包，因此只有<code>redhat</code>系的 Linux，比如 Fedora，Centos 支持<code>yum</code>。<code>yum</code>的主要能力就是帮你解决下载和依赖两个问题。</p><p>下载之所以是问题，是因为 Linux 生态非常庞大，有时候用户不知道该去哪里下载一款工具。比如用户想安装<code>vim</code>，只需要输入<code>sudo yum install vim</code>就可以安装了。<code>yum</code>的服务器收集了很多<code>linux</code>软件，因此<code>yum</code>会帮助用户找到<code>vim</code>的包。</p><p>另一方面，<code>yum</code>帮助用户解决了很多依赖，比如用户安装一个软件依赖了 10 个其他的软件，<code>yum</code>会把这 11 个软件一次性的装好。</p><p>关于<code>yum</code>的具体用法，你可以使用man工具进行学习。</p><p><strong>apt</strong></p><p>接下来我们来重点说说<code>apt</code>，然后再一起尝试使用。因为我这次是用<code>ubuntu</code>Linux 给你教学，所以我以 apt 为例子，yum 的用法是差不多的，你可以自己 man 一下。</p><p><code>apt</code>全名是 Advanced Packaging Tools，是一个<code>debian</code>及其衍生 Linux 系统下的包管理器。由于<code>advanced</code>（先进）是相对于<code>dpkg</code>而言的，因此它也能够提供和<code>yum</code>类似的下载和依赖管理能力。比如在没有<code>vim</code>的机器上，我们可以用下面的指令安装<code>vim</code>。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163206.png" alt="image-20210624163206691"></p><p>然后用<code>dpkg</code>指令查看 vim 的状态是<code>ii</code>。第一个<code>i</code>代表期望状态是已安装，第二个<code>i</code>代表实际状态是已安装。</p><p>下面我们卸载<code>vim</code>，再通过<code>dpkg</code>查看，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163234.png" alt="image-20210624163234275"></p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163245.png" alt="image-20210624163245181"></p><p>我们看到 vim 的状态从<code>ii</code>变成了<code>rc</code>，<code>r</code>是期望删除，<code>c</code>是实际上还有配置文件遗留。 如果我们想彻底删除配置文件，可以使用<code>apt purge</code>，就是彻底清除的意思，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163304.png" alt="image-20210624163304544"></p><p>再使用<code>dpkg -l</code>时，<code>vim</code>已经清除了。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163328.png" alt="image-20210624163328213"></p><p>期待结果是<code>u</code>就是 unkonw（未知）说明已经没有了。实际结果是<code>n</code>，就是 not-installed（未安装）。</p><p>如果想查询<code>mysql</code>相关的包，可以使用<code>apt serach mysql</code>，这样会看到很多和<code>mysql</code>相关的包，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163351.png" alt="image-20210624163351037"></p><p>如果我们想精确查找一个叫作<code>mysql-server</code>的包，可以用<code>apt list</code>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163445.png" alt="image-20210624163445128"></p><p>这里我们找到了<code>mysql-server</code>包。</p><p>另外有时候国内的<code>apt</code>服务器速度比较慢，你可以尝试使用阿里云的镜像服务器。具体可参考我下面的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">--以下是文件内容--</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>镜像地址可以通过<code>/etc/apt/sources.list</code>配置，注意<code>focal</code>是我用的<code>ubuntu</code>版本，你可以使用<code>sudo lsb_release</code>查看自己的 Ubuntu 版本。如果你想用我上面给出的内容覆盖你的<code>sources.list</code>，只需把版本号改成你自己的。注意，每个<code>ubuntu</code>版本都有自己的代号。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163604.png" alt="image-20210624163604579"></p><p>通过上面的学习，相信你已经逐渐了解了包管理器的基本概念和使用。如果你是<code>centos</code>或者<code>fedora</code>，需要自己<code>man</code>一下<code>yum</code>。</p><h3 id="编译安装-Nginx"><a href="#编译安装-Nginx" class="headerlink" title="编译安装 Nginx"></a>编译安装 Nginx</h3><p>接下来我们说说编译安装 Nginx（发音是 engine X），是一个家喻户晓的 Web 服务器。 它的发明者是俄国的伊戈尔·赛索耶夫。赛索耶夫 2002 年开始写 Nginx，主要目的是解决同一个互联网节点同时进入大量并发请求的问题。注意，大量并发请求不是大量 QPS 的意思，QPS 是吞吐量大，需要快速响应，而高并发时则需要合理安排任务调度。</p><p>后来塞索耶夫成立了 Nginx 公司， 2018 年估值到达到 4.3 亿美金。现在基本上国内大厂的 Web 服务器都是基于 Nginx，只不过进行了特殊的修改，比如淘宝用 Tengine。</p><p>下面我们再来看看源码安装，在 Linux 上获取<code>nginx</code>源码，可以去搜索 <a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx 官方网站</a>，一般都会提供源码包。</p><p>如上图所示，可以看到 nginx-1.18.0 的网址是：<a href="http://nginx.org/download/nginx-1.19.2.tar.gz%E3%80%82%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E7%94%A8" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.19.2.tar.gz。然后我们用</a> wget 去下载这个包。 wget 是 GNU 项目下的下载工具，GNU 是早期<code>unix</code>项目的一个变种。<code>linux</code>下很多工具都是从<code>unix</code>继承来的，这就是开源的好处，很多工具不用再次开发了。你可能很难想象<code>windows</code>下的命令工具可以在<code>linux</code>下用，但是<code>linux</code>下的工具却可以在任何系统中用。 因此，<code>linux</code>下面的工具发展速度很快，如今已成为最受欢迎的服务器操作系统。</p><p>当然也有同学的机器上没有<code>wget</code>，那么你可以用<code>apt</code>安装一下。</p><ul><li>第一步：下载源码。我们使用<code>wget</code>下载<code>nginx</code>源码包：</li></ul><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164203.png" alt="image-20210624164203352"></p><p>可以像我这样使用<code>cd</code>先切换到家目录。</p><ul><li>第二步：解压。我们解压下载好的<code>nginx</code>源码包。</li></ul><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164220.png" alt="image-20210624164219798"></p><p>用<code>ls</code>发现包已经存在了，然后使用<code>tar</code>命令解压。</p><p><code>tar</code>是用来打包和解压用的。之所以叫作<code>tar</code>是有一些历史原因：<code>t</code>代表<code>tape</code>（磁带）；<code>ar</code>是 archive（档案）。因为早期的存储介质很小，人们习惯把文件打包然后存储到磁带上，那时候<code>unix</code>用的命令就是<code>tar</code>。因为<code>linux</code>是个开源生态，所以就沿袭下来继续使用<code>tar</code>。</p><p><code>-x</code>代表 extract（提取）。-z代表<code>gzip</code>，也就是解压<code>gz</code>类型的文件。<code>-v</code>代表 verbose（显示细节），如果你不输入<code>-v</code>，就不会打印解压过程了。<code>-f</code>代表 file，这里指的是要操作文件，而不是磁带。 所以<code>tar</code>解压通常带有<code>x</code>和<code>f</code>，打包通常是<code>c</code>就是 create 的意思。</p><ul><li>第三步：配置和解决依赖。解压完，我们进入<code>nginx</code>的目录看一看。 如下图所示：</li></ul><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164338.png" alt="image-20210624164338269"></p><p>可以看到一个叫作<code>configure</code>的文件是绿色的，也就是可执行文件。然后我们执行 configure 文件进行配置，这个配置文件来自一款叫作<code>autoconf</code>的工具，也是 GNU 项目下的，说白了就是<code>bash</code>（Bourne Shell）下的安装打包工具（就是个安装程序）。这个安装程序支持很多配置，你可以用<code>./configure --help</code>看到所有的配置项，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164356.png" alt="image-20210624164356170"></p><p>这里有几个非常重要的配置项，叫作<code>prefix</code>。<code>prefix</code>配置项决定了软件的安装目录。如果不配置这个配置项，就会使用默认的安装目录。<code>sbin-path</code>决定了<code>nginx</code>的可执行文件的位置。<code>conf-path</code>决定了<code>nginx</code>配置文件的位置。我们都使用默认，然后执行<code>./configure</code>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164423.png" alt="image-20210624164423509"></p><p><code>autoconf</code>进行依赖检查的时候，报了一个错误，cc 没有找到。这是因为机器上没有安装<code>gcc</code>工具，gcc 是家喻户晓的工具套件，全名是 GNU Compiler Collection——里面涵盖了包括 c/c++ 在内的多门语言的编译器。</p><p>我们用包管理器，安装<code>gcc</code>，如下图所示。安装<code>gcc</code>通常是安装<code>build-essential</code>这个包。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164445.png" alt="image-20210624164445155"></p><p>安装完成之后，再执行<code>./configure</code>，如下图所示：</p><p>我们看到配置程序开始执行。但是最终报了一个错误，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164508.png" alt="image-20210624164508442"></p><p>报错的内容是，<code>nginx</code>的<code>HTTP rewrite</code>模块，需要<code>PCRE</code>库。 PCRE 是<code>perl</code>语言的兼容正则表达式库。<code>perl</code>语言一直以支持原生正则表达式，而受到广大编程爱好者的喜爱。我曾经看到过一个 IBM 的朋友用<code>perl</code>加上<code>wget</code>就实现了一个简单的爬虫。接下来，我们开始安装<code>PCRE</code>。</p><p>一般这种依赖库，会叫<code>pcre-dev</code>或者<code>libpcre</code>。用<code>apt</code>查询了一下，然后<code>grep</code>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164532.png" alt="image-20210624164532229"></p><p>我们看到有<code>pcre2</code>也有<code>pcre3</code>。这个时候可以考虑试试<code>pcre3</code>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164558.png" alt="image-20210624164557771"></p><p>安装完成之后再试试<code>./configure</code>，提示还需要<code>zlib</code>。然后我们用类似的方法解决<code>zlib</code>依赖。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164612.png" alt="image-20210624164611872"></p><p><code>zlib</code>包的名字叫<code>zlib1g</code>不太好找，需要查资料才能确定是这个名字。</p><p>我们再尝试配置，终于配置成功了。</p><ul><li>第四步：编译和安装。</li></ul><p>通常配置完之后，我们输入<code>make &amp;&amp; sudo make install</code>进行编译和安装。<code>make</code>是<code>linux</code>下面一个强大的构建工具。<code>autoconf</code>也就是<code>./configure</code>会在当前目录下生成一个 MakeFile 文件。<code>make</code>会根据<code>MakeFile</code>文件编译整个项目。编译完成后，能够形成和当前操作系统以及 CPU 指令集兼容的二进制可执行文件。然后再用<code>make install</code>安装。<code>&amp;&amp;</code>符号代表执行完<code>make</code>再去执行<code>make installl</code>。</p><p>你可以看到编译是个非常慢的活。等待了差不多 1 分钟，终于结束了。<code>nginx</code>被安装到了<code>/usr/local/nginx</code>中，如果需要让<code>nginx</code>全局执行，可以设置一个软连接到<code>/usr/local/bin</code>，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/<span class="built_in">local</span>/nginx/sbin/nginx /usr/<span class="built_in">local</span>/sbin/nginx</span><br></pre></td></tr></table></figure><h4 id="为什么会有编译安装？"><a href="#为什么会有编译安装？" class="headerlink" title="为什么会有编译安装？"></a>为什么会有编译安装？</h4><p>学完整个编译安装 Ngnix 过程后，你可能会问，为什么会有编译安装这么复杂的事情。</p><p>原来使用 C/C++ 写的程序存在一个交叉编译的问题。就是写一次程序，在很多个平台执行。而不同指令集的 CPU 指令，还有操作系统的可执行文件格式是不同的。因此，这里有非常多的现实问题需要解决。一般是由操作系统的提供方，比如 RedHat 来牵头解决这些问题。你可以用<code>apt</code>等工具提供给用户已经编译好的包。<code>apt</code>会自动根据用户的平台类型选择不同的包。</p><p>但如果某个包没有在平台侧注册，也没有提供某个 Linux 平台的软件包，我们就需要回退到编译安装，通过源代码直接在某个平台安装。</p><p><strong>编译安装和包管理安装有什么优势和劣势？</strong></p><p>老规矩，请你先在脑海里构思下给面试官的表述，并把你的思考写在留言区，然后再来看我接下来的分析。</p><p><strong>【解析】</strong> 包管理安装很方便，但是有两点劣势。</p><p>第一点是需要提前将包编译好，因此有一个发布的过程，如果某个包没有发布版本，或者在某个平台上找不到对应的发布版本，就需要编译安装。</p><p>第二点就是如果一个软件的定制程度很高，可能会在编译阶段传入参数，比如利用<code>configure</code>传入配置参数，这种时候就需要编译安装。</p><h3 id="利用-Linux-指令分析-Web-日志"><a href="#利用-Linux-指令分析-Web-日志" class="headerlink" title="利用 Linux 指令分析 Web 日志"></a><strong>利用 Linux 指令分析 Web 日志</strong></h3><h4 id="第一步：能不能这样做？"><a href="#第一步：能不能这样做？" class="headerlink" title="第一步：能不能这样做？"></a>第一步：能不能这样做？</h4><p>当我们想要分析一个线上文件的时候，首先要思考，能不能这样做？ 这里你可以先用<code>htop</code>指令看一下当前的负载。如果你的机器上没有<code>htop</code>，可以考虑用<code>yum</code>或者<code>apt</code>去安装。</p><p>然后我们用<code>ls</code>查看文件大小。发现这只是一个 7M 的文件，因此对线上的影响可以忽略不计。如果文件太大，建议你用<code>scp</code>指令将文件拷贝到闲置服务器再分析。下图中我使用了<code>--block-size</code>让<code>ls</code>以<code>M</code>为单位显示文件大小。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175451.png" alt="image-20210624175451215"></p><h4 id="第二步：LESS-日志文件"><a href="#第二步：LESS-日志文件" class="headerlink" title="第二步：LESS 日志文件"></a>第二步：LESS 日志文件</h4><p>在分析日志前，给你提个醒，记得要<code>less</code>一下，看看日志里面的内容。之前我们说过，尽量使用<code>less</code>这种不需要读取全部文件的指令，因为在线上执行<code>cat</code>是一件非常危险的事情，这可能导致线上服务器资源不足。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175512.png" alt="image-20210624175512545"></p><p>如上图所示，我们看到<code>nginx</code>的<code>access_log</code>每一行都是一次用户的访问，从左到右依次是：</p><ul><li>IP 地址；</li><li>时间；</li><li>HTTP 请求的方法、路径和协议版本、返回的状态码；</li><li>User Agent。</li></ul><h4 id="第三步：PV-分析"><a href="#第三步：PV-分析" class="headerlink" title="第三步：PV 分析"></a>第三步：PV 分析</h4><p>PV（Page View），用户每访问一个页面就是一次<code>Page View</code>。对于<code>nginx</code>的<code>acess_log</code>来说，分析 PV 非常简单，我们直接使用<code>wc -l</code>就可以看到整体的<code>PV</code>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175634.png" alt="image-20210624175634864"></p><p>如上图所示：我们看到了一共有 51462 条 PV。</p><h4 id="第四步：PV-分组"><a href="#第四步：PV-分组" class="headerlink" title="第四步：PV 分组"></a>第四步：PV 分组</h4><p>通常一个日志中可能有几天的 PV，为了得到更加直观的数据，有时候需要按天进行分组。为了简化这个问题，我们先来看看日志中都有哪些天的日志。</p><p>使用<code>awk &#39;{print $4}&#39; access.log | less</code>可以看到如下结果。<code>awk</code>是一个处理文本的领域专有语言。这里就牵扯到领域专有语言这个概念，英文是Domain Specific Language。领域专有语言，就是为了处理某个领域专门设计的语言。比如awk是用来分析处理文本的DSL，html是专门用来描述网页的DSL，SQL是专门用来查询数据的DSL……大家还可以根据自己的业务设计某种针对业务的DSL。</p><p>你可以看到我们用<code>$4</code>代表文本的第 4 列，也就是时间所在的这一列，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175755.png" alt="image-20210624175754952"></p><p>我们想要按天统计，可以利用 <code>awk</code>提供的字符串截取的能力。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175807.png" alt="image-20210624175807734"></p><p>上图中，我们使用<code>awk</code>的<code>substr</code>函数，数字<code>2</code>代表从第 2 个字符开始，数字<code>11</code>代表截取 11 个字符。</p><p>接下来我们就可以分组统计每天的日志条数了。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175820.png" alt="image-20210624175820453"></p><p>上图中，使用<code>sort</code>进行排序，然后使用<code>uniq -c</code>进行统计。你可以看到从 2015 年 5 月 17 号一直到 6 月 4 号的日志，还可以看到每天的 PV 量大概是在 2000~3000 之间。</p><h4 id="第五步：分析-UV"><a href="#第五步：分析-UV" class="headerlink" title="第五步：分析 UV"></a>第五步：分析 UV</h4><p>接下来我们分析 UV。UV（Uniq Visitor），也就是统计访问人数。通常确定用户的身份是一个复杂的事情，但是我们可以用 IP 访问来近似统计 UV。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175954.png" alt="image-20210624175954237"></p><p>上图中，我们使用 awk 去打印<code>$1</code>也就是第一列，接着<code>sort</code>排序，然后用<code>uniq</code>去重，最后用<code>wc -l</code>查看条数。 这样我们就知道日志文件中一共有<code>2660</code>个 IP，也就是<code>2660</code>个 UV。</p><h4 id="第六步：分组分析-UV"><a href="#第六步：分组分析-UV" class="headerlink" title="第六步：分组分析 UV"></a>第六步：分组分析 UV</h4><p>接下来我们尝试按天分组分析每天的 UV 情况。这个情况比较复杂，需要较多的指令，我们先创建一个叫作<code>sum.sh</code>的<code>bash</code>脚本文件，写入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line">awk <span class="string">'&#123;print substr($4, 2, 11) " " $1&#125;'</span> access.log |\</span><br><span class="line">sort | uniq |\</span><br><span class="line">awk <span class="string">'&#123;uv[$1]++;next&#125;END&#123;for (ip in uv) print ip, uv[ip]&#125;'</span></span><br></pre></td></tr></table></figure><p>具体分析如下。</p><ul><li>文件首部我们使用<code>#!</code>，表示我们将使用后面的<code>/usr/bin/bash</code>执行这个文件。</li><li>第一次<code>awk</code>我们将第 4 列的日期和第 1 列的<code>ip</code>地址拼接在一起。</li><li>下面的<code>sort</code>是把整个文件进行一次字典序排序，相当于先根据日期排序，再根据 IP 排序。</li><li>接下来我们用<code>uniq</code>去重，日期 +IP 相同的行就只保留一个。</li><li>最后的<code>awk</code>我们再根据第 1 列的时间和第 2 列的 IP 进行统计。</li></ul><p>为了理解最后这一行描述，我们先来简单了解下<code>awk</code>的原理。</p><p><code>awk</code>本身是逐行进行处理的。因此我们的<code>next</code>关键字是提醒<code>awk</code>跳转到下一行输入。 对每一行输入，<code>awk</code>会根据第 1 列的字符串（也就是日期）进行累加。之后的<code>END</code>关键字代表一个触发器，就是 END 后面用 {} 括起来的语句会在所有输入都处理完之后执行——当所有输入都执行完，结果被累加到<code>uv</code>中后，通过<code>foreach</code>遍历<code>uv</code>中所有的<code>key</code>，去打印<code>ip</code>和<code>ip</code>对应的数量。</p><p>编写完上面的脚本之后，我们保存退出编辑器。接着执行<code>chmod +x ./sum.sh</code>，给<code>sum.sh</code>增加执行权限。然后我们可以像下图这样执行，获得结果：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625083225.png" alt="image-20210625083225035"></p><h3 id="在成百上千的集群中安装一个-Java-环境"><a href="#在成百上千的集群中安装一个-Java-环境" class="headerlink" title="在成百上千的集群中安装一个 Java 环境"></a>在成百上千的集群中安装一个 Java 环境</h3><h4 id="第一步：搭建学习用的集群"><a href="#第一步：搭建学习用的集群" class="headerlink" title="第一步：搭建学习用的集群"></a>第一步：搭建学习用的集群</h4><p>第一步我们先搭建一个学习用的集群。这里简化一下模型。我在自己的电脑上装一个<code>ubuntu</code>桌面版的虚拟机，然后再装两个<code>ubuntu</code>服务器版的虚拟机。</p><p>相对于桌面版，服务器版对资源的消耗会少很多。我将教学材料中桌面版的<code>ubuntu</code>命名为<code>u1</code>，两个用来被管理的服务器版<code>ubuntu</code>叫作<code>v1</code>和<code>v2</code>。</p><p>用桌面版的原因是：我喜欢<code>ubuntu</code>漂亮的开源字体，这样会让我在给你准备素材的时候拥有一个好心情。如果你对此感兴趣，可以搜索<code>ubuntu mono</code>，尝试把这个字体安装到自己的文本编辑器中。不过我还是觉得在<code>ubuntu</code>中敲代码更有感觉。</p><p>注意，我在这里只用了 3 台服务器，但是接下来我们要写的脚本是可以在很多台服务器之间复用的。</p><h4 id="第二步：循环遍历-IP-列表"><a href="#第二步：循环遍历-IP-列表" class="headerlink" title="第二步：循环遍历 IP 列表"></a>第二步：循环遍历 IP 列表</h4><p>你可以想象一个局域网中有很多服务器需要管理，它们彼此之间网络互通，我们通过一台主服务器对它们进行操作，即通过<code>u1</code>操作<code>v1</code>和<code>v2</code>。</p><p>在主服务器上我们维护一个<code>ip</code>地址的列表，保存成一个文件，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625095958.png" alt="image-20210625095958770"></p><p>目前<code>iplist</code>中只有两项，但是如果我们有足够的机器，可以在里面放成百上千项。接下来，请你思考<code>shell</code>如何遍历这些<code>ip</code>？</p><p>你可以先尝试实现一个最简单的程序，从文件<code>iplist</code>中读出这些<code>ip</code>并尝试用<code>for</code>循环遍历这些<code>ip</code>，具体程序如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">readarray</span> -t ips &lt; iplist</span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="variable">$&#123;ips[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$ip</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>首行的<code>#!</code>叫作 Shebang。Linux 的程序加载器会分析 Shebang 的内容，决定执行脚本的程序。这里我们希望用<code>bash</code>来执行这段程序，因为我们用到的 readarray 指令是<code>bash 4.0</code>后才增加的能力。</p><p><code>readarray</code>指令将 iplist 文件中的每一行读取到变量<code>ips</code>中。<code>ips</code>是一个数组，可以用<code>echo ${ips[@]}</code>打印其中全部的内容：<code>@</code>代表取数组中的全部内容；<code>$</code>符号是一个求值符号。不带<code>$</code>的话，<code>ips[@]</code>会被认为是一个字符串，而不是表达式。</p><p><code>for</code>循环遍历数组中的每个<code>ip</code>地址，<code>echo</code>把地址打印到屏幕上。</p><p>如果用<code>shell</code>执行上面的程序会报错，因为<code>readarray</code>是<code>bash 4.0</code>后支持的能力，因此我们用<code>chomd</code>为<code>foreach.sh</code>增加执行权限，然后直接利用<code>shebang</code>的能力用<code>bash</code>执行，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100100.png" alt="image-20210625100100006"></p><h4 id="第三步：创建集群管理账户"><a href="#第三步：创建集群管理账户" class="headerlink" title="第三步：创建集群管理账户"></a>第三步：创建集群管理账户</h4><p>为了方便集群管理，通常使用统一的用户名管理集群。这个账号在所有的集群中都需要保持命名一致。比如这个集群账号的名字就叫作<code>lagou</code>。</p><p>接下来我们探索一下如何创建这个账户<code>lagou</code>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100117.png" alt="image-20210625100117108"></p><p>上面我们创建了<code>lagou</code>账号，然后把<code>lagou</code>加入<code>sudo</code>分组。这样<code>lagou</code>就有了<code>sudo</code>成为<code>root</code>的能力，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100241.png" alt="image-20210625100241632"></p><p>接下来，我们设置<code>lagou</code>用户的初始化<code>shell</code>是<code>bash</code>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100254.png" alt="image-20210625100254044"></p><p>这个时候如果使用命令<code>su lagou</code>，可以切换到<code>lagou</code>账号，但是你会发现命令行没有了颜色。因此我们可以将原来用户下面的<code>.bashrc</code>文件拷贝到<code>/home/lagou</code>目录下，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100315.png" alt="image-20210625100315812"></p><p>这样，我们就把一些自己平时用的设置拷贝了过去，包括终端颜色的设置。<code>.bashrc</code>是启动<code>bash</code>的时候会默认执行的一个脚本文件。</p><p>接下来，我们编辑一下<code>/etc/sudoers</code>文件，增加一行<code>lagou ALL=(ALL) NOPASSWD:ALL</code>表示<code>lagou</code>账号 sudo 时可以免去密码输入环节，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100334.png" alt="image-20210625100333873"></p><p>我们可以把上面的完整过程整理成指令文件，<code>create_lagou.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m -d /home/lagou lagou</span><br><span class="line">sudo passwd lagou</span><br><span class="line">sudo usermod -G sudo lagou</span><br><span class="line">sudo usermod --shell /bin/bash lagou</span><br><span class="line">sudo cp ~/.bashrc /home/lagou/</span><br><span class="line">sudo chown lagou.lagou /home/lagou/.bashrc</span><br><span class="line">sduo sh -c <span class="string">'echo "lagou ALL=(ALL)  NOPASSWD:ALL"&gt;&gt;/etc/sudoers'</span></span><br></pre></td></tr></table></figure><p>你可以删除用户<code>lagou</code>，并清理<code>/etc/sudoers</code>文件最后一行。用指令<code>userdel lagou</code>删除账户，然后执行<code>create_lagou.sh</code>重新创建回<code>lagou</code>账户。如果发现结果一致，就代表<code>create_lagou.sh</code>功能没有问题。</p><p>最后我们想在<code>v1``v2</code>上都执行<code>create_logou.sh</code>这个脚本。但是你不要忘记，我们的目标是让程序在成百上千台机器上传播，因此还需要一个脚本将<code>create_lagou.sh</code>拷贝到需要执行的机器上去。</p><p>这里，可以对<code>foreach.sh</code>稍做修改，然后分发<code>create_lagou.sh</code>文件。</p><p>如果你的机器非常多，上述过程会变得非常烦琐。你可以先带着这个问题学习下面的<code>Step 4</code>，然后再返回来重新思考这个问题，当然你也可以远程执行脚本。另外，还有一个叫作<code>sshpass</code>的工具，可以帮你把密码传递给要远程执行的指令，如果你对这块内容感兴趣，可以自己研究下这个工具。</p><h4 id="第四步：-打通集群权限"><a href="#第四步：-打通集群权限" class="headerlink" title="第四步： 打通集群权限"></a>第四步： 打通集群权限</h4><p>接下来我们需要打通从主服务器到<code>v1</code>和<code>v2</code>的权限。当然也可以每次都用<code>ssh</code>输入用户名密码的方式登录，但这并不是长久之计。 如果我们有成百上千台服务器，输入用户名密码就成为一件繁重的工作。</p><p>这时候，你可以考虑利用主服务器的公钥在各个服务器间登录，避免输入密码。接下来我们聊聊具体的操作步骤：</p><p>首先，需要在<code>u1</code>上用<code>ssh-keygen</code>生成一个公私钥对，然后把公钥写入需要管理的每一台机器的<code>authorized_keys</code>文件中。如下图所示：我们使用<code>ssh-keygen</code>在主服务器<code>u1</code>中生成公私钥对。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625112735.png" alt="image-20210625112735298"></p><p>然后使用<code>mkdir -p</code>创建<code>~/.ssh</code>目录，<code>-p</code>的优势是当目录不存在时，才需要创建，且不会报错。<code>~</code>代表当前家目录。 如果文件和目录名前面带有一个<code>.</code>，就代表该文件或目录是一个需要隐藏的文件。平时用<code>ls</code>的时候，并不会查看到该文件，通常这种文件拥有特别的含义，比如<code>~/.ssh</code>目录下是对<code>ssh</code>的配置。</p><p>我们用<code>cd</code>切换到<code>.ssh</code>目录，然后执行<code>ssh-keygen</code>。这样会在<code>~/.ssh</code>目录中生成两个文件，<code>id_rsa.pub</code>公钥文件和<code>is_rsa</code>私钥文件。 如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625112814.png" alt="image-20210625112814620"></p><p>可以看到id_rsa.pub文件中是加密的字符串，我们可以把这些字符串拷贝到其他机器对应用户的~/.ssh/authorized_keys文件中，当ssh登录其他机器的时候，就不用重新输入密码了。 这个传播公钥的能力，可以用一个shell脚本执行，这里我用transfer_key.sh实现。</p><p>我们修改一下foreach.sh，并写一个transfer_key.sh配合foreach.sh的工作。transfer_key.sh内容如下：</p><p><em>foreach.sh</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">readarray</span> -t ips &lt; iplist</span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="variable">$&#123;ips[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sh ./transfer_key.sh <span class="variable">$ip</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><em>tranfer_key.sh</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ip=<span class="variable">$1</span></span><br><span class="line">pubkey=$(cat ~/.ssh/id_rsa.pub)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"execute on .. <span class="variable">$ip</span>"</span></span><br><span class="line">ssh lagou@<span class="variable">$ip</span> <span class="string">" </span></span><br><span class="line"><span class="string">mkdir -p ~/.ssh</span></span><br><span class="line"><span class="string">echo <span class="variable">$pubkey</span>  &gt;&gt; ~/.ssh/authorized_keys</span></span><br><span class="line"><span class="string">chmod 700 ~/ssh</span></span><br><span class="line"><span class="string">chmod 600 ~/.ssh/authorized_keys</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure><p>在<code>foreach.sh</code>中我们执行 transfer_key.sh，并且将 IP 地址通过参数传递过去。在 transfer_key.sh 中，用<code>$1</code>读出 IP 地址参数， 再将公钥写入变量<code>pubkey</code>，然后登录到对应的服务器，执行多行指令。用<code>mkdir</code>指令检查<code>.ssh</code>目录，如不存在就创建这个目录。最后我们将公钥追加写入目标机器的<code>~/.ssh/authorized_keys</code>中。</p><p><code>chmod 700</code>和<code>chmod 600</code>是因为某些特定的<code>linux</code>版本需要<code>.ssh</code>的目录为可读写执行，<code>authorized_keys</code>文件的权限为只可读写。而为了保证安全性，组用户、所有用户都不可以访问这个文件。</p><p>此前，我们执行<code>foreach.sh</code>需要输入两次密码。完成上述操作后，我们再登录这两台服务器就不需要输入密码了。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155406.png" alt="image-20210625155359241"></p><p>接下来，我们尝试一下免密登录，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155440.png" alt="image-20210625155440560"></p><h4 id="第五步：单机安装-Java-环境"><a href="#第五步：单机安装-Java-环境" class="headerlink" title="第五步：单机安装 Java 环境"></a>第五步：单机安装 Java 环境</h4><p>在远程部署 Java 环境之前，我们先单机完成以下 Java 环境的安装，用来收集需要执行的脚本。</p><p>在<code>ubuntu</code>上安装<code>java</code>环境可以直接用<code>apt</code>。</p><p>我们通过下面几个步骤脚本配置 Java 环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk</span><br></pre></td></tr></table></figure><p>经过一番等待我们已经安装好了<code>java</code>，然后执行下面的脚本确认<code>java</code>安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> java</span><br><span class="line">java --version</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155533.png" alt="image-20210625155533445"></p><p>根据最小权限原则，执行 Java 程序我们考虑再创建一个用户<code>ujava</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m -d /opt/ujava ujava</span><br><span class="line">sudo usermod --shell /bin/bash lagou</span><br></pre></td></tr></table></figure><p>这个用户可以不设置密码，因为我们不会真的登录到这个用户下去做任何事情。接下来我们为用户配置 Java 环境变量，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155618.png" alt="image-20210625155618741"></p><p>通过两次 ls 追查，可以发现<code>java</code>可执行文件软连接到<code>/etc/alternatives/java</code>然后再次软连接到<code>/usr/lib/jvm/java-11-openjdk-amd64</code>下。</p><p>这样我们就可以通过下面的语句设置 JAVA_HOME 环境变量了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/</span><br></pre></td></tr></table></figure><p>Linux 的环境变量就好比全局可见的数据，这里我们使用 export 设置<code>JAVA_HOME</code>环境变量的指向。如果你想看所有的环境变量的指向，可以使用<code>env</code>指令。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155651.png" alt="image-20210625155651643"></p><p>其中有一个环境变量比较重要，就是<code>PATH</code>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155721.png" alt="image-20210625155721103"></p><p>如上图，我们可以使用<code>shell</code>查看<code>PATH</code>的值，<code>PATH</code>中用<code>:</code>分割，每一个目录都是<code>linux</code>查找执行文件的目录。当用户在命令行输入一个命令，Linux 就会在<code>PATH</code>中寻找对应的执行文件。</p><p>当然我们不希望<code>JAVA_HOME</code>配置后重启一次电脑就消失，因此可以把这个环境变量加入<code>ujava</code>用户的<code>profile</code>中。这样只要发生用户登录，就有这个环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">'echo "export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/" &gt;&gt; /opt/ujava/.bash_profile'</span></span><br></pre></td></tr></table></figure><p>将<code>JAVA_HOME</code>加入<code>bash_profile</code>，这样后续远程执行<code>java</code>指令时就可以使用<code>JAVA_HOME</code>环境变量了。</p><p>最后，我们将上面所有的指令整理起来，形成一个<code>install_java.sh</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install openjdk-11-jdk</span><br><span class="line"></span><br><span class="line">sudo useradd -m -d /opt/ujava ujava</span><br><span class="line"></span><br><span class="line">sudo usermod --shell /bin/bash ujava</span><br><span class="line"></span><br><span class="line">sudo sh -c <span class="string">'echo "export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/" &gt;&gt; /opt/ujava/.bash_profile'</span></span><br></pre></td></tr></table></figure><p><code>apt</code>后面增了一个<code>-y</code>是为了让执行过程不弹出确认提示。</p><h4 id="第六步：远程安装-Java-环境"><a href="#第六步：远程安装-Java-环境" class="headerlink" title="第六步：远程安装 Java 环境"></a>第六步：远程安装 Java 环境</h4><p>终于到了远程安装 Java 环境这一步，我们又需要用到<code>foreach.sh</code>。为了避免每次修改，你可以考虑允许<code>foreach.sh</code>带一个文件参数，指定需要远程执行的脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">readarray</span> -t ips &lt; iplist</span><br><span class="line"></span><br><span class="line">script=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="variable">$&#123;ips[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ssh <span class="variable">$ip</span> <span class="string">'bash -s'</span> &lt; <span class="variable">$script</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>改写后的<code>foreach</code>会读取第一个执行参数作为远程执行的脚本文件。 而<code>bash -s</code>会提示使用标准输入流作为命令的输入；<code>&lt; $script</code>负责将脚本文件内容重定向到远程<code>bash</code>的标准输入流。</p><p>然后我们执行<code>foreach.sh install_java.sh</code>，机器等待 1 分钟左右，在执行结束后，可以用下面这个脚本检测两个机器中的安装情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -u ujava -i /bin/bash -c <span class="string">'echo $JAVA_HOME'</span></span><br><span class="line"></span><br><span class="line">sudo -u ujava -i java --version</span><br></pre></td></tr></table></figure><p><code>check.sh</code>中我们切换到<code>ujava</code>用户去检查<code>JAVA_HOME</code>环境变量和 Java 版本。执行的结果如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155915.png" alt="image-20210625155915600"></p><h3 id="linux命令的一些题目"><a href="#linux命令的一些题目" class="headerlink" title="linux命令的一些题目"></a>linux命令的一些题目</h3><h4 id="搜索文件系统中所有以包含-std字符串且以-h扩展名结尾的文件。"><a href="#搜索文件系统中所有以包含-std字符串且以-h扩展名结尾的文件。" class="headerlink" title="搜索文件系统中所有以包含 std字符串且以.h扩展名结尾的文件。"></a>搜索文件系统中所有以包含 <code>std</code>字符串且以<code>.h</code>扩展名结尾的文件。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -name &quot;*std*.h&quot;</span><br></pre></td></tr></table></figure><h4 id="请问下面这段-Shell-程序的作用是什么？"><a href="#请问下面这段-Shell-程序的作用是什么？" class="headerlink" title="请问下面这段 Shell 程序的作用是什么？"></a>请问下面这段 Shell 程序的作用是什么？</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkfifo pipe1</span><br><span class="line">mkfifo pipe2</span><br><span class="line">echo -n run | cat - pipe1 &gt; pipe2 &amp;</span><br><span class="line">cat &lt; pipe2 &gt; pipe1</span><br></pre></td></tr></table></figure><p>前 2 行代码创建了两个管道文件。</p><p>从第 3 行开始，代码变得复杂。<code>echo -n run</code>就是向输出流中写入一个<code>run</code>字符串（不带回车，所以用<code>-n</code>）。通过管道，将这个结果传递给了<code>cat</code>。<code>cat</code>是 concatenate 的缩写，意思是把文件粘在一起。</p><ul><li>当<code>cat</code>用<code>&gt;</code>重定向输出到一个管道文件时，如果没有其他进程从管道文件中读取内容，<code>cat</code>会阻塞。</li><li>当<code>cat</code>用<code>&lt;</code>读取一个管道内容时，如果管道中没有输入，也会阻塞。</li></ul><p>从这个角度来看，总共有 3 次重定向：</p><ul><li>将<code>-</code>也就是输入流的内容和<code>pipe1</code>内容合并重定向到<code>pipe2</code>；</li><li>将<code>pipe2</code>内容重定向到<code>cat</code>；</li><li>将<code>cat</code>的内容重定向到<code>pipe1</code>。</li></ul><p>仔细观察下路径：<code>pipe1</code>-&gt;<code>pipe2</code>-&gt;<code>pipe1</code>，构成了一个循环。 这样导致管道<code>pipe1</code>管道<code>pipe2</code>中总是有数据（没有数据的时间太短）。于是，就构成了一个无限循环。我们打开执行这个程序后，可以用<code>htop</code>查看当前的 CPU 使用情况，会发现 CPU 占用率很高。</p><h4 id="如果一个目录是只读权限，那么这个目录下面的文件还可写吗？"><a href="#如果一个目录是只读权限，那么这个目录下面的文件还可写吗？" class="headerlink" title="如果一个目录是只读权限，那么这个目录下面的文件还可写吗？"></a>如果一个目录是只读权限，那么这个目录下面的文件还可写吗？</h4><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161610.png" alt="image-20210625161610424"></p><p>你可以看到上图中，foo 目录不可读了，下面的<code>foo/bar</code>文件还可以写。 即便它不可写了，下面的<code>foo/bar</code>文件还是可以写。</p><p>但是想要创建新文件就会出现报错，因为创建新文件也需要改目录文件。这个例子说明 Linux 中的文件内容并没有存在目录中，目录中却有文件清单。</p><h4 id="如何查看正在-TIME-WAIT-状态的连接数量？"><a href="#如何查看正在-TIME-WAIT-状态的连接数量？" class="headerlink" title="如何查看正在 TIME_WAIT 状态的连接数量？"></a>如何查看正在 TIME_WAIT 状态的连接数量？</h4><p>注意，这里有个小坑，就是 netstat 会有两行表头，这两行可以用 tail 过滤掉，下面<code>tail -n +3</code>就是告诉你 tail 从第 3 行开始显示。<code>-a</code>代表显示所有的 socket。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | tail -n +3  | wc -l</span><br></pre></td></tr></table></figure><h4 id="如果你在编译安装-MySQL-时，发现找不到libcrypt-so-，应该如何处理？"><a href="#如果你在编译安装-MySQL-时，发现找不到libcrypt-so-，应该如何处理？" class="headerlink" title="如果你在编译安装 MySQL 时，发现找不到libcrypt.so ，应该如何处理？"></a>如果你在编译安装 MySQL 时，发现找不到libcrypt.so ，应该如何处理？</h4><p>遇到这类问题，首先应该去查资料。 比如查 StackOverflow，搜索关键词：libcrypt.so not found，或者带上自己的操作系统<code>ubuntu</code>。下图是关于 Stackoverflow 的一个解答：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161838.png" alt="image-20210625161837849"></p><h4 id="根据今天的-access-log-分析出有哪些终端访问了这个网站，并给出分组统计结果。"><a href="#根据今天的-access-log-分析出有哪些终端访问了这个网站，并给出分组统计结果。" class="headerlink" title="根据今天的 access_log 分析出有哪些终端访问了这个网站，并给出分组统计结果。"></a>根据今天的 access_log 分析出有哪些终端访问了这个网站，并给出分组统计结果。</h4><p><code>access_log</code>中有<code>Debian</code>和<code>Ubuntu</code>等等。我们可以利用下面的指令看到，第 12 列是终端，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161919.png" alt="image-20210625161919389"></p><p>我们还可以使用<code>sort</code>和<code>uniq</code>查看有哪些终端，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161932.png" alt="image-20210625161932754"></p><p>最后需要写一个脚本，进行统计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat nginx_logs.txt |\</span><br><span class="line">awk &apos;&#123;tms[$12]++;next&#125;END&#123;for (t in tms) print t, tms[t]&#125;&apos;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162004.png" alt="image-20210625162004295"></p><h4 id="根据-access-log-分析出访问量-Top-前三的网页。"><a href="#根据-access-log-分析出访问量-Top-前三的网页。" class="headerlink" title="根据 access_log 分析出访问量 Top 前三的网页。"></a>根据 access_log 分析出访问量 Top 前三的网页。</h4><p>如果不需要 Substring 等复杂的处理，也可以使用<code>sort</code>和<code>uniq</code>的组合。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162028.png" alt="image-20210625162027902"></p><h4 id="bashrc-bash-profile-profile-和-etc-profile-的区别是什么？"><a href="#bashrc-bash-profile-profile-和-etc-profile-的区别是什么？" class="headerlink" title="~/.bashrc ~/.bash_profile, ~/.profile 和 /etc/profile 的区别是什么？"></a>~/.bashrc ~/.bash_profile, ~/.profile 和 /etc/profile 的区别是什么？</h4><p>执行一个 shell 的时候分成<strong>login shell</strong>和<strong>non-login shell</strong>。顾名思义我们使用了<code>sudo``su</code>切换到某个用户身份执行 shell，也就是<code>login shell</code>。还有 ssh 远程执行指令也是 login shell，也就是伴随登录的意思——<code>login shell</code> 会触发很多文件执行，路径如下：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162217.png" alt="image-20210625162217545"></p><p>如果以当前用户身份正常执行一个 shell，比如说<code>./a.sh</code>，就是一个<code>non-login</code>的模式。 这时候不会触发上述的完整逻辑。</p><p>另外shell还有另一种分法，就是<code>interactive</code>和<code>non-interactive</code>。interactive 是交互式的意思，当用户打开一个终端命令行工具后，会进入一个输入命令得到结果的交互界面，这个时候，就是<code>interactive shell</code>。</p><p><code>baserc</code>文件通常只在<code>interactive</code>模式下才会执行，这是因为<code>~/.bashrc</code>文件中通常有这样的语句，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162350.png" alt="image-20210625162349945"></p><p>这个语句通过<code>$-</code>看到当前<code>shell</code>的执行环境，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162413.png" alt="image-20210625162413103"></p><p>带 i 字符的就是<code>interactive</code>，没有带i字符就不是。</p><p>因此， 如果你需要通过 ssh 远程 shell 执行一个文件，你就不是在 interactive 模式下，bashrc 不会触发。但是因为登录的原因，login shell 都会触发，也就是说 profile 文件依然会执行。</p><h3 id="Linux-内核和-Windows-内核有什么区别？"><a href="#Linux-内核和-Windows-内核有什么区别？" class="headerlink" title="Linux 内核和 Windows 内核有什么区别？"></a><strong>Linux 内核和 Windows 内核有什么区别？</strong></h3><p>Windows 和 Linux 是当今两款最主流的服务器操作系统产品，都拥有广泛的用户和信徒。Windows 通过强大的商业运作，驱动了大量优秀人才加盟到它的开发团队中；Linux 通过社区产品的魅力吸引着世界上大量的顶级程序员为它贡献源代码、解答问题。两者在服务器市场上竞争激烈，不分伯仲，但也存在互相扶持的关系。</p><p><strong>今天从一道面试题目“ Linux 内核和 Windows 内核有什么区别</strong>？”入手，去了解这两个操作系统内核的设计，帮助你学习操作系统中最核心的一个概念——内核，并希望这些知识可以伴随你日后的每个系统设计。</p><h4 id="什么是内核？"><a href="#什么是内核？" class="headerlink" title="什么是内核？"></a>什么是内核？</h4><p>说到操作系统，就必须说内核。内核是操作系统中应用连接硬件设备的桥梁。</p><h4 id="内核的能力"><a href="#内核的能力" class="headerlink" title="内核的能力"></a>内核的能力</h4><p>对于一个现代的操作系统来说，它的内核至少应该提供以下 4 种基本能力：</p><ul><li>管理进程、线程（决定哪个进程、线程使用 CPU）；</li><li>管理内存（决定内存用来做什么）；</li><li>连接硬件设备（为进程、和设备间提供通信能力）；</li><li>提供系统调用（接收进程发送来的系统调用）。</li></ul><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162620.png" alt="image-20210625162620146"></p><h4 id="操作系统分层"><a href="#操作系统分层" class="headerlink" title="操作系统分层"></a>操作系统分层</h4><p>从上面 4 种能力来看操作系统和内核之间的关系，通常可以把操作系统分成 3 层，最底层的硬件设备抽象、中间的内核和最上层的应用。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162748.png" alt="image-20210625162748240"></p><h4 id="内核是如何工作的？"><a href="#内核是如何工作的？" class="headerlink" title="内核是如何工作的？"></a>内核是如何工作的？</h4><p><strong>为了帮助你理解什么是内核，请你先思考一个问题：进程和内核的关系，是不是像浏览器请求服务端服务</strong>？你可以先自己思考，然后在留言区写下你此时此刻对这个问题的认知，等学完“模块三”再反过头来回顾这个知识，相信你定会产生新的理解。</p><p>接下来，我们先一起分析一下这个问题。</p><p>内核权限非常高，它可以管理进程、可以直接访问所有的内存，因此确实需要和进程之间有一定的隔离。这个隔离用类似请求/响应的模型，非常符合常理。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162857.png" alt="image-20210625162857681"></p><p>但不同的是在浏览器、服务端模型中，浏览器和服务端是用不同的机器在执行，因此不需要共享一个 CPU。但是在进程调用内核的过程中，这里是存在资源共享的。</p><ul><li>比如，一个机器有 4 个 CPU，不可能让内核用一个 CPU，其他进程用剩下的 CPU。这样太浪费资源了。</li><li>再比如，进程向内核请求 100M 的内存，内核把 100M 的数据传回去。 这个模型不可行，因为传输太慢了。</li></ul><p>所以，这里多数操作系统的设计都遵循一个原则：进程向内核发起一个请求，然后将 CPU 执行权限让出给内核。内核接手 CPU 执行权限，然后完成请求，再转让出 CPU 执行权限给调用进程。</p><h4 id="Linux-的设计"><a href="#Linux-的设计" class="headerlink" title="Linux 的设计"></a>Linux 的设计</h4><p>Linux 操作系统第一版是1991 年林纳斯托·瓦兹（一个芬兰的小伙子，当时 22 岁）用 C 语音写的。 写完之后他在网络上发布了 Linux 内核的源代码。又经过了 3 年的努力，在 1994 年发布了完整的核心 Version 1.0。</p><p>说到 Linux 内核设计，这里有很多有意思的名词。大多数听起来复杂、专业，但是理解起来其实很简单。接下来我们一一讨论。</p><ul><li><strong>Multitask and SMP（Symmetric multiprocessing）</strong></li></ul><p><strong>MultiTask 指多任务</strong>，Linux 是一个多任务的操作系统。多任务就是多个任务可以同时执行，这里的“同时”并不是要求并发，而是在一段时间内可以执行多个任务。当然 Linux 支持并发。</p><p><strong>SMP 指对称多处理</strong>。其实是说 Linux 下每个处理器的地位是相等的，内存对多个处理器来说是共享的，每个处理器都可以访问完整的内存和硬件资源。 这个特点决定了在 Linux 上不会存在一个特定的处理器处理用户程序或者内核程序，它们可以被分配到任何一个处理器上执行。</p><ul><li><strong>ELF（Executable and Linkable Format）</strong></li></ul><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163156.png" alt="image-20210625163156664"></p><p>这个名词翻译过来叫作可执行文件链接格式。这是一种从 Unix 继承而来的可执行文件的存储格式。我们可以看到 ELF 中把文件分成了一个个分段（Segment），每个段都有自己的作用。如果想要深入了解这块知识，会涉及部分编译原理的知识，如果你感兴趣可以去网上多查些资料或者去留言区我们一起讨论。</p><ul><li><strong>Monolithic Kernel</strong></li></ul><p>这个名词翻译过来就是宏内核，宏内核反义词就是 Microkernel ，微内核的意思。Linux 是宏内核架构，这说明 Linux 的内核是一个完整的可执行程序，且内核用最高权限来运行。宏内核的特点就是有很多程序会打包在内核中，比如，文件系统、驱动、内存管理等。当然这并不是说，每次安装驱动都需要重新编译内核，现在 Linux 也可以动态加载内核模块。所以哪些模块在内核层，哪些模块在用户层，这是一种系统层的拆分，并不是很强的物理隔离。</p><p>与宏内核对应，接下来说说<strong>微内核，内核只保留最基本的能力。比如进程调度、虚拟内存、中断。多数应用，甚至包括驱动程序、文件系统，是在用户空间管理的</strong>。</p><p>与宏内核对应，接下来说说<strong>微内核，内核只保留最基本的能力。比如进程调度、虚拟内存、中断。多数应用，甚至包括驱动程序、文件系统，是在用户空间管理的</strong>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163419.png" alt="image-20210625163418940"></p><p>学到这里，你可能会问：在内核层和在用户层有什么区别吗？</p><p>感觉分层其实差不多。 我这里说一个很大的区别，比如说驱动程序是需要频繁调用底层能力的，如果在内核中，性能肯定会好很多。对于微内核设计，驱动在内核外，驱动和硬件设备交互就需要频繁做内核态的切换。</p><p>当然微内核也有它的好处，比如说微内核体积更小、可移植性更强。不过我认为，随着计算能力、存储技术越来越发达，体积小、安装快已经不能算是一个很大的优势了。现在更重要的是如何有效利用硬件设备的性能。</p><p>之所以这么思考，也可能因为我是带着现代的目光回望当时人们对内核的评判，事实上，当时 Linux 团队也因此争论过很长一段时间。 但是我觉得历史往往是螺旋上升的，说不定将来性能发展到了一个新的阶段，像微内核的灵活性、可以提供强大的抽象能力这样的特点，又重新受到人们的重视。</p><p>还有一种就是混合类型内核。 混合类型的特点就是架构像微内核，内核中会有一个最小版本的内核，其他功能会在这个能力上搭建。但是实现的时候，是用宏内核的方式实现的，就是内核被做成了一个完整的程序，大部分功能都包含在内核中。就是在宏内核之内有抽象出了一个微内核。</p><p>上面我们大体介绍了内核几个重要的特性，有关进程、内存、虚拟化等特性，我们会在后面几个模块中逐步讨论。</p><h4 id="Window-设计"><a href="#Window-设计" class="headerlink" title="Window 设计"></a>Window 设计</h4><p>接下来我们说说 Windows 的设计，Windows 和 Linux 的设计有很大程度的相似性。Windows也有内核，它的内核是 C/C++ 写的。准确地说，Windows 有两个内核版本。一个是早期的Windows 9x 内核，早期的 Win95, Win98 都是这个内核。我们今天用的 Windows 7, Windows 10 是另一个内核，叫作 Windows NT。NT 指的是 New Technology。接下来我们讨论的都是 NT 版本的内核。</p><p>下面我找到一张 Windows 内核架构的图片给你一个直观感受。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163747.png" alt="image-20210625163747124"></p><p>Windows 同样支持 Multitask 和 SMP（对称多处理）。Windows 的内核设计属于混合类型。你可以看到内核中有一个 Microkernel 模块。而整个内核实现又像宏内核一样，含有的能力非常多，是一个完整的整体。</p><p>Windows 下也有自己的可执行文件格式，这个格式叫作 Portable Executable（PE），也就是可移植执行文件，扩展名通常是<code>.exe</code>、<code>.dll</code>、<code>.sys</code>等。</p><p>PE 文件的结构和 ELF 结构有很多相通的地方，我找到了一张图片帮助你更直观地理解。 因为这部分知识涉及编译原理，我这里就不详细介绍了</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163858.png" alt="image-20210625163858613"></p><p>Windows 还有很多独特的能力，比如 Hyper-V 虚拟化技术，有关虚拟化技术我们将在“模块八：虚拟化和其他”中详细讲解。</p><h4 id="Linux-内核和-Windows-内核有什么区别？-1"><a href="#Linux-内核和-Windows-内核有什么区别？-1" class="headerlink" title="Linux 内核和 Windows 内核有什么区别？"></a><strong>Linux 内核和 Windows 内核有什么区别？</strong></h4><p>Windows 有两个内核，最新的是 NT 内核，目前主流的 Windows 产品都是 NT 内核。NT 内核和 Linux 内核非常相似，没有太大的结构化差异。</p><p>从整体设计上来看，Linux 是宏内核，NT 内核属于混合型内核。和微内核不同，宏内核和混合类型内核从实现上来看是一个完整的程序。只不过混合类型内核内部也抽象出了微内核的概念，从内核内部看混合型内核的架构更像微内核。</p><p>另外 NT 内核和 Linux 内核还存在着许多其他的差异，比如：</p><ul><li>Linux 内核是一个开源的内核；</li><li>它们支持的可执行文件格式不同；</li><li>它们用到的虚拟化技术不同。</li></ul><h3 id="用户态线程和内核态线程"><a href="#用户态线程和内核态线程" class="headerlink" title="用户态线程和内核态线程"></a><strong>用户态线程和内核态线程</strong></h3><h4 id="什么是用户态和内核态"><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h4><p>Kernel 运行在超级权限模式（Supervisor Mode）下，所以拥有很高的权限。按照权限管理的原则，多数应用程序应该运行在最小权限下。因此，很多操作系统，将内存分成了两个区域：</p><ul><li>内核空间（Kernal Space），这个空间只有内核程序可以访问；</li><li>用户空间（User Space），这部分内存专门给应用程序使用。</li></ul><h4 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h4><p>用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在<strong>用户态（User Mode）</strong> 执行。内核空间中的代码可以访问所有内存，我们称这些程序在<strong>内核态（Kernal Mode）</strong> 执行。</p><h4 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h4><p>如果用户态程序需要执行系统调用，就需要切换到内核态执行。下面我们来讲讲这个过程的原理。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625164318.png" alt="image-20210625164318025"></p><p>如上图所示：内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。当发生系统调用时，用户态的程序发起系统调用。因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。</p><p>发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。关于中断，后续会补充。</p><p>上面我们学习了用户态和内核态，接下来我们从进程和线程的角度进一步思考本课时开头抛出的问题。</p><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>一个应用程序启动后会在内存中创建一个执行副本，这就是<strong>进程</strong>。Linux 的内核是一个 Monolithic Kernel（宏内核），因此可以看作一个进程。也就是开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625164501.png" alt="image-20210625164501467"></p><p>进程可以分成用户态进程和内核态进程两类。用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。</p><p><strong>那么用户态进程如果要执行程序，是否也要向内核申请呢</strong>？</p><p>程序在现代操作系统中并不是以进程为单位在执行，而是以一种轻量级进程（Light Weighted Process），也称作线程（Thread）的形式执行。</p><p>如果进程想要创造更多的线程，就需要思考一件事情，这个线程创建在用户态还是内核态。</p><p>你可能会问，难道不是用户态的进程创建用户态的线程，内核态的进程创建内核态的线程吗？</p><p>其实不是，进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程，接下来我们说说用户态的线程和内核态的线程。</p><h4 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h4><p>用户态线程也称作用户级线程（User Level Thread）。操作系统内核并不知道它的存在，它完全是在用户空间中创建。</p><p>用户级线程有很多优势，比如。</p><ul><li><strong>管理开销小</strong>：创建、销毁不需要系统调用。</li><li><strong>切换成本低</strong>：用户空间程序可以自己维护，不需要走操作系统调度。</li></ul><p>但是这种线程也有很多的缺点。</p><ul><li><strong>与内核协作成本高</strong>：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。</li><li><strong>线程间协作成本高</strong>：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要支付额外的系统调用成本。</li><li><strong>无法利用多核优势</strong>：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。</li><li><strong>操作系统无法针对线程调度进行优化</strong>：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。</li></ul><h4 id="内核态线程"><a href="#内核态线程" class="headerlink" title="内核态线程"></a>内核态线程</h4><p>内核态线程也称作内核级线程（Kernel Level Thread）。这种线程执行在内核态，可以通过系统调用创造一个内核级线程。</p><p>内核级线程有很多优势。</p><ul><li><strong>可以利用多核 CPU 优势</strong>：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。</li><li><strong>操作系统级优化</strong>：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。</li></ul><p>当然内核线程也有一些缺点。</p><ul><li><strong>创建成本高</strong>：创建的时候需要系统调用，也就是切换到内核态。</li><li><strong>扩展性差</strong>：由一个内核程序管理，不可能数量太多。</li><li><strong>切换成本较高</strong>：切换的时候，也同样存在需要内核操作，需要切换内核态。</li></ul><h4 id="用户态线程和内核态线程之间的映射关系"><a href="#用户态线程和内核态线程之间的映射关系" class="headerlink" title="用户态线程和内核态线程之间的映射关系"></a>用户态线程和内核态线程之间的映射关系</h4><p>线程简单理解，就是要执行一段程序。程序不会自发的执行，需要操作系统进行调度。<strong>我们思考这样一个问题，如果有一个用户态的进程，它下面有多个线程。如果这个进程想要执行下面的某一个线程，应该如何做呢</strong>？</p><p>这时，比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。毕竟，内核线程是真正的线程。因为它会分配到 CPU 的执行资源。</p><p>如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。</p><p>这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。</p><p>由此可见，<strong>用户态线程创建成本低，问题明显，不可以利用多核。内核态线程，创建成本高，可以利用多核，切换速度慢</strong>。因此通常我们会在内核中预先创建一些线程，并反复利用这些线程。这样，用户态线程和内核态线程之间就构成了下面 4 种可能的关系：</p><h4 id="多对一（Many-to-One）"><a href="#多对一（Many-to-One）" class="headerlink" title="多对一（Many to One）"></a>多对一（Many to One）</h4><p>用户态进程中的多线程复用一个内核态线程。这样，极大地减少了创建内核态线程的成本，但是线程不可以并发。因此，这种模型现在基本上用的很少。我再多说一句，这里你可能会有疑问，比如：用户态线程怎么用内核态线程执行程序？</p><p>程序是存储在内存中的指令，用户态线程是可以准备好程序让内核态线程执行的。后面的几种方式也是利用这样的方法。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170256.png" alt="image-20210625170256011"></p><h4 id="一对一（One-to-One）"><a href="#一对一（One-to-One）" class="headerlink" title="一对一（One to One）"></a>一对一（One to One）</h4><p>该模型为每个用户态的线程分配一个单独的内核态线程，在这种情况下，每个用户态都需要通过系统调用创建一个绑定的内核线程，并附加在上面执行。 这种模型允许所有线程并发执行，能够充分利用多核优势，Windows NT 内核采取的就是这种模型。但是因为线程较多，对内核调度的压力会明显增加。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170318.png" alt="image-20210625170318451"></p><h4 id="多对多（Many-To-Many）"><a href="#多对多（Many-To-Many）" class="headerlink" title="多对多（Many To Many）"></a>多对多（Many To Many）</h4><p>这种模式下会为 n 个用户态线程分配 m 个内核态线程。m 通常可以小于 n。一种可行的策略是将 m 设置为核数。这种多对多的关系，减少了内核线程，同时也保证了多核心并发。Linux 目前采用的就是该模型。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170357.png" alt="image-20210625170357628"></p><h4 id="两层设计（Two-Level）"><a href="#两层设计（Two-Level）" class="headerlink" title="两层设计（Two Level）"></a>两层设计（Two Level）</h4><p>这种模型混合了多对多和一对一的特点。多数用户态线程和内核线程是 n 对 m 的关系，少量用户线程可以指定成 1 对 1 的关系。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170428.png" alt="image-20210625170428222"></p><p>上图所展现的是一个非常经典的设计。</p><p>我们这节课讲解的问题、考虑到的情况以及解决方法，将为你今后解决实际工作场景中的问题打下坚实的基础。比如处理并发问题、I/O 性能瓶颈、思考数据库连接池的配置等，要想完美地解决问题，就必须掌握这些模型，了解问题的本质上才能更好地思考问题衍生出来的问题。</p><h4 id="用户态线程和内核态线程的区别？"><a href="#用户态线程和内核态线程的区别？" class="headerlink" title="用户态线程和内核态线程的区别？"></a><strong>用户态线程和内核态线程的区别？</strong></h4><p>用户态线程工作在用户空间，内核态线程工作在内核空间。用户态线程调度完全由进程负责，通常就是由进程的主线程负责。相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。内核线程由内核维护，由操作系统调度。</p><p>用户态线程无法跨核心，一个进程的多个用户态线程不能并发，阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限。这些都是用户态线程的劣势。内核线程可以独立执行，操作系统会分配时间片段。因此内核态线程更完整，也称作轻量级进程。内核态线程创建成本高，切换成本高，创建太多还会给调度算法增加压力，因此不会太多。</p><p>实际操作中，往往结合两者优势，将用户态线程附着在内核态线程中执行。</p><h3 id="中断和中断向量"><a href="#中断和中断向量" class="headerlink" title="中断和中断向量"></a><strong>中断和中断向量</strong></h3><h4 id="如何设计响应键盘的整个链路？"><a href="#如何设计响应键盘的整个链路？" class="headerlink" title="如何设计响应键盘的整个链路？"></a>如何设计响应键盘的整个链路？</h4><p>当你拿到一个问题时，需要冷静下来思考和探索解决方案。你可以查资料、看视频或者咨询专家，但是在这之前，你先要进行一定的思考和梳理，有的问题可以直接找到答案，有的问题却需要继续深挖寻找其背后的理论支撑。</p><p><strong>问题 1：我们的目标是什么?</strong></p><p>我们的目标是在 Java/JS 中实现按键响应程序。这种实现有点像 Switch-Case 语句——根据不同的按键执行不同的程序，比如按下回车键可以换行，按下左右键可以移动光标。</p><p><strong>问题 2：按键怎么抽象？</strong></p><p>键盘上一般不超过 100 个键。因此我们可以考虑用一个 Byte 的数据来描述用户按下了什么键。按键有两个操作，一个是按下、一个是释放，这是两个不同的操作。对于一个 8 位的字节，可以考虑用最高位的 1 来描述按下还是释放的状态，然后后面的 7 位（0~127）描述具体按了哪个键。这样我们只要确定了用户按键/释放的顺序，对我们的系统来说，就不会有歧义。</p><p><strong>问题 3：如何处理按键？使用操作系统处理还是让每个程序自己实现？</strong></p><p>处理按键是一个通用程序，可以考虑由操作系统先进行一部分处理，比如：</p><ul><li>用户按下了回车键，先由操作系统进行统一的封装，再把按键的编码转换为字符串<code>Enter</code>方便各种程序使用。</li><li>处理组合键这种操作，由操作系统先一步进行计算比较好。因为底层只知道按键、释放，组合键必须结合时间因素判断。</li></ul><p>你可以把下面这种情况看作是一个<code>Ctrl + C</code>组合键，这种行为可以由操作系统进行统一处理，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">按下 Ctrl</span><br><span class="line">按下 C</span><br><span class="line">释放 Ctrl</span><br><span class="line">释放 C</span><br></pre></td></tr></table></figure><p><strong>问题 4：程序用什么模型响应按键？</strong></p><p>当一个 Java 或者 JS 写的应用程序想要响应按键时，应该考虑消息模型。因为如果程序不停地扫描按键，会给整个系统带来很大的负担。比如程序写一个<code>while</code>循环去扫描有没有按键，开销会很大。 如果程序在操作系统端注册一个响应按键的函数，每次只有真的触发按键时才执行这个函数，这样就能减少开销了。</p><p><strong>问题 5：处理用户按键，需不需要打断正在执行的程序？</strong></p><p>从用户体验上讲，按键应该是一个高优先级的操作，比如用户按 Ctrl+C 或者 Esc 的时候，可能是因为用户想要打断当前执行的程序。即便是用户只想要输入，也应该尽可能地集中资源给到用户，因为我们不希望用户感觉到延迟。</p><p>如果需要考虑到程序随时会被中断，去响应其他更高优先级的情况，那么从程序执行的底层就应该支持这个行为，而且最好从硬件层面去支持，这样速度最快。 这就引出了本课时的主角——中断。具体如何处理，见下面我们关于中断部分的分析。</p><p><strong>问题 6：操作系统如何知道用户按了哪个键？</strong></p><p>这里有一个和问题 5 类似的问题。操作系统是不断主动触发读取键盘按键，还是每次键盘按键到来的时候都触发一段属于操作系统的程序呢？</p><p>显然，后者更节省效率。</p><p>那么谁能随时随地中断操作系统的程序？ 谁有这个权限？是管理员账号吗？ 当然不是，拥有这么高权限的应该是机器本身。</p><p>我们思考下这个模型，用户每次按键，触发一个 CPU 的能力，这个能力会中断正在执行的程序，去处理按键。那 CPU 内部是不是应该有处理按键的程序呢？这肯定不行，因为我们希望 CPU 就是用来做计算的，如果 CPU 内部有自带的程序，会把问题复杂化。这在软件设计中，叫作耦合。CPU 的工作就是专注高效的执行指令。</p><p>因此，每次按键，必须有一个机制通知 CPU。我们可以考虑用总线去通知 CPU，也就是主板在通知 CPU。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625171945.png" alt="image-20210625171945006"></p><p>那么 CPU 接收到通知后，如何通知操作系统呢？CPU 只能中断正在执行的程序，然后切换到另一个需要执行的程序。说白了就是改变 PC 指针，CPU 只有这一种办法切换执行的程序。这里请你思考，是不是只有这一种方法：CPU 中断当前执行的程序，然后去执行另一个程序，才能改变 PC 指针？</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625172114.png" alt="image-20210625172114377"></p><p>接下来我们进一步思考，CPU 怎么知道 PC 指针应该设置为多少呢？是不是 CPU 知道操作系统响应按键的程序位置呢？</p><p>答案当然是不知道。</p><p>因此，我们只能控制 CPU 跳转到一个固定的位置。比如说 CPU 一收到主板的信息（某个按键被触发），CPU 就马上中断当前执行的程序，将 PC 指针设置为 0。也就是 PC 指针下一步会从内存地址 0 中读取下一条指令。当然这只是我们的一个思路，具体还需要进一步考虑。而操作系统要做的就是在这之前往内存地址 0 中写一条指令，比如说让 PC 指针跳转到自己处理按键程序的位置。</p><p>讲到这里，我们总结一下，CPU 要做的就是一看到中断，就改变 PC 指针（相当于中断正在执行的程序），而 PC 改变成多少，可以根据不同的类型来判断，比如按键就到 0。操作系统就要向这些具体的位置写入指令，当中断发生时，接管程序的控制权，也就是让 PC 指针指向操作系统处理按键的程序。</p><p>上面这个模型和实际情况还有出入，但是我们已经开始逐渐完善了。</p><p><strong>问题 7：主板如何知道键盘被按下?</strong></p><p>经过一层一层地深挖“如何设计响应键盘的整个链路？”这个问题，目前操作系统已经能接管按键，接下来，我们还需要思考主板如何知道有按键，并且通知 CPU。</p><p>你可以把键盘按键看作按下了某个开关，我们需要一个芯片将按键信息转换成具体按键的值。比如用户按下 A 键，A 键在第几行、第几列，可以看作一个电学信号。接着我们需要芯片把这个电学信号转化为具体的一个数字（一个 Byte）。转化完成后，主板就可以接收到这个数字（按键码），然后将数字写入自己的一个寄存器中，并通知 CPU。</p><p>为了方便 CPU 计算，CPU 接收到主板通知后，按键码会被存到一个寄存器里，这样方便处理按键的程序执行。</p><p>通过对以上 7 个问题的思考和分析，我们已经有了一个粗浅的设计，接下来就要开始整理思路了。</p><h4 id="思路的整理：中断的设计"><a href="#思路的整理：中断的设计" class="headerlink" title="思路的整理：中断的设计"></a>思路的整理：中断的设计</h4><p>整体设计分成了 3 层，第一层是硬件设计、第二层是操作系统设计、第三层是程序语言的设计。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625172558.png" alt="image-20210625172558167"></p><p>按键码的收集，是键盘芯片和主板的能力。主板知道有新的按键后，通知 CPU，CPU 要中断当前执行的程序，将 PC 指针跳转到一个固定的位置，我们称为一次<strong>中断</strong>（<strong>interrupt</strong>）。</p><p>考虑到系统中会出现各种各样的事件，我们需要根据中断类型来判断PC 指针跳转的位置，中断类型不同，PC 指针跳转的位置也可能会不同。比如按键程序、打印机就绪程序、系统异常等都需要中断，包括在“<strong>14 课时</strong>”我们学习的系统调用，也需要中断正在执行的程序，切换到内核态执行内核程序。</p><p>考虑到系统中会出现各种各样的事件，我们需要根据中断类型来判断PC 指针跳转的位置，中断类型不同，PC 指针跳转的位置也可能会不同。比如按键程序、打印机就绪程序、系统异常等都需要中断.</p><p>因此我们需要把不同的中断类型进行分类，这个类型叫作<strong>中断识别码</strong>。比如按键，我们可以考虑用编号 16，数字 16 就是按键中断类型的识别码。不同类型的中断发生时，CPU 需要知道 PC 指针该跳转到哪个地址，这个地址，称为<strong>中断向量（Interupt Vector）。</strong></p><p>你可以考虑这样的实现：当编号 16 的中断发生时，32 位机器的 PC 指针直接跳转到内存地址 16*4 的内存位置。如果设计最多有 255 个中断，编号就是从 0~255，刚好需要 1K 的内存地址存储中断向量——这个 1K 的空间，称为<strong>中断向量表</strong>。</p><p>因此 CPU 接收到中断后，CPU 根据中断类型操作 PC 指针，找到中断向量。操作系统必须在这之前，修改中断向量，插入一条指令。比如操作系统在这里写一条<code>Jump</code>指令，将 PC 指针再次跳转到自己处理对应中断类型的程序。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625172807.png" alt="image-20210625172807759"></p><p>操作系统接管之后，以按键程序为例，操作系统会进行一些处理，包括下面的几件事情：</p><ol><li>将按键放入一个队列，保存下来。这是因为，操作系统不能保证及时处理所有的按键，比如当按键过快时，需要先存储下来，再分时慢慢处理。</li><li>计算组合键。可以利用按下、释放之间的时间关系。</li><li>经过一定计算将按键抽象成消息（事件结构或对象）。</li><li>提供 API 给应用程序，让应用程序可以监听操作系统处理后的消息。</li><li>分发按键消息给监听按键的程序。</li></ol><p>所以程序在语言层面，比如像 Java/Node.js 这种拥有虚拟机的语言，只需要对接操作系统 API 就可以了。</p><h4 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h4><p>接下来我们一起讨论下中断的分类方法：</p><ul><li>按照中断的触发方分成<strong>同步中断和异步中断</strong>；</li><li>根据中断是否强制触发分成<strong>可屏蔽中断和不可屏蔽中断</strong>。</li></ul><p>中断可以由 CPU 指令直接触发，这种主动触发的中断，叫作<strong>同步中断</strong>。同步中断有几种情况。</p><ul><li>之前我们学习的系统调用，需要从用户态切换内核态，这种情况需要程序触发一个中断，叫作<strong>陷阱</strong>（Trap），中断触发后需要继续执行系统调用。</li><li>还有一种同步中断情况是错误（Fault），通常是因为检测到某种错误，需要触发一个中断，中断响应结束后，会重新执行触发错误的地方，比如后面我们要学习的缺页中断。</li><li>最后还有一种情况是程序的异常，这种情况和 Trap 类似，用于实现程序抛出的异常。</li></ul><p>另一部分中断不是由 CPU 直接触发，是因为需要响应外部的通知，比如响应键盘、鼠标等设备而触发的中断。这种中断我们称为<strong>异步中断</strong>。</p><p>CPU 通常都支持设置一个中断屏蔽位（一个寄存器），设置为 1 之后 CPU 暂时就不再响应中断。对于键盘鼠标输入，比如陷阱、错误、异常等情况，会被临时屏蔽。但是对于一些特别重要的中断，比如 CPU 故障导致的掉电中断，还是会正常触发。可以被屏蔽的中断我们称为<strong>可屏蔽中断，多数中断都是可屏蔽中断</strong>。</p><p>所以这里我们讲了两种分类方法，一种是同步中断和异步中断。另一种是可屏蔽中断和不可屏蔽中断。</p><h4 id="Java-Js-等语言为什么可以捕获到键盘输入？"><a href="#Java-Js-等语言为什么可以捕获到键盘输入？" class="headerlink" title="Java/Js 等语言为什么可以捕获到键盘输入？"></a><strong>Java/Js 等语言为什么可以捕获到键盘输入？</strong></h4><p>为了捕获到键盘输入，硬件层面需要把按键抽象成中断，中断 CPU 执行。CPU 根据中断类型找到对应的中断向量。操作系统预置了中断向量，因此发生中断后操作系统接管了程序。操作系统实现了基本解析按键的算法，将按键抽象成键盘事件，并且提供了队列存储多个按键，还提供了监听按键的 API。因此应用程序，比如 Java/Node.js 虚拟机，就可以通过调用操作系统的 API 使用键盘事件。</p><p><strong>Unix 和 Mac OS 内核属于哪种类型？</strong></p><p>Unix 和 Linux 非常类似，也是宏内核。Mac OS 用的是 XNU 内核， XNU 是一种混合型内核。为了帮助你理解，我找了一张 Mac OS 的内核架构图。 如下图所示，可以看到内部是一个叫作 XNU 的宏内核。XNU 是 X is not Unix 的意思， 是一个受 Unix 影响很大的内核。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625184430.png" alt="image-20210625184430161"></p><p><strong>JVM 的线程是用户态线程还是内核态线程？</strong></p><p>JVM 自己本身有一个线程模型。在 JDK 1.1 的时候，JVM 自己管理用户级线程。这样做缺点非常明显，操作系统只调度内核级线程，用户级线程相当于基于操作系统分配到进程主线程的时间片，再次拆分，因此无法利用多核特性。</p><p>为了解决这个问题，后来 Java 改用线程映射模型，因此，需要操作系统支持。在 Windows 上是 1 对 1 的模型，在 Linux 上是 n 对 m 的模型。顺便说一句，Linux 的PThreadAPI 创建的是用户级线程，如果 Linux 要创建内核级线程有KThreadAPI。映射关系是操作系统自动完成的，用户不需要管。</p><p><strong>操作系统可以处理键盘按键，这很好理解，但是在开机的时候系统还没有载入内存，为什么可以使用键盘呢？这个怎么解释？</strong></p><p>主板的一块 ROM 上往往还有一个简化版的操作系统，叫 BIOS（Basic Input/Ouput System）。在 OS 还没有接管计算机前，先由 BIOS 管理机器，并协助加载 OS 到内存。早期的 OS 还会利用 BIOS 的能力，现代的 OS 接管后，就会替换掉 BIOS 的中断向量。</p><p><strong>林纳斯 21 岁写出 Linux，那么开发一个操作系统的难度到底大不大？</strong></p><p>毫无疑问能在 21 岁就写出 Linux 的人定是天赋异禀，林纳斯是参照一个 Minix 系统写的 Linux 内核。如果你对此感兴趣，可以参考这个 1991 年的源代码。</p><p>写一个操作系统本身并不是非常困难。需要了解一些基础的数据结构与算法，硬件设备工作原理。关键是要有参照，比如核心部分可以参考前人的内核。</p><p>但是随着硬件、软件技术发展了这么多年，如果想再写一个大家能够接受的内核，是一件非常困难的事情。内核的能力在上升，硬件的种类在上升，所以 Android 和很多后来的操作系统都是拿 Linux 改装。</p><h3 id="进程和线程-1"><a href="#进程和线程-1" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程（Process），顾名思义就是正在执行的应用程序，是软件的执行副本。而线程是轻量级的进程。</p><p>进程是分配资源的基础单位。而线程很长一段时间被称作轻量级进程（Light Weighted Process），是程序执行的基本单位。</p><p>在计算机刚刚诞生的年代，程序员拿着一个写好程序的闪存卡，插到机器里，然后电能推动芯片计算，芯片每次从闪存卡中读出一条指令，执行后接着读取下一条指令。闪存中的所有指令执行结束后，计算机就关机。</p><p>一开始，这种单任务的模型，在那个时代叫作作业（Job），当时计算机的设计就是希望可以多处理作业。图形界面出现后，人们开始利用计算机进行办公、购物、聊天、打游戏等，因此一台机器正在执行的程序会被随时切来切去。于是人们想到，设计进程和线程来解决这个问题。</p><p>每一种应用，比如游戏，执行后是一个进程。但是游戏内部需要图形渲染、需要网络、需要响应用户操作，这些行为不可以互相阻塞，必须同时进行，这样就设计成线程。</p><h4 id="资源分配问题"><a href="#资源分配问题" class="headerlink" title="资源分配问题"></a>资源分配问题</h4><p>设计进程和线程，操作系统需要思考分配资源。最重要的 3 种资源是：计算资源（CPU）、内存资源和文件资源。早期的 OS 设计中没有线程，3 种资源都分配给进程，多个进程通过分时技术交替执行，进程之间通过管道技术等进行通信。</p><p>但是这样做的话，设计者们发现用户（程序员），一个应用往往需要开多个进程，因为应用总是有很多必须要并行做的事情。并行并不是说绝对的同时，而是说需要让这些事情看上去是同时进行的——比如图形渲染和响应用户输入。于是设计者们想到了，进程下面，需要一种程序的执行单位，仅仅被分配 CPU 资源，这就是线程。</p><h4 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h4><p>线程设计出来后，因为只被分配了计算资源（CPU），因此被称为轻量级进程。被分配的方式，就是由操作系统调度线程。操作系统创建一个进程后，进程的入口程序被分配到了一个主线程执行，这样看上去操作系统是在调度进程，其实是调度进程中的线程。</p><p>这种被操作系统直接调度的线程，我们也成为内核级线程。另外，有的程序语言或者应用，用户（程序员）自己还实现了线程。相当于操作系统调度主线程，主线程的程序用算法实现子线程，这种情况我们称为用户级线程。Linux 的 PThread API 就是用户级线程，KThread API 则是内核级线程。</p><h4 id="分时和调度"><a href="#分时和调度" class="headerlink" title="分时和调度"></a>分时和调度</h4><p>因为通常机器中 CPU 核心数量少（从几个到几十个）、进程&amp;线程数量很多（从几十到几百甚至更多），你可以类比为发动机少，而机器多，因此进程们在操作系统中只能排着队一个个执行。每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。再强调一下，现代操作系统都是直接调度线程，不会调度进程。</p><h4 id="分配时间片段"><a href="#分配时间片段" class="headerlink" title="分配时间片段"></a>分配时间片段</h4><p>如下图所示，进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始。这个就是分时技术。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231718.png" alt="image-20210625231711276"></p><p>下面这张图更加直观一些，进程 P1 先执行一个时间片段，然后进程 P2 开始执行一个时间片段， 然后进程 P3，然后进程 P4……</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231734.png" alt="image-20210625231734470"></p><p>注意，上面的两张图是以进程为单位演示，如果换成线程，操作系统依旧是这么处理。</p><h4 id="进程和线程的状态"><a href="#进程和线程的状态" class="headerlink" title="进程和线程的状态"></a>进程和线程的状态</h4><p>一个进程（线程）运行的过程，会经历以下 3 个状态：</p><p>进程（线程）创建后，就开始排队，此时它会处在“就绪”（Ready）状态；</p><p>当轮到该进程（线程）执行时，会变成“运行”（Running）状态；</p><p>当一个进程（线程）将操作系统分配的时间片段用完后，会回到“就绪”（Ready）状态。</p><p>我这里一直用进程(线程）是因为旧的操作系统调度进程，没有线程；现代操作系统调度线程。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231804.png" alt="image-20210625231804573"></p><p>有时候一个进程（线程）会等待磁盘读取数据，或者等待打印机响应，此时进程自己会进入“阻塞”（Block）状态。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231821.png" alt="image-20210625231821657"></p><p>因为这时计算机的响应不能马上给出来，而是需要等待磁盘、打印机处理完成后，通过中断通知 CPU，然后 CPU 再执行一小段中断控制程序，将控制权转给操作系统，操作系统再将原来阻塞的进程（线程）置为“就绪”（Ready）状态重新排队。</p><p>而且，一旦一个进程（线程）进入阻塞状态，这个进程（线程）此时就没有事情做了，但又不能让它重新排队（因为需要等待中断），所以进程（线程）中需要增加一个“阻塞”（Block）状态。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231849.png" alt="image-20210625231849282"></p><p>注意，因为一个处于“就绪”（Ready）的进程（线程）还在排队，所以进程（线程）内的程序无法执行，也就是不会触发读取磁盘数据的操作，这时，“就绪”（Ready）状态无法变成阻塞的状态，因此下图中没有从就绪到阻塞的箭头。</p><p>而处于“阻塞”（Block）状态的进程（线程）如果收到磁盘读取完的数据，它又需要重新排队，所以它也不能直接回到“运行”（Running）状态，因此下图中没有从阻塞态到运行态的箭头。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231932.png" alt="image-20210625231932849"></p><h4 id="进程和线程的设计"><a href="#进程和线程的设计" class="headerlink" title="进程和线程的设计"></a>进程和线程的设计</h4><p>接下来我们思考几个核心的设计约束：</p><p>进程和线程在内存中如何表示？需要哪些字段？</p><p>进程代表的是一个个应用，需要彼此隔离，这个隔离方案如何设计？</p><p>操作系统调度线程，线程间不断切换，这种情况如何实现？</p><p>需要支持多 CPU 核心的环境，针对这种情况如何设计？</p><p>接下来我们来讨论下这4个问题。</p><h4 id="进程和线程的表示"><a href="#进程和线程的表示" class="headerlink" title="进程和线程的表示"></a>进程和线程的表示</h4><p>可以这样设计，在内存中设计两张表，一张是进程表、一张是线程表。</p><p>进程表记录进程在内存中的存放位置、PID 是多少、当前是什么状态、内存分配了多大、属于哪个用户等，这就有了进程表。如果没有这张表，进程就会丢失，操作系统不知道自己有哪些进程。这张表可以考虑直接放到内核中。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625232027.png" alt="image-20210625232027197"></p><p>细分的话，进程表需要这几类信息。</p><p>描述信息：这部分是描述进程的唯一识别号，也就是 PID，包括进程的名称、所属的用户等。</p><p>资源信息：这部分用于记录进程拥有的资源，比如进程和虚拟内存如何映射、拥有哪些文件、在使用哪些 I/O 设备等，当然 I/O 设备也是文件。</p><p>内存布局：操作系统也约定了进程如何使用内存。如下图所示，描述了一个进程大致内存分成几个区域，以及每个区域用来做什么。 每个区域我们叫作一个段。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625232119.png" alt="image-20210625232118993"></p><p>操作系统还需要一张表来管理线程，这就是线程表。线程也需要 ID， 可以叫作 ThreadID。然后线程需要记录自己的执行状态（阻塞、运行、就绪）、优先级、程序计数器以及所有寄存器的值等等。线程需要记录程序计数器和寄存器的值，是因为多个线程需要共用一个 CPU，线程经常会来回切换，因此需要在内存中保存寄存器和 PC 指针的值。</p><p>用户级线程和内核级线程存在映射关系，因此可以考虑在内核中维护一张内核级线程的表，包括上面说的字段。</p><p>如果考虑到这种映射关系，比如 n-m 的多对多映射，可以将线程信息还是存在进程中，每次执行的时候才使用内核级线程。相当于内核中有个线程池，等待用户空间去使用。每次用户级线程把程序计数器等传递过去，执行结束后，内核线程不销毁，等待下一个任务。这里其实有很多灵活的实现，总体来说，创建进程开销大、成本高；创建线程开销小，成本低。</p><h4 id="隔离方案"><a href="#隔离方案" class="headerlink" title="隔离方案"></a>隔离方案</h4><p>操作系统中运行了大量进程，为了不让它们互相干扰，可以考虑为它们分配彼此完全隔离的内存区域，即便进程内部程序读取了相同地址，而实际的物理地址也不会相同。这就好比 A 小区的 10 号楼 808 和 B 小区的 10 号楼 808 不是一套房子，这种方法叫作地址空间，我们将在“21 讲”的页表部分讨论“地址空间”的详细内容。</p><p>所以在正常情况下进程 A 无法访问进程 B 的内存，除非进程 A 找到了某个操作系统的漏洞，恶意操作了进程 B 的内存，或者利用我们在“21 讲”讲到的“进程间通信”的手段。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234904.png" alt="image-20210625234904626"></p><p>对于一个进程的多个线程来说，可以考虑共享进程分配到的内存资源，这样线程就只需要被分配执行资源。</p><h4 id="进程（线程）切换"><a href="#进程（线程）切换" class="headerlink" title="进程（线程）切换"></a>进程（线程）切换</h4><p>进程（线程）在操作系统中是不断切换的，现代操作系统中只有线程的切换。 每次切换需要先保存当前寄存器的值的内存，注意 PC 指针也是一种寄存器。当恢复执行的时候，就需要从内存中读出所有的寄存器，恢复之前的状态，然后执行。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234920.png" alt="image-20210625234920411"></p><p>上面讲到的内容，我们可以概括为以下 5 个步骤：</p><p>当操作系统发现一个进程（线程）需要被切换的时候，直接控制 PC 指针跳转是非常危险的事情，所以操作系统需要发送一个“中断”信号给 CPU，停下正在执行的进程（线程）。</p><p>当 CPU 收到中断信号后，正在执行的进程（线程）会立即停止。注意，因为进程（线程）马上被停止，它还来不及保存自己的状态，所以后续操作系统必须完成这件事情。</p><p>操作系统接管中断后，趁寄存器数据还没有被破坏，必须马上执行一小段非常底层的程序（通常是汇编编写），帮助寄存器保存之前进程（线程）的状态。</p><p>操作系统保存好进程状态后，执行调度程序，决定下一个要被执行的进程（线程）。</p><p>最后，操作系统执行下一个进程（线程）。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234931.png" alt="image-20210625234931667"></p><p>当然，一个进程（线程）被选择执行后，它会继续完成之前被中断时的任务，这需要操作系统来执行一小段底层的程序帮助进程（线程）恢复状态。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234944.png" alt="image-20210625234944395"></p><p>一种可能的算法就是通过栈这种数据结构。进程（线程）中断后，操作系统负责压栈关键数据（比如寄存器）。恢复执行时，操作系统负责出栈和恢复寄存器的值。</p><h4 id="多核处理"><a href="#多核处理" class="headerlink" title="多核处理"></a>多核处理</h4><p>在多核系统中我们上面所讲的设计原则依然成立，只不过动力变多了，可以并行执行的进程（线程）。通常情况下，CPU 有几个核，就可以并行执行几个进程（线程）。这里强调一个概念，我们通常说的并发，英文是 concurrent，指的在一段时间内几个任务看上去在同时执行（不要求多核）；而并行，英文是 parallel，任务必须绝对的同时执行（要求多核）。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234955.png" alt="image-20210625234955314"></p><p>比如一个 4 核的 CPU 就好像拥有 4 条流水线，可以并行执行 4 个任务。一个进程的多个线程执行过程则会产生竞争条件，这块我们会在“19 讲”锁和信号量部分给你介绍。因为操作系统提供了保存、恢复进程状态的能力，使得进程（线程）也可以在多个核心之间切换。</p><h4 id="创建进程（线程）的-API"><a href="#创建进程（线程）的-API" class="headerlink" title="创建进程（线程）的 API"></a>创建进程（线程）的 API</h4><p>用户想要创建一个进程，最直接的方法就是从命令行执行一个程序，或者双击打开一个应用。但对于程序员而言，显然需要更好的设计。</p><p>站在设计者的角度，你可以这样思考：首先，应该有 API 打开应用，比如可以通过函数打开某个应用；另一方面，如果程序员希望执行完一段代价昂贵的初始化过程后，将当前程序的状态复制好几份，变成一个个单独执行的进程，那么操作系统提供了 fork 指令。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625235008.png" alt="image-20210625235008770"></p><p>也就是说，每次 fork 会多创造一个克隆的进程，这个克隆的进程，所有状态都和原来的进程一样，但是会有自己的地址空间。如果要创造 2 个克隆进程，就要 fork 两次。</p><p>你可能会问：那如果我就是想启动一个新的程序呢？</p><p>我在上文说过：操作系统提供了启动新程序的 API。</p><p>你可能还会问：如果我就是想用一个新进程执行一小段程序，比如说每次服务端收到客户端的请求时，我都想用一个进程去处理这个请求。</p><p>如果是这种情况，我建议你不要单独启动进程，而是使用线程。因为进程的创建成本实在太高了，因此不建议用来做这样的事情：要创建条目、要分配内存，特别是还要在内存中形成一个个段，分成不同的区域。所以通常，我们更倾向于多创建线程。</p><p>不同程序语言会自己提供创建线程的 API，比如 Java 有 Thread 类；go 有 go-routine（注意不是协程，是线程）。</p><h4 id="进程的开销比线程大在了哪里？"><a href="#进程的开销比线程大在了哪里？" class="headerlink" title="进程的开销比线程大在了哪里？"></a>进程的开销比线程大在了哪里？</h4><p>Linux 中创建一个进程自然会创建一个线程，也就是主线程。创建进程需要为进程划分出一块完整的内存空间，有大量的初始化操作，比如要把内存分段（堆栈、正文区等）。创建线程则简单得多，只需要确定 PC 指针和寄存器的值，并且给线程分配一个栈用于执行程序，同一个进程的多个线程间可以复用堆栈。因此，创建进程比创建线程慢，而且进程的内存开销更大。</p><h3 id="如何控制同一时间只有-2-个线程运行？"><a href="#如何控制同一时间只有-2-个线程运行？" class="headerlink" title="如何控制同一时间只有 2 个线程运行？"></a>如何控制同一时间只有 2 个线程运行？</h3><p>锁是一个面试的热门话题，有乐观锁、悲观锁、重入锁、公平锁、分布式锁。有很多和锁相关的数据结构，比如说阻塞队列。还有一些关联的一些工具，比如说 Semaphore、Monitor 等。这些知识点可以关联很多的面试题目，比如：</p><p>锁是如何实现的？</p><p>如何控制同一时间只有 2 个线程运行？</p><p>如何实现分布式锁？</p><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>要想弄清楚锁，就要弄清楚锁的实现，实现锁需要底层提供的原子操作，因此我们先来学习下原子操作。</p><p>原子操作就是操作不可分。在多线程环境，一个原子操作的执行过程无法被中断。那么你可以思考下，具体原子操作的一个示例。</p><p>比如<code>i++</code>就不是一个原子操作，因为它是 3 个原子操作组合而成的：</p><p>读取 <code>i</code> 的值；</p><p>计算 <code>i+1</code>；</p><p>写入新的值。</p><p>像这样的操作，在多线程 + 多核环境会造成竞争条件。</p><h4 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h4><p>竞争条件就是说多个线程对一个资源（内存地址）的读写存在竞争，在这种条件下，最后这个资源的值不可预测，而是取决于竞争时具体的执行顺序。</p><p>举个例子，比如两个线程并发执行<code>i++</code>。那么可以有下面这个操作顺序，假设执行前<code>i=0</code>：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210627232933.png" alt="image-20210627232933788"></p><p>虽然上面的程序执行了两次<code>i++</code>，但最终<code>i</code>的值为 1。</p><p><code>i++</code>这段程序访问了共享资源，也就是变量<code>i</code>，这种访问共享资源的程序片段我们称为<em>临界区</em>。在临界区，程序片段会访问共享资源，造成竞争条件，也就是共享资源的值最终取决于程序执行的时序，因此这个值不是确定的。</p><p>竞争条件是一件非常糟糕的事情，你可以把上面的程序想象成两个自动提款机。如果用户同时操作两个自动提款机，用户的余额就可能会被算错。</p><h4 id="解决竞争条件"><a href="#解决竞争条件" class="headerlink" title="解决竞争条件"></a>解决竞争条件</h4><p>解决竞争条件有很多方案，一种方案就是不要让程序同时进入临界区，这个方案叫作互斥。还有一些方案旨在避免竞争条件，比如 ThreadLocal、 cas 指令以及 “19 讲”中我们要学习的乐观锁。</p><h4 id="避免临界区"><a href="#避免临界区" class="headerlink" title="避免临界区"></a>避免临界区</h4><p>不让程序同时进入临界区这个方案比较简单，核心就是我们给每个线程一个变量i，比如利用 ThreadLocal，这样线程之间就不存在竞争关系了。这样做优点很明显，缺点就是并不是所有的情况都允许你这样做。有一些资源是需要共享的，比如一个聊天室，如果每次用户请求都有一个单独的线程在处理，不可能为每个请求（线程）都维护一份聊天记录。</p><h4 id="cas-指令"><a href="#cas-指令" class="headerlink" title="cas 指令"></a>cas 指令</h4><p>另一个方案是利用 CPU 的指令，让<code>i++</code>成为一个原子操作。 很多 CPU 都提供 Compare And Swap 指令。这个指令的作用是更新一个内存地址的值，比如把<code>i</code>更新为<code>i+1</code>，但是这个指令明确要求使用者必须确定知道内存地址中的值是多少。比如一个线程想把<code>i</code>从100更新到101，线程必须明确地知道现在<code>i</code>是 100，否则就会更新失败。</p><p>cas 可以用下面这个函数表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas(&amp;oldValue, expectedValue, targetValue)</span><br></pre></td></tr></table></figure><p>这里我用的是伪代码，用&amp;符号代表这里取内存地址。注意 cas 是 CPU 提供的原子操作。因此上面的比较和设置值的过程，是原子的，也就是不可分。</p><p>比如想用 cas 更新i的值，而且知道i是 100，想更新成101。那么就可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas(&amp;i, 100, 101)</span><br></pre></td></tr></table></figure><p>如果在这个过程中，有其他线程把i更新为101，这次调用会返回 false，否则返回 true。</p><p>所以i++程序可以等价的修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas(&amp;i, i, i+1)</span><br></pre></td></tr></table></figure><p>上面的程序执行时，其实是 3 条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读取i </span><br><span class="line">计算i+1</span><br><span class="line">cas操作：比较期望值i和i的真实值的值是否相等，如果是，更新目标值</span><br></pre></td></tr></table></figure><p>假设i=0，考虑两个线程分别执行一次这个程序，尝试构造竞争条件：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628093200.png" alt="image-20210628093200450"></p><p>你可以看到通过这种方式，cas 解决了一部分问题，找到了竞争条件，并返回了 false。但是还是无法计算出正确的结果。因为最后一次 cas 失败了。</p><p>如果要完全解决可以考虑这样去实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(!cas(&amp;i, i, i+1))&#123;</span><br><span class="line">  // 什么都不做</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 cas 返回 false，那么会尝试再读一次 i 的值，直到 cas 成功。</p><h4 id="tas-指令"><a href="#tas-指令" class="headerlink" title="tas 指令"></a>tas 指令</h4><p>还有一个方案是 tas 指令，有的 CPU 没有提供 cas（大部分服务器是提供的），提供一种 Test-And-Set 指令（tas）。tas 指令的目标是设置一个内存地址的值为 1，它的工作原理和 cas 相似。首先比较内存地址的数据和 1 的值，如果内存地址是 0，那么把这个地址置 1。如果是 1，那么失败。</p><p>所以你可以把 tas 看作一个特殊版的cas，可以这样来理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tas(&amp;lock) &#123;</span><br><span class="line">  return cas(&amp;lock, 0, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁（lock），目标是实现抢占（preempt）。就是只让给定数量的线程进入临界区。锁可以用tas或者cas来实现。</p><p>举个例子：如果希望同时只能有一个线程执行i++，伪代码可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enter();</span><br><span class="line">i++;</span><br><span class="line">leave();</span><br></pre></td></tr></table></figure><p>可以考虑用cas实现enter和leave函数，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int lock = 0;</span><br><span class="line">enter()&#123;</span><br><span class="line">  while( !cas(&amp;lock, 0, 1) ) &#123;</span><br><span class="line">    // 什么也不做</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">leave()&#123;</span><br><span class="line">  lock = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个线程竞争一个整数的 lock 变量，0 代表目前没有线程进入临界区，1 代表目前有线程进入临界区。利用cas原子指令我们可以对临界区进行管理。如果一个线程利用 cas 将 lock 设置为 1，那么另一个线程就会一直执行cas操作，直到锁被释放。</p><h4 id="语言级锁的实现"><a href="#语言级锁的实现" class="headerlink" title="语言级锁的实现"></a>语言级锁的实现</h4><p>上面解决竞争条件的时候，我们用到了锁。 相比 cas，锁是一种简单直观的模型。总体来说，cas 更底层，用 cas 解决问题优化空间更大。但是用锁解决问题，代码更容易写——进入临界区之前 lock，出去就 unlock。 从上面这段代码可以看出，为了定义锁，我们需要用到一个整型。如果实现得好，可以考虑这个整数由语言级定义。</p><p>比如考虑让用户传递一个变量过去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int lock = 0;</span><br><span class="line">enter(&amp;lock);</span><br><span class="line">//临界区代码</span><br><span class="line">leave(&amp;lock);</span><br></pre></td></tr></table></figure><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>上面我们已经用过自旋锁了，这是之前的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enter()&#123;</span><br><span class="line">  while( !cas(&amp;lock, 0, 1) ) &#123;</span><br><span class="line">    // 什么也不做</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码不断在 CPU 中执行指令，直到锁被其他线程释放。这种情况线程不会主动释放资源，我们称为自旋锁。自旋锁的优点就是不会主动发生 Context Switch，也就是线程切换，因为线程切换比较消耗时间。自旋锁缺点也非常明显，比较消耗 CPU 资源。如果自旋锁一直拿不到锁，会一直执行。</p><h4 id="wait-操作"><a href="#wait-操作" class="headerlink" title="wait 操作"></a>wait 操作</h4><p>你可以考虑实现一个 wait 操作，主动触发 Context Switch。这样就解决了 CPU 消耗的问题。但是触发 Context Switch 也是比较消耗成本的事情，那么有没有更好的方法呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enter()&#123;</span><br><span class="line">  while( !cas(&amp;lock, 0, 1) ) &#123;</span><br><span class="line">    // sleep(1000ms);</span><br><span class="line">    wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看下上面的代码，这里有一个更好的方法：就是 cas 失败后，马上调用sleep方法让线程休眠一段时间。但是这样，可能会出现锁已经好了，但是还需要多休眠一小段时间的情况，影响计算效率。</p><p>另一个方案，就是用wait方法，等待一个信号——直到另一个线程调用notify方法，通知这个线程结束休眠。但是这种情况——wait 和 notify 的模型要如何实现呢？</p><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><p>一个合理的实现就是生产者消费者模型。 wait 是一个生产者，将当前线程挂到一个等待队列上，并休眠。notify 是一个消费者，从等待队列中取出一个线程，并重新排队。</p><p>如果使用这个模型，那么我们之前简单用<code>enter</code>和<code>leave</code>来封装加锁和解锁的模式，就需要变化。我们需要把<code>enter</code> <code>leave</code> <code>wait</code> <code>notify</code>的逻辑都封装起来，不让用户感知到它们的存在。</p><p>比如 Java 语言，Java 为每个对象增加了一个 Object Header 区域，里面一个锁的位（bit），锁并不需要一个 32 位整数，一个 bit 足够。下面的代码用户使用 synchronized 关键字让临界区访问互斥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj)&#123;// enter</span><br><span class="line">  // 临界区代码</span><br><span class="line">&#125; // leave</span><br></pre></td></tr></table></figure><p>synchronized 关键字的内部实现，用到了封装好的底层代码——Monitor 对象。每个 Java 对象都关联了一个 Monitor 对象。Monitor 封装了对锁的操作，比如 enter、leave 的调用，这样简化了 Java 程序员的心智负担，你只需要调用 synchronized 关键字。</p><p>另外，Monitor 实现了生产者、消费者模型。</p><ul><li>如果一个线程拿到锁，那么这个线程继续执行；</li><li>如果一个线程竞争锁失败，Montior 就调用 wait 方法触发生产者的逻辑，把线程加入等待集合；</li><li>如果一个线程执行完成，Monitor 就调用一次 notify 方法恢复一个等待的线程。</li></ul><p>这样，Monitor 除了提供了互斥，还提供了线程间的通信，避免了使用自旋锁，还简化了程序设计。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>接下来介绍一个叫作信号量的方法，你可以把它看作是互斥的一个广义版。我们考虑一种更加广义的锁，这里请你思考如何同时允许 N 个线程进入临界区呢？</p><p>我们先考虑实现一个基础的版本，用一个整数变量<code>lock</code>来记录进入临界区线程的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int lock = 0;</span><br><span class="line">enter()&#123;</span><br><span class="line">  while(lock++ &gt; 2) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">leave()&#123;</span><br><span class="line">  lock--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码具有一定的欺骗性，没有考虑到<strong>竞争条件</strong>，执行的时候会出问题，可能会有超过2个线程同时进入临界区。</p><p>下面优化一下，作为一个考虑了竞争条件的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">up(&amp;lock)&#123;</span><br><span class="line">  while(!cas(&amp;lock, lock, lock+1)) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">down(&amp;lock)&#123;</span><br><span class="line">  while(!cas(&amp;lock, lock, lock - 1) || lock == 0)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了简化模型，我们重新设计了两个原子操作<code>up</code>和<code>down</code>。<code>up</code>将<code>lock</code>增 1，<code>down</code>将<code>lock</code>减 1。当 lock 为 0 时，如果还在<code>down</code>那么会自旋。考虑用多个线程同时执行下面这段程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int lock = 2;</span><br><span class="line">down(&amp;lock);</span><br><span class="line">// 临界区</span><br><span class="line">up(&amp;lock);</span><br></pre></td></tr></table></figure><p>如果只有一个线程在临界区，那么<code>lock</code>等于 1，第 2 个线程还可以进入。 如果两个线程在临界区，第 3 个线程尝试<code>down</code>的时候，会陷入自旋锁。当然我们也可以用其他方式来替代自旋锁，比如让线程休眠。</p><p>当<code>lock</code>初始值为 1 的时候，这个模型就是实现<strong>互斥（mutex）</strong>。如果 lock 大于 1，那么就是同时允许多个线程进入临界区。这种方法，我们称为<strong>信号量（semaphore）</strong>。</p><h4 id="信号量实现生产者消费者模型"><a href="#信号量实现生产者消费者模型" class="headerlink" title="信号量实现生产者消费者模型"></a>信号量实现生产者消费者模型</h4><p>信号量可以用来实现生产者消费者模型。下面我们通过一段代码实现生产者消费者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">int empty = N; // 当前空位置数量</span><br><span class="line"></span><br><span class="line">int mutex = 1; // 锁</span><br><span class="line"></span><br><span class="line">int full = 0; // 当前的等待的线程数</span><br><span class="line"></span><br><span class="line">wait()&#123;</span><br><span class="line"></span><br><span class="line">  down(&amp;empty);</span><br><span class="line"></span><br><span class="line">  down(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  insert(); </span><br><span class="line"></span><br><span class="line">  up(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  up(&amp;full);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notify()&#123;</span><br><span class="line"></span><br><span class="line">  down(&amp;full);</span><br><span class="line"></span><br><span class="line">  down(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  remove(); </span><br><span class="line"></span><br><span class="line">  up(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  up(&amp;empty)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert()&#123;</span><br><span class="line"></span><br><span class="line">  wait_queue.add(currentThread);</span><br><span class="line"></span><br><span class="line">  yield();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove()&#123;</span><br><span class="line"></span><br><span class="line">  thread = wait_queue.dequeue();</span><br><span class="line"></span><br><span class="line">  thread.resume();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中 wait 是生产者，notify 是消费者。 每次<code>wait</code>操作减少一个空位置数量，empty-1；增加一个等待的线程，full+1。每次<code>notify</code>操作增加一个空位置，empty+1，减少一个等待线程，full-1。</p><p><code>insert</code>和<code>remove</code>方法是互斥的操作，需要用另一个 mutex 锁来保证。<code>insert</code>方法将当前线程加入等待队列，并且调用 yield 方法，交出当前线程的控制权，当前线程休眠。<code>remove</code>方法从等待队列中取出一个线程，并且调用<code>resume</code>进行恢复。以上， 就构成了一个简单的生产者消费者模型。</p><h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><p>另外就是在并行的时候，如果两个线程互相等待对方获得的锁，就会发生死锁。你可以把死锁理解成一个环状的依赖关系。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int lock1 = 0;</span><br><span class="line"></span><br><span class="line">int lock2 = 0;</span><br><span class="line"></span><br><span class="line">// 线程1</span><br><span class="line"></span><br><span class="line">enter(&amp;lock1);</span><br><span class="line"></span><br><span class="line">enter(&amp;lock2);</span><br><span class="line"></span><br><span class="line">leave(&amp;lock1);</span><br><span class="line"></span><br><span class="line">leave(&amp;lock2);</span><br><span class="line"></span><br><span class="line">// 线程2</span><br><span class="line"></span><br><span class="line">enter(&amp;lock2);</span><br><span class="line"></span><br><span class="line">enter(&amp;lock1);</span><br><span class="line"></span><br><span class="line">leave(&amp;lock1);</span><br><span class="line"></span><br><span class="line">leave(&amp;lock2)</span><br></pre></td></tr></table></figure><p>上面的程序，如果是按照下面这个顺序执行，就会死锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程1： enter(&amp;lock1);</span><br><span class="line"></span><br><span class="line">线程2： enter(&amp;lock2);</span><br><span class="line"></span><br><span class="line">线程1： enter(&amp;lock2)</span><br><span class="line"></span><br><span class="line">线程2:  enter(&amp;lock1)</span><br><span class="line"></span><br><span class="line">// 死锁发生，线程1、2陷入等待</span><br></pre></td></tr></table></figure><p>上面程序线程 1 获得了<code>lock1</code>，线程 2 获得了<code>lock2</code>。接下来线程 1 尝试获得<code>lock2</code>，线程 2 尝试获得<code>lock1</code>，于是两个线程都陷入了等待。这个等待永远都不会结束，我们称之为<strong>死锁</strong>。</p><p>关于死锁如何解决，我们会在“<strong>21 | 哲学家就餐问题：什么情况下会触发饥饿和死锁</strong>？”讨论。这里我先讲一种最简单的解决方案，你可以尝试让两个线程对锁的操作顺序相同，这样就可以避免死锁问题。</p><h4 id="分布式环境的锁"><a href="#分布式环境的锁" class="headerlink" title="分布式环境的锁"></a>分布式环境的锁</h4><p>最后，我们留一点时间给分布式锁。我们之前讨论了非常多的实现，是基于多个线程访问临界区。现在要考虑一个更庞大的模型，我们有 100 个容器，每一个里面有一个为用户<strong>减少积分</strong>的服务。</p><p>简化下模型，假设积分存在 Redis 中。当然数据库中也有，但是我们只考虑 Redis。使用 Redis，我们目标是给数据库减负。</p><p>假设这个接口可以看作 3 个原子操作：</p><ol><li>从 Redis 读出当前库存；</li><li>计算库存 -1；</li><li>更新 Redis 库存。</li></ol><p>和<code>i++</code>类似，很明显，当用户并发的访问这个接口，是会发生竞争条件的。 因为程序已经不是在同一台机器上执行了，解决方案就是<strong>分布式锁</strong>。实现锁，我们需要原子操作。</p><p>在单机多线程并发的场景下，原子操作由 CPU 指令提供，比如 <code>cas</code> 和 <code>tas</code> 指令。那么在分布式环境下，原子操作由谁提供呢？``</p><p>有很多工具都可以提供分布式的原子操作，比如 <code>Redis</code> 的 <code>setnx</code> 指令，Zookeeper 的节点操作等等。作为操作系统课程，这部分我不再做进一步的讲解。这里是从多线程的处理方式，引出分布式的处理方式，通过两个类比，帮助你提高。如果你感兴趣，可以自己查阅更多的分布式锁的资料。</p><h4 id="如何控制同一时间只有-2-个线程运行？-1"><a href="#如何控制同一时间只有-2-个线程运行？-1" class="headerlink" title="如何控制同一时间只有 2 个线程运行？"></a>如何控制同一时间只有 2 个线程运行？</h4><p>同时控制两个线程进入临界区，一种方式可以考虑用信号量（semaphore）。</p><p>另一种方式是考虑生产者、消费者模型。想要进入临界区的线程先在一个等待队列中等待，然后由消费者每次消费两个。这种实现方式，类似于实现一个线程池，所以也可以考虑实现一个 <code>ThreadPool</code> 类，然后再实现一个调度器类，最后实现一个每次选择两个线程执行的调度算法。</p><h3 id="除了上锁还有哪些并发控制方法？"><a href="#除了上锁还有哪些并发控制方法？" class="headerlink" title="除了上锁还有哪些并发控制方法？"></a><strong>除了上锁还有哪些并发控制方法？</strong></h3><p>上面这道面试题是在“有哪些并发控制方法？”这个问题的基础上加了一个限制条件。</p><p>在我面试候选人的过程中，“上锁”是我听到过回答频次最多的答案，也就是说大多数程序员都可以想到这个并发控制方法。因此，是否能回答出上锁以外的方法，是检验程序员能力的一个分水岭，其实锁以外还有大量优秀的方法。</p><p>你掌握的方法越多，那么在解决实际问题的时候，思路就越多。即使你没有做过高并发场景的设计，但是如果脑海中有大量优秀的方法可以使用，那么公司也会考虑培养你，将高并发场景交给你去解决。今天我们就以这道面试题为引，一起探讨下“锁以外的并发控制方法”。</p><h4 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁/乐观锁"></a>悲观锁/乐观锁</h4><p>说到并发场景，设计系统的目的往往是达到同步（Synchronized）的状态，同步就是大家最终对数据的理解达成了一致。</p><p>同步的一种方式，就是让<strong>临界区</strong>互斥。 这种方式，每次只有一个线程可以进入临界区。比如多个人修改一篇文章，这意味着必须等一个人编辑完，另一个人才能编辑。但是从实际问题出发，如果多个人编辑的不是文章的同一部分，是可以同时编辑的。因此，让临界区互斥的方法（对临界区上锁），具有强烈的排他性，对修改持保守态度，我们称为<strong>悲观锁（Pressimistic Lock）</strong>。</p><p>通常意义上，我们说上锁，就是悲观锁，比如说 MySQL 的表锁、行锁、Java 的锁，本质是互斥（mutex）。</p><p>和<strong>悲观锁（PressimisticLock）</strong>持相反意见的，是<strong>乐观锁（Optimistic Lock）</strong>。你每天都用的，基于乐观锁的应用就是版本控制工具 Git。Git 允许大家一起编辑，将结果先存在本地，然后都可以向远程仓库提交，如果没有版本冲突，就可以提交上去。这就是一种典型的乐观锁的场景，或者称为基于版本控制的场景。</p><h4 id="Git-的类比"><a href="#Git-的类比" class="headerlink" title="Git 的类比"></a>Git 的类比</h4><p>比如现在代码仓库的版本是 100。Bob 和 Alice 把版本 100 拷贝到本地，Bob 在本地写到了 106 版本，Alice 在本地写到 108 版本。那么如果 Alice 先提交，代码仓库的版本就到了 108。 Bob 再提交的时候，发现版本已经不是 100 了，就需要把最新的代码 fetch 到本地，然后合并冲突，再尝试提交一个更新的版本，比如 110。</p><p>这种方式非常类似<code>cas</code>指令的形式，就是每次更新的发起方，需要明确地知道想从多少版本更新到多少版本。以 Git 为例，可以写出<code>cas</code>的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cas(&amp;version, 100, 108); // 成功</span><br><span class="line"></span><br><span class="line">cas(&amp;version, 100, 106); // 失败，因为version是108</span><br></pre></td></tr></table></figure><h4 id="购物车的类比"><a href="#购物车的类比" class="headerlink" title="购物车的类比"></a>购物车的类比</h4><p>再举个例子，比如说要实现一个购物车。用户可能在移动端、PC 端之间切换，比如他用一会手机累了，然后换成用电脑，当他用电脑累了，再换回手机。</p><p>在移动端和 PC 端，用户都在操作购物车。 比如在移动端上，用户增加了商品 A；然后用户打开 PC 端，增加了商品 B；然后用户又换回了移动端，想增加商品 C。</p><p>这种时候，如果用悲观锁，用户登录移动端后，一种方案就是把 PC 端下线——当然这个方案显然不合理。 合理的方案是给购物车一个版本号，假设是 MySQL 表，那么购物车表中就会多一个版本字段。这样当用户操作购物车的时候，检查一下当前购物车的版本号是不是最新的，如果是最新的，那么就正常操作。如果不是最新的，就提示用户购物车在其他地方已被更新，需要刷新。</p><h4 id="去中心化方案：区块链的类比"><a href="#去中心化方案：区块链的类比" class="headerlink" title="去中心化方案：区块链的类比"></a>去中心化方案：区块链的类比</h4><p>继续类比，我们可以思考一个更加有趣的方案。在传统的架构中，我们之所以害怕并发，是因为中心化。比如说 DNS 系统，如果全球所有的 DNS 查询都执行一个集群，这个吞吐量是非常恐怖的，因此 DNS 系统用了一个分级缓存的策略。</p><p>但是交易数据分布的时候，比如下单、支付、修改库存，如果用分布式处理，就牵扯到分布式锁（分布式事务）。那么，有没有一个去中心化的方案，让业务不需要集中处理呢？比如说双 11 期间你在淘宝上买东西，可不可以直接和商家下单，而不用通过淘宝的中心系统呢？——如果可以，这也就相当于实现了同步，或者说去掉了高并发的同步。</p><h4 id="解决最基本的信用问题"><a href="#解决最基本的信用问题" class="headerlink" title="解决最基本的信用问题"></a>解决最基本的信用问题</h4><p>考虑购买所有的网购产品，下单不再走中心化的平台。比如阿里、拼多多、 京东、抖音……这些平台用户都不走平台的中心系统下单，而是用户直接和商家签订合同。这个技术现在已经实现了，叫作电子合同。</p><p>举例：Alice（A）向苹果店 B 购买了一个 iPhone。那么双方签订电子合同，合同内容 C 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from=A, to=B, price=10000, signature=alice的签名</span><br><span class="line">from=B, to=A, object=iphone, signature=苹果店的签名</span><br></pre></td></tr></table></figure><p>上面两条记录，第 1 条是说 A 同意给 B 转 10000 块钱；第 2 条记录说，B 同意给 A 一个 iPhone。如果 A 收了 iPhone 不给 B 打款，B 可以拿着这个电子合同去法院告 A。因为用 A 的签名，可以确定是 Alice 签署了这份协议。同理，如果苹果店不给 Alice iPhone，Alice 可以去法院告苹果店，因为 Alice 可以用苹果店的签名证明合同是真的。</p><h4 id="解决货币和库存的问题"><a href="#解决货币和库存的问题" class="headerlink" title="解决货币和库存的问题"></a>解决货币和库存的问题</h4><p>有了上面的例子，最基本的信用问题解决了。接下来，你可能会问，Alice 怎么证明自己有足够的钱买 iPhone？苹果店怎么证明有足够的 iPhone？</p><p>比如在某个对公开放的节点中，记录了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">account=alice, money=10000</span><br><span class="line"></span><br><span class="line">account=bob, iphone=100</span><br><span class="line"></span><br><span class="line">…… 以及很多其他的数据</span><br></pre></td></tr></table></figure><p>我们假设这里的钱可能是 Alice 用某种手段放进来的。或者我们再简化这个模型，比如全世界所有人的钱，都在这个系统里，这样我们就不用关心钱从哪里来这个问题了。如果是比特币，钱是需要挖矿的。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628095938.png" alt="image-20210628095938526"></p><p>如图，这个结构也叫作区块链。每个 Block 下面可以存一些数据，每个 Block 知道上一个节点是谁。每个 Block 有上一个节点的摘要签名。也就是说，如果 Block 10 是 Block 11 的上一个节点，那么 Block 11 会知道 Block 10 的存在，且用 Block 11 中 Block 10 的摘要签名，可以证明 Block 10 的数据没有被篡改过。</p><p>区块链构成了一个基于历史版本的事实链，前一个版本是后一个版本的历史。Alice 的钱和苹果店的 iPhone 数量，包括全世界所有人的钱，都在这些 Block 里。</p><h4 id="购买转账的过程"><a href="#购买转账的过程" class="headerlink" title="购买转账的过程"></a><strong>购买转账的过程</strong></h4><p>下面请你思考，Alice 购买了 iPhone，需要提交两条新数据到上面的区块链。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628100030.png" alt="image-20210628100030658"></p><p>比如，Alice 先在本地完成这件事情，本地的区块链就会像上图那样。 假设有一个中心化的服务器，专门接收这些区块数据，Alice 接下来就可以把数据提交到中心化的服务器，苹果店从中心化服务器上看到这条信息，认为交易被 Alice 执行了，就准备发货。</p><p>如果世界上有很多人同时在这个末端节点上写新的 Block。那么可以考虑由一个可信任的中心服务帮助合并新增的区块数据。就好像多个人同时编辑了一篇文章，发生了冲突，那就可以考虑由一个人整合大家需要修改和新增的内容，避免同时操作产生混乱。</p><h4 id="解决欺诈问题"><a href="#解决欺诈问题" class="headerlink" title="解决欺诈问题"></a>解决欺诈问题</h4><p>正常情况下，所有记录都可以直接合并。但是比如Alice在一家店购买了 1 个 iPhone，在另外一家店购买了 2 个 iPhone，这个时候 Alice 的钱就不够付款了。 或者说 Alice 想用 20000 块买 3 个 iPhone，她还想骗一个。</p><p>那么 Alice 最终就需要写这样的记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from=A, to=B, price=10000, signature=alice的签名</span><br><span class="line"></span><br><span class="line">from=B, to=A, object=iphone, signature=一个苹果店的签名</span><br><span class="line"></span><br><span class="line">from=A, to=B1, price=20000, signature=alice的签名</span><br><span class="line"></span><br><span class="line">from=B1, to=A, object=iphonex2, signature=另一个苹果店的签名</span><br></pre></td></tr></table></figure><p>无论 Alice 以什么顺序写入这些记录，她的钱都是不够的，因为她只有 20000 的余额。 这样简单地就解决了欺诈问题。</p><p>如果 Alice 想要修改自己的余额，那么 Alice 怎么做呢？</p><p>Alice 需要新增一个末端的节点，比如她在末端节点上将自己的余额修改为 999999。那么 Alice 的余额，就和之前 Block 中记录的冲突了。简单一查，就知道 Alice 在欺诈。如果 Alice 想要修改之前的某个节点的数据，这个节点的摘要签名就会发生变化了， 那么后面所有的节点就失效了。</p><p>比如 Alice 修改了 Block 9 的数据，并把整个区块链拷贝给 Bob。Bob 通过验证签名，就知道 Alice 在骗人。如果 Alice 修改了所有 Block 9 以后的 Block，相当于修改了完整的一个链条，且修改了所有的签名。Bob 只需要核对其中几个版本和其他人，或者和中心服务的签名的区别就知道 Alice 在欺诈。</p><p>刚才有一个设计，就是有一个中心平台供 Bob 下载。如果中心平台修改了数据。那么 Bob 会马上发现存在本地的和自己相关的数据与中心平台不一致。这样 Bob 就会联合其他用户一起抵制中心平台。</p><p>所以结论是，区块链一旦写入就不能修改，这样可以防止很多欺诈行为。</p><h4 id="解决并发问题"><a href="#解决并发问题" class="headerlink" title="解决并发问题"></a>解决并发问题</h4><p>假设全球有几十亿人都在下单。那么每次下单，需要创建新的一个 Block。这种情况，会导致最后面的 Block，开很多分支。</p><p>这个时候你会发现，这里有同步问题对不对？ 最傻的方案就是用锁解决，比如用一个集中式的办法，去接收所有的请求，这样就又回到中心化的设计。</p><p>还有一个高明的办法，就是允许商家开分支。 用户和苹果店订合同，苹果店独立做一个分支，把用户的合同连起来。</p><p>这样苹果店自己先维护自己的 Block-Chain，等待合适的时机，再去合并到主分支上。 如果有合同合并不进去，比如余额不足，那再作废这个合同（不发货了）。</p><p>这里请你思考这样一种处理方式：如果全世界每天有 1000 亿笔订单要处理，那么可以先拆分成 100 个区域，每个区域是 10W 家店。这样最终每家店的平均并发量在 10000 单。 然后可以考虑每过多长时间，比如 10s，进行一次逐级合并。</p><p>这样，整体每个节点的压力就不是很大了。</p><p>并发问题也不仅仅是要解决并发问题，并发还伴随着一致性、可用性、欺诈及吞吐量等。一名优秀的架构师是需要储备多个维度的知识，所以还是我常常跟你强调的，知识在于积累，绝非朝夕之功。</p><h4 id="除了上锁还有哪些并发控制方法？-1"><a href="#除了上锁还有哪些并发控制方法？-1" class="headerlink" title="除了上锁还有哪些并发控制方法？"></a><strong>除了上锁还有哪些并发控制方法？</strong></h4><p>这一讲我们介绍了基于乐观锁的版本控制，还介绍了区块链技术。另外还有一个名词，并不属于操作系统课程范畴，我也简单给你介绍下。处理并发还可以考虑 Lock-Free 数据结构。比如 Lock-Free 队列，是基于 cas 指令实现的，允许多个线程使用这个队列。再比如 ThreadLocal，让每个线程访问不同的资源，旨在用空间换时间，也是避免锁的一种方案。</p><h3 id="线程调度都有哪些方法？"><a href="#线程调度都有哪些方法？" class="headerlink" title="线程调度都有哪些方法？"></a><strong>线程调度都有哪些方法？</strong></h3><p>所谓<strong>调度</strong>，是一个制定计划的过程，放在线程调度背景下，就是操作系统如何决定未来执行哪些线程？</p><p>第一条是形形色色调度场景怎么来的？第二条是每个调度算法是如何工作的？</p><h4 id="先到先服务"><a href="#先到先服务" class="headerlink" title="先到先服务"></a>先到先服务</h4><p>早期的操作系统是一个个处理作业（Job），比如很多保险业务，每处理一个称为一个作业（Job）。处理作业最容易想到的就是<strong>先到先服务（First Come First Service，FCFS）</strong>，也就是先到的作业先被计算，后到的作业，排队进行。</p><p>这里需要用到一个叫作队列的数据结构，具有<strong>先入先出（First In First Out，FIFO）性质</strong>。先进入队列的作业，先处理，因此从<strong>公平性</strong>来说，这个算法非常朴素。另外，一个作业完全完成才会进入下一个作业，作业之间不会发生切换，从<strong>吞吐量</strong>上说，是最优的——因为没有额外开销。</p><p>但是这样对于等待作业的用户来说，是有问题的。比如一笔需要用时 1 天的作业 ，如果等待了 10 分钟，用户是可以接受的；一个用时 10 分钟的作业，用户等待一天就要投诉了。 因此如果用时 1 天的作业先到，用时 10 分钟的任务后到，应该优先处理用时少的，也就是<strong>短作业优先（Shortest Job First，SJF）</strong>。</p><h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><p>通常会同时考虑到来顺序和作业预估时间的长短，比如下面的到来顺序和预估时间：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628101849.png" alt="image-20210628101849835"></p><p>这样就会优先考虑第一个到来预估时间为 3 分钟的任务。 我们还可以从另外一个角度来审视短作业优先的优势，就是平均等待时间。</p><h4 id="平均等待时间-总等待时间-任务数"><a href="#平均等待时间-总等待时间-任务数" class="headerlink" title="平均等待时间 = 总等待时间/任务数"></a><strong>平均等待时间 = 总等待时间/任务数</strong></h4><p>上面例子中，如果按照 3,3,10 的顺序处理，平均等待时间是：(0 + 3 + 6) / 3 = 3 分钟。 如果按照 10,3,3 的顺序来处理，就是( 0+10+13 )/ 3 = 7.66 分钟。</p><p>平均等待时间和用户满意度是成反比的，等待时间越长，用户越不满意，因此<strong>在大多数情况下，应该优先处理用时少的，从而降低平均等待时长</strong>。</p><p>采用 FCFS 和 SJF 后，还有一些问题没有解决。</p><ol><li>紧急任务如何插队？比如老板安排的任务。</li><li>等待太久的任务如何插队？比如用户等太久可能会投诉。</li><li>先执行的大任务导致后面来的小任务没有执行如何处理？比如先处理了一个 1 天才能完成的任务，工作半天后才发现预估时间 1 分钟的任务也到来了。</li></ol><p>为了解决上面的问题，我们设计了两种方案， <strong>一种是优先级队列（PriorityQueue）</strong>，<strong>另一种是抢占（Preemption）。</strong></p><h4 id="优先级队列（PriorityQueue）"><a href="#优先级队列（PriorityQueue）" class="headerlink" title="优先级队列（PriorityQueue）"></a>优先级队列（PriorityQueue）</h4><p>刚才提到老板安排的任务需要紧急插队，那么下一个作业是不是应该安排给老板？毫无疑问肯定是这样！那么如何控制这种优先级顺序呢？一种方法是用优先级队列。优先级队列可以给队列中每个元素一个优先级，优先级越高的任务就会被先执行。</p><p>优先级队列的一种实现方法就是用到了堆（Heap）这种数据结构，更最简单的实现方法，就是每次扫描一遍整个队列找到优先级最高的任务。也就是说，堆（Heap）可以帮助你在 O(1) 的时间复杂度内查找到最大优先级的元素。<br>比如老板的任务，就给一个更高的优先级。 而对于普通任务，可以在<strong>等待时间（W）</strong> 和<strong>预估执行时间（P）</strong> 中，找一个数学关系来描述。比如：优先级 = W/P。W 越大，或者 P 越小，就越排在前面。 当然还可以有很多其他的数学方法，利用对数计算，或者某种特别的分段函数。</p><p>这样，关于紧急任务如何插队？等待太久的任务如何插队？这两个问题我们都解决了，接下来我们来看先执行的大任务导致后面来的小任务没有执行的情况如何处理？</p><h4 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h4><p>为了解决这个问题，我们需要用到<strong>抢占（Preemption）</strong>。</p><p>抢占就是把执行能力分时，分成时间片段。 让每个任务都执行一个时间片段。如果在时间片段内，任务完成，那么就调度下一个任务。如果任务没有执行完成，则中断任务，让任务重新排队，调度下一个任务。</p><p>拥有了抢占的能力，再结合之前我们提到的优先级队列能力，这就构成了一个基本的线程调度模型。线程相对于操作系统是排队到来的，操作系统为每个到来的线程分配一个优先级，然后把它们放入一个优先级队列中，优先级最高的线程下一个执行。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103020.png" alt="image-20210628103020152"></p><p>每个线程执行一个时间片段，然后每次执行完一个线程就执行一段调度程序。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103053.png" alt="image-20210628103053438"></p><p>图中用红色代表调度程序，其他颜色代表被调度线程的时间片段。调度程序可以考虑实现为一个单线程模型，这样不需要考虑竞争条件。</p><p>上面这个模型已经是一个非常优秀的方案了，但是还有一些问题可以进一步处理得更好。</p><ol><li>如果一个线程优先级非常高，其实没必要再抢占，因为无论如何调度，下一个时间片段还是给它。那么这种情况如何实现？</li><li>如果希望实现最短作业优先的抢占，就必须知道每个线程的执行时间，而这个时间是不可预估的，那么这种情况又应该如何处理？</li></ol><p>为了解决上面两个问题，我们可以考虑引入多级队列模型。</p><h4 id="多级队列模型"><a href="#多级队列模型" class="headerlink" title="多级队列模型"></a>多级队列模型</h4><p>多级队列，就是多个队列执行调度。 我们先考虑最简单的两级模型，如图：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103553.png" alt="image-20210628103552965"></p><p>上图中设计了两个优先级不同的队列，从下到上优先级上升，上层队列调度紧急任务，下层队列调度普通任务。只要上层队列有任务，下层队列就会让出执行权限。</p><ul><li>低优先级队列可以考虑抢占 + 优先级队列的方式实现，这样每次执行一个时间片段就可以判断一下高优先级的队列中是否有任务。</li><li>高优先级队列可以考虑用非抢占（每个任务执行完才执行下一个）+ 优先级队列实现，这样紧急任务优先级有个区分。如果遇到十万火急的情况，就可以优先处理这个任务。</li></ul><p>上面这个模型虽然解决了任务间的优先级问题，但是还是没有解决短任务先行的问题。可以考虑再增加一些队列，让级别更多。比如下图这个模型：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103822.png" alt="image-20210628103822066"></p><p>紧急任务仍然走高优队列，非抢占执行。普通任务先放到优先级仅次于高优任务的队列中，并且只分配很小的时间片；如果没有执行完成，说明任务不是很短，就将任务下调一层。下面一层，最低优先级的队列中时间片很大，长任务就有更大的时间片可以用。通过这种方式，短任务会在更高优先级的队列中执行完成，长任务优先级会下调，也就类似实现了最短作业优先的问题。</p><p>实际操作中，可以有 n 层，一层层把大任务筛选出来。 最长的任务，放到最闲的时间去执行。要知道，大部分时间 CPU 不是满负荷的。</p><p><strong>线程调度都有哪些方法</strong>？</p><p>回答这个问题你要把握主线，千万不要教科书般的回答：任务调度分成抢占和非抢占的，抢占的可以轮流执行，也可以用优先级队列执行；非抢占可以先到先服务，也可以最短任务优先。</p><p>上面这种回答可以用来过普通的程序员岗位，但是面试官其实更希望听到你的见解，这是初中级开发人员与高级开发人员之间的差异。</p><p>比如你告诉面试官：非抢占的先到先服务的模型是最朴素的，公平性和吞吐量可以保证。但是因为希望减少用户的平均等待时间，操作系统往往需要实现抢占。操作系统实现抢占，仍然希望有优先级，希望有最短任务优先。</p><p>但是这里有个困难，操作系统无法预判每个任务的预估执行时间，就需要使用分级队列。最高优先级的任务可以考虑非抢占的优先级队列。 其他任务放到分级队列模型中执行，从最高优先级时间片段最小向最低优先级时间片段最大逐渐沉淀。这样就同时保证了小任务先行和高优任务最先执行。</p><h3 id="什么情况下会触发饥饿和死锁？"><a href="#什么情况下会触发饥饿和死锁？" class="headerlink" title="什么情况下会触发饥饿和死锁？"></a><strong>什么情况下会触发饥饿和死锁</strong>？</h3><p>读题可知，这道题目在提问“场景”，从表面来看，解题思路是列举几个例子。但是在回答这类面试题前你一定要想一想面试官在考察什么，往往在题目中看到“<strong>什么情况下</strong>”时，其实考察的是你总结和概括信息的能力。</p><p>关于上面这道题目，如果你只回答一个场景，而没有输出概括性的总结内容，就很容易被面试官认为对知识理解不到位，因而挂掉面试。另外，<strong>提问死锁和饥饿还有一个更深层的意思，就是考察你在实战中对并发控制算法的理解，是否具备设计并发算法来解决死锁问题并且兼顾性能（并发量）的思维和能力</strong>。</p><p>要学习这部分知识有一个非常不错的模型，就是哲学家就餐问题。1965 年，计算机科学家 Dijkstra 为了帮助学生更好地学习并发编程设计的一道练习题，后来逐渐成为大家广泛讨论的问题。</p><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>问题描述如下：有 5 个哲学家，围着一个圆桌就餐。圆桌上有 5 份意大利面和 5 份叉子。哲学家比较笨，他们必须拿到左手和右手的 2 个叉子才能吃面。哲学不饿的时候就在思考，饿了就去吃面，吃面的必须前提是拿到 2 个叉子，吃完面哲学家就去思考。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628162006.png" alt="image-20210628162006422"></p><h4 id="问题的抽象"><a href="#问题的抽象" class="headerlink" title="问题的抽象"></a>问题的抽象</h4><p>接下来请你继续思考，我们对问题进行一些抽象，比如哲学是一个数组，编号 0~4。我这里用 Java 语言给你演示，哲学家是一个类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Philosopher[] philosophers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">       philosophers = <span class="keyword">new</span> Philosopher[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里考虑叉子也使用编号 0~4，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer[] forks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Philosopher[] philosophers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        philosophers[i] = <span class="keyword">new</span> Philosopher(i);</span><br><span class="line">        forks[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>forks[i]</code>的值等于 x，相当于编号为<code>i</code>的叉子被编号为 x 的哲学家拿起；如果等于<code>-1</code>，那么叉子目前放在桌子上。</p><p>我们经常需要描述左、右的关系，为了方便计算，可以设计 1 个帮助函数（helper functions），帮助我们根据一个编号，计算它左边的编号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LEFT</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">4</span> : i-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设和哲学家编号一致的叉子在右边，这样如果要判断编号为<code>id</code>哲学家是否可以吃面，需要这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(forks[LEFT(id)] == id &amp;&amp; forks[id] == id) &#123;</span><br><span class="line">  <span class="comment">// 可以吃面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个<code>_take</code>函数拿起编号为<code>i</code>叉子; 再设计一个<code>_put</code>方法放下叉子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_take</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    forks[i] = id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_put</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(forks[i] == id)</span><br><span class="line"></span><br><span class="line">    forks[i] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>forks[i]</code>的值等于 x，相当于编号为<code>i</code>的叉子被编号为 x 的哲学家拿起；如果等于<code>-1</code>，那么叉子目前放在桌子上。</p><p>我们经常需要描述左、右的关系，为了方便计算，可以设计 1 个帮助函数（helper functions），帮助我们根据一个编号，计算它左边的编号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> private static int LEFT(int i) &#123;</span><br><span class="line">      return i == 0 ? 4 : i-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设和哲学家编号一致的叉子在右边，这样如果要判断编号为<code>id</code>哲学家是否可以吃面，需要这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(forks[LEFT(id)] == id &amp;&amp; forks[id] == id) &#123;</span><br><span class="line">  <span class="comment">// 可以吃面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个<code>_take</code>函数拿起编号为<code>i</code>叉子; 再设计一个<code>_put</code>方法放下叉子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_take</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    forks[i] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_put</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(forks[i] == id)</span><br><span class="line">    forks[i] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_take</code>函数之所以会等待 10ms，是因为<strong>哲学家就餐问题的实际意义，是 I/O 处理的场景，拿起叉子好比读取磁盘，需要有一等的时间开销，这样思考才有意义</strong>。</p><p>然后是对<code>think</code>和<code>eat</code>两个方法的抽象。首先我封装了一个枚举类型，描述哲学家的状态，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> PHIS &#123;</span><br><span class="line"></span><br><span class="line">    THINKING,</span><br><span class="line"></span><br><span class="line">    HUNGRY,</span><br><span class="line"></span><br><span class="line">    EATING</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现<code>think</code>方法，<code>think</code>方法不需要并发控制，但是这里用<code>Thread.sleep</code>模拟实际思考需要的开销，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">think</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(String.format(<span class="string">"Philosopher %d thinking..."</span>, id));</span><br><span class="line"></span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) Math.floor(Math.random()*<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.state = PHIS.HUNGRY;</span><br></pre></td></tr></table></figure><p>最后是<code>eat</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (forks) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(forks[LEFT(id)] == id &amp;&amp; forks[id] == id) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">this</span>.state = PHIS.EATING;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread.sleep((<span class="keyword">long</span>) Math.floor(Math.random()*<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eat</code>方法依赖于<code>forks</code>对象的锁，相当于<code>eat</code>方法这里会同步——因为这里有读取临界区操作做。<code>Thread.sleep</code>依然用于描述<code>eat</code>方法的时间开销。<code>sleep</code>方法没有放到<code>synchronized</code>内是因为<strong>在并发控制时，应该尽量较少锁的范围，这样可以增加更大的并发量</strong>。</p><p>以上，我们对问题进行了一个基本的抽象。接下来请你思考在什么情况会发生死锁？</p><h4 id="死锁（DeadLock）和活锁（LiveLock）"><a href="#死锁（DeadLock）和活锁（LiveLock）" class="headerlink" title="死锁（DeadLock）和活锁（LiveLock）"></a>死锁（DeadLock）和活锁（LiveLock）</h4><p>首先，可以思考一种最简单的解法，每个哲学家用一个<code>while</code>循环表示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">  think();</span><br><span class="line"></span><br><span class="line">  _take(LEFT(id)); </span><br><span class="line"></span><br><span class="line">  _take(id);</span><br><span class="line"></span><br><span class="line">  eat();</span><br><span class="line"></span><br><span class="line">  _put(LEFT(id));</span><br><span class="line"></span><br><span class="line">  _put(id); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_take</span><span class="params">(id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(forks[id] != -<span class="number">1</span>) &#123;  Thread.yield();  &#125;</span><br><span class="line">  Thread.sleep(<span class="number">10</span>); <span class="comment">// 模拟I/O用时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_take</code>可以考虑阻塞，直到哲学家得到叉子。上面程序我们还没有进行并发控制，会发生竞争条件。 顺着这个思路，就可以想到加入并发控制，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">  think();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span>(fork[LEFT(id)]) &#123;</span><br><span class="line">    _take(LEFT(id)); </span><br><span class="line">    <span class="keyword">synchronized</span>(fork[id]) &#123;</span><br><span class="line">      _take(id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  eat();</span><br><span class="line">  <span class="keyword">synchronized</span>(fork[LEFT(id)]) &#123;</span><br><span class="line">    _put(LEFT(id));</span><br><span class="line">    <span class="keyword">synchronized</span>(fork[id]) &#123;</span><br><span class="line">      _put(id); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的并发控制，会发生死锁问题，大家可以思考这样一个时序，如果 5 个哲学家都同时通过<code>synchronized(fork[LEFT(id)])</code>，有可能会出现下面的情况：</p><ul><li>第 0 个哲学家获得叉子 4，接下来请求叉子 0；</li><li>第 1 个哲学家获得叉子 0，接下来请求叉子 1；</li><li>第 2 个哲学家获得叉子 1，接下来请求叉子 2；</li><li>第 3 个哲学家获得叉子 2，接下来请求叉子 3；</li><li>第 4 个哲学家获得叉子 3，接下来请求叉子 4。</li></ul><p>为了帮助你理解，这里我画了一幅图。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628164745.png" alt="image-20210628164745775"></p><p>如上图所示，可以看到这是一种循环依赖的关系，在这种情况下所有哲学家都获得了一个叉子，并且在等待下一个叉子。这种等待永远不会结束，因为没有哲学家愿意放弃自己拿起的叉子。</p><p>以上这种情况称为<strong>死锁（Deadlock），</strong>这是一种<strong>饥饿（Starvation）</strong>的形式。从概念上说，死锁是线程间互相等待资源，但是没有一个线程可以进行下一步操作。饥饿就是因为某种原因导致线程得不到需要的资源，无法继续工作。死锁是饥饿的一种形式，因为循环等待无法得到资源。哲学家就餐问题，会形成一种环状的死锁（循环依赖）， 因此非常具有代表性。</p><p>死锁有 4 个基本条件。</p><ol><li><strong>资源存在互斥逻辑：每次只有一个线程可以抢占到资源</strong>。这里是哲学家抢占叉子。</li><li><strong>持有等待</strong>：这里哲学家会一直等待拿到叉子。</li><li><strong>禁止抢占：如果拿不到资源一直会处于等待状态，而不会释放已经拥有的资源</strong>。</li><li><strong>循环等待</strong>：这里哲学家们会循环等待彼此的叉子。</li></ol><p>刚才提到死锁也是一种饥饿（Starvation）的形式，饥饿比较简单，就是线程长期拿不到需要的资源，无法进行下一步操作。</p><p>要解决死锁的问题，可以考虑哲学家拿起 1 个叉子后，如果迟迟没有等到下一个叉子，就放弃这次操作。比如 Java 的 Lock Interface 中，提供的<code>tryLock</code>方法，就可以实现定时获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>Java 提供的这个能力是拿不到锁，就报异常，并可以依据这个能力开发释放已获得资源的能力。</p><p>但是这样，我们会碰到一个叫作活锁（LiveLock）的问题。LiveLock 也是一种饥饿。可能在某个时刻，所有哲学及都拿起了左手的叉子，然后发现右手的叉子拿不到，就放下了左手的叉子——如此周而复始，这就是一种活锁。所有线程都在工作，但是没有线程能够进一步——解决问题。</p><p>在实际工作场景下，LiveLock 可以靠概率解决，因为同时拿起，又同时放下这种情况不会很多。实际工作场景很多系统，确实依赖于这个问题不频发。但是，优秀的设计者不能把系统设计依托在一个有概率风险的操作上，因此我们需要继续往深一层思考。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>其实解决上述问题有很多的方案，最简单、最直观的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(someLock) &#123;</span><br><span class="line"></span><br><span class="line">      think();</span><br><span class="line"></span><br><span class="line">      _take(LEFT(id)); </span><br><span class="line"></span><br><span class="line">      _take(id);</span><br><span class="line"></span><br><span class="line">      eat();</span><br><span class="line"></span><br><span class="line">      _put(LEFT(id));</span><br><span class="line"></span><br><span class="line">      _put(id); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段程序同时只允许一个哲学家使用所有资源，我们用<code>synchronized</code>构造了一种排队的逻辑。而哲学家，每次必须拿起所有的叉子，吃完，再到下一哲学家。 这样并发度是 1，同时最多有一个线程在执行。 这样的方式可以完成任务，但是性能太差。</p><p>另一种方法是规定拿起过程必须同时拿起，放下过程也同时放下，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    think();</span><br><span class="line">    <span class="keyword">synchronized</span>(someLock) &#123;</span><br><span class="line">      _takeForks(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(someLock) &#123;</span><br><span class="line"></span><br><span class="line">      _puts();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_takeForks</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( forks[LEFT(id)] == -<span class="number">1</span> &amp;&amp; forks[id] == -<span class="number">1</span> ) &#123;</span><br><span class="line"></span><br><span class="line">    forks[LEFT(id)] = id;</span><br><span class="line"></span><br><span class="line">    forks[id] = id;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_puts</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(forks[LEFT(id)] == id)</span><br><span class="line"></span><br><span class="line">      forks[LEFT(id)] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(forks[id] == id)</span><br><span class="line"></span><br><span class="line">      forks[id] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段程序，<code>think</code>函数没有并发控制，一个哲学家要么拿起两个叉子，要么不拿起，这样并发度最高为 2（最多有两个线程同时执行）。而且，这个算法中只有一个锁，因此不存在死锁和饥饿问题。</p><p>到这里，我们已经对这个问题有了一个初步的方案，那么如何进一步优化呢？</p><h4 id="思考和最终方案"><a href="#思考和最终方案" class="headerlink" title="思考和最终方案"></a>思考和最终方案</h4><p>整个问题复杂度的核心在于哲学家拿起叉子是有成本的。好比线程读取磁盘，需要消耗时间。哲学家的思考，是独立的。好比读取了磁盘数据，进行计算。那么有没有办法允许 5 个哲学家都同时去拿叉子呢？这样并发度是最高的。</p><p>经过初步思考，马上会发现这里有环状依赖， 会出现<strong>死锁</strong>。 原因就是如果 5 个哲学家同时拿叉子，那就意味着有的哲学家必须要放弃叉子。但是如果不放下会出现什么情况呢？</p><p>假设当一个哲学家发现自己拿不到两个叉子的时候，他去和另一个哲学家沟通把自己的叉子给对方。这样就相当于，有一个转让方法。相比于磁盘 I/O，转让内存中的数据成本就低的多了。 我们假设有这样一个转让的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">_transfer</span><span class="params">(<span class="keyword">int</span> fork, <span class="keyword">int</span> philosopher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      forks[fork] = philosopher;</span><br><span class="line"></span><br><span class="line">dirty[fork] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个方法相当于把叉子转让给另一个哲学家，这里你先不用管上面代码中的 dirty，后文中会讲到。而获取叉子的过程，我们可以进行调整，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (forks[i]) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(forks[i] == -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">              _take(id); </span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              Philosopher other = philosophers[forks[i]];</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(other.state != PHIS.EATING &amp;&amp; dirty[i]) &#123;</span><br><span class="line"></span><br><span class="line">                  other._transfer(i, forks[i]);</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_take</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    forks[i] = id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把每个叉子看作一个锁，有多少个叉子，就有多少个锁，相当于同时可以拿起 5 个叉子（并发度是 5）。如果当前没有人拿起叉子，那么可以自己拿起。 如果叉子属于其他哲学家，就需要判断对方的状态。只要对方不在<code>EATING</code>，就可以考虑转让叉子。</p><p>最后是对 LiveLock 的思考，为了避免叉子在两个哲学家之间来回转让，我们为每个叉子增加了一个<code>dirty</code>属性。一开始叉子的<code>dirty</code>是<code>true</code>，每次转让后，哲学家会把自己的叉子擦干净给另一个哲学家。转让的前置条件是叉子是<code>dirty</code>的，所以叉子在两个哲学家之间只会转让一次。</p><p>通过上面算法，我们就可以避免死锁、饥饿以及提高读取数据（获取叉子）的并发度。最后完整的程序如下，给你做参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class DiningPhilosophers &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    enum PHIS &#123;</span><br><span class="line"></span><br><span class="line">        THINKING,</span><br><span class="line"></span><br><span class="line">        HUNGRY,</span><br><span class="line"></span><br><span class="line">        EATING</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Philosopher implements Runnable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private static Philosopher[] philosophers;</span><br><span class="line"></span><br><span class="line">        private static Integer[] forks;</span><br><span class="line"></span><br><span class="line">        private static boolean[] dirty;</span><br><span class="line"></span><br><span class="line">        private PHIS state = PHIS.THINKING;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line"></span><br><span class="line">            philosophers = new Philosopher[5];</span><br><span class="line"></span><br><span class="line">            forks = new Integer[5];</span><br><span class="line"></span><br><span class="line">            dirty = new boolean[5];</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line"></span><br><span class="line">                philosophers[i] = new Philosopher(i);</span><br><span class="line"></span><br><span class="line">                forks[i] = -1;</span><br><span class="line"></span><br><span class="line">                dirty[i] = true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private static int LEFT(int i) &#123;</span><br><span class="line"></span><br><span class="line">            return i == 0 ? 4 : i-1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public Philosopher(int id) &#123;</span><br><span class="line"></span><br><span class="line">            this.id = id;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private int id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        void think() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(String.format(&quot;Philosopher %d thinking...&quot;, id));</span><br><span class="line"></span><br><span class="line">            Thread.sleep((long) Math.floor(Math.random()*1000));</span><br><span class="line"></span><br><span class="line">            this.state = PHIS.HUNGRY;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">             System.out.println(Arrays.toString(forks));</span><br><span class="line"></span><br><span class="line">                    //System.out.println(Arrays.toString(dirty));</span><br><span class="line"></span><br><span class="line">                    if(forks[LEFT(id)] == id &amp;&amp; forks[id] == id) &#123;</span><br><span class="line"></span><br><span class="line">                        this.state = PHIS.EATING;</span><br><span class="line"></span><br><span class="line">                    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                        return;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(String.format(&quot;Philosopher %d eating...&quot;, id));</span><br><span class="line"></span><br><span class="line">            Thread.sleep((long) Math.floor(Math.random()*1000));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            synchronized (forks) &#123;</span><br><span class="line"></span><br><span class="line">                dirty[LEFT(id)] = true;</span><br><span class="line"></span><br><span class="line">                dirty[id] = true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            var lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">            lock.tryLock(5, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            state = PHIS.THINKING;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        void _take(int i) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(10);</span><br><span class="line"></span><br><span class="line">            forks[i] = id;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        void _transfer(int fork, int philosopher) &#123;</span><br><span class="line"></span><br><span class="line">            forks[fork] = philosopher;</span><br><span class="line"></span><br><span class="line">            dirty[fork] = false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        void _putdown(int i) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(10);</span><br><span class="line"></span><br><span class="line">            forks[i] = -1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        void take(int i) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            synchronized (forks[i]) &#123;</span><br><span class="line"></span><br><span class="line">                if(forks[i] == -1) &#123;</span><br><span class="line"></span><br><span class="line">                    _take(id);</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    Philosopher other = philosophers[forks[i]];</span><br><span class="line"></span><br><span class="line">                    if(other.state != PHIS.EATING &amp;&amp; dirty[i]) &#123;</span><br><span class="line"></span><br><span class="line">                        other._transfer(i, forks[i]);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void takeForks() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            take(LEFT(id));</span><br><span class="line"></span><br><span class="line">            take(id);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line"></span><br><span class="line">                while(true) &#123;</span><br><span class="line"></span><br><span class="line">                    think();</span><br><span class="line"></span><br><span class="line">                    while (state == PHIS.HUNGRY) &#123;</span><br><span class="line"></span><br><span class="line">                        takeForks();</span><br><span class="line"></span><br><span class="line">                        System.out.println(&quot;here--&quot; + Math.random());</span><br><span class="line"></span><br><span class="line">                        eat();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line"></span><br><span class="line">            new Thread(new Philosopher(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什么情况下会触发饥饿和死锁？</strong></p><p><strong>【解析】</strong> 线程需要资源没有拿到，无法进行下一步，就是饥饿。死锁（Deadlock）和活锁（Livelock）都是饥饿的一种形式。 非抢占的系统中，互斥的资源获取，形成循环依赖就会产生死锁。死锁发生后，如果利用抢占解决，导致资源频繁被转让，有一定概率触发活锁。死锁、活锁，都可以通过设计并发控制算法解决，比如哲学家就餐问题。</p><h3 id="进程间通信都有哪些方法？"><a href="#进程间通信都有哪些方法？" class="headerlink" title="进程间通信都有哪些方法？"></a><strong>进程间通信都有哪些方法？</strong></h3><p>在上一讲中，我们提到过，凡是面试官问“<strong>什么情况下</strong>”的时候，面试官实际想听的是你经过理解，整理得到的认知。回答应该是概括的、简要的。而不是真的去列举每一种 case。</p><p>另外，<strong>面试官考察进程间通信，有一个非常重要的意义——进程间通信是架构复杂系统的基石</strong>。复杂系统往往是分成各种子系统、子模块、微服务等等，按照 Unix 的设计哲学，系统的每个部分应该是稳定、独立、简单有效，而且强大的。系统本身各个模块就像人的器官，可以协同工作。而这个协同的枢纽，就是我们今天的主题——进程间通信。</p><h4 id="什么是进程间通信？"><a href="#什么是进程间通信？" class="headerlink" title="什么是进程间通信？"></a>什么是进程间通信？</h4><p>进程间通信（Intermediate Process Communication，IPC）。所谓通信就是交换数据。所以，狭义地说，就是操作系统创建的进程们之间在交换数据。 我们今天不仅讨论狭义的通信，还要讨论 IPC 更广泛的意义——程序间的通信。 程序可以是进程，可以是线程，可以是一个进程的两个部分（进程自己发送给自己），也可以是分布式的——总之，今天讨论的是广义的交换数据。</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>之前我们在“<strong>07 | 进程、重定向和管道指令：xargs 指令的作用是</strong>？”中讲解过管道和命名管道。 管道提供了一种非常重要的能力，就是组织计算。进程不用知道有管道存在，因此管道的设计是非侵入的。程序员可以先着重在程序本身的设计，只需要预留响应管道的接口，就可以利用管道的能力。比如用<code>shell</code>执行MySQL语句，可能会这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程1 | 进程2 | 进程3 | mysql -u... -p | 爬虫进程</span><br></pre></td></tr></table></figure><p>我们可以由进程 1、进程 2、进程 3 计算出 MySQL 需要的语句，然后直接通过管道执行。MySQL经过计算将结果传给一个爬虫进程，爬虫就开始工作。MySQL并不是设计用于管道，爬虫进程也不是设计专门用于管道，只是程序员恰巧发现可以这样用，完美地解决了自己的问题，比如：用管道构建一个微型爬虫然后把结果入库。</p><p>我们还学过一个词叫作<strong>命名管道</strong>。命名管道并没有改变管道的用法。相比匿名管道，命名管道提供了更多的编程手段。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程1 &gt; namedpipe</span><br><span class="line">进程2 &gt; namedpipe</span><br></pre></td></tr></table></figure><p>上面的程序将两个进程的临时结果都同时重定向到 namedpipe，相当于把内容合并了再找机会处理。再比如说，你的进程要不断查询本地的 MySQL，也可以考虑用命名管道将查询传递给 MySQL，再用另一个命名管道传递回来。这样可以省去和 localhost 建立 TCP 3 次握手的时间。 当然，现在数据库都是远程的了，这里只是一个例子。</p><p>管道的核心是不侵入、灵活，不会增加程序设计负担，又能组织复杂的计算过程。</p><h4 id="本地内存共享"><a href="#本地内存共享" class="headerlink" title="本地内存共享"></a>本地内存共享</h4><p>同一个进程的多个线程本身是共享进程内存的。 这种情况不需要特别考虑共享内存。如果是跨进程的线程（或者理解为跨进程的程序），可以考虑使用共享内存。内存共享是现代操作系统提供的能力， Unix 系操作系统，包括 Linux 中有 POSIX 内存共享库——shmem。（如果你感兴趣可以参考<a href="https://www.man7.org/linux/man-pages/man7/shm_overview.7.html" target="_blank" rel="noopener">网页中的内容</a>，这里不做太深入地分析。）Linux 内存共享库的实现原理是以虚拟文件系统的形式，从内存中划分出一块区域，供两个进程共同使用。看上去是文件，实际操作是内存。</p><p>共享内存的方式，速度很快，但是程序不是很好写，因为这是一种侵入式的开发，也就是说你需要为此撰写大量的程序。比如如果修改共享内存中的值，需要调用 API。如果考虑并发控制，还要处理同步问题等。因此，只要不是高性能场景，进程间通信通常不考虑共享内存的方式。</p><h4 id="本地消息-队列"><a href="#本地消息-队列" class="headerlink" title="本地消息/队列"></a>本地消息/队列</h4><p>内存共享不太好用，因此本地消息有两种常见的方法。一种是用消息队列——现代操作系统都会提供类似的能力。Unix 系可以使用 POSIX 标准的 mqueue。另一种方式，就是直接用网络请求，比如 TCP/IP 协议，也包括建立在这之上的更多的通信协议（这些我们在下文中的“<strong>远程调用</strong>”部分详细讲解）。</p><p>本质上，这些都是收/发消息的模式。进程将需要传递的数据封装成格式确定的消息，这对写程序非常有帮助。程序员可以根据消息类型，分门别类响应消息；也可以根据消息内容，触发特殊的逻辑操作。在消息体量庞大的情况下，也可以构造生产者队列和消费者队列，用并发技术进行处理。</p><h4 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h4><p>远程调用（Remote Procedure Call，RPC）是一种通过本地程序调用来封装远程服务请求的方法。</p><p>程序员调用 RPC 的时候，程序看上去是在调用一个本地的方法，或者执行一个本地的任务，但是后面会有一个服务程序（通常称为 stub），将这种本地调用转换成远程网络请求。 同理，服务端接到请求后，也会有一个服务端程序（stub），将请求转换为一个真实的服务端方法调用。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628170950.png" alt="image-20210628170949931"></p><p>你可以观察上面这张图，表示客户端和服务端通信的过程，一共是 10 个步骤，分别是：</p><ol><li>客户端调用函数（方法）；</li><li>stub 将函数调用封装为请求；</li><li>客户端 socket 发送请求，服务端 socket 接收请求；</li><li>服务端 stub 处理请求，将请求还原为函数调用；</li><li>执行服务端方法；</li><li>返回结果传给 stub；</li><li>stub 将返回结果封装为返回数据；</li><li>服务端 socket 发送返回数据，客户端 socket 接收返回数据；</li><li>客户端 socket 将数据传递给客户端 stub；</li><li>客户端 stub 把返回数据转义成函数返回值。</li></ol><p>RPC 调用过程有很多约定， 比如函数参数格式、返回结果格式、异常如何处理。还有很多细粒度的问题，比如处理 TCP 粘包、处理网络异常、I/O 模式选型——其中有很多和网络相关的知识比较复杂，你可以参考我将在拉勾教育上线的《<strong>计算机网络》专栏</strong>。</p><p>上面这些问题比较棘手，因此在实战中通常的做法是使用框架。比如 Thrift 框架（Facebook 开源）、Dubbo 框架（阿里开源）、grpc（Google 开源）。这些 RPC 框架通常支持多种语言，这需要一个接口定义语言支持在多个语言间定义接口（IDL）。</p><p>RPC 调用的方式比较适合微服务环境的开发，当然 RPC 通常需要专业团队的框架以支持高并发、低延迟的场景。不过，硬要说 RPC 有额外转化数据的开销（主要是序列化），也没错，但这不是 RPC 的主要缺点。<strong>RPC 真正的缺陷是增加了系统间的耦合</strong>。<strong>当系统主动调用另一个系统的方法时</strong>，<strong>就意味着在增加两个系统的耦合</strong>。<strong>长期增加 RPC 调用</strong>，<strong>会让系统的边界逐渐腐</strong>化。这才是使用 RPC 时真正需要注意的东西。</p><p><strong>进程间通信都有哪些方法？</strong></p><p><strong>【解析】</strong> 你可以从<strong>单机和分布式角度</strong>给面试管阐述。</p><ul><li>如果考虑单机模型，有管道、内存共享、消息队列。这三个模型中，内存共享程序最难写，但是性能最高。管道程序最好写，有标准接口。消息队列程序也比较好写，比如用发布/订阅模式实现具体的程序。</li><li>如果考虑分布式模型，就有远程调用、消息队列和网络请求。直接发送网络请求程序不好写，不如直接用实现好的 RPC 调用框架。RPC 框架会增加系统的耦合，可以考虑 消息队列，以及发布订阅事件的模式，这样可以减少系统间的耦合。</li></ul><h3 id="服务应该开多少个进程、多少个线程？"><a href="#服务应该开多少个进程、多少个线程？" class="headerlink" title="服务应该开多少个进程、多少个线程？"></a><strong>服务应该开多少个进程、多少个线程？</strong></h3><h4 id="计算密集型和-I-O-密集型"><a href="#计算密集型和-I-O-密集型" class="headerlink" title="计算密集型和 I/O 密集型"></a>计算密集型和 I/O 密集型</h4><p>通常我们会遇到两种任务，一种是计算、一种是 I/O。</p><p><strong>计算</strong>，就是利用 CPU 处理算数运算。比如深度神经网络（Deep Neural Networks），需要大量的计算来计算神经元的激活和传播。再比如，根据营销规则计算订单价格，虽然每一个订单只需要少量的计算，但是在并发高的时候，所有订单累计加起来就需要大量计算。如果一个应用的主要开销在计算上，我们称为<strong>计算密集型</strong>。</p><p>再看看 <strong>I/O 密集型</strong>，I/O 本质是对设备的读写。读取键盘的输入是 I/O，读取磁盘（SSD）的数据是 I/O。通常 CPU 在设备 I/O 的过程中会去做其他的事情，当 I/O 完成，设备会给 CPU 一个中断，告诉 CPU 响应 I/O 的结果。比如说从硬盘读取数据完成了，那么硬盘给 CPU 一个中断。如果操作对 I/O 的依赖强，比如频繁的文件操作（写日志、读写数据库等），可以看作<strong>I/O 密集型</strong>。</p><p>你可能会有一个疑问，<strong>读取硬盘数据到内存中这个过程，CPU 需不需要一个个字节处理</strong>？</p><p>通常是不用的，因为在今天的计算机中有一个叫作 Direct Memory Access（DMA）的模块，这个模块允许硬件设备直接通过 DMA 写内存，而不需要通过 CPU（占用 CPU 资源）。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628171637.png" alt="image-20210628171637337"></p><p>很多情况下我们没法使用 DMA，比如说你想把一个数组拷贝到另一个数组内，执行的 memcpy 函数内部实现就是一个个 byte 拷贝，这种情况也是一种<strong>CPU 密集的操作</strong>。</p><p>可见，区分是计算密集型还是 I/O 密集型这件事比较复杂。按说查询数据库是一件 I/O 密集型的事情，但是如果存储设备足够好，比如用了最好的固态硬盘阵列，I/O 速度很快，反而瓶颈会在计算上（对缓存的搜索耗时成为主要部分）。因此，需要一些可衡量指标，来帮助我们确认应用的特性。</p><h4 id="衡量-CPU-的工作情况的指标"><a href="#衡量-CPU-的工作情况的指标" class="headerlink" title="衡量 CPU 的工作情况的指标"></a>衡量 CPU 的工作情况的指标</h4><p>我们先来看一下 CPU 关联的指标。如下图所示：CPU 有 2 种状态，忙碌和空闲。此外，CPU 的时间还有一种被偷走的情况。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628171759.png" alt="image-20210628171758977"></p><p>忙碌就是 CPU 在执行有意义的程序，空闲就是 CPU 在执行让 CPU 空闲（空转）的指令。通常让 CPU 空转的指令能耗更低，因此让 CPU 闲置时，我们会使用特别的指令，最终效果和让 CPU 计算是一样的，都可以把 CPU 执行时间填满，只不过这类型指令能耗低一些而已。除了忙碌和空闲，CPU 的时间有可能被宿主偷走，比如一台宿主机器上有 10 个虚拟机，宿主可以偷走给任何一台虚拟机的时间。</p><p>如上图所示，CPU 忙碌有 3 种情况：</p><ol><li>执行用户空间程序；</li><li>执行内核空间程序；</li><li>执行中断程序。</li></ol><p>CPU 空闲有 2 种情况。</p><ol><li>CPU 无事可做，执行空闲指令（注意，不能让 CPU 停止工作，而是执行能耗更低的空闲指令）。</li><li>CPU 因为需要等待 I/O 而空闲，比如在等待磁盘回传数据的中断，这种我们称为 I/O Wait。</li></ol><p>下图是我们执行 top 指令看到目前机器状态的快照，接下来我们仔细研究一下这些指标的含义：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628171907.png" alt="image-20210628171906894"></p><p>如上图所示，你可以细看下 <strong>%CPU(s)</strong> 开头那一行（第 3 行）：</p><ol><li>us（user），即用户空间 CPU 使用占比。</li><li>sy（system），即内核空间 CPU 使用占比。</li><li>ni（nice），nice 是 Unix 系操作系统控制进程优先级用的。-19 是最高优先级， 20 是最低优先级。这里代表了调整过优先级的进程的 CPU 使用占比。</li><li>id（idle），闲置的 CPU 占比。</li><li>wa（I/O Wait），I/O Wait 闲置的 CPU 占比。</li><li>hi（hardware interrupts），响应硬件中断 CPU 使用占比。</li><li>si（software interrrupts），响应软件中断 CPU 使用占比。</li><li>st（stolen），如果当前机器是虚拟机，这个指标代表了宿主偷走的 CPU 时间占比。对于一个宿主多个虚拟机的情况，宿主可以偷走任何一台虚拟机的 CPU 时间。</li></ol><p>上面我们用 top 看的是一个平均情况，如果想看所有 CPU 的情况可以 top 之后，按一下<code>1</code>键。结果如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628172018.png" alt="image-20210628172018226"></p><p>当然，对性能而言，CPU 数量也是一个重要因素。可以看到我这台虚拟机一共有 16 个核心。</p><h3 id="负载指标"><a href="#负载指标" class="headerlink" title="负载指标"></a>负载指标</h3><p>上面的指标非常多，在排查问题的时候，需要综合分析。其实还有一些更简单的指标，比如上图中 top 指令返回有一项叫作<code>load average</code>——平均负载。 负载可以理解成某个时刻正在排队执行的进程数除以 CPU 核数。平均负载需要多次采样求平均值。 如果这个值大于<code>1</code>，说明 CPU 相当忙碌。因此如果你想发现问题，可以先检查这个指标。</p><p>具体来说，如果平均负载很高，CPU 的 I/O Wait 也很高， 那么就说明 CPU 因为需要大量等待 I/O 无法处理完成工作。产生这个现象的原因可能是：线上服务器打日志太频繁，读写数据库、网络太频繁。你可以考虑进行批量读写优化。</p><p>到这里，你可能会有一个疑问：为什么批量更快呢？我们知道一次写入 1M 的数据，就比写一百万次一个 byte 快。因为前者可以充分利用 CPU 的缓存、复用发起写操作程序的连接和缓冲区等。</p><p>如果想看更多<code>load average</code>，你可以看<code>/proc/loadavg</code>文件。</p><h3 id="通信量（Traffic）"><a href="#通信量（Traffic）" class="headerlink" title="通信量（Traffic）"></a>通信量（Traffic）</h3><p>如果怀疑瓶颈发生在网络层面，或者想知道当前网络状况。可以查看<code>/proc/net/dev</code>，下图是在我的虚拟机上的查询结果：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628174552.png" alt="image-20210628174552044"></p><p>我们来一起看一下上图中的指标。表头分成了 3 段：</p><ul><li>Interface（网络接口），可以理解成网卡</li><li>Receive：接收的数据</li><li>Transmit：发送的数据</li></ul><p>然后再来看具体的一些参数：</p><ul><li>byte 是字节数</li><li>package 是封包数</li><li>erros 是错误数</li><li>drop 是主动丢弃的封包，比如说时间窗口超时了</li><li>fifo: FIFO 缓冲区错误（<strong>如果想了解更多可以关注我即将推出的《计算机网络》专栏</strong>）</li><li>frame: 底层网络发生了帧错误，代表数据出错了</li></ul><p>如果你怀疑自己系统的网络有故障，可以查一下通信量部分的参数，相信会有一定的收获。</p><h4 id="衡量磁盘工作情况"><a href="#衡量磁盘工作情况" class="headerlink" title="衡量磁盘工作情况"></a>衡量磁盘工作情况</h4><p>有时候 I/O 太频繁导致磁盘负载成为瓶颈，这个时候可以用<code>iotop</code>指令看一下磁盘的情况，如图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628174702.png" alt="image-20210628174702314"></p><p>上图中是磁盘当前的读写速度以及排行较靠前的进程情况。</p><p>另外，如果磁盘空间不足，可以用<code>df</code>指令：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628174718.png" alt="image-20210628174718444"></p><p>其实 df 是按照挂载的文件系统计算空间。图中每一个条目都是一个文件系统。有的文件系统直接挂在了一个磁盘上，比如图中的<code>/dev/sda5</code>挂在了<code>/</code>上，因此这样可以看到各个磁盘的使用情况。</p><p>如果想知道更细粒度的磁盘 I/O 情况，可以查看<code>/proc/diskstats</code>文件。 这里有 20 多个指标我就不细讲了，如果你将来怀疑自己系统的 I/O 有问题，可以查看这个文件，并阅读相关手册。</p><h4 id="监控平台"><a href="#监控平台" class="headerlink" title="监控平台"></a>监控平台</h4><p>Linux 中有很多指令可以查看服务器当前的状态，有 CPU、I/O、通信、Nginx 等维度。如果去记忆每个指令自己搭建监控平台，会非常复杂。这里你可以用市面上别人写好的开源系统帮助你收集这些资料。 比如 Taobao System Activity Report（tsar）就是一款非常好用的工具。它集成了大量诸如上面我们使用的工具，并且帮助你定时收集服务器情况，还能记录成日志。你可以用 logstash 等工具，及时将日志收集到监控、分析服务中，比如用 ELK 技术栈。</p><h4 id="决定进程-线程数量"><a href="#决定进程-线程数量" class="headerlink" title="决定进程/线程数量"></a>决定进程/线程数量</h4><p>最后我们讲讲如何决定线程、进程数量。 上面观察指标是我们必须做的一件事情，通过观察上面的指标，可以对我们开发的应用有一个基本的认识。</p><p>下面请你思考一个问题：<strong>如果线程或进程数量 = CPU 核数，是不是一个好的选择</strong>？</p><p>有的应用不提供线程，比如 PHP 和 Node.js。</p><p>Node.js 内部有一个事件循环模型，这个模型可以理解成协程（Coroutine），相当于大量的协程复用一个进程，可以达到比线程池更高的效率（减少了线程切换）。PHP 模型相对则差得多。Java 是一个多线程的模型，线程和内核线程对应比 1：1；Go 有轻量级线程，多个轻量级线程复用一个内核级线程。</p><p>以 Node.js 为例，如果现在是 8 个核心，那么开 8 个 Node 进程，是不是就是最有效利用 CPU 的方案呢？ 乍一看——8 个核、8 个进程，每个进程都可以使用 1 个核，CPU 利用率很高——其实不然。 你不要忘记，CPU 中会有一部分闲置时间是 I/O Wait，这个时候 CPU 什么也不做，主要时间用于等待 I/O。</p><p>假设我们应用执行的期间只用 50% CPU 的执行时间，其他 50% 是 I/O Wait。那么 1 个 CPU 同时就可以执行两个进程/线程。</p><p>我们考虑一个更一般的模型，如果你的应用平均 I/O 时间占比是 P，假设现在内存中有 n 个这样的线程，那么 CPU 的利用率是多少呢？</p><p>假设我们观察到一个应用 （进程），I/O 时间占比是 P，那么可以认为这个进程等待 I/O 的概率是 P。那么如果有 n 个这样的线程，n 个线程都在等待 I/O 的概率是Pn。而满负荷下，CPU 的利用率就是 CPU 不能空转——也就是不能所有进程都在等待 I/O。因此 CPU 利用率 = 1 -Pn。</p><p>理论上，如果 P = 50%，两个这样的进程可以达到满负荷。 但是从实际出发，何时运行线程是一个分时的调度行为，实际的 CPU 利用率还要看开了多少个这样的线程，如果是 2 个，那么还是会有一部分闲置资源。</p><p>因此在实际工作中，开的线程、进程数往往是超过 CPU 核数的。<strong>你可能会问，具体是多少最好呢</strong>？——这里没有具体的算法，要以实际情况为准。比如：你先以 CPU 核数 3 倍的线程数开始，然后进行模拟真实线上压力的测试，分析压测的结果。</p><ul><li>如果发现整个过程中，瓶颈在 CPU，比如<code>load average</code>很高，那么可以考虑优化 I/O Wait，让 CPU 有更多时间计算。</li><li>当然，如果 I/O Wait 优化不动了，算法都最优了，就是磁盘读写速度很高达到瓶颈，可以考虑延迟写、延迟读等等技术，或者优化减少读写。</li><li>如果发现 idle 很高，CPU 大面积闲置，就可以考虑增加线程。</li></ul><p><strong>我的服务应该开多少个进程、多少个线程？</strong></p><p><strong>【解析】</strong> 计算密集型一般接近核数，如果负载很高，建议留一个内核专门给操作系统。I/O 密集型一般都会开大于核数的线程和进程。 但是无论哪种模型，都需要实地压测，以压测结果分析为准；另一方面，还需要做好监控，观察服务在不同并发场景的情况，避免资源耗尽。</p><p>然后具体语言的特性也要考虑，Node.js 每个进程内部实现了大量类似协程的执行单元，因此 Node.js 即便在 I/O 密集型场景下也可以考虑长期使用核数 -1 的进程模型。而 Java 是多线程模型，线程池通常要大于核数才能充分利用 CPU 资源。</p><p>所以核心就一句，眼见为实，上线前要进行压力测试。</p><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628204545.png" alt="image-20210628204545448"></p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628204612.png" alt="image-20210628204612785"></p><p><strong>如果考虑到 CPU 缓存的存在，会对上面我们讨论的算法有什么影响</strong>？</p><p>这是一道需要大家查一些资料的题目。这里涉及一个叫作内存一致性模型的概念。具体就是说，在同一时刻，多线程之间，对内存中某个地址的数据认知是否一致（简单理解，就是多个线程读取同一个内存地址能不能读到一致的值）。</p><p>对某个地址，和任意时刻，如果所有线程读取值，得到的结果都一样，是一种强一致性，我们称为线性一致性（Sequencial Consistency），含义就是所有线程对这个地址中数据的历史达成了一致，历史没有分差，有一条大家都能认可的主线，因此称为线性一致。 如果只有部分时刻所有线程的理解是一致的，那么称为弱一致性（Weak Consistency）。</p><p>那么为什么会有内存不一致问题呢? 这就是因为 CPU 缓存的存在。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628210820.png" alt="image-20210628210820412"></p><p>如上图所示：假设一开始 A=0,B=0。两个不在同一个 CPU 核心执行的 Thread1、Thread2 分别执行上图中的简单程序。在 CPU 架构中，Thread1,Thread2 在不同核心，因此它们的 L1\L2 缓存不共用， L3 缓存共享。</p><p>在这种情况下，如果 Thread1 发生了写入 A=1，这个时候会按照 L1,L2,L3 的顺序写入缓存，最后写内存。而对于 Thread2 而言，在 Thread1 刚刚发生写入时，如果去读取 A 的值，就需要去内存中读，这个时候 A=1 可能还没有写入内存。但是对于线程 1 来说，它只要发生了写入 A=1，就可以从 L1 缓存中读取到这次写入。所以在线程 1 写入 A=1 的瞬间，线程 1 线程 2 无法对 A 的值达成一致，造成内存不一致。这个结果会导致 print 出来的 A 和 B 结果不确定，可能是 0 也可能是 1，取决于具体线程执行的时机。</p><p>考虑一个锁变量，和 cas 上锁操作，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lock = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!cas(&amp;lock, <span class="number">0</span>, <span class="number">1</span>))&#123;</span><br><span class="line">    <span class="comment">// CPU降低功耗的指令</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序构成了一个简单的自旋锁（spin-lock）。如果考虑到内存一致性模型，线程 1 通过 cas 操作将 lock 从 0 置 1。这个操作会先发生在线程所在 CPU 的 L1 缓存中。cas 函数通过底层 CPU 指令保证了原子性，cas 执行完成之前，线程 2 的 cas 无法执行。当线程 1 开始临界区的时候，假设这个时候线程 2 开始执行，尝试获取锁。如果这个过程切换非常短暂，线程 2 可能会从内存中读取 lock 的值（而这个值可能还没有写入，还在 Thread 所在 CPU 的 L1、L2 中），线程 2 可能也会通过 cas 拿到锁。两个线程同时进入了临界区，造成竞争条件。</p><p>这个时候，就需要强制让线程 2的读取指令一定等到写入指令彻底完成之后再执行，避免使用 CPU 缓存。Java 提供了一个 volatile 关键字实现这个能力，只需要这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> lock = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>就可以避免从读取不到对lock的写入问题。</p><p><strong>举例各 2 个悲观锁和乐观锁的应用场景</strong>？</p><p>乐观锁、悲观锁都能够实现避免竞争条件，实现数据的一致性。 比如减少库存的操作，无论是乐观锁、还是悲观锁都能保证最后库存算对（一致性）。 但是对于并发减库存的各方来说，体验是不一样的。悲观锁要求各方排队等待。 乐观锁，希望各方先各自进步。所以进步耗时较长，合并耗时较短的应用，比较适合乐观锁。 比如协同创作（写文章、视频编辑、写程序等），协同编辑（比如共同点餐、修改购物车、共同编辑商品、分布式配置管理等），非常适合乐观锁，因为这些操作需要较长的时间进步（比如写文章要思考、配置管理可能会连续修改多个配置）。乐观锁可以让多个协同方不急于合并自己的版本，可以先 focus 在进步上。</p><p>相反，悲观锁适用在进步耗时较短的场景，比如锁库存刚好是进步（一次库存计算）耗时少的场景。这种场景使用乐观锁，不但没有足够的收益，同时还会导致各个等待方（线程、客户端等）频繁读取库存——而且还会面临缓存一致性的问题（类比内存一致性问题）。这种进步耗时短，频繁同步的场景，可以考虑用悲观锁。类似的还有银行的交易，订单修改状态等。</p><p>再比如抢购逻辑，就不适合乐观锁。抢购逻辑使用乐观锁会导致大量线程频繁读取缓存确认版本（类似 cas 自旋锁），这种情况下，不如用队列（悲观锁实现）。</p><p>综上：有一个误区就是悲观锁对冲突持有悲观态度，所以性能低；乐观锁，对冲突持有乐观态度，鼓励线程进步，因此性能高。 这个不能一概而论，要看具体的场景。最后补充一下，悲观锁性能最高的一种实现就是阻塞队列，你可以参考 Java 的 7 种继承于 BlockingQueue 阻塞队列类型。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629101758.png" alt="image-20210629101758701"></p><p><strong>用你最熟悉的语言模拟分级队列调度的模型</strong>？</p><p>我用 Java 实现了一个简单的 yield 框架。 没有到协程的级别，但是也初具规模。考虑到协程实现需要更复杂一些，所以我用 PriorityQueue 来放高优任务；然后我用 LinkedList 来作为放普通任务的队列。Java 语言中的<code>add</code>和<code>remove</code>方法刚好构成了入队和出队操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private PriorityQueue&lt;Task&gt; urgents;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;LinkedList&lt;Task&gt;&gt; multLevelQueues;</span><br></pre></td></tr></table></figure><p>我实现了一个<code>submit</code>方法用于提交任务，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  var scheduler = new MultiLevelScheduler();</span><br><span class="line"></span><br><span class="line">  scheduler.submit((IYieldFunction yield) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;Urgent&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;, 10);</span><br></pre></td></tr></table></figure><p>普通任务我的程序中默认是 3 级队列。提交的任务优先级小于 100 的会放入紧急队列。每个任务就是一个简单的函数。我构造了一个 next() 方法用于决定下一个执行的任务，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    private Task next()&#123;</span><br><span class="line"></span><br><span class="line">        if(this.urgents.size() &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            return this.urgents.remove();</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; this.level; i++) &#123;</span><br><span class="line"></span><br><span class="line">                var queue = this.multLevelQueues.get(i);</span><br><span class="line"></span><br><span class="line">                if(queue.size() &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">                    return queue.remove();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先判断高优队列，然后再逐级看普通队列。</p><p>执行的程序就是递归调用 runNext() 方法，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> private void runNext()&#123;</span><br><span class="line"></span><br><span class="line">        var nextTask = this.next();</span><br><span class="line"></span><br><span class="line">        if(nextTask == null) &#123;return;&#125;</span><br><span class="line"></span><br><span class="line">        if(nextTask.isYield()) &#123;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nextTask.run(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            // yiled 内容……省略</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        this.runNext();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面程序中，如果当前任务在<code>yield</code>状态，那么终止当前程序。<code>yield</code>相当于函数调用，从<code>yield</code>函数调用中返回相当于继续执行。<code>yield</code>相当于任务主动让出执行时间。使用<code>yield</code>模式不需要线程切换，可以最大程度利用单核效率。</p><p>最后是<code>yield</code>的实现，nextTask.run 后面的匿名函数就是<code>yield</code>方法，它像一个调度程序一样，先简单保存当前的状态，然后将当前任务放到对应的位置（重新入队，或者移动到下一级队列）。如果当前任务是高优任务，<code>yield</code>程序会直接返回，因为高优任务没有必要<code>yield</code>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">nextTask.run(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    if(nextTask.level == -1) &#123;</span><br><span class="line"></span><br><span class="line">        // high-priority forbid yield</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextTask.setYield(true);</span><br><span class="line"></span><br><span class="line">    if(nextTask.level &lt; this.level - 1) &#123;</span><br><span class="line"></span><br><span class="line">        multLevelQueues.get(nextTask.level + 1).add(nextTask);</span><br><span class="line"></span><br><span class="line">        nextTask.setLevel(nextTask.level + 1);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        multLevelQueues.get(nextTask.level).add(nextTask);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.runNext();</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面是完成的程序，你可以在自己的 IDE 中尝试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line">import java.util.function.Function;</span><br><span class="line"></span><br><span class="line">public class MultiLevelScheduler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"></span><br><span class="line">     * High-priority</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private PriorityQueue&lt;Task&gt; urgents;</span><br><span class="line"></span><br><span class="line">    private ArrayList&lt;LinkedList&lt;Task&gt;&gt; multLevelQueues;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"></span><br><span class="line">     * Levels of Scheduler</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private int level = 3;</span><br><span class="line"></span><br><span class="line">    public MultiLevelScheduler()&#123;</span><br><span class="line"></span><br><span class="line">        this.init();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MultiLevelScheduler(int level) &#123;</span><br><span class="line"></span><br><span class="line">        this.level = level;</span><br><span class="line"></span><br><span class="line">        this.init();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init()&#123;</span><br><span class="line"></span><br><span class="line">        urgents = new PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        multLevelQueues = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; this.level; i++) &#123;</span><br><span class="line"></span><br><span class="line">            multLevelQueues.add(new LinkedList&lt;Task&gt;());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @FunctionalInterface</span><br><span class="line"></span><br><span class="line">    interface IYieldFunction &#123;</span><br><span class="line"></span><br><span class="line">        void yield();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @FunctionalInterface</span><br><span class="line"></span><br><span class="line">    interface ITask&#123;</span><br><span class="line"></span><br><span class="line">        void run(IYieldFunction yieldFunction);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Task implements Comparable&lt;Task&gt;&#123;</span><br><span class="line"></span><br><span class="line">        int level = -1;</span><br><span class="line"></span><br><span class="line">        ITask task;</span><br><span class="line"></span><br><span class="line">        int priority;</span><br><span class="line"></span><br><span class="line">        private boolean yield;</span><br><span class="line"></span><br><span class="line">        public Task(ITask task, int priority) &#123;</span><br><span class="line"></span><br><span class="line">           this.task = task;</span><br><span class="line"></span><br><span class="line">           this.priority = priority;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line"></span><br><span class="line">        public int compareTo(Task o) &#123;</span><br><span class="line"></span><br><span class="line">            return this.priority - o.priority;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getLevel() &#123;</span><br><span class="line"></span><br><span class="line">            return level;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setLevel(int level) &#123;</span><br><span class="line"></span><br><span class="line">            this.level = level;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run(IYieldFunction f) &#123;</span><br><span class="line"></span><br><span class="line">            this.task.run(f);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setYield(boolean yield) &#123;</span><br><span class="line"></span><br><span class="line">            this.yield = yield;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean isYield() &#123;</span><br><span class="line"></span><br><span class="line">            return yield;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void submit(ITask itask, int priority) &#123;</span><br><span class="line"></span><br><span class="line">        var task = new Task(itask, priority);</span><br><span class="line"></span><br><span class="line">        if(priority &gt;= 100) &#123;</span><br><span class="line"></span><br><span class="line">           this.multLevelQueues.get(0).add(task);</span><br><span class="line"></span><br><span class="line">           task.setLevel(0);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            this.urgents.add(task);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void submit(ITask t) &#123;</span><br><span class="line"></span><br><span class="line">        this.submit(t, 100);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Task next()&#123;</span><br><span class="line"></span><br><span class="line">        if(this.urgents.size() &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            return this.urgents.remove();</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; this.level; i++) &#123;</span><br><span class="line"></span><br><span class="line">                var queue = this.multLevelQueues.get(i);</span><br><span class="line"></span><br><span class="line">                if(queue.size() &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">                    return queue.remove();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void runNext()&#123;</span><br><span class="line"></span><br><span class="line">        var nextTask = this.next();</span><br><span class="line"></span><br><span class="line">        if(nextTask == null) &#123;return;&#125;</span><br><span class="line"></span><br><span class="line">        if(nextTask.isYield()) &#123;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nextTask.run(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            if(nextTask.level == -1) &#123;</span><br><span class="line"></span><br><span class="line">                // high-priority forbid yield</span><br><span class="line"></span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nextTask.setYield(true);</span><br><span class="line"></span><br><span class="line">            if(nextTask.level &lt; this.level - 1) &#123;</span><br><span class="line"></span><br><span class="line">                multLevelQueues.get(nextTask.level + 1).add(nextTask);</span><br><span class="line"></span><br><span class="line">                nextTask.setLevel(nextTask.level + 1);</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                multLevelQueues.get(nextTask.level).add(nextTask);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.runNext();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        this.runNext();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        this.runNext();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        var scheduler = new MultiLevelScheduler();</span><br><span class="line"></span><br><span class="line">        scheduler.submit((IYieldFunction yield) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Urgent&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;, 10);</span><br><span class="line"></span><br><span class="line">        scheduler.submit((IYieldFunction yield) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Most Urgent&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;, 0);</span><br><span class="line"></span><br><span class="line">        scheduler.submit((IYieldFunction yield) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;A1&quot;);</span><br><span class="line"></span><br><span class="line">            yield.yield();</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;A2&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        scheduler.submit((IYieldFunction yield) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        scheduler.submit((IYieldFunction f) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        scheduler.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是执行结果如下：</p><p><em>Most Urgent</em></p><p><em>Urgent</em></p><p><em>A1</em></p><p><em>B</em></p><p><em>C</em></p><p><em>A2</em></p><p><em>Process finished with exit code 0</em></p><p>我们看到结果中任务 1 发生了<code>yield</code>在打印 A2 之前交出了控制权导致任务 B,C 先被执行。如果你想在 yield 出上增加定时的功能，可以考虑 yield 发生后将任务移出队列，并在定时结束后重新插入回来。</p><p>什么情况下会触发饥饿和死锁？</p><p><strong>如果哲学家就餐问题拿起叉子、放下叉子，只需要微小的时间，主要时间开销集中在 think 需要计算资源（CPU 资源）上，那么使用什么模型比较合适</strong>？</p><p>哲学家就餐问题最多允许两组哲学家就餐，如果开销集中在计算上，那么只要同时有两组哲学家可以进入临界区即可。不考虑 I/O 成本，问题就很简化了，也失去了讨论的意义。比如简单要求哲学家们同时拿起左右手的叉子的做法就可以达到 2 组哲学家同时进餐。</p><p><strong>还有哪些我没有讲到的进程间通信方法</strong>？</p><p> 我看到有同学提到了 Android 系统的 OpenBinder 机制——允许不同进程的线程间调用（类似 RPC）。底层是 Linux 的文件系统和内核对 Binder 的驱动。</p><p>我还有没讲到的进程间的通信方法，比如说：</p><ul><li>使用数据库</li><li>使用普通文件</li><li>还有一种是信号，一个进程可以通过操作系统提供的信号。举个例子，假如想给某个进程（pid=9999）发送一个 USR1 信号，那么可以用：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -s USR1 9999</span><br></pre></td></tr></table></figure><p>进程 9999 可以通过写程序接收这个信号。 上述过程除了用<code>kill</code>指令外，还可以调用操作系统 API 完成。</p><p><strong>如果磁盘坏了，通常会是怎样的情况</strong>？</p><p>磁盘如果彻底坏了，服务器可能执行程序报错，无法写入，甚至死机。这些情况非常容易发现。而比较不容易观察的是坏道，坏道是磁盘上某个小区域数据无法读写了。有可能是硬损坏，就是物理损坏了，相当于永久损坏。也有可能是软损坏，比如数据写乱了。导致磁盘坏道的原因很多，比如电压不稳、灰尘、磁盘质量等问题。</p><p>磁盘损坏之前，往往还伴随性能整体的下降；坏道也会导致读写错误。所以在出现问题前，通常是可以在监控系统中观察到服务器性能指标变化的。比如 CPU 使用量上升，I/O Wait 增多，相同并发量下响应速度变慢等。</p><p>如果在工作中你怀疑磁盘坏了，可以用下面这个命令检查坏道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo badblocks -v /dev/sda5</span><br></pre></td></tr></table></figure><p>我的机器上是 /dev/sda5，你可以用<code>df</code>命令查看自己的文件系统。</p><h3 id="一个程序最多能使用多少内存？"><a href="#一个程序最多能使用多少内存？" class="headerlink" title="一个程序最多能使用多少内存？"></a><strong>一个程序最多能使用多少内存？</strong></h3><h4 id="为什么内存不够用？"><a href="#为什么内存不够用？" class="headerlink" title="为什么内存不够用？"></a>为什么内存不够用？</h4><p>总体来说，<strong>虚拟化技术是为了解决内存不够用的问题</strong></p><p>历史上有过不少的解决方案，但最终沉淀下的是虚拟化技术。接下来我为你介绍一种历史上存在过的 Swap 技术以及虚拟化技术。</p><h4 id="交换（Swap）技术"><a href="#交换（Swap）技术" class="headerlink" title="交换（Swap）技术"></a>交换（Swap）技术</h4><p>Swap 技术允许一部分进程使用内存，不使用内存的进程数据先保存在磁盘上。注意，这里提到的数据，是完整的进程数据，包括正文段（程序指令）、数据段、堆栈段等。轮到某个进程执行的时候，尝试为这个进程在内存中找到一块空闲的区域。如果空间不足，就考虑把没有在执行的进程交换（Swap）到磁盘上，把空间腾挪出来给需要的进程。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629102827.png" alt="image-20210629102827535"></p><p>上图中，内存被拆分成多个区域。 内核作为一个程序也需要自己的内存。另外每个进程独立得到一个空间——我们称为地址空间（<strong>Address Space）</strong>。你可以认为地址空间是一块连续分配的内存块。每个进程在不同地址空间中工作，构成了一个原始的虚拟化技术。</p><p>比如：当进程 A 想访问地址 100 的时候，实际上访问的地址是基于地址空间本身位置（首字节地址）计算出来的。另外，当进程 A 执行时，CPU 中会保存它地址空间的开始位置和结束位置，当它想访问超过地址空间容量的地址时，CPU 会检查然后报错。</p><p>上图描述的这种方法，是一种比较原始的虚拟化技术，进程使用的是基于地址空间的虚拟地址。但是这种方案有很多明显的缺陷，比如：</p><ol><li><strong>碎片问题</strong>：上图中我们看到进程来回分配、回收交换，内存之间会产生很多缝隙。经过反反复复使用，内存的情况会变得十分复杂，导致整体性能下降。</li><li><strong>频繁切换问题</strong>：如果进程过多，内存较小，会频繁触发交换。</li></ol><p>你可以先思考这两个问题的解决方案，接下来我会带你进行一些更深入地思考——首先重新 Review 下我们的设计目标。</p><ol><li>隔离：每个应用有自己的地址空间，互不影响。</li><li>性能：高频使用的数据保留在内存中、低频使用的数据持久化到磁盘上。</li><li>程序好写（降低程序员心智负担）：让程序员不用关心底层设施。</li></ol><p>现阶段，Swap 技术已经初步解决了问题 1。关于问题 2，Swap 技术在性能上存在着碎片、频繁切换等明显劣势。关于问题 3，使用 Swap 技术，程序员需要清楚地知道自己的应用用多少内存，并且小心翼翼地使用内存，避免需要重新申请，或者研发不断扩容的算法——这让程序心智负担较大。</p><p>经过以上分析，需要更好的解决方案，就是我们接下来要学习的虚拟化技术。</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟化技术中，操作系统设计了虚拟内存（理论上可以无限大的空间），受限于 CPU 的处理能力，通常 64bit CPU，就是 264 个地址。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103056.png" alt="image-20210629103056529"></p><p>虚拟化技术中，应用使用的是虚拟内存，操作系统管理虚拟内存和真实内存之间的映射。操作系统将虚拟内存分成整齐小块，每个小块称为一个<strong>页（Page）</strong>。之所以这样做，原因主要有以下两个方面。</p><ul><li><p>一方面应用使用内存是以页为单位，整齐的页能够避免内存碎片问题。</p></li><li><p>另一方面，每个应用都有高频使用的数据和低频使用的数据。这样做，操作系统就不必从应用角度去思考哪个进程是高频的，仅需思考哪些页被高频使用、哪些页被低频使用。如果是低频使用，就将它们保存到硬盘上；如果是高频使用，就让它们保留在真实内存中。</p></li></ul><p>如果一个应用需要非常大的内存，应用申请的是虚拟内存中的很多个页，真实内存不一定需要够用。</p><h4 id="页（Page）和页表"><a href="#页（Page）和页表" class="headerlink" title="页（Page）和页表"></a>页（Page）和页表</h4><p>接下来，我们详细讨论下这个设计。操作系统将虚拟内存分块，每个小块称为一个页（Page）；真实内存也需要分块，每个小块我们称为一个 Frame。Page 到 Frame 的映射，需要一种叫作页表的结构。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103155.png" alt="image-20210629103155027"></p><p>上图展示了 Page、Frame 和页表 （PageTable）三者之间的关系。 Page 大小和 Frame 大小通常相等，页表中记录的某个 Page 对应的 Frame 编号。页表也需要存储空间，比如虚拟内存大小为 10G， Page 大小是 4K，那么需要 10G/4K = 2621440 个条目。如果每个条目是 64bit，那么一共需要 20480K = 20M 页表。操作系统在内存中划分出小块区域给页表，并负责维护页表。</p><p>页表维护了虚拟地址到真实地址的映射。每次程序使用内存时，需要把虚拟内存地址换算成物理内存地址，换算过程分为以下 3 个步骤：</p><ol><li>通过虚拟地址计算 Page 编号；</li><li>查页表，根据 Page 编号，找到 Frame 编号；</li><li>将虚拟地址换算成物理地址。</li></ol><p>下面我通过一个例子给你讲解上面这个换算的过程：如果页大小是 4K，假设程序要访问地址：100,000。那么计算过程如下。</p><ol><li>页编号（Page Number） = 100,000/4096 = 24 <strong>余</strong>1619。 24 是页编号，1619 是地址偏移量（Offset）。</li><li>查询页表，得到 24 关联的 Frame 编号（假设查到 Frame 编号 = 10）。</li><li>换算：通常 Frame 和 Page 大小相等，替换 Page Number 为 Frame Number 物理地址 = 4096 * 10 + 1619 = 42579。</li></ol><h4 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h4><p>上面的过程发生在 CPU 中一个小型的设备——内存管理单元（Memory Management Unit， MMU）中。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103532.png" alt="image-20210629103532025"></p><p>当 CPU 需要执行一条指令时，如果指令中涉及内存读写操作，CPU 会把虚拟地址给 MMU，MMU 自动完成虚拟地址到真实地址的计算；然后，MMU 连接了地址总线，帮助 CPU 操作真实地址。</p><p>这样的设计，就不需要在编写应用程序的时候担心虚拟地址到物理地址映射的问题。我们把全部难题都丢给了操作系统——操作系统要确定MMU 可以读懂自己的页表格式。所以，操作系统的设计者要看 MMU 的说明书完成工作。</p><p>难点在于不同 CPU 的 MMU 可能是不同的，因此这里会遇到很多跨平台的问题。解决跨平台问题不但有繁重的工作量，更需要高超的编程技巧，Unix 最初期的移植性（跨平台）是 C 语言作者丹尼斯·里奇实现的。</p><p>学到这里，细心的同学可能会有疑问：MMU 需要查询页表（这是内存操作），而 CPU 执行一条指令通过 MMU 获取内存数据，难道可以容忍在执行一条指令的过程中，发生多次内存读取（查询）操作？难道一次普通的读取操作，还要附加几次查询页表的开销吗？当然不是，这里还有一些高速缓存的设计，这部分我们放到“<strong>25 讲</strong>”中详细讨论。</p><h4 id="页表条目"><a href="#页表条目" class="headerlink" title="页表条目"></a>页表条目</h4><p>上面我们笼统介绍了页表将 Page 映射到 Frame。那么，页表中的每一项（<strong>页表条目</strong>）长什么样子呢？下图是一个页表格式的一个演示。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103643.png" alt="image-20210629103643243"></p><p>页表条目本身的编号可以不存在页表中，而是通过偏移量计算。 比如地址 100,000 的编号，可以用 100,000 除以页大小确定。</p><ul><li>Absent（“在”）位，是一个 bit。0 表示页的数据在磁盘中（不再内存中），1 表示在内存中。如果读取页表发现 Absent = 0，那么会触发缺页中断，去磁盘读取数据。</li><li>Protection（保护）字段可以实现成 3 个 bit，它决定页表用于读、写、执行。比如 000 代表什么都不能做，100 代表只读等。</li><li>Reference（访问）位，代表这个页被读写过，这个记录对回收内存有帮助。</li><li>Dirty（“脏”）位，代表页的内容被修改过，如果 Dirty =1，那么意味着页面必须回写到磁盘上才能置换（Swap)。如果 Dirty = 0，如果需要回收这个页，可以考虑直接丢弃它（什么也不做，其他程序可以直接覆盖）。</li><li>Caching（缓存位），描述页可不可以被 CPU 缓存。CPU 缓存会造成内存不一致问题，在上个模块的加餐中我们讨论了内存一致性问题，具体你可以参考“<strong>模块四</strong>”的加餐内容。</li><li>Frame Number（Frame 编号），这个是真实内存的位置。用 Frame 编号乘以页大小，就可以得到 Frame 的基地址。</li></ul><p>在 64bit 的系统中，考虑到 Absent、Protection 等字段需要占用一定的位，因此不能将 64bit 都用来描述真实地址。但是 64bit 可以寻址的空间已经远远超过了 EB 的级别（1EB = 220TB），这已经足够了。在真实世界，我们还造不出这么大的内存呢。</p><h4 id="大页面问题"><a href="#大页面问题" class="headerlink" title="大页面问题"></a>大页面问题</h4><p>最后，我们讨论一下大页面的问题。假设有一个应用，初始化后需要 12M 内存，操作系统页大小是 4K。那么应该如何设计呢？</p><p>为了简化模型，下图中，假设这个应用只有 3 个区域（3 个段）——正文段（程序）、数据段（常量、全局变量）、堆栈段。一开始我们 3 个段都分配了 4M 的空间。随着程序执行，堆栈段的空间会继续增加，上不封顶。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103850.png" alt="image-20210629103850384"></p><p>上图中，进程内部需要一个页表存储进程的数据。如果进程的内存上不封顶，那么页表有多少个条目合适呢？ 进程分配多少空间合适呢？ 如果页表大小为 1024 个条目，那么可以支持 1024*4K = 4M 空间。按照这个计算，如果进程需要 1G 空间，则需要 256K 个条目。我们预先为进程分配这 256K 个条目吗？ 创建一个进程就划分这么多条目是不是成本太高了？</p><p>为了减少条目的创建，可以考虑进程内部用一个更大的页表（比如 4M），操作系统继续用 4K 的页表。这就形成了一个二级页表的结构，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103924.png" alt="image-20210629103924287"></p><p>这样 MMU 会先查询 1 级页表，再查询 2 级页表。在这个模型下，进程如果需要 1G 空间，也只需要 1024 个条目。比如 1 级页编号是 2， 那么对应 2 级页表中 [2* 1024, 3*1024-1] 的部分条目。而访问一个地址，需要同时给出一级页编号和二级页编号。整个地址，还可以用 64bit 组装，如下图所示：<img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629104016.png" alt="image-20210629104015892"></p><p>MMU 根据 1 级编号找到 1 级页表条目，1 级页表条目中记录了对应 2 级页表的位置。然后 MMU 再查询 2 级页表，找到 Frame。最后通过地址偏移量和 Frame 编号计算最终的物理地址。这种设计是一个递归的过程，因此还可增加 3 级、4 级……每增加 1 级，对空间的利用都会提高——当然也会带来一定的开销。这对于大应用非常划算，比如需要 1T 空间，那么使用 2 级页表，页表的空间就节省得多了。而且，这种多级页表，顶级页表在进程中可以先只创建需要用到的部分，就这个例子而言，一开始只需要 3 个条目，从 256K 个条目到 3 个，这就大大减少了进程创建的成本。</p><p><strong>一个程序最多能使用多少内存</strong>？</p><p>目前我们主要都是在用 64bit 的机器。因为 264 数字过于大，即便是虚拟内存都不需要这么大的空间。因此通常操作系统会允许进程使用非常大，但是不到 264 的地址空间。通常是几十到几百 EB（1EB = 106TB = 109GB)。</p><h3 id="什么情况下使用大内存分页？"><a href="#什么情况下使用大内存分页？" class="headerlink" title="什么情况下使用大内存分页？"></a><strong>什么情况下使用大内存分页</strong>？</h3><p>虚拟地址到物理地址的转换过程：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629142514.png" alt="image-20210629142514130"></p><p>MMU: Memory Management Unit</p><p>你可以把虚拟地址看成由页号和偏移量组成，把物理地址看成由 Frame Number 和偏移量组成。在 CPU 中有一个完成虚拟地址到物理地址转换的小型设备，叫作内存管理单元（Memory Management Unit(MMU）。</p><p>在程序执行的时候，指令中的地址都是虚拟地址，虚拟地址会通过 MMU，MMU 会查询页表，计算出对应的 Frame Number，然后偏移量不变，组装成真实地址。然后 MMU 通过地址总线直接去访问内存。所以 MMU 承担了虚拟地址到物理地址的转换以及 CPU 对内存的操作这两件事情。</p><p>如下图所示，从结构上 MMU 在 CPU 内部，并且直接和地址总线连接。因此 MMU 承担了 CPU 和内存之间的代理。对操作系统而言，MMU 是一类设备，有多种型号，就好比显卡有很多型号一样。操作系统需要理解这些型号，会使用 MMU。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629142927.png" alt="image-20210629142926877"></p><h4 id="TLB-和-MMU-的性能问题"><a href="#TLB-和-MMU-的性能问题" class="headerlink" title="TLB 和 MMU 的性能问题"></a>TLB 和 MMU 的性能问题</h4><p>上面的过程，会产生一个问题：指令的执行速度非常快，而 MMU 还需要从内存中查询页表。最快的内存查询页需要从 CPU 的缓存中读取，假设缓存有 95% 的命中率，比如读取到 L2 缓存，那么每次操作也需要几个 CPU 周期。你可以回顾一下 CPU 的指令周期，如下图所示，有 fetch/decode/execute 和 store。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629142948.png" alt="image-20210629142948243"></p><p>在 fetch、execute 和 store 这 3 个环节中都有可能发生内存操作，因此内存操作最好能在非常短的时间内完成，尤其是 Page Number 到 Frame Number 的映射，我们希望尽快可以完成，最好不到 0.2 个 CPU 周期，这样就不会因为地址换算而增加指令的 CPU 周期。</p><p>因此，在 MMU 中往往还有一个微型的设备，叫作转置检测缓冲区（Translation Lookaside Buffer，TLB）。</p><p>缓存的设计，通常是一张表，所以 TLB 也称作快表。TLB 中最主要的信息就是 Page Number到 Frame Number 的映射关系。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629143035.png" alt="image-20210629143035212"></p><p>如上表所示，最简单的表达就是一个二维表格，每一行是一个 Page Number 和一个 Frame Number。我们把这样的每一行称为一个缓存行（Cache Line），或者缓存条目（Entry）。</p><p><strong>TLB 的作用就是根据输入的 Page Number，找到 Frame Numbe</strong>r。TLB 是硬件实现的，因此速度很快。因为用户的局部程序，往往会反复利用相同的内存地址。比如说 for 循环会反复利用循环变量，因此哪怕是只有几十个缓存行的 TLB，也会有非常高的命中率。而且现在的多核 CPU，会为每个核心提供单独的 TLB。这样，相当于减少了 TLB 的冲突。比如酷睿 i7 CPU 当中，每个核心都有自己的 TLB，而且 TLB 还进行了类似 CPU 缓存的分级策略。在 i7 CPU 中，L1 级 TLB 一共 64 个，L2 级 TLB 一共 1024 个。通过这样的设计，绝大多数的页表查询就可以用 TLB 实现了。</p><h4 id="TLB-Miss-问题"><a href="#TLB-Miss-问题" class="headerlink" title="TLB Miss 问题"></a>TLB Miss 问题</h4><p>如果 Page Number 在 TLB 总没有找到，我们称为<strong>TLB 失效（Miss）</strong>。这种情况，分成两种。</p><p>一种是<strong>软失效</strong>（Soft Miss），这种情况 Frame 还在内存中，只不过 TLB 缓存中没有。那么这个时候需要刷新 TLB 缓存。如果 TLB 缓存已经满了，就需要选择一个已经存在的缓存条目进行覆盖。具体选择哪个条目进行覆盖，我们称为缓存置换（缓存不够用了，需要置换）。缓存置换时，通常希望高频使用的数据保留，低频使用的数据被替换。比如常用的 LRU（Least Recently Used）算法就是基于这种考虑，每次置换最早使用的条目。</p><p>另一种情况是<strong>硬失效（Hard Miss)**，这种情况下对应的 Frame 没有在内存中，需要从磁盘加载。这种情况非常麻烦，首先操作系统要触发一个缺页中断（原有需要读取内存的线程被休眠），然后中断响应程序开始从磁盘读取对应的 Frame 到内存中，读取完成后，再次触发中断通知更新 TLB，并且唤醒被休眠的线程去排队。</strong>注意，线程不可能从休眠态不排队就进入执行态，因此 Hard Miss 是相对耗时的**。</p><p><strong>无论是软失效、还是硬失效，都会带来性能损失，这是我们不希望看到的。因此缓存的设计，就非常重要了</strong>。</p><h4 id="TLB-缓存的设计"><a href="#TLB-缓存的设计" class="headerlink" title="TLB 缓存的设计"></a>TLB 缓存的设计</h4><p>每个缓存行可以看作一个映射，TLB 的缓存行将 Page Number 映射到 Frame Number，通常我们设计这种基于缓存行（Cache Line）的缓存有 3 种映射方案：</p><ul><li>全相联映射（Fully Associative Mapping）</li><li>直接映射（Direct Mapping）</li><li>n 路组相联映射（n-way Set-Associative Mapping）</li></ul><p>所谓相联（Associative），讲的是缓存条目和缓存数据之间的映射范围。如果是全相联，那么一个数据，可能在任何条目。如果是组相联（Set-Associative），意味对于一个数据，只能在一部分缓存条目中出现（比如前 4 个条目）。</p><p><strong>方案一：全相联映射（Fully Associative Mapping）</strong></p><p>如果 TLB 用全相联映射实现，那么一个 Frame，可能在任何缓存行中。虽然名词有点复杂，但是通常新人设计缓存时，会本能地想到全相联。因为在给定的空间下，最容易想到的就是把缓存数据都放进一个数组里。</p><p>对于 TLB 而言，如果是全相联映射，给定一个具体的 Page Number，想要查找 Frame，需要遍历整个缓存。当然作为硬件实现的缓存，如果缓存条目少的情况下，可以并行查找所有行。这种行为在软件设计中是不存在的，软件设计通常需要循环遍历才能查找行，但是利用硬件电路可以实现这种并行查找到过程。可是如果条目过多，比如几百个上千个，硬件查询速度也会下降。所以，全相联映射，有着明显性能上的缺陷。我们不考虑采用。</p><p><strong>方案二：直接映射（Direct Mapping）</strong></p><p>对于水平更高一些的同学，马上会想到直接映射。直接映射类似一种哈希函数的形式，给定一个内存地址，可以通过类似于哈希函数计算的形式，去计算它在哪一个缓存条目。假设我们有 64 个条目，那么可以考虑这个计算方法：<strong>缓存行号 = Page Number % 64</strong>。</p><p>当然在这个方法中，假如实际的虚拟地址空间大小是 1G，页面大小是 4K，那么一共有 1G/4K = 262144 个页，平均每 262144/64 = 4096 个页共享一个条目。这样的共享行为是很正常的，本身缓存大小就不可能太大，之前我们讲过，性能越高的存储离 CPU 越近，成本越高，空间越小。</p><p>上面的设计解决了全相联映射的性能缺陷，那么缓存命中率如何呢？</p><p>一种最简单的思考就是能不能基于直接映射实现 LRU 缓存。仔细思考，其实是不可能实现的。因为当我们想要置换缓存的时候（新条目进来，需要寻找一个旧条目出去），会发现每次都只有唯一的选择，因为对于一个确定的虚拟地址，它所在的条目也是确定的。这导致直接映射不支持各种缓存置换算法，因此 TLB Miss 肯定会更高。</p><p>综上，我们既要解决直接映射的缓存命中率问题，又希望解决全相联映射的性能问题。而核心就是需要能够实现类似 LRU 的算法，让高频使用的缓存留下来——最基本的要求，就是一个被缓存的值，必须可以存在于多个位置——于是人们就发明了 n 路组相联映射。</p><p><strong>方案三：n 路组相联映射（n-way Set-Associative Mapping）</strong></p><p>组相联映射有点像哈希表的开放寻址法，但是又有些差异。组相联映射允许一个虚拟页号（Page Number）映射到固定数量的 n 个位置。举个例子，比如现在有 64 个条目，要查找地址 100 的位置，可以先用一个固定的方法计算，比如 100%64 = 36。这样计算出应该去条目 36 获取 Frame 数据。但是取出条目 36 看到条目 36 的 Page Number 不是 100，这个时候就顺延一个位置，去查找 37,38,39……如果是 4 路组相联，那么就只看 36,37,38,39，如果是8 路组相联，就只看 36-43 位置。</p><p>这样的方式，一个 Page Number 可以在 n 个位置出现，这样就解决了 LRU 算法的问题。每次新地址需要置换进来的时候，可以从 n 个位置中选择更新时间最早的条目置换出去。至于具体 n 设置为多少，需要实战的检验。而且缓存是一个模糊、基于概率的方案，本身对 n 的要求不是很大。比如：i7 CPU 的 L1 TLB 采用 4-way 64 条目的设计；L2 TLB 采用 8-way 1024 条目的设计。Intel 选择了这样的设计，背后有大量的数据支撑。这也是缓存设计的一个要点，在做缓存设计的时候，你一定要收集数据实际验证。</p><p>以上，我们解决了 TLB 的基本设计问题，最后选择采用 n 路组相联映射。 然后还遗留了一个问题，如果一个应用（进程）对内存的需求比较大，比如 1G，而默认分页 4K 比较小。 这种情况下会有 262144 个页。考虑到 1024 个条目的 TLB，那么 262144/1024 = 256，如果 256 个地址复用 1 个缓存，很容易冲突。这个问题如何解决呢？</p><h4 id="大内存分页"><a href="#大内存分页" class="headerlink" title="大内存分页"></a>大内存分页</h4><p>解决上面的遗留问题，可以考虑采用大内存分页（Large Page 或 Huge Page）。 这里我们先复习一下上一讲学习的多级页表。 多层页面就是进程内部维护一张页表，比如说 4M 一个页表（一级），然后每个一级页表关联 1024 个二级页表。 这样会给 MMU 带来一定的负担，因为 MMU 需要先检查一级页表，再检查二级页表。 但是 MMU 仍然可以利用 TLB 进行加速。因为 TLB 是缓存，所有根据值查找结果的逻辑，都可以用 TLB。</p><p>但是这没有解决我们提出的页表太多的问题，最终这种多级页表的设计还是需要查询大小为 4K 的页（这里请你思考上面的例子，如果是 1G 空间有 262144 个页）。如果我们操作系统能够提供大小为 4M 的页，那么是不是就减少了 1024 倍的页数呢？ ——这样就大大提高了 TLB 的查询性能。</p><p>因此 Linux 内核 2.6 版之后就开始提供大内存分页（HugeTable），默认是不开启的。如果你有应用需要使用大内存分页，可以考虑用下面的语句开启它：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w vm.nr_hugepages=2048</span><br></pre></td></tr></table></figure><p><code>sysctl</code>其实就是修改一下配置项，上面我们允许应用使用最多 2048 个大内存页。上面语句执行后，你可以按照下方截图的方式去查看自己大内存页表使用的情况。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629144737.png" alt="image-20210629144736821"></p><p>从上图中你可以看到我总共有 2048 个大内存页，每个大小是 2048KB。具体这个大小是不可以调整的，这个和机器用的 MMU 相关。</p><p>打开大内存分页后如果有应用需要使用，就会去申请大内存分页。比如 Java 应用可以用<code>-XX:+UseLargePages</code>开启使用大内存分页。 下图是我通过一个 Java 程序加上 UseLargePages 参数的结果。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629144754.png" alt="image-20210629144754602"></p><p>注意：我的 Java 应用使用的分页数 = Total-Free+Rsvd = 2048-2032+180 = 196。Total 就是总共的分页数，Free 代表空闲的（包含 Rsvd，Reserved 预留的）。因此是上面的计算关系。</p><p><strong>什么情况下使用大内存分页</strong>？</p><p>通常应用对内存需求较大时，可以考虑开启大内存分页。比如一个搜索引擎，需要大量在内存中的索引。有时候应用对内存的需求是隐性的。比如有的机器用来抗高并发访问，虽然平时对内存使用不高，但是当高并发到来时，应用对内存的需求自然就上去了。虽然每个并发请求需要的内存都不大， 但是总量上去了，需求总量也会随之提高高。这种情况下，你也可以考虑开启大内存分页。</p><h3 id="LRU-用什么数据结构实现更合理？"><a href="#LRU-用什么数据结构实现更合理？" class="headerlink" title="LRU 用什么数据结构实现更合理？"></a><strong>LRU 用什么数据结构实现更合理？</strong></h3><p>LRU（最近最少使用），是一种缓存置换算法。缓存是用来存储常用的数据，加速常用数据访问的数据结构。有软件实现，比如数据库的缓存；也有硬件实现，比如我们上一讲学的 TLB。<strong>缓存设计中有一个重要的环节：当缓存满了，新的缓存条目要写入时，哪个旧条目被置换出去呢</strong>？</p><p>这就需要用到缓存置换算法（Cache Replacement Algorithm）。缓存置换应用场景非常广，比如发生缺页中断后，操作系统需要将磁盘的页导入内存，那么已经在内存中的页就需要置换出去。CDN 服务器为了提高访问速度，需要决定哪些 Web 资源在内存中，哪些在磁盘上。CPU 缓存每次写入一个条目，也就相当于一个旧的条目被覆盖。数据库要决定哪些数据在内存中，应用开发要决定哪些数据在 Redis 中，而空间是有限的，这些都关联着缓存的置换。</p><p>今天我们就以 LRU 用什么数据结构实现更合理，这道缓存设计题目为引，为你讲解缓存设计中（包括置换算法在内）的一些通用的思考方法。</p><h4 id="理想状态"><a href="#理想状态" class="headerlink" title="理想状态"></a>理想状态</h4><p><strong>设计缓存置换算法的期望是：每次将未来使用频率最低的数据置换出去</strong>。假设只要我们知道未来的所有指令，就可以计算出哪些内存地址在未来使用频率高，哪些内存地址在未来使用频率低。这样，我们总是可以开发出理论上最高效的缓存置换算法。</p><p>再复习下缓存的基本概念，在缓存中找到数据叫作一次命中（Hit），没有找到叫作穿透（Miss）。假设穿透的概率为 M，缓存的访问时间（通常叫作延迟）是 L，穿透的代价（访问到原始数据，比如 Redis 穿透，访问到 DB）也就是穿透后获取数据的平均时间是 T，那么 M*T+L 可以看作是接近缓存的平均响应时间。L 通常是不变的，这个和我们使用了什么缓存相关。这样，如果我们知道未来访问数据的顺序，就可以把 M 降到最低，让缓存平均响应时间降到最低。</p><p>当然这只是美好的愿望，在实际工作中我们还不可能预知未来。</p><h4 id="随机-FIFO-FILO"><a href="#随机-FIFO-FILO" class="headerlink" title="随机/FIFO/FILO"></a>随机/FIFO/FILO</h4><p>接下来我要和你讨论的 3 种策略，是对理想状态的一种悲观表达，或者说不好的设计。</p><p>比如说随机置换，一个新条目被写入，随机置换出去一个旧条目。这种设计，具有非常朴素的公平，但是性能会很差（穿透概率高），因为可能置换出去未来非常需要的数据。</p><p>再比如先进先出（First In First Out）。设计得不好的电商首页，每次把离现在时间最久的产品下线，让新产品有机会展示，而忽略销量、热度、好评等因素。这也是一种朴素的公平，但是和我们设计缓存算法的初衷——预估未来使用频率更高的数据保留在缓存中，相去甚远。所以，FIFO 的结构也是一种悲观的设计。</p><p>FIFO 的结构使用一个链表就能实现，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145239.png" alt="image-20210629145239118"></p><p>为了方便你理解本讲后面的内容，我在这里先做一个知识铺垫供你参考。上图中，新元素从链表头部插入，旧元素从链表尾部离开。 这样就构成了一个队列（Queue），队列是一个经典的 FIFO 模型。</p><p>还有一种策略是先进后出（First In Last Out）。但是这种策略和 FIFO、随机一样，没有太强的实际意义。因为先进来的元素、后进来的元素，还是随机的某个元素，和我们期望的未来使用频率，没有任何本质联系。</p><p>同样 FILO 的策略也可以用一个链表实现，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145400.png" alt="image-20210629145400071"></p><p>新元素从链表头部插入链表，旧元素从链表头部离开链表，就构成了一个栈（Stack），栈是一种天然的 FILO 数据结构。这里仅供参考了，我们暂时还不会用到这个方法。</p><p>当然我们不可能知道未来，但是可以考虑基于历史推测未来。经过前面的一番分析，接下来我们开始讨论一些更有价值的置换策略。</p><h4 id="最近未使用（NRU）"><a href="#最近未使用（NRU）" class="headerlink" title="最近未使用（NRU）"></a>最近未使用（NRU）</h4><p>一种非常简单、有效的缓存实现就是优先把最近没有使用的数据置换出去（Not Recently Used)。从概率上说，最近没有使用的数据，未来使用的概率会比最近经常使用的数据低。缓存设计本身也是基于概率的，一种方案有没有价值必须经过实践验证——在内存缺页中断后，如果采用 NRU 置换页面，可以提高后续使用内存的命中率，这是实践得到的结论。</p><p>而且 NRU 实现起来比较简单，下图是我们在“<strong>24 讲</strong>”中提到的页表条目设计。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145457.png" alt="image-20210629145457762"></p><p>在页表中有一个访问位，代表页表有被读取过。还有一个脏位，代表页表被写入过。无论是读还是写，我们都可以认为是访问过。 为了提升效率，一旦页表被使用，可以用硬件将读位置 1，然后再设置一个定时器，比如 100ms 后，再将读位清 0。当有内存写入时，就将写位置 1。过一段时间将有内存写入的页回写到磁盘时，再将写位清 0。这样读写位在读写后都会置为 1，过段时间，也都会回到 0。</p><p>上面这种方式，就构成了一个最基本的 NRU 算法。每次置换的时候，操作系统尽量选择读、写位都是 0 的页面。而一个页面如果在内存中停留太久，没有新的读写，读写位会回到 0，就可能会被置换。</p><p>这里多说一句，NRU 本身还可以和其他方法结合起来工作，比如我们可以利用读、写位的设计去改进 FIFO 算法。</p><p>每次 FIFO 从队列尾部找到一个条目要置换出去的时候，就检查一下这个条目的读位。如果读位是 0，就删除这个条目。如果读位中有 1，就把这个条目从队列尾部移动到队列的头部，并且把读位清 0，相当于多给这个条目一次机会，因此也被称为<strong>第二次机会算法</strong>。多给一次机会，就相当于发生访问的页面更容易存活。而且，这样的算法利用天然的数据结构优势（队列），保证了 NRU 的同时，节省了去扫描整个缓存寻找读写位是 0 的条目的时间。</p><p>第二次机会算法还有一个更巧妙的实现，就是利用循环链表。这个实现可以帮助我们节省元素从链表尾部移动到头部的开销。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145715.png" alt="image-20210629145715823"></p><p>如上图所示，我们可以将从尾部移动条目到头部的这个操作简化为头指针指向下一个节点。每次移动链表尾部元素到头部，只需要操作头指针指向下一个元素即可。这个方法非常巧妙，而且容易实现，你可以尝试在自己系统的缓存设计中尝试使用它。</p><p><strong>以上，是我们学习的第一个比较有价值的缓存置换算法。基本可用，能够提高命中率</strong>。缺点是只考虑了最近用没用过的情况，没有充分考虑综合的访问情况。优点是简单有效，性能好。缺点是考虑不周，对缓存的命中率提升有限。但是因为简单，容易实现，NRU 还是成了一个被广泛使用的算法。</p><h4 id="最近使用最少（LRU）"><a href="#最近使用最少（LRU）" class="headerlink" title="最近使用最少（LRU）"></a>最近使用最少（LRU）</h4><p>一种比 NRU 考虑更周密，实现成本更高的算法是最近最少使用（Least Recently Used， LRU）算法，它会置换最久没有使用的数据。和 NRU 相比，LRU 会考虑一个时间范围内的数据，对数据的参考范围更大。LRU 认为，最近一段时间最少使用到的数据应该被淘汰，把空间让给最近频繁使用的数据。这样的设计，即便数据都被使用过，还是会根据使用频次多少进行淘汰。比如：CPU 缓存利用 LUR 算法将空间留给频繁使用的内存数据，淘汰使用频率较低的内存数据。</p><p><strong>常见实现方案</strong></p><p>LRU 的一种常见实现是链表，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629153904.png" alt="image-20210629153903931"></p><p>用双向链表维护缓存条目。如果链表中某个缓存条目被使用到，那么就将这个条目重新移动到表头。如果要置换缓存条目出去，就直接从双线链表尾部删除一个条目。</p><p>通常 LRU 缓存还要提供查询能力，这里我们可以考虑用类似 Java 中 LinkedHashMap 的数据结构，同时具备双向链表和根据 Key 查找值的能力。</p><p>以上是常见的实现方案，但是这种方案在缓存访问量非常大的情况下，需要同时维护一个链表和一个哈希表，因此开销较高。</p><p><strong>举一个高性能场景的例子，比如页面置换算法。</strong> 如果你需要维护一个很大的链表来存储所有页，然后经常要删除大量的页面（置换缓存），并把大量的页面移动到链表头部。这对于页面置换这种高性能场景来说，是不可以接受的。</p><p><strong>另外一个需要 LRU 高性能的场景是 CPU 的缓存</strong>，CPU 的多路组相联设计，比如 8-way 设计，需要在 8 个地址中快速找到最久未使用的数据，不可能再去内存中建立一个链表来实现。</p><p>正因为有这么多困难，才需要不断地优化迭代，让缓存设计成为一门艺术。接下来我选取了内存置换算法中数学模拟 LRU 的算法，分享给你。</p><p><strong>如何描述最近使用次数？</strong></p><p><strong>设计 LRU 缓存第一个困难是描述最近使用次数</strong>。 因为“最近”是一个模糊概念，没有具体指出是多长时间？按照 CPU 周期计算还是按照时间计算？还是用其他模糊的概念替代？</p><p>比如说页面置换算法。在实际的设计中，可以考虑把页表的读位利用起来。做一个定时器，每隔一定的 ms 数，就把读位累加到一个计数器中。相当于在每个页表条目上再增加一个累计值。</p><p>例如：现在某个页表条目的累计值是 0， 接下来在多次计数中看到的读位是：1,0,0,1,1，那么累计值就会变成 3。这代表在某段时间内（5 个计数器 Tick 中）有 3 次访问操作。</p><p>通过这种方法，就解决了描述使用次数的问题。如果单纯基于使用次数最少判断置换，我们称为最少使用（Least Frequently Used,，LFU）算法。<strong>LFU 的劣势在于它不会忘记数据，累计值不会减少</strong>。比如如果有内存数据过去常常被用到，但是现在已经有很长一段时间没有被用到了，在这种情况下它并不会置换出去。那么我们该如何描述“最近”呢？</p><p>有一个很不错的策略就是利用一个叫作“老化”（Aging）的算法。比起传统的累加计数的方式，Aging 算法的累加不太一样。</p><p>比如用 8 位来描述累计数（A），那么每次当读位的值（R）到来的时候，我们都考虑将 A 的值右移，然后将 R 放到 A 的最高位。</p><p>例如 A 目前的值是<code>00000000</code>，在接下来的 5 个 Tick 中 R 来临的序列是<code>11100</code>，那么 A 的值变更顺序为：</p><ol><li>10000000</li><li>11000000</li><li>11100000</li><li>01110000</li><li>00111000</li></ol><p>你可以看到随着 Aging 算法的执行，有访问操作的时候 A 的值上升，没有访问操作的时候，A的值逐渐减少。如果一直没有访问操作，A 的值会回到 0。</p><p>这样的方式就巧妙地用数学描述了“最近”。然后操作系统每次页面置换的时候，都从 A 值最小的集合中取出一个页面放入磁盘。这个算法是对 LRU 的一种模拟，也被称作 LFUDA（动态老化最少使用，其中 D 是 Dynamic,，A 是 Aging）。</p><p>而计算 Aging（累计值）的过程，可以由硬件实现，这样就最大程度提升了性能。</p><p>相比写入操作，查询是耗时相对较少的。这是因为有 CPU 缓存的存在，我们通常不用直接去内存中查找数据，而是在缓存中进行。对于发生缺页中断的情况，并不需要追求绝对的精确，可以在部分页中找到一个相对累计值较小的页面进行置换。不过即便是模拟的 LRU 算法，也不是硬件直接支持的，总有一部分需要软件实现，因此还是有较多的时间开销。</p><p><strong>是否采用 LRU，一方面要看你所在场景的性能要求，有没有足够的优化措施（比如硬件提速）；另一方面，就要看最终的结果是否能够达到期望的命中率和期望的使用延迟了</strong>。</p><p>本讲我们讨论的频次较高、频次较低，是基于历史的。 历史在未来并不一定重演。比如读取一个大型文件，无论如何操作都很难建立一个有效的缓存。甚至有的时候，最近使用频次最低的数据被缓存，使用频次最高的数据被置换，效率会更高。比如说有的数据库设计同时支持 LRU 缓存和 MRU（ Most Recently Used）缓存。MRU 是 LRU 的对立面，这看似茅盾，但其实是为了解决不同情况下的需求。</p><p>这并不是说缓存设计无迹可寻，而是经过思考和预判，还得以事实的命中率去衡量缓存置换算法是否合理。</p><p><strong>LRU 用什么数据结构实现更合理</strong>？</p><p>最原始的方式是用数组，数组的每一项中有数据最近的使用频次。数据的使用频次可以用计时器计算。每次置换的时候查询整个数组实现。</p><p>另一种更好的做法是利用双向链表实现。将使用到的数据移动到链表头部，每次置换时从链表尾部拿走数据。链表头部是最近使用的，链表尾部是最近没有被使用到的数据。</p><p>但是在应对实际的场景的时候，有时候不允许我们建立专门用于维护缓存的数据结构（内存大小限制、CPU 使用限制等），往往需要模拟 LRU。比如在内存置换场景有用“老化”技术模拟 LRU 计算的方式。</p><h3 id="如何解决内存的循环引用问题？"><a href="#如何解决内存的循环引用问题？" class="headerlink" title="如何解决内存的循环引用问题？"></a><strong>如何解决内存的循环引用问题？</strong></h3><p>内存泄漏一直是很多大型系统故障的根源，也是一个面试热点。那么在编程语言层面已经提供了内存回收机制，为什么还会产生内存泄漏呢？</p><p>这是因为应用的内存管理一直处于一个和应用程序执行并发的状态，如果应用程序申请内存的速度，超过内存回收的速度，内存就会被用满。当内存用满，操作系统就开始需要频繁地切换页面，进行频繁地磁盘读写。</p><p><strong>所以我们观察到的系统性能下降，往往是一种突然的崩溃，因为一旦内存被占满，系统性能就开始雪崩式下降</strong>。</p><p>特别是有时候程序员不懂内存回收的原理，错误地使用内存回收器，导致部分对象没有被回收。而在高并发场景下，每次并发都产生一点不能回收的内存，不用太长时间内存就满了，这就是泄漏通常的成因。</p><p>这一块知识点关联着很多常见的面试题，比如。</p><ul><li>这一讲关联的题目：如何解决循环引用问题？</li><li>下节课关联的题目：三色标记-清除算法的工作原理？生代算法等。</li><li>还有一些题目会考察你对内存回收器整体的理解，比如如何在吞吐量、足迹和暂停时间之间选择？</li></ul><p>接下来，我会用 27 和 28 两讲和你探讨内存回收技术，把这些问题一网打尽。</p><h4 id="什么是-GC"><a href="#什么是-GC" class="headerlink" title="什么是 GC"></a>什么是 GC</h4><p>通常意义上我们说的垃圾回收器（Garbage Collector，GC），和多数同学的理解会有出入。你可能认为 GC 是做内存回收用的模块，而事实上程序语言提供的 GC 往往是应用的实际内存管理者。刚刚入门咱们就遇到了一个容易出现理解偏差的问题，所以 GC 是值得花时间细学的。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629161923.png" alt="image-20210629161923118"></p><p>如上图所示，一方面 GC 要承接操作系统虚拟内存的架构，另一方面 GC 还要为应用提供内存管理。GC 有一个含义，就是 Garbage Collection 内存回收的具体动作。无论是名词的回收器，还是动词的回收行为，在下文中我都称作 GC。</p><p>下面我们具体来看一下 GC 都需要承担哪些“工作”，这里我总结为以下 4 种。</p><ol><li>GC 要和操作系统进行交互，负责申请内存，并把不用的内存还给操作系统（释放内存）。</li><li>应用会向 GC 申请内存。</li><li>GC 要承担我们通常意义上说的垃圾回收能力，标记不用的对象，并回收他们。</li><li>GC 还需要针对应用特性进行动态的优化。</li></ol><p>所以现在程序语言实现的 GC 模块通常是实际负责应用内存管理的模块。在程序语言实现 GC 的时候，会关注下面这几个指标。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629163221.png" alt="image-20210629163221753"></p><ul><li><strong>吞吐量（Throughput）</strong>：执行程序（不包括 GC 执行的时间）和总是间的占比。注意这个吞吐量和通常意义上应用去处理作业的吞吐量是不一样的，这是从 GC 的角度去看应用。只要不在 GC，就认为是吞吐量的一部分。</li><li><strong>足迹（FootPrint）</strong>： 一个程序使用了多少硬件的资源，也称作程序在硬件上的足迹。GC 里面说的足迹，通常就是应用对内存的占用情况。比如说应用运行需要 2G 内存，但是好的 GC 算法能够帮助我们减少 500MB 的内存使用，满足足迹这个指标。</li><li><strong>暂停时间（Pause Time）</strong>： GC 执行的时候，通常需要停下应用（避免同步问题），这称为 Stop The World，或者暂停。不同应用对某次内存回收可以暂停的时间需求是不同的，比如说一个游戏应用，暂停了几毫秒用户都可能有很大意见；而看网页的用户，稍微慢了几毫秒是没有感觉的。</li></ul><p>GC 目标的思考</p><p>如果单纯从让 GC 尽快把工作做完的角度来讲，其实是提升吞吐量。比如利用好多核优势就是一种最直观的方法。</p><p>因为涉及并行计算，我这里给你讲讲并行计算领域非常重要的阿姆达定律，这个定律用来衡量并行计算对原有算法的改进，公式如下：</p><p>S = 1 / (1- P)</p><p>你现在看到的是一个简化版的阿姆达定律，P 是任务中可以并发执行部分的占比，S 是并行带来的理论提速倍数的极限。比如说 P 是 0.9，代入公式可得：</p><p>S = 1 / （1 - 0.9） = 10</p><p>上面表达式代表着有 90% 的任务可以并行，只有 10% 的任务不能够并行。假设我们拥有无限多的 CPU 去分担 90% 可以并行的任务，其实就相当于并行的任务可以在非常短的时间内完成。但是还有 10% 的任务不能并行，因此理论极限是 1/0.1=10 倍。</p><p>通常我们设计 GC，都希望它能够支持并行处理任务。因为 GC 本身也有着繁重的工作量，需要扫描所有的对象，对内存进行标记清除和整理等。</p><p><strong>经过上述分析，那么我们在设计算法的时候是不是应该尽量做到高并发呢？</strong></p><p>很可惜并不是这样。如果算法支持的并发度非常高，那么和单线程算法相比，它也会带来更多的其他开销。比如任务拆分的开销、解决同步问题的开销，还有就是空间开销，GC 领域空间开销通常称为 FootPrint。理想情况下当然是核越多越好，但是如果考虑计算本身的成本，就需要找到折中的方案。</p><p>还有一个问题是，GC 往往不能拥有太长的暂停时间（Pause Time），因为 GC 和应用是并发的执行。如果 GC 导致应用暂停（Stop The World，STL）太久，那么对有的应用来说是灾难性的。 比如说你用鼠标的时候，如果突然卡了你会很抓狂。如果一个应用提供给百万级的用户用，假设这个应用帮每个用户每天节省了 1s 的等待时间，那么按照乔布斯的说法每天就为用户节省了 11 天的时间，每年是 11 年——5 年就相当于拯救了一条生命。</p><p>如果暂停时间只允许很短，那么 GC 和应用的交替就需要非常频繁。这对 GC 算法要求就会上升，因为每次用户程序执行后，会产生新的变化，甚至会对已有的 GC 结果产生影响。后面我们在讨论标记-清除算法的时候，你会感受到这种情况。</p><p>所以说，吞吐量高，不代表暂停时间少，也不代表空间使用（FootPrint）小。 同样的，使用空间小的 GC 算法，吞吐量反而也会下降。<strong>正因为三者之间存在类似相同成本代价下不可兼得的关系，往往编程语言会提供参数让你选择根据自己的应用特性决定 GC 行为</strong>。</p><h4 id="引用计数算法（Reference-Counter）"><a href="#引用计数算法（Reference-Counter）" class="headerlink" title="引用计数算法（Reference Counter）"></a>引用计数算法（Reference Counter）</h4><p>接下来我们说说，具体怎么去实现 GC。实现 GC 最简单的方案叫作引用计数，下图中节点的引用计数是 2，代表有两个节点都引用了它。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629164711.png" alt="image-20210629164710950"></p><p>如果一个节点的引用计数是 0，就意味着没有任何一个节点引用它——此时，理论上这个节点应该被回收。GC 不断扫描引用计数为 0 的节点进行回收，就构成了最简单的一个内存回收算法。</p><p>但是，这个算法可能会出现下图中循环引用的问题（我们写程序的过程中经常会遇到这样的引用关系）。下图中三个节点，因为循环引用，引用计数都是 1。</p><p>引用计数是 1，因此就算这 3 个对象不会再使用了，GC 不会回收它们。</p><p>另一个考虑是在多线程环境下引用计数的算法一旦算错 1 次（比如因为没有处理好竞争条件），那么就无法再纠正了。而且处理竞争条件本身也比较耗费性能。</p><p>还有就是引用计数法回收内存会产生碎片，当然碎片不是只有引用计数法才有的问题，所有的 GC 都需要面对碎片。下图中内存回收的碎片可以通过整理的方式，清理出更多空间出来。关于内存空间的碎片，下一讲会有专门的一个小节讨论。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629164820.png" alt="image-20210629164820264"></p><p>综上，<strong>引用计数法出错概率大</strong>，比如我们编程时会有对象的循环引用；另一方面，<strong>引用计数法容错能力差</strong>，一旦计算错了，就会导致内存永久无法被回收，因此我们需要更好的方式。</p><h4 id="Root-Tracing-算法"><a href="#Root-Tracing-算法" class="headerlink" title="Root Tracing 算法"></a>Root Tracing 算法</h4><p>下面我再给你介绍一种更好的方式—— Root Tracing 算法。这是一类算法，后面我们会讲解的标记-清除算法和 3 色标记-清除算法都属于这一类。</p><p>Root Tracing 的原理是：从引用路径上，如果一个对象的引用链中包括一个根对象（Root Object），那么这个对象就是活动的。根对象是所有引用关系的源头。比如用户在栈中创建的对象指针；程序启动之初导入数据区的全局对象等。在 Java 中根对象就包括在栈上创建指向堆的对象；JVM 的一些元数据，包括 Method Area 中的对象等。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629164948.png" alt="image-20210629164948046"></p><p>在 Root Tracing 工作过程中，如果一个对象和根对象间有连通路径，也就是从根节点开始遍历可以找到这个对象，代表有对象可以引用到这个对象，那么这个节点就不需要被回收。所以算法的本质还是引用，只不过判断条件从引用计数变成了有根对象的引用链。</p><p>如果一个对象从根对象不可达，那么这个对象就应该被回收，即便这个对象存在循环引用。可以看到，上图中红色的 3 个对象循环引用，并且到根集合没有引用链，因此需要被回收。这样就解决了循环引用的问题。</p><p>Root Tracing 的容错性很好，GC 通过不断地执行 Root Tracing 算法找到需要回收的元素。如果在这个过程中，有一些本来应该回收的元素没有被计算出（比如并发原因），也不会导致这些对象永久无法回收。因为在下次执行 Root Tracing 的时候，GC 就会通过执行 Root Tracing 算法找到这些元素。不像引用计数法，一旦算错就很难恢复。</p><h4 id="标记-清除（Mark-Sweep）算法"><a href="#标记-清除（Mark-Sweep）算法" class="headerlink" title="标记-清除（Mark Sweep）算法"></a>标记-清除（Mark Sweep）算法</h4><p>下面我为你具体介绍一种 Root Tracing 的算法， 就是标记清除-算法。标记-清除算法中，用白色代表一种不确定的状态：可能被回收。 黑色代表一种确定的状态：不会被回收。算法的实现，就是为所有的对象染色。算法执行结束后，所有是白色的对象就需要被回收。</p><p>算法实现过程中，假设有两个全局变量是已知的：</p><ul><li>heapSet 中拥有所有对象</li><li>rootSet 中拥有所有 Root Object</li></ul><p>算法执行的第一步，就是将所有的对象染成白色，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> obj in heapSet &#123;</span><br><span class="line"></span><br><span class="line">    obj.color = white</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们定义一个标记函数，它会递归地将一个对象的所有子对象染成黑色，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func mark(obj) &#123;</span><br><span class="line"></span><br><span class="line">  if obj.color == white &#123;</span><br><span class="line"></span><br><span class="line">    obj.color = black</span><br><span class="line"></span><br><span class="line">    for v in references(obj) &#123;</span><br><span class="line"></span><br><span class="line">      mark(v)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629165508.png" alt="image-20210629165508334"></p><h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><p>上面的 mark 函数对 obj 进行了深度优先搜索。深度优先搜索，就是自然的递归序。随着递归函数执行，遇到子元素就遍历子元素，就构成了天然的深度优先搜索。还有一个相对的概念是广度优先搜索（Breadth First Serach），如果你不知道深度优先搜索和广度优先搜索，可以看下我下面的图例。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629165525.png" alt="image-20210629165525502"></p><p>上图中，深度优先搜索优先遍历完整的子树（递归），广度优先搜索优先遍历所有的子节点（逐层）。</p><p>然后我们从所有的 Root Object 开始执行 mark 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for root in rootSet &#123;</span><br><span class="line"></span><br><span class="line">  mark(root)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结束后，所有和 Root Object 连通的对象都已经被染成了黑色。然后我们遍历整个 heapSet 找到白色的对象进行回收，这一步开始是<strong>清除（Sweep）阶段</strong>，以上是<strong>标记（Mark）阶段</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for obj in heapSet &#123;</span><br><span class="line"></span><br><span class="line">  if obj.color == white &#123;</span><br><span class="line"></span><br><span class="line">    free(obj)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上算法就是一个简单的标记-清除算法。相比引用计数，这个算法不需要维护状态。算法执行开始所有节点都被标记了一遍。结束的时候，算法找到的垃圾就被清除了。 算法有两个阶段，标记阶段（Mark），还有清除阶段（Sweep），因此被称为标记-清除算法。</p><p>这里请你思考：如果上面的 GC 程序在某个时刻暂停了下来，然后开始执行用户程序。如果用户程序删除了对某个已经标记为黑色对象的所有引用，用户程序没办法通知 GC 程序。这个节点就会变成浮动垃圾（Floating Garbage），需要等待下一个 GC 程序执行。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629165616.png" alt="image-20210629165616789"></p><p>假设用户程序和 GC 交替执行，用户程序不断进行修改（Mutation），而 GC 不断执行标记-清除算法。那么这中间会产生大量浮动垃圾影响 GC 的效果。</p><p>另一方面，考虑到 GC 是一个非常消耗性能程序，在某些情况下，我们希望 GC 能够增量回收。 比如说，用户仅仅是高频删除了一部分对象，那么是否可以考虑设计不需要从整个 Root 集合进行遍历，而是增量的只处理最近这一批变更的算法呢？答案是可以的，我们平时可以多执行增量 GC，偶尔执行一次全量 GC。具体增量的方式会在下一讲为你讲解。</p><p>我们发现双色标记-清除算法有一个明显的问题，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170014.png" alt="image-20210629170014302"></p><p>你可以把 GC 的过程看作标记、清除及程序不断对内存进行修改的过程，分成 3 种任务：</p><p>标记程序（Mark）</p><p>清除程序（Sweep）</p><p>变更程序（Mutation）</p><p>标记（Mark）就是找到不用的内存，清除（Sweep）就是回收不用的资源，而修改（Muation）则是指用户程序对内存进行了修改。通常情况下，在 GC 的设计中，上述 3 种程序不允许并行执行（Simultaneously）。对于 Mark、Sweep、Mutation 来说内存是共享的。如果并行执行相当于需要同时处理大量竞争条件的手段，这会增加非常多的开销。当然你可以开多个线程去 Mark、Mutation 或者 Sweep，但前提是每个过程都是独立的。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170109.png" alt="image-20210629170108855"></p><p>因为 Mark 和 Sweep 的过程都是 GC 管理，而 Mutation 是在执行应用程序，在实时性要求高的情况下可以允许一边 Mark，一边 Sweep 的情况； 优秀的算法设计也可能会支持一边 Mark、一边 Mutation 的情况。这种算法通常使用了 Read On Write 技术，本质就是先把内存拷贝一份去 Mark/Sweep，让 Mutation 完全和 Mark 隔离。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170301.png" alt="image-20210629170301428"></p><p>上图中 GC 开始后，拷贝了一份内存的原本，进行 Mark 和 Sweep，整理好内存之后，再将原本中所有的 Mutation 合并进新的内存。 这种算法设计起来会非常复杂，但是可以保证实时性 GC。</p><p>上图的这种 GC 设计比较少见，通常 GC 都会发生 STL（Stop The World）问题，Mark/Sweep/Mutation 只能够交替执行。也就是说， 一种程序执行的时候，另一种程序必须停止。</p><p>对于双色标记-清除算法，如果 Mark 和 Sweep 之间存在 Mutation，那么 Mutation 的伤害是比较大的。比如 Mutation 新增了一个白色的对象，这个白色的对象就可能会在 Sweep 启动后被清除。当然也可以考虑新增黑色的对象，这样对象就不会在 Sweep 启动时被回收。但是会发生下面这个问题，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170357.png" alt="image-20210629170357311"></p><p>如果一个新对象指向了一个已经删除的对象，一个新的黑色对象指向了一个白色对象，这个时候 GC 不会再遍历黑色对象，也就是白色的对象还是会被清除。因此，我们希望创建一个在并发环境更加稳定的程序，让 Mark/Mutation/Sweep 可以交替执行，不用特别在意它们之间的关联。</p><p>有一个非常优雅地实现就是再增加一种中间的灰色，把灰色看作可以增量处理的工作，来重新定义白色的含义。</p><h4 id="三色标记-清除算法（Tri-Color-Mark-Sweep）"><a href="#三色标记-清除算法（Tri-Color-Mark-Sweep）" class="headerlink" title="三色标记-清除算法（Tri-Color Mark Sweep）"></a>三色标记-清除算法（Tri-Color Mark Sweep）</h4><p>接下来，我会和你讨论这种有三个颜色标记的算法，通常称作三色标记-清除算法。首先，我们重新定义黑、白、灰三种颜色的含义：</p><p>白色代表需要 GC 的对象；</p><p>黑色代表确定不需要 GC 的对象；</p><p>灰色代表可能不需要 GC 的对象，但是还未完成标记的任务，也可以认为是增量任务。</p><p>在三色标记-清除算法中，一开始所有对象都染成白色。初始化完成后，会启动标记程序。在标记的过程中，是可以暂停标记程序执行 Mutation。</p><p>算法需要维护 3 个集合，白色集合、黑色集合、灰色集合。3 个集合是互斥的，对象只能在一个集合中。执行之初，所有对象都放入白色集合，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170534.png" alt="image-20210629170534268"></p><p>第一次执行，算法将 Root 集合能直接引用的对象加入灰色集合，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170619.png" alt="image-20210629170618902"></p><p>接下来算法会不断从灰色集合中取出元素进行标记，主体标记程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while greySet.size() &gt; 0 &#123;</span><br><span class="line"></span><br><span class="line">  var item = greySet.remove();</span><br><span class="line"></span><br><span class="line">  mark(item);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记的过程主要分为 3 个步骤：</p><ol><li>如果对象在白色集合中，那么先将对象放入灰色集合；</li><li>然后遍历节点的所有的引用对象，并递归所有引用对象；</li><li>当一个对象的所有引用对象都在灰色集合中，就把这个节点放入为黑色集合。</li></ol><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func mark(obj) &#123;</span><br><span class="line"></span><br><span class="line">  if obj in whiteSet &#123;</span><br><span class="line"></span><br><span class="line">    greySet.add(obj)</span><br><span class="line"></span><br><span class="line">    for v in refs(obj) &#123;</span><br><span class="line"></span><br><span class="line">      mark(v)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    greySet.remove(obj)</span><br><span class="line"></span><br><span class="line">    blackSet.add(obj)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以观察下上面的程序，这是一个 DFS 的过程。如果多个线程对不同的 Root Object 并发执行这个算法，我们需要保证 3 个集合都是线程安全的，可以考虑利用 ConcurrentSet（这样性能更好），或者对临界区上锁。并发执行这个算法的时候，如果发现一个灰色节点说明其他线程正在处理这个节点，就忽略这个节点。这样，就解决了标记程序可以并发执行的问题。</p><p>当标记算法执行完成的时候，所有不需要 GC 的元素都会涂黑：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172322.png" alt="image-20210629172322359"></p><p>标记算法完成后，白色集合内就是需要回收的对象。</p><p>以上，是类似双色标记-清除算法的全量 GC 程序，我们从 Root 集合开始遍历，完成了对所有元素的标记（将它们放入对应的集合）。</p><p>接下来我们来考虑增加 GC（Incremental GC）的实现。首先对用户的修改进行分类，有这样 3 类修改（Mutation）需要考虑：</p><ol><li>创建新对象</li><li>删除已有对象</li><li>调整已有引用</li></ol><p>如果用户程序创建了新对象，可以考虑把新对象直接标记为灰色。虽然，也可以考虑标记为黑色，但是标记为灰色可以让 GC 意识到新增了未完成的任务。比如用户创建了新对象之后，新对象引用了之前删除的对象，就需要重新标记创建的部分。</p><p>如果用户删除了已有的对象，通常做法是等待下一次全量 Mark 算法处理。下图中我们删除了 Root Object 到 A 的引用，这个时候如果把 A 标记成白色，那么还需要判断是否还有其他路径引用到 A，而且 B,C 节点的颜色也需要重新计算。关键的问题是，虽然可以实现一个基于 A 的 DFS 去解决这个问题，但实际情况是我们并不着急解决这个问题，因为内存空间往往是有富余的。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172756.png" alt="image-20210629172756625"></p><p><strong>在调整已有的引用关系时，三色标记算法的表现明显更好</strong>。下图是对象 B 将对 C 的引用改成了对 F 的引用，C,F 被加入灰色集合。接下来 GC 会递归遍历 C,F，最终然后 F,E,G 都会进入灰色集合。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172811.png" alt="image-20210629172811414"></p><p>内存回收就好比有人在随手扔垃圾，清洁工需要不停打扫。如果清洁工能够跟上人们扔垃圾的速度，那么就不需要太多的 STL（Stop The World）。如果清洁工跟不上扔垃圾的速度，最终环境就会被全部弄乱，这个时候清洁工就会要求“Stop The World”。<strong>三色算法的优势就在于它支持多一些情况的 Mutation，这样能够提高“垃圾”被并发回收的概率</strong>。</p><p>目前的 GC 主要都是基于三色标记算法。 至于清除算法，有原地回收算法，也有把存活下来的对象（黑色对象）全部拷贝到一个新的区域的算法。</p><h4 id="碎片整理和生代技术"><a href="#碎片整理和生代技术" class="headerlink" title="碎片整理和生代技术"></a>碎片整理和生代技术</h4><p>三色标记-清除算法，还没有解决内存回收产生碎片的问题。通常，我们会在三色标记-清除算法之上，再构建一个整理内存（Compact）的算法。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172930.png" alt="image-20210629172930467"></p><p>Compact 算法将对象重新挤压到一起，让更多空间可以被使用。我们在设计这个算法时，观察到了一个现象：新创建出来的对象，死亡（被回收）概率会更高，而那些已经存在了一段时间的对象，往往更不容易死亡。这有点类似 LRU 缓存，其实是一个概率问题。接下来我们考虑针对这个现象进行优化。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172919.png" alt="image-20210629172919695"></p><p>如上图所示，你可以把新创建的对象，都先放到一个统一的区域，在 Java 中称为伊甸园（Eden）。这个区域因为频繁有新对象死亡，因此需要经常 GC。考虑整理使用中的对象成本较高，因此可以考虑将存活下来的对象拷贝到另一个区域，Java 中称为存活区（Survior）。存活区生存下来的对象再进入下一个区域，Java 中称为老生代。</p><p>上图展示的三个区域，<strong>Eden、Survior 及老生代之间的关系是对象的死亡概率逐级递减，对象的存活周期逐级增加</strong>。三个区域都采用三色标记-清除算法。每次 Eden 存活下来的对象拷贝到 Survivor 区域之后，Eden 就可以完整的回收重利用。Eden 可以考虑和 Survivor 用 1:1 的空间，老生代则可以用更大的空间。Eden 中全量 GC 可以频繁执行，也可以增量 GC 混合全量 GC 执行。老生代中的 GC 频率可以更低，偶尔执行一次全量的 GC。</p><h4 id="GC-的选择"><a href="#GC-的选择" class="headerlink" title="GC 的选择"></a>GC 的选择</h4><p>最后我们来聊聊 GC 的选择。<strong>通常选择 GC 会有实时性要求（最大容忍的暂停时间），需要从是否为高并发场景、内存实际需求等维度去思考</strong>。<strong>在选择 GC 的时候，复杂的算法并不一定更有效。下面是一些简单有效的思考和判断</strong>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629173135.png" alt="image-20210629173135074"></p><ol><li>如果你的程序内存需求较小，GC 压力小，这个时候每次用双色标记-清除算法，等彻底标记-清除完再执行应用程序，用户也不会感觉到多少延迟。双色标记-清除算法在这种场景可能会更加节省时间，因为程序简单。</li><li>对于一些对暂停时间不敏感的应用，比如说数据分析类应用，那么选择一个并发执行的双色标记-清除算法的 GC 引擎，是一个非常不错的选择。因为这种应用 GC 暂停长一点时间都没有关系，关键是要最短时间内把整个 GC 执行完成。</li><li>如果内存的需求大，同时对暂停时间也有要求，就需要三色标记清除算法，让部分增量工作可以并发执行。</li><li>如果在高并发场景，内存被频繁迭代，这个时候就需要生代算法。将内存划分出不同的空间，用作不同的用途。</li><li>如果实时性要求非常高，就需要选择专门针对实时场景的 GC 引擎，比如 Java 的 Z。</li></ol><p><strong>当然，并不是所有的语言都提供多款 GC 选择。但是通常每个语言都会提供很多的 GC 参数</strong>。这里也有一些最基本的思路，下面我为你介绍一下。</p><p><strong>如果内存不够用，有两种解决方案。一种是降低吞吐量——相当于 GC 执行时间上升；另一种是增加暂停时间，暂停时间较长，GC 更容易集中资源回收内存</strong>。那么通常语言的 GC 都会提供设置吞吐量和暂停时间的 API。</p><p><strong>如果内存够用，有的 GC 引擎甚至会选择当内存达到某个阈值之后，再启动 GC 程序</strong>。通常阈值也是可以调整的。因此如果内存够用，就建议让应用使用更多的内存，提升整体的效率。</p><ul><li><strong>如何解决内存的循环引用问题？</strong></li><li><strong>三色标记清除算法的工作原理？</strong></li></ul><p>解决循环引用的问题可以考虑利用 Root Tracing 类的 GC 算法。从根集合利用 DFS 或者 BFS 遍历所有子节点，最终不能和根集合连通的节点都是需要回收的。</p><p>三色标记算法利用三种颜色进行标记。白色代表需要回收的节点；黑色代表不需要回收的节点；灰色代表会被回收，但是没有完成标记的节点。</p><p>初始化的时候所有节点都标记为白色，然后利用 DFS 从 Root 集合遍历所有节点。每遍历到一个节点就把这个节点放入灰色集合，如果这个节点所有的子节点都遍历完成，就把这个节点放入黑色的集合。最后白色集合中剩下的就是需要回收的元素。</p><p><strong>可不可以利用哈希表直接将页编号映射到 Frame 编号</strong>？</p><p>按照普通页表的设计，如果页大小是 4K，1G 空间内存需要 262144 个页表条目，如果每个条目用 4 个字节来存储，就需要 1M 的空间。那么创建 1T 的虚拟内存，就需要 1G 的空间。这意味着操作系统需要在启动时，就把这块需要的内存空间预留出来。</p><p>正因为我们设计的虚拟内存往往大于实际的内存，因此在历史上出现过各种各样节省页表空间的方案，其中就有用 HashTable 存储页表的设计。HashTable 是一种将键（Key）映射到值（Value）的数据结构。在页表的例子中，键是页编号，值是 Frame 编号。 你可以把这个 HashTable 看作存储了很多 &lt;PageId, FrameId&gt; 键值对的数据结构。</p><p>为了方便你理解下面的内容，我绘制了一张图。下图使用了一个有 1024 个条目的 HashTable。当查找页面 50000 的时候，先通过哈希函数 h 计算出 50000 对应的 HashTable 条目是 24。HashTable 的每个条目都是一个链表，链表的每个节点是一个 PageId 和 FrameId 的组合。接下来，算法会遍历条目 24 上的链表，然后找到 Page = 50000 的节点。取出 Frame 编号为 1232。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629174119.png" alt="image-20210629174118903"></p><p>通常虚拟内存会有非常多的页，但是只有少数的页会被使用到。这种情况下，用传统的页表，会导致过多的空间被预分配。而基于 HashTable 的设计则不同，可以先分配少量的项，比如在上图中，先只分配了 1024 个项。每次查找一个页表编号发现不存在的情况，再去对应位置的链表中添加一个具体的键-值对。 这样就大大节省了内存。</p><p>当然节省空间也是有代价的，这会直接导致性能下降，因为比起传统页表我们可以直接通过页的编号知道页表条目，基于 HashTable 的做法需要先进行一次 Hash 函数的计算，然后再遍历一次链表。 最后，HashTable 的时间复杂度可以看作 O(k)，k 为 HashTable 表中总共的 &lt;k,v&gt; 数量除以哈希表的条目数。当 k 较小的时候 HashTable 的时间复杂度趋向于 O(1)。</p><p><strong>Java 和 Go 默认需不需要开启大内存分页?</strong></p><p>在回答什么情况下使用前，我们先说说这两个语言对大内存分页的支持。</p><p>当然，两门语言能够使用大内存分页的前提条件，是通过“<strong>25 讲”</strong>中演示的方式，开启了操作系统的大内存分页。满足这个条件后，我们再来说说两门语言还需要做哪些配置。</p><p><strong>Go 语言</strong></p><p>Go 是一门编译执行的语言。在 Go 编译器的前端，源代码被转化为 AST；在 Go 编译器的后端，AST 经过若干优化步骤，转化为目标机器代码。因此 Go 的内存分配程序基本上可以直接和操作系统的 API 对应。因为 Go 没有虚拟机。</p><p>而且 Go 提供了一个底层的库 syscall，直接支持上百个系统调用。 具体请参考<a href="https://golang.org/pkg/syscall/" target="_blank" rel="noopener">Go 的官方文档</a>。其中的 syscall.madvise 系统调用，可以直接提示操作系统某个内存区间的程序是否使用大内存分页技术加速 TLB 的访问。具体可以参考 Linux 中<a href="https://www.man7.org/linux/man-pages/man2/madvise.2.html" target="_blank" rel="noopener">madise 的文档</a>，这个工具的作用主要是提示操作系统如何使用某个区域的内存，开启大内存分页是它之中的一个选项。</p><p>下面的程序通过 malloc 分配内存，然后用 madvise 提示操作系统使用大内存分页的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line"></span><br><span class="line">size_t size = 256*1024*1024;</span><br><span class="line"></span><br><span class="line">char* mymemory = malloc(size);</span><br><span class="line"></span><br><span class="line">madvise(mymemory, size, MADV_HUGEPAGE);</span><br></pre></td></tr></table></figure><p>如果放到 Go 语言，那么需要用的是<code>runtime.sysAlloc</code>和<code>syscall.Madvise</code>函数。</p><p><strong>Java 语言</strong></p><p>JVM 是一个虚拟机，应用了Just-In-Time 在虚拟指令执行的过程中，将虚拟指令转换为机器码执行。 JVM 自己有一套完整的动态内存管理方案，而且提供了很多内存管理工具可选。在使用 JVM 时，虽然 Java 提供了 UnSafe 类帮助我们执行底层操作，但是通常情况下我们不会使用UnSafe 类。一方面 UnSafe 类功能不全，另一方面看名字就知道它过于危险。</p><p>Java 语言在“<strong>25 讲”中</strong>提到过有一个虚拟机参数：XX:+UseLargePages，开启这个参数，JVM 会开始尝试使用大内存分页。</p><p><strong>那么到底该不该用大内存分页</strong>？</p><p>首先可以分析下你应用的特性，看看有没有大内存分页的需求。通常 OS 是 4K，思考下你有没有需要反复用到大内存分页的场景。</p><p>另外你可以使用<code>perf</code>指令衡量你系统的一些性能指标，其中就包括<code>iTLB-load-miss</code>可以用来衡量 TLB Miss。 如果发现自己系统的 TLB Miss 较高，那么可以深入分析是否需要开启大内存分页。</p><p><strong>在 TLB 多路组相联缓存设计中（比如 8-way），如何实现 LRU 缓存</strong>？</p><p>TLB 是 CPU 的一个“零件”，在 TLB 的设计当中不可能再去内存中创建数据结构。因此在 8 路组相联缓存设计中，我们每次只需要从 8 个缓存条目中选择 Least Recently Used 缓存。</p><p><strong>增加累计值</strong></p><p>先说一种方法， 比如用硬件同时比较 8 个缓存中记录的缓存使用次数。这种方案需要做到 2 点：</p><ol><li>缓存条目中需要额外的空间记录条目的使用次数（累计位）。类似我们在页表设计中讨论的基于计时器的读位操作——每过一段时间就自动将读位累计到一个累计位上。</li><li>硬件能够实现一个快速查询最小值的算法。</li></ol><p>第 1 种方法会产生额外的空间开销，还需要定时器配合，成本较高。 注意缓存是很贵的，对于缓存空间利用自然能省则省。而第 2 种方法也需要额外的硬件设计。那么，有没有更好的方案呢？</p><p><strong>1bit 模拟 LRU</strong></p><p>一个更好的方案就是模拟 LRU，我们可以考虑继续采用上面的方式，但是每个缓存条目只拿出一个 LRU 位（bit）来描述缓存近期有没有被使用过。 缓存置换时只是查找 LRU 位等于 0 的条目置换。</p><p>还有一个基于这种设计更好的方案，可以考虑在所有 LRU 位都被置 1 的时候，清除 8 个条目中的 LRU 位（置零），这样可以节省一个计时器。 相当于发生内存操作，LRU 位置 1；8 个位置都被使用，LRU 都置 0。</p><p><strong>搜索树模拟 LRU</strong></p><p>最后我再介绍一个巧妙的方法——用搜索树模拟 LRU。</p><p>对于一个 8 路组相联缓存，这个方法需要 8-1 = 7bit 去构造一个树。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630074809.png" alt="image-20210630074808921"></p><p>8 个缓存条目用 7 个节点控制，每个节点是 1 位。0 代表节点指向左边，1 代表节点指向右边。</p><p>初始化的时候，所有节点都指向左边，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630074921.png" alt="image-20210630074921098"></p><p>接下来每次写入，会从根节点开始寻找，顺着箭头方向（0 向左，1 向右），找到下一个更新方向。比如现在图中下一个要更新的位置是 0。更新完成后，所有路径上的节点箭头都会反转，也就是 0 变成 1，1 变成 0。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630074952.png" alt="image-20210630074952274"></p><p>上图是<code>read a</code>后的结果，之前路径上所有的箭头都被反转，现在看到下一个位置是 4，我用橘黄色进行了标记。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630075950.png" alt="image-20210630075950806"></p><p>上图是发生操作<code>read b</code>之后的结果，现在橘黄色可以更新的位置是 2。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080008.png" alt="image-20210630080008756"></p><p>上图是读取 c 后的情况。后面我不一一绘出，假设后面的读取顺序是<code>d,e,f,g,h</code>，那么缓存会变成如下图所示的结果：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080027.png" alt="image-20210630080027636"></p><p>这个时候用户如果读取了已经存在的值，比如说<code>c</code>，那么指向<code>c</code>那路箭头会被翻转，下图是<code>read c</code>的结果：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080043.png" alt="image-20210630080043461"></p><p>这个结果并没有改变下一个更新的位置，但是翻转了指向 c 的路径。 如果要读取<code>x</code>，那么这个时候就会覆盖橘黄色的位置。</p><p><strong>因此，本质上这种树状的方式，其实是在构造一种先入先出的顺序。任何一个节点箭头指向的子节点，应该被先淘汰（最早被使用）</strong>。</p><p>这是一个我个人觉得非常天才的设计，因为如果在这个地方构造一个队列，然后每次都把命中的元素的当前位置移动到队列尾部。就至少需要构造一个链表，而链表的每个节点都至少要有当前的值和 next 指针，这就需要创建复杂的数据结构。在内存中创建复杂的数据结构轻而易举，但是在 CPU 中就非常困难。 所以这种基于 bit-tree，就轻松地解决了这个问题。当然，这是一个模拟 LRU 的情况，你还是可以构造出违反 LRU 缓存的顺序。</p><p><strong>如果内存太大了，无论是标记还是清除速度都很慢，执行一次完整的 GC 速度下降该如何处理</strong>？</p><p>当应用申请到的内存很大的时候，如果其中内部对象太多。只简单划分几个生代，每个生代占用的内存都很大，这个时候使用 GC 性能就会很糟糕。</p><p>一种参考的解决方案就是将内存划分成很多个小块，类似在应用内部再做一个虚拟内存层。 每个小块可能执行不同的内存回收策略。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080147.png" alt="image-20210630080147261"></p><p>上图中绿色、蓝色和橘黄色代表 3 种不同的区域。绿色区域中对象存活概率最低（类似 Java 的 Eden），蓝色生存概率上升，橘黄色最高（类似 Java 的老生代）。灰色区域代表应用从操作系统中已经申请了，但尚未使用的内存。通过这种划分方法，每个区域中进行 GC 的开销都大大减少。Java 目前默认的内存回收器 G1，就是采用上面的策略。</p><p><strong>通过内存管理的学习，我希望你开始理解虚拟化的价值，内存管理部分的虚拟化，是一种应对资源稀缺、增加资源流动性的手段</strong>（听起来那么像银行印的货币）。</p><h3 id="Linux-下的各个目录有什么作用？"><a href="#Linux-下的各个目录有什么作用？" class="headerlink" title="Linux 下的各个目录有什么作用？"></a><strong>Linux 下的各个目录有什么作用？</strong></h3><p>学习文件系统的意义在于文件系统有很多设计思路可以迁移到实际的工作场景中，比如：</p><ul><li>MySQL 的 binlog 和 Redis AOF 都像极了日志文件系统的设计；</li><li>B Tree 用于加速磁盘数据访问的设计，对于索引设计也有通用的意义。</li></ul><p>特别是近年来分布式系统的普及，学习分布式文件系统，也是理解分布式架构最核心的一个环节。其实文件系统最精彩的还是虚拟文件系统的设计，比如 Linux 可以支持每个目录用不同的文件系统。这些文件看上去是一个个目录和文件，实际上可能是磁盘、内存、网络文件系统、远程磁盘、网卡、随机数产生器、输入输出设备等，这样虚拟文件系统就成了整合一切设备资源的平台。大量的操作都可以抽象成对文件的操作，程序的书写就会完整而统一，且扩展性强。</p><p>这一讲，我会从 Linux 的目录结构和用途开始，带你认识 Linux 的文件系统。Linux 所有的文件都建立在虚拟文件系统（Virtual File System ，VFS）之上，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080417.png" alt="image-20210630080417018"></p><h4 id="分区结构"><a href="#分区结构" class="headerlink" title="分区结构"></a>分区结构</h4><p>在 Linux 中，<code>/</code>是根目录。之前我们在“<strong>08 讲</strong>”提到过，每个目录可以是不同的文件系统（不同的磁盘或者设备）。你可能会问我，<code>/</code>是对应一个磁盘还是多个磁盘呢？在<code>/</code>创建目录的时候，目录属于哪个磁盘呢？</p><p>当你访问一个目录或者文件，虽然用的是 Linux 标准的文件 API 对文件进行操作，但实际操作的可能是磁盘、内存、网络或者数据库等。<strong>因此，Linux 上不同的目录可能是不同的磁盘，不同的文件可能是不同的设备</strong>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080512.png" alt="image-20210630080512118"></p><p>你可以用<code>df -h</code>查看上面两个问题的答案，在上图中我的<code>/</code>挂载到了<code>/dev/sda5</code>上。如果你想要看到更多信息，可以使用<code>df -T</code>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080549.png" alt="image-20210630080549828"></p><p><code>/</code>的文件系统类型是<code>ext4</code>。这是一种常用的日志文件系统。关于日志文件系统，我会在“<strong>30 讲”</strong>为你介绍。然后你可能还会有一个疑问，<code>/dev/sda5</code>究竟是一块磁盘还是别的什么？这个时候你可以用<code>fdisk -l</code>查看，结果如下图：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080610.png" alt="image-20210630080610257"></p><p>你可以看到我的 Linux 虚拟机上，有一块 30G 的硬盘（当然是虚拟的）。然后这块硬盘下有 3 个设备（Device）：/dev/sda1, /dev/sda2 和 /dev/sda5。在 Linux 中，数字 1~4 结尾的是主分区，通常一块磁盘最多只能有 4 个主分区用于系统启动。主分区之下，还可以再分成若干个逻辑分区，4 以上的数字都是逻辑分区。因此<code>/dev/sda2</code>和<code>/dev/sda5</code>是主分区包含逻辑分区的关系。</p><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>分区结构最终需要最终挂载到目录上。上面例子中<code>/dev/sda5</code>分区被挂载到了<code>/</code>下。 这样在<code>/</code>创建的文件都属于这个<code>/dev/sda5</code>分区。 另外，<code>/dev/sda5</code>采用<code>ext4</code>文件系统。可见<strong>不同的目录可以采用不同的文件系统</strong>。</p><p>将一个文件系统映射到某个目录的过程叫作挂载（Mount）。当然这里的文件系统可以是某个分区、某个 USB 设备，也可以是某个读卡器等。你可以用<code>mount -l</code>查看已经挂载的文件系统。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080742.png" alt="image-20210630080742427"></p><p>上图中的<code>sysfs``proc``devtmpfs``tmpfs``ext4</code>都是不同的文件系统，下面我们来说说它们的作用。</p><ul><li><code>sysfs</code>让用户通过文件访问和设置设备驱动信息。</li><li><code>proc</code>是一个虚拟文件系统，让用户可以通过文件访问内核中的进程信息。</li><li><code>devtmpfs</code>在内存中创造设备文件节点。</li><li><code>tmpfs</code>用内存模拟磁盘文件。</li><li><code>ext4</code>是一个通常意义上我们认为的文件系统，也是管理磁盘上文件用的系统。</li></ul><p>你可以看到挂载记录中不仅有文件系统类型，挂载的目录（on 后面部分），还有读写的权限等。你也可以用<code>mount</code>指令挂载一个文件系统到某个目录，比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda6 /abc</span><br></pre></td></tr></table></figure><p>上面这个命令将<code>/dev/sda6</code>挂载到目录<code>abc</code>。</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>因为 Linux 内文件系统较多，用途繁杂，Linux 对文件系统中的目录进行了一定的归类，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080849.png" alt="image-20210630080849295"></p><p><strong>最顶层的目录称作根目录，</strong> 用<code>/</code>表示。<code>/</code>目录下用户可以再创建目录，但是有一些目录随着系统创建就已经存在，接下来我会和你一起讨论下它们的用途。</p><p><strong>/bin（二进制</strong>）包含了许多所有用户都可以访问的可执行文件，如 ls, cp, cd 等。这里的大多数程序都是二进制格式的，因此称作<code>bin</code>目录。<code>bin</code>是一个命名习惯，比如说<code>nginx</code>中的可执行文件会在 Nginx 安装目录的 bin 文件夹下面。</p><p><strong>/dev（设备文件）</strong> 通常挂载在<code>devtmpfs</code>文件系统上，里面存放的是设备文件节点。通常直接和内存进行映射，而不是存在物理磁盘上。</p><p>值得一提的是其中有几个有趣的文件，它们是虚拟设备。</p><p><strong>/dev/null</strong>是可以用来销毁任何输出的虚拟设备。你可以用<code>&gt;</code>重定向符号将任何输出流重定向到<code>/dev/null</code>来忽略输出的结果。</p><p><strong>/dev/zero</strong>是一个产生数字 0 的虚拟设备。无论你对它进行多少次读取，都会读到 0。</p><p><strong>/dev/ramdom</strong>是一个产生随机数的虚拟设备。读取这个文件中数据，你会得到一个随机数。你不停地读取这个文件，就会得到一个随机数的序列。</p><p><strong>/etc（配置文件），</strong><code>/etc</code>名字的含义是<code>and so on……</code>，也就是“等等及其他”，Linux 用它来保管程序的配置。比如说<code>mysql</code>通常会在<code>/etc/mysql</code>下创建配置。再比如说<code>/etc/passwd</code>是系统的用户配置，存储了用户信息。</p><p><strong>/proc（进程和内核文件）</strong> 存储了执行中进程和内核的信息。比如你可以通过<code>/proc/1122</code>目录找到和进程<code>1122</code>关联的全部信息。还可以在<code>/proc/cpuinfo</code>下找到和 CPU 相关的全部信息。</p><p><strong>/sbin（系统二进制）</strong> 和<code>/bin</code>类似，通常是系统启动必需的指令，也可以包括管理员才会使用的指令。</p><p><strong>/tmp（临时文件）</strong> 用于存放应用的临时文件，通常用的是<code>tmpfs</code>文件系统。因为<code>tmpfs</code>是一个内存文件系统，系统重启的时候清除<code>/tmp</code>文件，所以这个目录不能放应用和重要的数据。</p><p><strong>/var （Variable data file,，可变数据文件）</strong> 用于存储运行时的数据，比如日志通常会存放在<code>/var/log</code>目录下面。再比如应用的缓存文件、用户的登录行为等，都可以放到<code>/var</code>目录下，<code>/var</code>下的文件会长期保存。</p><p><strong>/boot（启动）</strong> 目录下存放了 Linux 的内核文件和启动镜像，通常这个目录会写入磁盘最头部的分区，启动的时候需要加载目录内的文件。</p><p><strong>/opt（Optional Software，可选软件）</strong> 通常会把第三方软件安装到这个目录。以后你安装软件的时候，可以考虑在这个目录下创建。</p><p><strong>/root（root 用户家目录）</strong> 为了防止误操作，Linux 设计中 root 用户的家目录没有设计在<code>/home/root</code>下，而是放到了<code>/root</code>目录。</p><p><strong>/home（家目录）</strong> 用于存放用户的个人数据，比如用户<code>lagou</code>的个人数据会存放到<code>/home/lagou</code>下面。并且通常在用户登录，或者执行<code>cd</code>指令后，都会在家目录下工作。 用户通常会对自己的家目录拥有管理权限，而无法访问其他用户的家目录。</p><p><strong>/media（媒体）</strong> 自动挂载的设备通常会出现在<code>/media</code>目录下。比如你插入 U 盘，通常较新版本的 Linux 都会帮你自动完成挂载，也就是在<code>/media</code>下创建一个目录代表 U 盘。</p><p><strong>/mnt（Mount，挂载）</strong> 我们习惯把手动挂载的设备放到这个目录。比如你插入 U 盘后，如果 Linux 没有帮你完成自动挂载，可以用<code>mount</code>命令手动将 U 盘内容挂载到<code>/mnt</code>目录下。</p><p><strong>/svr（Service Data,，服务数据）</strong> 通常用来存放服务数据，比如说你开发的网站资源文件（脚本、网页等）。不过现在很多团队的习惯发生了变化， 有的团队会把网站相关的资源放到<code>/www</code>目录下，也有的团队会放到<code>/data</code>下。总之，在存放资源的角度，还是比较灵活的。</p><p><strong>/usr（Unix System Resource）</strong> 包含系统需要的资源文件，通常应用程序会把后来安装的可执行文件也放到这个目录下，比如说</p><ul><li><code>vim</code>编辑器的可执行文件通常会在<code>/usr/bin</code>目录下，区别于<code>ls</code>会在<code>/bin</code>目录下</li><li><code>/usr/sbin</code>中会包含有通常系统管理员才会使用的指令。</li><li><code>/usr/lib</code>目录中存放系统的库文件，比如一些重要的对象和动态链接库文件。</li><li><code>/usr/lib</code>目录下会有大量的<code>.so</code>文件，这些叫作<code>Shared Object</code>，类似<code>windows</code>下的<code>dll</code>文件。</li><li><code>/usr/share</code>目录下主要是文档，比如说 man 的文档都在<code>/usr/share/man</code>下面。</li></ul><h3 id="FAT、NTFS-和-Ext3-文件系统有什么区别？"><a href="#FAT、NTFS-和-Ext3-文件系统有什么区别？" class="headerlink" title="FAT、NTFS 和 Ext3 文件系统有什么区别？"></a><strong>FAT、NTFS 和 Ext3 文件系统有什么区别</strong>？</h3><p>10 年前 FAT 文件系统还是常见的格式，而现在 Windows 上主要是 NTFS，Linux 上主要是 Ext3、Ext4 文件系统。关于这块知识，一般资料只会从支持的磁盘大小、数据保护、文件名等各种维度帮你比较，但是最本质的内容却被一笔带过。<strong>它们最大的区别是文件系统的实现不同，具体怎么不同</strong>？<strong>文件系统又有哪些实现</strong>？这一讲，我将带你一起来探索和学习这部分知识。</p><h4 id="硬盘分块"><a href="#硬盘分块" class="headerlink" title="硬盘分块"></a>硬盘分块</h4><p>在了解文件系统实现之前，我们先来了解下操作系统如何使用硬盘。</p><p><strong>使用硬盘和使用内存有一个很大的区别，内存可以支持到字节级别的随机存取，而这种情况在硬盘中通常是不支持的</strong>。过去的机械硬盘内部是一个柱状结构，有扇区、柱面等。读取硬盘数据要转动物理的磁头，每转动一次磁头时间开销都很大，因此一次只读取一两个字节的数据，非常不划算。</p><p>随着 SSD 的出现，机械硬盘开始逐渐消失（还没有完全结束），现在的固态硬盘内部是类似内存的随机存取结构。但是硬盘的读写速度还是远远不及内存。而连续读多个字节的速度，还远不如一次读一个硬盘块的速度。</p><p>因此，<strong>为了提高性能，通常会将物理存储（硬盘）划分成一个个小块</strong>，比如每个 4KB。这样做也可以让硬盘的使用看起来非常整齐，方便分配和回收空间。况且，数据从磁盘到内存，需要通过电子设备，比如 DMA、总线等，如果一个字节一个字节读取，速度较慢的硬盘就太耗费时间了。过去的机械硬盘的速度可以比内存慢百万倍，现在的固态硬盘，也会慢几十到几百倍。即便是最新的 NvMe 接口的硬盘，和内存相比速度仍然有很大的差距。因此，一次读/写一个块（Block）才是可行的方案。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082207.png" alt="image-20210630082206967"></p><p>如上图所示，操作系统会将磁盘分成很多相等大小的块。这样做还有一个好处就是如果你知道块的序号，就可以准确地计算出块的物理位置。</p><h4 id="文件的描述"><a href="#文件的描述" class="headerlink" title="文件的描述"></a>文件的描述</h4><p>我们将硬盘分块后，如何利用上面的硬盘存储文件，就是文件系统（File System）要负责的事情了。当然目录也是一种文件，因此我们先讨论文件如何读写。不同的文件系统利用方式不同，今天会重点讨论 3 种文件系统：</p><ul><li>早期的 FAT 格式</li><li>基于 inode 的传统文件系统</li><li>日志文件系统（如 NTFS, EXT2、3、4）</li></ul><h4 id="FAT-表"><a href="#FAT-表" class="headerlink" title="FAT 表"></a>FAT 表</h4><p>早期人们找到了一种方案就是文件分配表（File Allocate Table，FAT）。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082256.png" alt="image-20210630082256398"></p><p><strong>一个文件，最基本的就是要描述文件在硬盘中到底对应了哪些块。FAT 表通过一种类似链表的结构描述了文件对应的块</strong>。上图中：文件 1 从位置 5 开始，这就代表文件 1 在硬盘上的第 1 个块的序号是 5 的块 。然后位置 5 的值是 2，代表文件 1 的下一个块的是序号 2 的块。顺着这条链路，我们可以找到 5 → 2 → 9 → 14 → 15 → -1。-1 代表结束，所以文件 1 的块是：5,2,9,14,15。同理，文件 2 的块是 3,8,12。</p><p><strong>FAT 通过一个链表结构解决了文件和物理块映射的问题，算法简单实用，因此得到过广泛的应用，到今天的 Windows/Linux/MacOS 都还支持 FAT 格式的文件系统</strong>。FAT 的缺点就是非常占用内存，比如 1T 的硬盘，如果块的大小是 1K，那么就需要 1G 个 FAT 条目。通常一个 FAT 条目还会存一些其他信息，需要 2~3 个字节，这就又要占用 2-3G 的内存空间才能用 FAT 管理 1T 的硬盘空间。显然这样做是非常浪费的，问题就出在了 FAT 表需要全部维护在内存当中。</p><h4 id="索引节点（inode）"><a href="#索引节点（inode）" class="headerlink" title="索引节点（inode）"></a>索引节点（inode）</h4><p>为了改进 FAT 的容量限制问题，可以考虑为每个文件增加一个索引节点（inode）。这样，随着虚拟内存的使用，当文件导入内存的时候，先导入索引节点（inode），然后索引节点中有文件的全部信息，包括文件的属性和文件物理块的位置。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082432.png" alt="image-20210630082432563"></p><p>如上图，索引节点除了属性和块的位置，还包括了一个指针块的地址。这是为了应对文件非常大的情况。一个大文件，一个索引节点存不下，需要通过指针链接到其他的块去描述文件。</p><p>这种文件索引节点（inode）的方式，完美地解决了 FAT 的缺陷，一直被沿用至今。FAT 要把所有的块信息都存在内存中，索引节点只需要把用到的文件形成数据结构，而且可以使用虚拟内存分配空间，随着页表置换，这就解决了 FAT 的容量限制问题。</p><h4 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h4><p>有了文件的描述，接下来我们来思考如何实现目录（Directory）。目录是特殊的文件，所以每个目录都有自己的 inode。目录是文件的集合，所以目录的内容中必须有所有其下文件的 inode 指针。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082520.png" alt="image-20210630082520140"></p><p>文件名也最好不要放到 inode 中，而是放到文件夹中。这样就可以灵活设置文件的别名，及实现一个文件同时在多个目录下。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082535.png" alt="image-20210630082535220"></p><p>如上图，/foo 和 /bar 两个目录中的 b.txt 和 c.txt 其实是一个文件，但是拥有不同的名称。这种形式我们称作“硬链接”，就是多个文件共享 inode。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082642.png" alt="image-20210630082642563"></p><p>硬链接有一个非常显著的特点，硬链接的双方是平等的。上面的程序我们用<code>ln</code>指令为文件 a 创造了一个硬链接<code>b</code>。如果我们创造完删除了 a，那么 b 也是可以正常工作的。如果要删除掉这个文件的 inode，必须 a,b 同时删除。这里你可以看出 a,b 是平等的。</p><p>和硬链接相对的是软链接，软链接的原理如下图：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082707.png" alt="image-20210630082707436"></p><p>图中<code>c.txt</code>是<code>b.txt</code>的一个软链接，软链接拥有自己的<code>inode</code>，但是文件内容就是一个快捷方式。因此，如果我们删除了<code>b.txt</code>，那么<code>b.txt</code>对应的 inode 也就被删除了。但是<code>c.txt</code>依然存在，只不过指向了一个空地址（访问不到）。如果删除了<code>c.txt</code>，那么不会对<code>b.txt</code>造成任何影响。</p><p>在 Linux 中可以通过<code>ln -s</code>创造软链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s a b # 将b设置为a的软链接(b是a的快捷方式)</span><br></pre></td></tr></table></figure><p>以上，我们对文件系统的实现有了一个初步的了解。从<strong>整体设计上，本质还是将空间切块，然后划分成目录和文件管理这些分块</strong>。读、写文件需要通过 inode 操作磁盘。操作系统提供的是最底层读写分块的操作，抽象成文件就交给文件系统。比如想写入第 10001 个字节，那么会分成这样几个步骤：</p><ol><li>修改内存中的数据</li><li>计算要写入第几个块</li><li>查询 inode 找到真实块的序号</li><li>将这个块的数据完整的写入一次磁盘</li></ol><p><strong>你可以思考一个问题，如果频繁读写磁盘，上面这个模型会有什么问题</strong>？可以把你的思考和想法写在留言区，我们在本讲后面会详细讨论。</p><h4 id="解决性能和故障：日志文件系统"><a href="#解决性能和故障：日志文件系统" class="headerlink" title="解决性能和故障：日志文件系统"></a>解决性能和故障：日志文件系统</h4><p><strong>在传统的文件系统实现中，inode 解决了 FAT 容量限制问题，但是随着 CPU、内存、传输线路的速度越来越快，对磁盘读写性能的要求也越来越高</strong>。传统的设计，每次写入操作都需要进行一次持久化，所谓“持久化”就是将数据写入到磁盘，这种设计会成为整个应用的瓶颈。因为磁盘速度较慢，内存和 CPU 缓存的速度非常快，如果 CPU 进行高速计算并且频繁写入磁盘，那么就会有大量线程阻塞在等待磁盘 I/O 上。磁盘的瓶颈通常在写入上，因为通常读取数据的时候，会从缓存中读取，不存在太大的瓶颈。</p><p>加速写入的一种方式，就是利用缓冲区。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630084651.png" alt="image-20210630084651264"></p><p>上图中所有写操作先存入缓冲区，然后每过一定的秒数，才进行一次持久化。 这种设计，是一个很好的思路，但最大的问题在于容错。 比如上图的步骤 1 或者步骤 2 只执行了一半，如何恢复？如果步骤 2 只写入了一半，那么数据就写坏了。如果步骤 1 只写入了一半，那么数据就丢失了。无论出现哪种问题，都不太好处理。更何况写操作和写操作之间还有一致性问题，比如说一次删除 inode 的操作后又发生了写入……</p><p>解决上述问题的一个非常好的方案就是利用日志。假设 A 是文件中某个位置的数据，比起传统的方案我们反复擦写 A，日志会帮助我们把 A 的所有变更记录下来，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A=1</span><br><span class="line"></span><br><span class="line">A=2</span><br><span class="line"></span><br><span class="line">A=3</span><br></pre></td></tr></table></figure><p>上面 A 写入了 3 次，因此有 3 条日志。日志文件系统文件中存储的就是像上面那样的日志，而不是文件真实的内容。当用户读取文件的时候，文件内容会在内存中还原，所以内存中 A 的值是 3，但实际磁盘上有 3 条记录。</p><p>从性能上分析，如果日志造成了 3 倍的数据冗余，那么读取的速度并不会真的慢三倍。因为我们多数时候是从内存和 CPU 缓存中读取数据。而写入的时候，因为采用日志的形式，可以考虑下图这种方式，在内存缓冲区中积累一批日志才写入一次磁盘。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630084827.png" alt="image-20210630084827466"></p><p>上图这种设计可以让写入变得非常快速，多数时间都是写内存，最后写一次磁盘。<strong>而上图这样的设计成不成立，核心在能不能解决容灾问题</strong>。</p><p>你可以思考一下这个问题——<strong>丢失一批日志和丢失一批数据的差别大不大</strong>。其实它们之间最大的差别在于，如果丢失一批日志，只不过丢失了近期的变更；但如果丢失一批数据，那么就可能造成永久伤害。</p><p>举个例子，比如说你把最近一天的订单数据弄乱了，你可以通过第三方支付平台的交易流水、系统的支付记录等帮助用户恢复数据，还可以通过订单关联的用户信息查询具体是哪些用户的订单出了问题。但是如果你随机删了一部分订单， 那问题就麻烦了。你要去第三发支付平台调出所有流水，用大数据引擎进行分析和计算。</p><p>为了进一步避免损失，一种可行的方案就是创建还原点（Checkpoint），比如说系统把最近 30s 的日志都写入一个区域中。下一个 30s 的日志，写入下一个区域中。每个区域，我们称作一个还原点。创建还原点的时候，我们将还原点涂成红色，写入完成将还原点涂成绿色。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630084959.png" alt="image-20210630084959570"></p><p>如上图，当日志文件系统写入磁盘的时候，每隔一段时间就会把这段时间内的所有日志写入一个或几个连续的磁盘块，我们称为还原点（Checkpoint）。操作系统读入文件的时候，依次读入还原点的数据，如果是绿色，那么就应用这些日志，如果是红色，就丢弃。所以上图中还原点 3 的数据是不完整的，这个时候会丢失不到 30s 的数据。如果将还原点的间隔变小，就可以控制风险的粒度。另外，我们还可以对还原点 3 的数据进行深度恢复，这里可以有人工分析，也可以通过一些更加复杂的算法去恢复。</p><ul><li>FAT 的设计简单高效，如果你要自己管理一定的空间，可以优先考虑这种设计。</li><li>inode 的设计在内存中创造了一棵树状结构，对文件、目录进行管理，并且索引到磁盘中的数据。这是一种经典的数据结构，这种思路会被数据库设计、网络资源管理、缓存设计反复利用。</li><li>日志文件系统——日志结构简单、容易存储、按时间容易分块，这样的设计非常适合缓冲、批量写入和故障恢复。</li></ul><p>现在我们很多分布式系统的设计也是基于日志，比如 MySQL 同步数据用 binlog，Redis 的 AOF，著名的分布式一致性算法 Paxos ，因此 Zookeeper 内部也在通过实现日志的一致性来实现分布式一致性。</p><p><strong>FAT、NTFS 和 Ext3 有什么区别</strong>？</p><p>FAT 通过内存中一个类似链表的结构，实现对文件的管理。<strong>NTFS 和 Ext3 是日志文件系统，它们和 FAT 最大的区别在于写入到磁盘中的是日志，而不是数据</strong>。日志文件系统会先把日志写入到内存中一个高速缓冲区，定期写入到磁盘。日志写入是追加式的，不用考虑数据的覆盖。一段时间内的日志内容，会形成还原点。这种设计大大提高了性能，当然也会有一定的数据冗余。</p><h3 id="MySQL-中-B-树和-B-树有什么区别？"><a href="#MySQL-中-B-树和-B-树有什么区别？" class="headerlink" title="MySQL 中 B 树和 B+ 树有什么区别？"></a><strong>MySQL 中 B 树和 B+ 树有什么区别？</strong></h3><p>B 树和 B+ 树是两种数据结构（关于它们的名字为什么以 B 开头，因为众说纷纭，本讲我就不介绍了），构建了磁盘中的高速索引结构，因此不仅 MySQL 在用，MongoDB、Oracle 等也在用，基本属于数据库的标配常规操作。</p><p>数据库要经常和磁盘与内存打交道，为了提升性能，通常需要自己去构建类似文件系统的结构。这一讲的内容有限，我只是先带你入一个门，如果你感兴趣后续可以自己深入学习。下面我们一起来探讨数据库如何利用磁盘空间设计索引。</p><h4 id="行存储和列存储"><a href="#行存储和列存储" class="headerlink" title="行存储和列存储"></a>行存储和列存储</h4><p>在学习构建磁盘数据的索引结构前，我们先通过行存储、列存储的学习来了解一些基本的存储概念，帮助你建立一个基本的认知。</p><p>目前数据库存储一张表格主要是行存储（Row Storage）和列存储（Column Storage）两种存储方式。行存储将表格看作一个个记录，每个记录是一行。以包含订单号、金额、下单时间 3 项的表为例，行存储如下图所示：</p><p><img src="C:\Users\flyho\AppData\Roaming\Typora\typora-user-images\image-20210630090802588.png" alt="image-20210630090802321"></p><p>如上图所示，在计算机中没有真正的行的概念。行存储本质就是数据一个接着一个排列，一行数据后面马上跟着另一行数据。如果订单表很大，一个磁盘块（Block）存不下，那么实际上就是每个块存储一定的行数。 类似下图这样的结构：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630090928.png" alt="image-20210630090928389"></p><p>行存储更新一行的操作，往往可以在一个块（Block）中进行。而查询数据，聚合数据（比如求 4 月份的订单数），往往需要跨块（Block）。因此，<strong>行存储优点很明显，更新快、单条记录的数据集中，适合事务。但缺点也很明显，查询慢</strong>。</p><p>还有一种表格的存储方式是列存储（Column Storage），列存储中数据是一列一列存的。还以订单表为例，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630091007.png" alt="image-20210630091007790"></p><p>你可以看到订单号在一起、姓名在一起、时间在一起、金额也在一起——每个列的数据都聚集在一起。乍一看这样的结构很低效，比如说你想取出第一条订单，需要取第 1 列的第 1 个数据<code>1001</code>，然后取第 2 列的第 1 个数据<code>小明</code>，以此类推，需要 4 次磁盘读取。特别是更新某一条记录的时候，需要更新多处，速度很慢。那么列存储优势在哪里呢？<strong>优势其实是在查询和聚合运算</strong>。</p><p>在列存储中同一列数据总是存放在一起，比如要查找某个时间段，很有可能在一个块中就可以找到，因为时间是集中存储的。假设磁盘块的大小是 4KB，一条记录是 100 字节， 那么 4KB 可以存 40 条记录；但是存储时间戳只需要一个 32 位整数，4KB 可以存储 1000 个时间。更关键的是，我们可以把一片连续的硬盘空间通过 DMA 技术直接映射到内存，这样就大大减少了搜索需要的时间。所以有时候在行存储需要几分钟的搜索操作，在列存储中只需几秒钟就可以完成。</p><p><strong>总结一下，行存储、列存储，最终都需要把数据存到磁盘块</strong>。行存储记录一个接着一个，列存储一列接着一列。前面我们提到行存储适合更新及事务处理，更新好理解，因为一个订单可以在相同的 Block 中更新，那么为什么适合事务呢？</p><p>其实适合不适合是相对的，说行存储适合是因为列存储非常不适合事务。试想一下，你更新一个表的若干个数据，如果要在不同块中更新，就可能产生多次更新操作。更新次数越多，保证一致性越麻烦。在单机环境我们可以上锁，可以用阻塞队列，可以用屏障……但是分布式场景中保证一致性（特别是强一致性）开销很大。因此我们说行存储适合事务，而列存储不适合。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><strong>接下来，我们在行存储、列存储的基础上，讨论如何创建一些更高效的查询结构，这种结构通常称为索引</strong>。我们经常会遇到根据一个订单编号查订单的情况，比如说<code>select * from order where id=1000000</code>，这个时候就需要用到索引。而下面我将试图通过二分查找的场景，和你一起讨论<strong>索引是什么。</strong></p><p>在亿级的订单 ID 中查找某个编号，很容易想到二分查找。要理解二分查找，最需要关心的是算法的进步机制。这个算法每进行一次查找，都会让问题的规模减半。当然，也有场景限制，二分查找只能应用在排序好的数据上。</p><p>比如我们要在下面排序好的数组中查找 3：</p><p>1,3,5,8,11,12,15,19,21,25</p><p>数组中一共有 10 个元素，因此我们第一次查找从数组正中间的元素找起。如果数组正中间有两个元素，就取左边的那个——对于这个例子是 11。我们比较 11 和 3 的值，因为 11 大于 3，因此可以排除包括 11 在内的所有 11 右边的元素。相当于我们通过一次运算将数据的规模减半。假设我们有 240 （1T 数据）个元素需要查询（规模已经相当大了，万亿级别），用二分查找只需要 40 次运算。</p><p>所以按照这个思路，我们需要做的是将数据按照订单 ID 排好序，查询的时候就可以应用二分查找了。而且按照二分查找的思路，也可以进行范围查找。比如要查找 [a,b] 之间的数据，可以先通过二分查找找到 a 的序号，再二分找到 b 的序号，两个序号之间的数据就是目标结果。</p><p>但是直接在原始数据上排序，我们可能会把数据弄乱，常规做法是设计冗余数据描述这种排序关系——这就是索引。下面我通过一个简单的例子告诉你为什么不能在原始数据上直接排序。</p><p>假设我们有一个订单表，里面有订单 ID 和金额。使用列存储做演示如下：</p><p>订单 ID 列：</p><p>10005 10001 ……</p><p>订单金额列：</p><p>99.00 100.00 ……</p><p>可以看到，订单（10001）是第 2 个订单。但是进行排序后，订单（10001）会到第 1 个位置。这样会弄乱订单 ID（10001）和 金额（100.00）对应的关系。</p><p>因此我们必须用空间换时间，额外将订单列拷贝一份排序：</p><p>10001，2，10005， 1</p><p>以上这种<strong>专门用来进行数据查询的额外数据，就是索引</strong>。<strong>索引中的一个数据，也称作索引条目</strong>。上面的索引条目一个接着一个，每个索引条目是 &lt;订单 ID, 序号&gt; 的二元组。</p><p>如果你考虑是行存储（比如 MySQL），那么依然可以生成上面的索引，订单 ID 和序号（行号）关联。如果有多个索引，就需要创造多个上面的数据结构。如果有复合索引，比如 &lt;订单状态、日期、序号&gt; 作为一个索引条目，其实就是先按照订单状态，再按照日期排序的索引。</p><p>所以复合索引，无非就是多消耗一些空间，排序维度多一些。而且你可以看出复合索引和单列索引完全是独立关系，所以我们可以认为每创造一组索引，就创造了一份冗余的数据。也创造了一种特别的查询方式。关于索引还有很多有趣的知识，我们先介绍这些，如果感兴趣可以自己查资料深挖。</p><p>接下来，请分析一个非常<strong>核心的问题：上面的索引是一个连续的、从小到大的索引，那么应不应该使用这种从小到大排序的索引呢</strong>？例如，我们需要查询订单，就事先创建另一个根据订单 ID 从小到大排序的索引，当用户查找某个订单的时候，无论是行存储、还是列存储，我们就用二分查找查询对应的索引条目。这种方式，我们姑且称为线性排序索引——看似很不错的一个方式，但是并不是非常好的一种做法，请看我接下来的讨论。</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>线性排序的数据虽然好用，但是插入新元素的时候性能太低。如果是内存操作，插入一个元素，需要将这个元素之后的所有元素后移一位。但如果这个操作发生在磁盘中呢？这必然是灾难性的。因为磁盘的速度比内存慢至少 10-1000 倍，如果是机械硬盘可能慢几十万到百万倍。</p><p>所以我们不能用一种线性结构将磁盘排序。那么树呢？ 比如二叉搜索树（Binary Serach Tree）行不行呢？利用磁盘的空间形成一个二叉搜索树，例如将订单 ID 作为二叉搜索树的 Key。</p><p>如下图所示，二叉搜索树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点。而且，因为索引条目较少，确实可以考虑在查询的时候，先将足够大的树导入内存，然后再进行搜索。搜索的算法是递归的，与二分查找非常类似，每次计算可以将问题规模减半。当然，具体有多少数据可以导入内存，受实际可以使用的内存数量的限制。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630114725.png" alt="image-20210630114725249"></p><p>在上面的二叉搜索树中，每个节点的数据分成 Key 和 Value。Key 就是索引值，比如订单 ID 创建索引，那么 Key 就是订单 ID。值中至少需要序号（对行存储也就是行号）。这样，如果们想找 18 对应的行，就可以先通过二叉搜索树找到对应的行号，然后再去对应的行读取数据。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630114822.png" alt="image-20210630114822531"></p><p>二叉搜索树是一个天生的二分查找结构，每次查找都可以减少一半的问题规模。而且二叉搜索树解决了插入新节点的问题，因为二叉搜索树是一个跳跃结构，不必在内存中连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。</p><p><strong>那么回到本质问题，在使用磁盘的时候，二叉搜索树是不是一种合理的查询结构</strong>？</p><p>当然还不算，因此还需要继续优化我们的算法。二叉搜索树，在内存中是一个高效的数据结构。这是因为内存速度快，不仅可以随机存取，还可以高频操作。注意 CPU 缓存的穿透率只有 5% 左右，也就是 95% 的操作是在更快的 CPU 缓存中执行的。而且即便穿透，内存操作也是在纳秒级别可以完成。</p><p>但是，这个逻辑在磁盘中是不存在的，磁盘的速度慢太多了。我们可以尝试把尽可能多的二叉搜索树读入磁盘，但是如果数据量大，只能读入一部分呢？因此我们还需要继续改进算法。</p><h4 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B 树和 B+ 树"></a>B 树和 B+ 树</h4><p>二叉搜索树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。但是，当需要索引的数据量很大，无法在一个磁盘 Block 中存下整棵二叉搜索树的时候。每一次递归向下的搜索，实际都是读取不同的磁盘块。这个时候二叉搜索树的开销很大。</p><p>试想一个一万亿条订单的表，进行 40 次查找找到答案，在内存中不是问题，要考虑到 CPU 缓存有 90% 以上的命中率（当然前提是内存足够大）。通常情况下我们没有这么大的内存空间，如果 40 次查找发生在磁盘上，也是非常耗时的。那么有没有更好的方案呢？</p><p><strong>一个更好的方案，就是继续沿用树状结构，利用好磁盘的分块让每个节点多一些数据，并且允许子节点也多一些，树就会更矮。因为树的高度决定了搜索的次数</strong>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115010.png" alt="image-20210630115010402"></p><p><strong>上图中我们构造的树被称为 B 树</strong>（<strong>B-Tree</strong>），开头说过，B 这个字母具体是哪个单词或者人名的缩写，至今有争议，具体你可以查查资料。</p><p>B-Tree 是一种递归的搜索结构，与二叉搜索树非常类似。不同的是，B 树中的父节点中的数据会对子树进行区段分割。比如上图中节点 1 有 3 个子节点，并用数字 9,30 对子树的区间进行了划分。</p><p>上图中的 B 树是一个 3-4 B 树，3 指的是每个非叶子节点允许最大 3 个索引，4 指的是每个节点最多允许 4 个子节点，4 也指每个叶子节点可以存 4 个索引。上面只是一个例子，在实际的操作中，子节点有几十个、甚至上百个索引也很常见，因为我们希望树变矮，好减少磁盘操作。</p><p>B 树的每个节点是一个索引条目（例如：一个 &lt;订单 ID，序号&gt; 的组合），如果是行数据库可以索引到一条存储在磁盘上的记录。</p><h4 id="继承-B-树：B-树"><a href="#继承-B-树：B-树" class="headerlink" title="继承 B 树：B+ 树"></a>继承 B 树：B+ 树</h4><p>为了达到最高的效率，实战中我们往往使用的是一种继承于 B 树设计的结构，称为 B+ 树。B+ 树只有叶子节点才映射数据，下图中是对 B 树设计的一种改进，节点 1 为冗余节点，它不存储数据，只划定子树数据的范围。你可以看到节点 1 的索引 Key：12 和 30，在节点 3 和 4 中也有一份。</p><h4 id="树的形成：插入"><a href="#树的形成：插入" class="headerlink" title="树的形成：插入"></a>树的形成：插入</h4><p>下面我以一棵 2-3 B+ 树来演示 B+ 树的插入过程。2 指的是 B+ 树每个非叶子节点允许 2 个数据，叶子节点最多允许 3 个索引，每个节点允许最多 3 个子节点。我们要在 2-3 B+ 树中依次插入 3,6,9,12,19,15,26,8,30。下图是演示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115403.gif"></p><p>插入 3,6,9 过程很简单，都写入一个节点即可，因为叶子节点最多允许每个 3 个索引。接下来我们插入 12，会发生一次过载，然后节点就需要拆分，这个时候按照 B+ 树的设计会产生冗余节点。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115722.png" alt="image-20210630115722136"></p><p>然后插入 15 非常简单，直接加入即可：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115733.png" alt="image-20210630115733217"></p><p>接下来插入 19， 这个时候下图中红色部分发生过载：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115747.png" alt="image-20210630115747830"></p><p>因此需要拆分节点数据，我们从中间把红色的节点拆开，15 作为冗余的索引写入父节点，就形成下图的情况：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115757.png" alt="image-20210630115757351"></p><p>接着插入 26， 写入到对应位置即可。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115809.png" alt="image-20210630115809252"></p><p>接下来，插入 8 到对应位置即可。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115820.png" alt="image-20210630115820343"></p><p>然后我们插入 30，此时右边节点发生过载：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115834.png" alt="image-20210630115834408"></p><p>解决完一次过载问题之后，因为 26 会浮上去，根节点又发生了过载：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115846.png" alt="image-20210630115846288"></p><p>再次解决过载，拆分红色部分，得到最后结果：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115857.png" alt="image-20210630115857267"></p><p>在上述过程中，B+ 树始终可以保持平衡状态，而且所有叶子节点都在同一层级。更复杂的数学证明，我就不在这里讲解了。不过建议对算法感兴趣对同学，可以学习《算法导论》中关于树的部分。</p><h4 id="插入和删除效率"><a href="#插入和删除效率" class="headerlink" title="插入和删除效率"></a>插入和删除效率</h4><p>B+ 树有大量的冗余节点，比如删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点。这样删除非常快。B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂。比如删除根节点中的数据，可能涉及复杂的树的变形。</p><p>B+ 树的插入也是一样，有冗余节点，插入可能存在节点的拆分（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要更多复杂的算法，类似红黑树的旋转操作等。</p><p>因此，<strong>B+ 树的插入和删除效率更高</strong>。</p><h4 id="搜索：链表的作用"><a href="#搜索：链表的作用" class="headerlink" title="搜索：链表的作用"></a>搜索：链表的作用</h4><p>B 树和 B+ 树搜索原理基本一致。先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。</p><p>你可能会注意到，B+ 树所有叶子节点间还有一个链表进行连接。这种设计对范围查找非常有帮助，比如说我们想知道 1 月 20 日和 1 月 22 日之间的订单，这个时候可以先查找到 1 月 20 日所在的叶子节点，然后利用链表向右遍历，直到找到 1 月22 日的节点。这样我们就进一步节省搜索需要的时间。</p><p>这一讲我们学习了在数据库中如何利用文件系统造索引。无论是行存储还是列存储，构造索引的过程都是类似的。索引有很多做法，除了 B+ 树，还有 HashTable、倒排表等。<strong>如果是存储海量数据的数据库，我们的思考点需要放在 I/O 的效率上</strong>。<strong>如果把今天的知识放到分布式数据库上，那除了需要节省磁盘读写还需要节省网络 I/O</strong>。</p><h3 id="MySQL-中的-B-树和-B-树有什么区别？"><a href="#MySQL-中的-B-树和-B-树有什么区别？" class="headerlink" title="MySQL 中的 B 树和 B+ 树有什么区别？"></a><strong>MySQL 中的 B 树和 B+ 树有什么区别？</strong></h3><p>B+ 树继承于 B 树，都限定了节点中数据数目和子节点的数目。B 树所有节点都可以映射数据，B+ 树只有叶子节点可以映射数据。</p><p>单独看这部分设计，看不出 B+ 树的优势。为了只有叶子节点可以映射数据，B+ 树创造了很多冗余的索引（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，而且可以自动平衡，因此 B+ 树的所有叶子节点总是在一个层级上。所以 B+ 树可以用一条链表串联所有的叶子节点，也就是索引数据，这让 B+ 树的范围查找和聚合运算更快。</p><h3 id="分布式文件系统是怎么回事？"><a href="#分布式文件系统是怎么回事？" class="headerlink" title="分布式文件系统是怎么回事？"></a><strong>分布式文件系统是怎么回事？</strong></h3><p>们讨论大数据环境下的数据管理——分布式文件系统和分布式数据库。分布式文件系统通过计算机网络连接大量物理节点，将不同机器、不同磁盘、不同逻辑分区的数据组织在一起，提供海量的数据存储（一般是 Petabytes 级别，1PB = 1024TB）。分布式数据库则在分布式文件系统基础上，提供应对具体场景的海量数据解决方案。</p><p>说起大数据，就不得不提历史上在存储领域影响深远的两篇 Paper。</p><ul><li>Google File System</li><li>BigTable：A Distributed Storage System for Structured Data</li></ul><p>Google File System 是一个分布式文件系统，构成了今天大数据生态的底层存储，也是我们本讲主角 HDFS 的原型。HDFS（Hadoop Distributed File System）是 Google File System 的一个重要实现。</p><p>后者 BigTable 是一个分布式数据库。BigTable 本身是 Google 内部的项目，建立在 Google File System 之上，为 Google 的搜索引擎提供数据支撑。它是 2005 年公布的第一个版本，而且通过 Paper 公布了实现，在那个大数据还处于萌芽阶段的时代，BigTable 成为了启明星，今天我们常用的 HBase 还沿用着 BigTable 的设计。</p><p>因为两个重量级的 Paper 都是 Google 的产物，所以这一讲，我会结合搜索引擎的设计，带你走进分布式存储和数据库的世界。</p><h4 id="存储所有的网页"><a href="#存储所有的网页" class="headerlink" title="存储所有的网页"></a>存储所有的网页</h4><p>作为搜索引擎最核心的一个能力，就是要存储所有的网页。目前世界上有 20 多亿个网站，每个网站还有大量的页面。搜索引擎不单单要存下这些页面，而且搜索引擎还需要存储这些网页的历史版本。</p><p>这里请你思考下，网站所有页面加起来有多大？举个例子，豆瓣所有页面加起来会有多大？如果把所有的变更都算上，比如一张页面经过 200 次迭代，就存 200 份，那么需要多少空间？Google 要把这些数据都存储下来，肯定是 PB 级别的数据。而且这个庞大的数据还需要提供给 Google 内部的分布式计算引擎等去计算，为网站打分、为用户生成索引，如果没有强大的存储能力是做不到的。</p><h4 id="模型的选择"><a href="#模型的选择" class="headerlink" title="模型的选择"></a>模型的选择</h4><p>我们先来思考应该用何种模型存下这个巨大的网页表。</p><p>网页的历史版本，可以用 URL+ 时间戳进行描述。但是为了检索方便，网页不仅有内容，还有语言、外链等。在存储端可以先不考虑提供复杂的索引，比如说提供全文搜索。但是我们至少应该提供合理的数据读写方式。</p><p>网页除了内容，还有外链，外链就是链接到网页的外部网站。链接到一个网站的外链越多，那就说明这个网站在互联网中扮演的角色越重要。Google 创立之初就在基于外链的质量和数量为网站打分。外链可能是文字链接、图片链接等，因此外链也可以有版本，比如外链文本调整了，图片换了。除了外链还有标题、Logo，也需要存储。其实要存储的内容有很多，我不一一指出了。</p><p>我们先看看行存储，可不可以满足需求。比如每个网页（ URL） 的数据是一行。 看似这个方案可行，可惜列不是固定。比如外链可能有很多个，如下表：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630120634.png" alt="image-20210630120634095"></p><p>列不固定，不仅仅是行的大小不好确定，而是表格画不出来。何况每一列内容还可能有很多版本，不同版本是搜索引擎的爬虫在不同时间收录的内容，再加上内容本身也很大，有可能一个磁盘 Block 都存不下。看来行存储困难重重。</p><p>那么列存储行不行呢？ 当然不行，我们都不确定到底有多少列？ 有的网站有几千个外链，有的一个都没有，外链到底用多少列呢？</p><p>所以上表只可以作为我们存储设计的一个逻辑概念——这种逻辑概念在设计系统的时候，还有一个名词，叫作领域语言。领域语言是我们的思考方式，从搜索引擎的职责上讲，数据需要按照上面的结构聚合。况且根据 URL 拿数据，这是必须提供的能力。但是底层如何持久化，还需要进一步思考。</p><p>因为列是不确定的，这种情况下只能考虑用 Key-Value 结构，也就是 Map 存储。Map 是一种抽象的数据结构，本质是 Key-Value 数据的集合。 作为搜索引擎的支撑，Key 可以考虑设计为 &lt;URL, Column，时间戳&gt; 的三元组，值就是对应版本的数据。</p><p>列名（Column）可以考虑分成两段，用<code>:</code>分隔开。列名包括列家族（Family) 、列标识（Qualifier）。这样设计是因为有时候多个列描述的是相似的数据，比如说外链（Anchor），就是一个列家族。然后百度、搜狐是外链家族的具体的标识（Qualifier）。比如来自百度页面 a 外链的列名是<code>anchor:baidu.com/a</code>。分成家族还有一个好处就是<strong>权限控制</strong>，比如不同部门的内部人员可以访问不同列家族的数据。当然有的列家族可能只有一个列，比如网页语言；有的列家族可能有很多列，比如外链。</p><p><strong>接下来，我们思考：这个巨大的 Map（Key-Value）的集合应该用什么数据结构呢？——数组？链表？树？哈希表</strong>？</p><p><em>小提示：Map 只是 Key-Value 的集合。并没有约定具体如何实现，比如 HashMap 就是用哈希表实现 Map，ArrayMap 就是用数组实现 Map。LinkedMap 就是用链表实现 Map。LinkedJumpMap 就是用跳表实现 Map……</em></p><p>考虑到一行的数据并不会太大，我们可以用 URL 作为行的索引。当用户想用 Key 查找 Value 时，先使用 Key 中 URL 帮用户找到完整的行。这里可以考虑使用上一讲学习的 B+ 树去存储所有的 URL，建立一个 URL 到行号的索引。你看看，知识总是被重复利用，再次证明了人类的本质是复读机，其实就是学好基础很重要。通过 B+ 树，这样即便真的有海量的数据，也可以在少数几次、几十次查询内完成找到 URL 对应的数据。况且，我们还可以设计缓存。</p><p>B+ 树需要一种顺序，比较好的做法是 URL 以按照字典序排列。这是因为，相同域名的网页资源同时被用到的概率更高，应该安排从物理上更近，尽量把相同域名的数据放到相邻的存储块中（节省磁盘操作）。</p><p>那么行内的数据应该如何存储呢？可以考虑分列存储。那么行内用什么数据结构呢？如果列非常多，也可以考虑继续用 B+ 树。还有一种设计思路，是先把大表按照行拆分，比如若干行形成一个小片称作 Tablet，然后 Tablet 内部再使用列存储，这个设计我们会在后面一点讨论。</p><h4 id="查询和写入"><a href="#查询和写入" class="headerlink" title="查询和写入"></a>查询和写入</h4><p>当客户端查询的时候，请求参数中会包含 &lt;URL, 列名&gt;，这个时候我们可以通过 B+ 树定位到具体的行（也就是 URL 对应的数据）所在的块，再根据列名找到具体的列。然后，将一列数据导入到内存中，最后在内存中找到对应版本的数据。</p><p>客户端写入时，也是按照行→列的顺序，先找到列，再在这一列最后面追加数据。</p><p>对于修改、删除操作可以考虑不支持，因为所有的变更已经记录下来了。</p><h4 id="分片（Tablet）的抽象"><a href="#分片（Tablet）的抽象" class="headerlink" title="分片（Tablet）的抽象"></a>分片（Tablet）的抽象</h4><p>上面我们提到了可以把若干行组合在一起存储的设计。这个设计比较适合数据在集群中分布。假设存储网页的表有几十个 PB，那么先水平分表，就是通过 行（URL） 分表。URL 按照字典排序，相邻的 URL 数据从物理上也会相近。水平分表的结果，字典序相近的行（URL）数据会形成分片（Tablet），Tablet 这个单词类似药片的含义。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122049.png" alt="image-20210630122049634"></p><p>如上图所示：每个分片中含有一部分的行，视情况而定。分片（Tablet），可以作为数据分布的最小单位。分片内部可以考虑图上的行存储，也可以考虑内部是一个 B+ 树组织的列存储。</p><p>为了实现分布式存储，每个分片可以对应一个分布式文件系统中的文件。假设这个分布式文件系统接入了 Linux 的虚拟文件系统，使用和操作会同 Linux 本地文件并无二致。其实不一定会这样实现，这只是一个可行的方案。</p><p>为了存储安全，一个分片最少应该有 2 个副本，也就是 3 份数据。3 份数据在其中一份数据不一致后，可以对比其他两份的结果修正数据。这 3 份数据，我们不考虑跨数据中心。因为跨地域成本太高，吞吐量不好保证，假设它们还在同一地域的机房内，只不过在不同的机器、磁盘上。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122159.png" alt="image-20210630122159671"></p><h4 id="块（Chunk）的抽象"><a href="#块（Chunk）的抽象" class="headerlink" title="块（Chunk）的抽象"></a>块（Chunk）的抽象</h4><p>比分片更小的单位是块（Chunk），这个单词和磁盘的块（Block）区分开。Chunk 是一个比 Block 更大的单位。Google File System 把数据分成了一个个 Chunk，然后每个 Chunk 会对应具体的磁盘块（Block）。</p><p>如下图，Table 是最顶层的结构，它里面含有许多分片（Tablets）。从数据库层面来看，每个分片是一个文件。数据库引擎维护到这个层面即可，至于这个文件如何在分布式系统中工作，就交给底层的文件系统——比如 Google File System 或者 Hadoop Distributed File System。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122235.png" alt="image-20210630122235204"></p><p>分布式文件系统通常会在磁盘的 Block 上再抽象一层 Chunk。一个 Chunk 通常比 Block 大很多，比如 Google File System 是 64KB，而通常磁盘的 Block 大小是 4K；HDFS 则是 128MB。这样的设计是为了减少 I/O 操作的频率，分块太小 I/O 频率就会上升，分块大 I/O 频率就减小。 比如一个 Google 的爬虫积攒了足够多的数据再提交到 GFS 中，就比爬虫频繁提交节省网络资源。</p><h4 id="分布式文件的管理"><a href="#分布式文件的管理" class="headerlink" title="分布式文件的管理"></a>分布式文件的管理</h4><p>接下来，我们来讨论一个完整的分布式系统设计。和单机文件系统一样，一个文件必须知道自己的数据（Chunk）存放在哪里。下图展示了一种最简单的设计，文件中包含了许多 Chunk 的 ID，然后每个 ChunkID 可以从 Chunk 的元数据中找到 Chunk 对应的位置。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122328.png" alt="image-20210630122327998"></p><p>如果 Chunk 比较大，比如说 HDFS 中 Chunk 有 128MB，那么 1PB 的数据需要 8,388,608 个条目。如果每个条目用 64bit 描述，也就是 8 个字节，只需要 64M 就可以描述清楚。考虑到一个 Chunk 必然会有冗余存储，也就是多个位置，实际会比 64M 多几倍，但也不会非常大了。</p><p>因此像 HDFS 和 GFS 等，为了简化设计会把所有文件目录结构信息，加上 Chunk 的信息，保存在一个单点上，通常称为 Master 节点。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122411.png" alt="image-20210630122411827"></p><p>下图中，客户端想要读取<code>/foo/bar</code>中某个 Chunk 中某段内容（Byterange）的数据，会分成 4 个步骤：</p><ol><li>客户端向 Master 发送请求，将想访问的文B件名、Chunk 的序号（可以通过 Chunk 大小和内容位置计算）；</li><li>Master 响应请求，返回 Chunk 的地址和 Chunk 的句柄（ID）；</li><li>客户端向 Chunk 所在的地址（一台 ChunkServer）发送请求，并将句柄（ID）和内容范围（Byterange）作为参数；</li><li>ChunkServer 将数据返回给客户端。</li></ol><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122600.png" alt="image-20210630122600057"></p><p>在上面这个模型中，有 3 个实体。</p><ol><li>客户端（Client）或者应用（Application），它们是数据的实际使用方，比如说 BigTable 数据库是 GFS 的 Client。</li><li>Master 节点，它存储了所有的文件信息、Chunk 信息，权限信息等。</li><li>ChunkServer 节点，它存储了实际的 Chunk 数据。</li></ol><p>Master 只有一台，ChunkServer 可以有很多台。上图中的 namespace 其实就是文件全名（含路径）的集合。Chunk 的 namespace 存储的是含文件全名 + ChunkLocation + ChunkID 的组合。文件的命名空间、Chunk 的命名空间，再加上文件和 Chunk 的对应关系，因为需要频繁使用，可以把它们全部都放到 Master 节点的内存中，并且利用 B 树等在内存中创建索引结构。ChunkServer 会和 Master 保持频繁的联系，将自己的变更告知 Master。这样就构成了一个完整的过程。</p><h4 id="读和写"><a href="#读和写" class="headerlink" title="读和写"></a>读和写</h4><p>读取文件的过程需要两次往返（Round Trip），第一次是客户端和 Master 节点，第二次是客户端和某个 ChunkServer。</p><p>写入某个 Chunk 的时候，因为所有存储了这个 Chunk 的服务器都需要更新，所以需要将数据推送给所有的 ChunkServer。这里 GFS 设计中使用了一个非常巧妙的方案，先由客户端将数据推送给所有 ChunkServer 并缓存，而不马上更新。直到所有 ChunkServer 都收到数据后，再集中更新。这样的做法减少了数据不一致的时间。</p><p>下图是具体的更新步骤：</p><ol><li>客户端要和服务器签订租约，得到一个租期（Lease）。其实就是 Chunk 和 Chunk 所有复制品的修改权限。如果一个客户端拿到租期，在租期内，其他客户端能不能修改这个 Chunk。</li><li>Master 告诉客户端该 Chunk 所有的节点位置。包括 1 台主节点（Primary）和普通节点（Secondary）。当然主节点和普通节点，都是 ChunkServer。主 ChunkServer 的作用是协助更新所有从 ChunkServer 的数据。</li><li>这一步是设计得最巧妙的地方。客户端接下来将要写入的数据同时推送给所有关联的 ChunkServer。这些 ChunkServer 不会更新数据，而是把数据先缓存起来。</li><li>图中的所有 ChunkServer 都收到了数据，并且给客户端回复后，客户端向主 ChunkServer 请求写入。</li><li>主 ChunkServer 通知其他节点写入数据。因为数据已经推送过来了，所以这一步很快完成。</li><li>写入完数据的节点，所有节点给主 ChunkServer 回复。</li><li>主 ChunkServer 通知客户端成功。</li></ol><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122821.png" alt="image-20210630122821044"></p><p>以上，就是 GFS 的写入过程。这里有个规律，实现强一致性（所有时刻、所有客户端读取到的数据是一致的）就需要停下所有节点的工作牺牲可用性；或者牺牲分区容错性，减少节点。GFS 和 HDFS 的设计，牺牲的是一致性本身，允许数据在一定时间范围内是不一致的，从而提高吞吐量。</p><h4 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h4><p>在 HDFS 设计中，Master 节点也被称为 NameNode，用于存储命名空间数据。ChunkServer 也被称为 DataNode，用来存储文件数据。在 HDFS 的设计中，还有一个特殊的节点叫作辅助节点（Secondary Node）。辅助节点本身更像一个客户端，它不断和 NameNode 交流，并把 NameNode 最近的变更写成日志，存放到 DataNode 中。类似日志文件系统，每过一段时间，在 HDFS 中这些日志会形成一个还原点文件，这个机制和上一讲我们提到的日志文件系统类似。如果 Master 节点发生了故障，就可以通过这些还原点进行还原。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>在分布式文件系统和分布式数据库的设计中，还有很多有趣的知识，比如缓存的设计、空间的回收。如果你感兴趣，你可以进一步阅读我开篇给出的两篇论文。</p><ul><li>Google File System</li><li>BigTable：A Distributed Storage System for Structured Data</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>现在，我们已经可以把所有的场景都串联起来。Google 需要的是一个分布式数据库，存储的数据是包括内容、外链、Logo、标题等在内的网页的全部版本和描述信息。为了描述这些信息，一台机器磁盘不够大，吞吐量也不够大。因此 Google 需要将数据分布存储，将这个大表（BigTable）拆分成很多小片（Tablet）。当然，这并不是直接面向用户的架构。给几十亿用户提供高效查询，还需要分布式计算，计算出给用户使用的内容索引。</p><p>Google 团队发现将数据分布出去是一个通用需求。不仅仅是 BigTable 数据库需要，很多其他数据库也可以在这个基础上构造。按照软件设计的原则，每个工具应该尽可能的专注和简单， Google 的架构师意识到需要一个底层的文件系统，就是 Google File System。这样，BigTable 使用 Tablet 的时候，只需要当成文件在使用，具体的分布式读写，就交给了 GFS。</p><p>后来，Hadoop 根据 GFS 设计了 Hadoop 分布式文件系统，用于处理大数据，仍然延续了整个 GFS 的设计。</p><p>以上，是一个完整的，分布式数据库、分布式存储技术的一个入门级探讨。</p><p><strong>分布式文件系统是怎么回事</strong>？</p><p>分布式文件系统通过网络将不同的机器、磁盘、逻辑分区等存储资源利用起来，提供跨平台、跨机器的文件管理。通过这种方式，我们可以把很多相对廉价的服务器组合起来形成巨大的存储力量。</p><p><strong>socket 文件都存在哪里</strong>？</p><p>socket 没有实体文件，只有 inode，所以 socket 是没有名字的文件。</p><p>你可以在 /proc/net/tcp 目录下找到所有的 TCP 连接，在 /proc/[pid]/fd 下也可以找到这些 socket 文件，都是数字代号，数字就是 socket 文件的 fd，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630123321.png" alt="image-20210630123321474"></p><p>你也可以用<code>lsof -i -a -p [pid</code>查找某个进程的 socket 使用情况。下面结果和你用<code>ls /proc/[pid]/fd</code>看到的 fd 是一致的，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630123348.png" alt="image-20210630123348380"></p><p><strong>思考日志文件系统的数据冗余如何处理</strong>？</p><p>日志系统产生冗余几乎是必然发生的。 只要发生了修改、删除，肯定就会有数据冗余。日志系统通常不会主动压缩，但是日志文件系统通常会对磁盘碎片进行整理，这种机制和内存的管理非常相似。</p><p>首先我们把这个磁盘切割成很多等大的小块，大文件可能需要分配多个小块，多个小文件共用一个小块。而当很多文件被删除之后，磁盘中的小块会产生碎片，文件系统会进行碎片整理，比如把多个有很多碎片的区域拷贝到一起，使存储空间更加紧凑。</p><p>回到正题，最终的答案就是不压缩、不处理冗余，空间换时间，提升写入速度。</p><p><strong>按照应该尽量减少磁盘读写操作的原则，是不是哈希表的索引更有优势</strong>？</p><p>哈希表是一种稀疏的离散结构，通常使用键查找值。给定一个键，哈希表会通过数学计算的方式找到值的内存地址。因此，从这个角度去分析，哈希表的查询速度非常快。单独查找某一个数据速度超过了 B+ 树（比如根据姓名查找用户）。因此，包括 MySQL 在内的很多数据库，在支持 B+ 树索引的同时，也支持哈希表索引。</p><p><strong>这两种索引最大的区别是：B+ 树是对范围的划分，其中的数据还保持着连续性；而哈希表是一种离散的查询结构，数据已经分散到不同的空间中去了</strong>。所以当数据要进行<strong>范围查找</strong>时，比如查找某个区间内的订单，或者进行聚合运算，这个时候哈希表的性能就非常低了。</p><p>哈希表有一个设计约束，如果我们用了 m 个桶（Bucket，比如链表）去存储哈希表中的数据，再假设总共需要存储 N 个数据。那么平均查询次数 k = N/m。为了让 k 不会太大，当数据增长到一定规模时，哈希表需要增加桶的数目，这个时候就需要重新计算所有节点的哈希值（重新分配所有节点属于哪个桶）。</p><p>综上，对于大部分的操作 B+ 树都有较好的性能，比如说 &gt;,&lt;, =,BETWEEN，LIKE 等，哈希表只能用于等于的情况。</p><p><strong>Master 节点如果宕机了，影响有多大，如何恢复</strong>？</p><p>在早期的设计中，Master 是一个单点（Single Point），如果发生故障，系统就会停止运转，这就是所谓的单点故障（Single Point of Failure）。由此带来的后果会非常严重。发生故障后，虽然我们可以设置第二节点不断备份还原点，通过还原点加快系统恢复的速度，但是在数据的恢复期间，整个系统是不可用的。</p><p>在一个高可用的设计当中，我们不希望发生任何的单点故障（SPoF），因此所有的节点都至少有两份。于是在 Hadoop 后来的设计当中，增加了一种主从结构。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630123725.png" alt="image-20210630123725692"></p><p>如上图所示，我们同时维护两个 Master 节点（在 Hadoop 中称为 NameNode，NN）——一个活动（Active）的 NN 节点，一个待命（StandBy）的 NN 节点。</p><p>为了保证在系统出现故障的时候，可以迅速切换节点，我们需要一个故障控制单元。因为是分布式的设计，控制单元在每个 NN 中都必须有一个，这个单元可以考虑 NN 节点进程中的一个线程。控制单元不断地检测节点的状态，并且不断探测其他 NN 节点的状态。一旦检测到故障，控制单元随时准备切换节点。</p><p>一方面，因为我们不能信任任何的 NN 节点不出现故障，所以不能将节点的状态存在任何一个 NN 节点中。并且节点的状态也不适合存在数据节点中，因为大数据集群的数据节点实时性不够，它是用来存储大文件的。因此，可以考虑将节点的状态放入一个第三方的存储当中，通常就是 ZooKeeper。</p><p>另一方面，因为活动 NN 节点和待命 NN 节点数据需要完全一致，所以数据节点也会把自己的状态同时发送给活动节点和待命节点（比如命名空间变动等）。最后客户端会把请求发送给活动节点，因此活动节点会产生操作日志。不可以把活动节点的操作日志直接发送给待命节点，是因为我们不确定待命节点是否可用。</p><p>而且，为了保证日志数据不丢失，它们应该存储至少 3 份。即使其中一份数据发生损坏，也可以通过对比半数以上的节点（2 个）恢复数据。因此，这里需要设计专门的日志节点（Journal Node）存储日志。至少需要 3 个日志节点，而且必须是奇数。活动节点将自己的日志发送给日志节点，待命节点则从日志节点中读取日志，同步自己的状态。</p><p>我们再来回顾一下这个高可用的设计。<strong>为了保证可用性，我们增加了备用节点待命，随时替代活动节点</strong>。为了达成这个目标。有 3 类数据需要同步。</p><ul><li><strong>数据节点同步给主节点的日志</strong>。这类数据由数据节点同时同步给活动、待命节点。</li><li><strong>活动节点同步给待命节点的操作记录</strong>。这类数据由活动节点同步给日志节点，再由日志节点同步给待命节点。日志又至少有 3 态机器的集群保管，每个上放一个日志节点。</li><li><strong>记录节点本身状态的数据</strong>（比如节点有没有心跳）。这类数据存储在分布式应用协作引擎上，比如 ZooKeeper。</li></ul><p>有了这样的设计，当活动节点发生故障的时候，只需要迅速切换节点即可修复故障。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>这个模块我们对文件系统进行了系统的学习，下面我来总结一下文件系统的几块核心要点。</p><ul><li>理解虚拟文件系统的设计，理解在一个目录树结构当中，可以拥有不同的文件系统——一切皆文件的设计。基于这种结构，设备、磁盘、分布式文件系、网络请求都可以是文件。</li><li>将空间分块管理是一种高效的常规手段。方便分配、方便回收、方便整理——除了文件系统，内存管理和分布式文件系统也会用到这种手段。</li><li>日志文件系统的设计是重中之重，日志文件系统通过空间换时间，牺牲少量的读取性能，提升整体的写入效率。除了单机文件系统，这种设计在分布式文件系统和很多数据库当中也都存在。</li><li>分层架构：将数据库系统、分布式文件系搭建在单机文件管理之上——知识是死的、思路是活的。希望你能将这部分知识运用到日常开发中，提升自己系统的性能。</li></ul><h3 id="互联网协议群（TCP-IP）：多路复用是怎么回事？"><a href="#互联网协议群（TCP-IP）：多路复用是怎么回事？" class="headerlink" title="互联网协议群（TCP/IP）：多路复用是怎么回事？"></a><strong>互联网协议群（TCP/IP）：多路复用是怎么回事？</strong></h3><p>现在来看，“计算机网络”也许是一个过时的词汇，它讲的是怎么用计算实现通信。今天我们已经发展到了一个互联网、物联网的时代，社交网络、云的时代，再来看网络，意义已经发生转变。但这里面还是有很多经典的知识依旧在传承。比如说 TCP/IP 协议，问世后就逐渐成为占有统治地位的通信协议。虽然后面诞生出了许许多多的协议，但是我们仍然习惯性地把整个互联网的架构称为 TCP/IP 协议群，也叫作互联网协议群（Internet Protocol Suit）。</p><h4 id="协议的分层"><a href="#协议的分层" class="headerlink" title="协议的分层"></a>协议的分层</h4><p>对于多数的<strong>应用</strong>和<strong>用户</strong>而言，使用互联网的一个基本要求就是数据可以无损地到达。用户通过应用进行网络通信，应用启动之后就变成了进程。因此，<strong>所有网络通信的本质目标就是进程间通信</strong>。世界上有很多进程需要通信，我们要找到一种通用的，每个进程都能认可和接受的通信方式，这就是<strong>协议</strong>。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>从分层架构上看，应用工作在应用层（<strong>Application Layer</strong>）。应用的功能，都在应用层实现。所以应用层很好理解，说的就是应用本身。当两个应用需要通信的时候，应用（进程中的线程）就调用传输层进行通信。从架构上说，应用层只专注于为用户提供价值即可，没有必要思考数据如何传输。而且应用的开发商和传输库的提供方也不是一个团队。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630132054.png" alt="image-20210630132054214"></p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>为应用层提供网络支持的，就是传输层（<strong>Transport Layer</strong>）。</p><p>传输层控制协议（Transmission Control Protocol）是目前世界上应用最广泛的传输层协议。传输层为应用提供通信能力。比如浏览器想访问服务器，浏览器程序就会调用传输层程序；Web 服务接收浏览器的请求，Web 服务程序就会调用传输层程序接收数据。</p><p>考虑到应用需要传输的数据可能会非常大，直接传输不好控制。传输层需要将数据切块，即使一个分块传丢了、损坏了，可以重新发一个分块，而不用重新发送整体。在 TCP 协议中，我们把每个分块称为一个 TCP 段（TCP Segment）。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630132147.png" alt="image-20210630132147250"></p><p>传输层负责帮助应用传输数据给应用。考虑到一台主机上可能有很多个应用在传输数据，而一台服务器上可能有很多个应用在接收数据。因此，我们需要一个编号将应用区分开。这个编号就是<strong>端口号</strong>。比如 80 端口通常是 Web 服务器在使用；22 端口通常是远程登录服务在使用。而桌面浏览器，可能每个打开的标签栏都是一个独立的进程，每个标签栏都会使用临时分配的端口号。TCP 封包（TCP Segment）上携带了端口号，接收方可以识别出封包发送给哪个应用。</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p><strong>接下来你要思考的问题是：传输层到底负不负责将数据从一个设备传输到另一个设备</strong>（主机到主机，Host To Host）。仔细思考这个过程，你会发现如果这样设计，传输层就会违反简单、高效、专注的设计原则。</p><p>我们从一个主机到另一个主机传输数据的网络环境是非常复杂的。中间会通过各种各样的线路，有形形色色的交叉路口——有各式各样的路径和节点需要选择。<strong>核心的设计原则是，我们不希望一层协议处理太多的问题。传输层作为应用间数据传输的媒介，服务好应用即可</strong>。对应用层而言，传输层帮助实现应用到应用的通信。而实际的传输功能交给传输层的下一层，也就是<strong>网络层（Internet Layer）</strong> 会更好一些。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630132331.png" alt="image-20210630132331789"></p><p>IP 协议（Internet Protocol）是目前起到统治地位的网络层协议。IP 协议会将传输层的封包再次切分，得到 IP 封包。网络层负责实际将数据从一台主机传输到另一台主机（Host To Host），因此网络层需要区分主机的编号。</p><p>在互联网上，我们用 IP 地址给主机进行编号。例如 IPv4 协议，将地址总共分成了四段，每段是 8 位，加起来是 32 位。寻找地址的过程类似我们从国家、城市、省份一直找到区县。当然还有特例，比如有的城市是直辖市，有的省份是一个特别行政区。而且国与国体制还不同，像美国这样的国家，一个州其实可以相当于一个国家。</p><p>IP 协议里也有这个问题，类似行政区域划分，IP 协议中具体如何划分子网，需要配合<strong>子网掩码</strong>才能够明确。每一级网络都需要一个子网掩码，来定义网络子网的性质，相当于告诉物流公司到这一级网络该如何寻找目标地址，也就是寻址（Addressing）。关于更多子网掩码如何工作，及更多原理类的知识我会在拉勾教育的《<strong>计算机网络</strong>》专栏中和你分享。</p><p>除了<strong>寻址</strong>（<strong>Addressing</strong>），IP 协议还有一个非常重要的能力就是路由。在实际传输过程当中，数据并不是从主机直接就传输到了主机。而是会经过网关、基站、防火墙、路由器、交换机、代理服务器等众多的设备。而网络的路径，也称作链路，和现实生活中道路非常相似，会有岔路口、转盘、高速路、立交桥等。</p><p>因此，当封包到达一个节点，需要通过算法决定下一步走哪条路径。我们在现实生活中经常会碰到多条路径都可以到达同一个目的地的情况，在网络中也是如此。总结一下。<strong>寻址告诉我们去往下一个目的地该朝哪个方向走，路由则是根据下一个目的地选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p><h4 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h4><p>考虑到现实的情况，网络并不是一个完整的统一体。比如一个基站覆盖的周边就会形成一个网络。一个家庭的所有设备，一个公司的所有设备也会形成一个网络。所以在现实的情况中，数据在网络中设备间或者跨网络进行传输。而数据一旦需要跨网络传输，就需要有一个设备同时在两个网络当中。通过路由，我们知道了下一个要去的 IP 地址，可是当前的网络中哪个设备对应这个 IP 地址呢？</p><p>为了解决这个问题，我们需要有一个专门的层去识别网络中的设备，让数据在一个链路（网络中的路径）中传递，这就是<strong>数据链路层</strong>（<strong>Data Link Layer</strong>）<strong>。数据链路层为网络层提供链路级别传输的支持</strong>。</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>当数据在实际的设备间传递时，可能会用电线、电缆、光纤、卫星、无线等各种通信手段。因此，还需要一层将光电信号、设备差异封装起来，为数据链路层提供二进制传输的服务。这就是<strong>物理层（Physical Layer）。</strong></p><p>因此，从下图中你可以看到，由上到下，互联网协议可以分成五层，分别是应用层、传输层、网络层、数据链路层和物理层。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630133938.png" alt="image-20210630133938525"></p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>在上述的分层模型当中，一台机器上的应用可以有很多。但是实际的出口设备，比如说网卡、网线通常只有一份。因此这里需要用到一个叫作多路复用（Multiplex）的技术。多路复用，就是多个信号，复用一个信道。</p><h4 id="传输层多路复用"><a href="#传输层多路复用" class="headerlink" title="传输层多路复用"></a>传输层多路复用</h4><p>对应用而言，应用层抽象应用之间通信的模型——比如说请求返回模型。一个应用可能会同时向服务器发送多个请求。因为建立一个连接也是需要开销的，所以可以多个请求复用一个 TCP 连接。复用连接一方面可以节省流量，另一方面能够降低延迟。如果应用<strong>串行地</strong>向服务端发送请求，那么假设第一个请求体积较大，或者第一个请求发生了故障，就会阻塞后面的请求。</p><p>而使用多路复用技术，如下图所示，多个请求相当于并行的发送请求。即使其中某个请求发生故障，也不会阻塞其他请求。从这个角度看，多路复用实际上是一种 Non-Blocking（非阻塞）的技术。我们再来看下面这张图，不同的请求被传输层切片，我用不同的颜色区分出来，如果其中一个数据段（TCP Segment）发生异常，只影响其中一个颜色的请求，其他请求仍然可以到达服务。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630134225.png" alt="image-20210630134225434"></p><h4 id="网络层多路复用"><a href="#网络层多路复用" class="headerlink" title="网络层多路复用"></a>网络层多路复用</h4><p>传输层是一个虚拟的概念，但是网络层是实实在在的。两个应用之间的传输，可以建立无穷多个传输层连接，前提是你的资源足够。但是两个应用之间的线路、设备，需要跨越的网络往往是固定的。在我们的互联网上，每时每刻都有大量的应用在互发消息。而这些应用要复用同样的基础建设——网线、路由器、网关、基站等。</p><p>网络层没有连接这个概念。你可以把网络层理解成是一个巨大的物流公司。不断从传输层接收数据，然后进行打包，每一个包是一个 IP 封包。然后这个物流公司，负责 IP 封包的收发。所以，是很多很多的传输层在共用底下同一个网络层，这就是网络层的多路复用。</p><p>总结一下。<strong>应用层的多路复用，如多个请求使用同一个信道并行的传输，实际上是传输层提供的多路复用能力</strong>。<strong>传输层的多路复用，比如多个 TCP 连接复用一条线路，实际上是网络层在提供多路复用能力</strong>。你可以把网络层想象成一个不断收发包裹的机器，在网络层中并没有连接这个概念，所以网络层天然就是支持多路复用的。</p><h4 id="多路复用的意义"><a href="#多路复用的意义" class="headerlink" title="多路复用的意义"></a>多路复用的意义</h4><p>在工作当中，我们经常会使用到多路复用的能力。多路复用让多个信号（例如：请求/返回等）共用一个信道（例如：一个 TCP 连接），那么在这个信道上，信息密度就会增加。在密度增加的同时，通过并行发送信号的方式，可以减少阻塞。比如说应用层的 HTTP 协议，浏览器打开的时候就会往服务器发送很多个请求，多个请求混合在一起，复用相同连接，数据紧密且互相隔离（不互相阻塞）。同理，服务之间的远程调用、消息队列，这些也经常需要多路复用。</p><p><strong>多路复用是怎么回事</strong>？</p><p>【<strong>解析</strong>】多路复用让多个信号（例如：请求/返回等）共用一个信道（例如：一个 TCP 连接）。它有两个明显的优势。</p><ol><li>提升吞吐量。多一个信号被紧密编排在一起（例如：TCP 多路复用节省了多次连接的数据），这样网络不容易空载。</li><li>多个信号间隔离。信号间并行传输，并且隔离，不会互相影响。</li></ol><h3 id="UDP-协议：UDP-和-TCP-相比快在哪里？"><a href="#UDP-协议：UDP-和-TCP-相比快在哪里？" class="headerlink" title="UDP 协议：UDP 和 TCP 相比快在哪里？"></a><strong>UDP 协议：UDP 和 TCP 相比快在哪里？</strong></h3><p>TCP 和 UDP 是目前使用最广泛的两个传输层协议，同时也是面试考察的重点内容。今天我会初步带你认识这两个协议，一起探寻它们之间最大的区别。</p><p>在开始本讲的重点内容前，我们先来说说 RFC 文档（Request For Comments，请求评论），互联网的很多基础建设都是以 RFC 的形式文档化，它给用户提供了阅读和学习的权限。在给大家准备《<strong>计算机网络</strong>》专栏的时候，我也经常查阅 RFC 文档。</p><p>如果你查阅 TCP 和 UDP 的 RFC 文档，会发现一件非常有趣的事情。TCP 协议的 RFC 很长，我足足读了好几天才把它们全部弄明白。UDP 的 RFC 非常短，只有短短的两页，一个小时就能读明白。这让我不禁感叹，如果能穿越到当时那个年代，我就去发明 UDP 协议，因为实在是太简单了。但即使是这个简单协议，也同样主宰着计算机网络协议的半壁江山。</p><p>那么这一讲我们就以 TCP 和 UDP 的区别为引，带你了解这两个在工作中使用频率极高、极为重要的传输层协议。</p><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>首先我们比较一下这两个协议在<strong>可靠性（Reliablility）\</strong>上的区别。如果一个网络协议是可靠的，那么它能够保证数据被**无损**地传送到目的地。当应用的设计者选择一个具有可靠性的协议时，通常意味着这个应用不能容忍数据在传输过程中被损坏。</p><p>如果你是初学者，可能会认为所有的应用都需要可靠性。其实不然，比如说一个视频直播服务。如果在传输过程当中，视频图像发生了一定的损坏，用户看到的只是某几个像素、颜色不准确了，或者某几帧视频丢失了——这对用户来说是可以容忍的。但在观看视频的时候，用户最怕的不是实时数据发生一定的损坏，而是吞吐量得不到保证。比如视频看到一半卡住了，要等很久，或者丢失了一大段视频数据，导致错过精彩的内容。</p><p><strong>TCP 协议，是一个支持可靠性的协议。UDP 协议，是一个不支持可靠性的协议</strong>。接下来我们讨论几个常见实现可靠性的手段。</p><h4 id="校验和（Checksum）"><a href="#校验和（Checksum）" class="headerlink" title="校验和（Checksum）"></a>校验和（Checksum）</h4><p>首先我们来说说<strong>校验和</strong>。<strong>这是一种非常常见的可靠性检查手段</strong>。</p><p>尽管 UDP 不支持可靠性，但是像校验和（Checksum）这一类最基本的数据校验，它还是支持的。<strong>不支持可靠性，并不意味着完全放弃可靠性。TCP 和 UDP 都支持最基本的校验和算法</strong>。</p><p>下面我为你举例<strong>一种最简单的校验和算法：纵向冗余检查</strong>。伪代码如下：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte c = 0;</span><br><span class="line">for(byte x in bytes) &#123;</span><br><span class="line">  c = c xor x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>xor</code>是异或运算。上面的程序在计算字节数组 bytes 的校验和。<code>c</code>是最终的结果。你可以看到将所有<code>bytes</code>两两异或，最终的结果就是校验和。假设我们要传输 bytes，如果在传输过程中<code>bytes</code>发生了变化，校验和有<strong>很大概率</strong>也会跟着变化。当然也可能存在<code>bytes</code>发生变化，校验和没有变化的特例，不过校验和可以很大程度上帮助我们识别数据是否损坏了。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630143310.png" alt="image-20210630143310841"></p><p>当要传输数据的时候，数据会被分片，我们把每个分片看作一个字节数组。然后在分片中，预留几个字节去存储校验和。校验和随着数据分片一起传输到目的地，目的地会用同样的算法再次计算校验和。如果二者校验和不一致，代表中途数据发生了损坏。</p><p><strong>对于 TCP 和 UDP，都实现了校验和算法，但二者的区别是，TCP 如果发现校验核对不上，也就是数据损坏，会主动丢失这个封包并且重发。而 UDP 什么都不会处理，UDP 把处理的权利交给使用它的程序员</strong>。</p><h4 id="请求-应答-连接模型"><a href="#请求-应答-连接模型" class="headerlink" title="请求/应答/连接模型"></a>请求/应答/连接模型</h4><p>另一种保证可靠性的方法是<strong>请求响应和连接的模型</strong>。TCP 实现了请求、响应和连接的模型，UDP 没有实现这个模型。</p><p>在通信当中，我们可以把通信双方抽象成两个人用电话通信一样，需要先建立联系（保持连接）。发起会话的人是发送请求，对方需要应答（或者称为响应）。会话双方保持一个连接，直到双方说再见。</p><p>在 TCP 协议当中，任何一方向另一方发送信息，另一方都需要给予一个应答。如果发送方在一定的时间内没有获得应答，发送方就会认为自己的信息没有到达目的地，中途发生了损坏或者丢失等，因此发送方会选择重发这条消息。</p><p>这样一个模式也造成了 TCP 协议的三次握手和四次挥手，下面我们一起来具体分析一下。</p><p><strong>1. TCP 的三次握手</strong></p><p>在 TCP 协议当中。我们假设 Alice 和 Bob 是两个通信进程。当 Alice 想要和 Bob 建立连接的时候，Alice 需要发送一个请求建立连接的消息给 Bob。这种请求建立连接的消息在 TCP 协议中称为<strong>同步</strong>（<strong>Synchronization， SYN</strong>）。而 Bob 收到 SYN，必须马上给 Alice 一个响应。这个响应在 TCP 协议当中称为<strong>响应</strong>（<strong>Acknowledgement，ACK</strong>）。请你务必记住这两个单词。不仅是 TCP 在用，其他协议也会复用这样的概念，来描述相同的事情。</p><p>当 Alice 给 Bob SYN，Bob 给 Alice ACK，这个时候，对 Alice 而言，连接就建立成功了。但是 TCP 是一个双工协议。所谓双工协议，代表数据可以双向传送。虽然对 Alice 而言，连接建立成功了。但是对 Bob 而言，连接还没有建立。为什么这么说呢？你可以这样思考，如果这个时候，Bob 马上给 Alice 发送信息，信息可能先于 Bob 的 ACK 到达 Alice，但这个时候 Alice 还不知道连接建立成功。 所以解决的办法就是 Bob 再给 Alice 发一次 SYN ，Alice 再给 Bob 一个 ACK。以上就是 TCP 的三次握手内容。</p><p>你可能会问，这明明是<strong>四次握手，哪里是三次握手</strong>呢？这是因为，Bob 给 Alice 的 ACK ，可以和 Bob 向 Alice 发起的 SYN 合并，称为一条 SYN-ACK 消息。TCP 协议以此来减少握手的次数，减少数据的传输，于是 TCP 就变成了三次握手。下图中绿色标签状是 Alice 和 Bob 的状态，完整的 TCP 三次握手的过程如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630143358.png" alt="image-20210630143358324"></p><p><strong>2. TCP 的四次挥手</strong></p><p>四次挥手（TCP 断开连接）的原理类似。中断连接的请求我们称为 Finish（用 FIN 表示）；和三次握手过程一样，需要分析成 4 步：</p><ul><li>第 1 步是 Alice 发送 FIN</li><li>第 2 步是 Bob 给 ACK</li><li>第 3 步是 Bob 发送 FIN</li><li>第 4 步是 Alice 给 ACK</li></ul><p>之所以是四次挥手，是因为第 2 步和 第 3 步在挥手的过程中不能合并为 FIN-ACK。原因是在挥手的过程中，Alice 和 Bob 都可能有未完成的工作。比如对 Bob 而言，可能还存在之前发给 Alice 但是还没有收到 ACK 的请求。因此，Bob 收到 Alice 的 FIN 后，就马上给 ACK。但是 Bob 会在自己准备妥当后，再发送 FIN 给 Alice。完整的过程如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630143425.png" alt="image-20210630143425650"></p><p><strong>3. 连接</strong></p><p>连接是一个虚拟概念，连接的目的是让连接的双方达成默契，倾尽资源，给对方最快的响应。经历了三次握手，Alice 和 Bob 之间就建立了连接。<strong>连接也是一个很好的编程模型。当连接不稳定的时候，可以中断连接后再重新连接。这种模式极大地增加了两个应用之间的数据传输的可靠性</strong>。</p><p>以上就是 TCP 中存在的，而 UDP 中没有的机制，你可以仔细琢磨琢磨。</p><h4 id="封包排序"><a href="#封包排序" class="headerlink" title="封包排序"></a>封包排序</h4><p><strong>可靠性有一个最基本的要求是数据有序发出、无序传输，并且有序组合。TCP 协议保证了这种可靠性，UDP 则没有保证</strong>。</p><p>在传输之前，数据被拆分成分块。在 TCP 中叫作一个<strong>TCP Segment</strong>。在 UDP 中叫作一个<strong>UDP Datagram</strong>。Datagram 单词的含义是数据传输的最小单位。在到达目的地之后，尽管所有的数据分块可能是乱序到达的，但为了保证可靠性，乱序到达的数据又需要被重新排序，恢复到原有数据的顺序。</p><p><strong>在这个过程当中，TCP 利用了滑动窗口、快速重传等算法，保证了数据的顺序。而 UDP，仅仅是为每个 Datagram 标注了序号，并没有帮助应用程序进行数据的排序</strong>，<strong>这也是 TCP 和 UDP 在保证可靠性上一个非常重要的区别。</strong></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>上面的内容中，我们比较了 TCP 和 UDP 在可靠性上的区别，接下来我们看看两个协议的使用场景。</p><p><strong>我们先来看一道面试题：如果客户端和服务器之间的单程平均延迟是 30 毫秒，那么客户端 Ping 服务端需要多少毫秒</strong>？</p><p>【<strong>分析</strong>】这个问题最核心的点是需要思考 Ping 服务应该由 TCP 实现还是 UDP 实现？请你思考：Ping 需不需要保持连接呢？答案是不需要，Ping 服务器的时候把数据发送过去即可，并不需要特地建立一个连接。</p><p>请你再思考，Ping 需不需要保证可靠性呢？答案依然是不需要，如果发生了丢包， Ping 将丢包计入丢包率即可。所以从这个角度来看，Ping 使用 UDP 即可。</p><p>所以这道面试题应该是 Round Trip 最快需要在 60 毫秒左右。一个来回的时间，我们也通常称为 Round Trip 时间。</p><p>通过分析上面的例子，我想告诉你，TCP 和 UDP 的使用场景是不同的。<strong>TCP 适用于需要可靠性，需要连接的场景</strong>。UDP 因为足够简单，只对数据进行简单加工处理，就调用底层的网络层（IP 协议）传输数据去了。<strong>因此 UDP 更适合对可靠性要求不高的场景</strong>。</p><p>另外很多需要定制化的场景，非常需要 UDP。以 HTTP 协议为例，在早期的 HTTP 协议的设计当中就选择了 TCP 协议。因为在 HTTP 的设计当中，请求和返回都是需要可靠性的。但是随着 HTTP 协议的发展，到了 HTTP 3.0 的时候，就开始基于 UDP 进行传输。这是因为，在 HTTP 3.0 协议当中，在 UDP 之上有另一个QUIC 协议在负责可靠性。UDP 足够简单，在其上构建自己的协议就很方便。</p><p><strong>你可以再思考一个问题：文件上传应该用 TCP 还是 UDP 呢</strong>？乍一看肯定是 TCP 协议，因为文件上传当然需要可靠性，防止数据损坏。但是如果你愿意在 UDP 上去实现一套专门上传文件的可靠性协议，性能是可以超越 TCP 协议的。因为你只需要解决文件上传一种需求，不用像 TCP 协议那样解决通用需求。</p><p>所以时至今日，到底什么情况应该用 TCP，什么情况用 UDP？这个问题边界的确在模糊化。<strong>总体来说，需要可靠性，且不希望花太多心思在网络协议的研发上，就使用 TCP 协议</strong>。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>最后我们再来总结一下，大而全的协议用起来舒服，比如 TCP；灵活的协议方便定制和扩展，比如 UDP。二者不分伯仲，各有千秋。</p><p>这一讲我们深入比较了 TCP 和 UDP 的可靠性及它们的使用场景。关于原理部分，比如具体 TCP 的滑动窗口算法、数据的切割算法、数据重传算法；TCP、UDP 的封包内部究竟有哪些字段，格式如何等。如果你感兴趣，可以来学习我将在拉勾教育推出的《<strong>计算机网络</strong>》专栏。</p><p><strong>你现在可以尝试来回答本讲关联的面试题目：UDP 比 TCP 快在哪里</strong>？</p><p>【<strong>解析</strong>】使用 UDP 传输数据，不用建立连接，数据直接丢过去即可。至于接收方，有没有在监听？会不会接收？那就是接收方的事情了。UDP 甚至不考虑数据的可靠性。至于发送双方会不会基于 UDP 再去定制研发可靠性协议，那就是开发者的事情了。所以 UDP 快在哪里？UDP 快在它足够简单。因为足够简单，所以 UDP 对计算性能、对网络占用都是比 TCP 少的。</p><h3 id="select-poll-epoll-有什么区别？"><a href="#select-poll-epoll-有什么区别？" class="headerlink" title="select/poll/epoll 有什么区别？"></a><strong>select/poll/epoll 有什么区别？</strong></h3><p>我们总是想方设法地提升系统的性能。操作系统层面不能给予处理业务逻辑太多帮助，但对于 I/O 性能，操作系统可以通过底层的优化，帮助应用做到极致。</p><p>这一讲我将和你一起讨论 I/O 模型。为了引发你更多的思考，我将同步/异步、阻塞/非阻塞等概念滞后讲解。<strong>我们先回到一个最基本的问题：如果有一台服务器，需要响应大量的请求，操作系统如何去架构以适应这样高并发的诉求</strong>。</p><p>说到架构，就离不开操作系统提供给应用程序的系统调用。我们今天要介绍的 select/poll/epoll 刚好是操作系统提供给应用的三类处理 I/O 的系统调用。这三类系统调用有非常强的代表性，这一讲我会围绕它们，以及处理并发和 I/O 多路复用，为你讲解操作系统的 I/O 模型。</p><h4 id="从网卡到操作系统"><a href="#从网卡到操作系统" class="headerlink" title="从网卡到操作系统"></a>从网卡到操作系统</h4><p>为了弄清楚高并发网络场景是如何处理的，我们先来看一个最基本的内容：<strong>当数据到达网卡之后，操作系统会做哪些事情</strong>？</p><p>网络数据到达网卡之后，首先需要把数据拷贝到内存。拷贝到内存的工作往往不需要消耗 CPU 资源，而是通过 DMA 模块直接进行内存映射。之所以这样做，是因为网卡没有大量的内存空间，只能做简单的缓冲，所以必须赶紧将它们保存下来。</p><p>Linux 中用一个双向链表作为缓冲区，你可以观察下图中的 Buffer，看上去像一个有很多个凹槽的线性结构，每个凹槽（节点）可以存储一个封包，这个封包可以从网络层看（IP 封包），也可以从传输层看（TCP 封包）。操作系统不断地从 Buffer 中取出数据，数据通过一个协议栈，你可以把它理解成很多个协议的集合。协议栈中数据封包找到对应的协议程序处理完之后，就会形成 Socket 文件。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630151654.png" alt="image-20210630151653941"></p><p>如果高并发的请求量级实在太大，有可能把 Buffer 占满，此时，操作系统就会拒绝服务。网络上有一种著名的攻击叫作<strong>拒绝服务攻击</strong>，就是利用的这个原理。<strong>操作系统拒绝服务，实际上是一种保护策略。通过拒绝服务，避免系统内部应用因为并发量太大而雪崩</strong>。</p><p>如上图所示，传入网卡的数据被我称为 Frames。一个 Frame 是数据链路层的传输单位（或封包）。现代的网卡通常使用 DMA 技术，将 Frame 写入缓冲区（Buffer），然后在触发 CPU 中断交给操作系统处理。操作系统从缓冲区中不断取出 Frame，通过协进栈（具体的协议）进行还原。</p><p>在 UNIX 系的操作系统中，一个 Socket 文件内部类似一个双向的管道。因此，非常适用于进程间通信。在网络当中，本质上并没有发生变化。网络中的 Socket 一端连接 Buffer， 一端连接应用——也就是进程。网卡的数据会进入 Buffer，Buffer 经过协议栈的处理形成 Socket 结构。通过这样的设计，进程读取 Socket 文件，可以从 Buffer 中对应节点读走数据。</p><p>对于 TCP 协议，Socket 文件可以用源端口、目标端口、源 IP、目标 IP 进行区别。不同的 Socket 文件，对应着 Buffer 中的不同节点。进程们读取数据的时候从 Buffer 中读取，写入数据的时候向 Buffer 中写入。通过这样一种结构，无论是读和写，进程都可以快速定位到自己对应的节点。</p><p>以上就是我们对操作系统和网络接口交互的一个基本讨论。接下来，我们讨论一下作为一个编程模型的 Socket。</p><h4 id="Socket-编程模型"><a href="#Socket-编程模型" class="headerlink" title="Socket 编程模型"></a>Socket 编程模型</h4><p>通过前面讲述，我们知道 Socket 在操作系统中，有一个非常具体的从 Buffer 到文件的实现。但是对于进程而言，Socket 更多是一种编程的模型。接下来我们讨论作为编程模型的 Socket。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630152655.png" alt="image-20210630152655321"></p><p>如上图所示，Socket 连接了应用和协议，如果应用层的程序想要传输数据，就创建一个 Socket。应用向 Socket 中写入数据，相当于将数据发送给了另一个应用。应用从 Socket 中读取数据，相当于接收另一个应用发送的数据。而具体的操作就是由 Socket 进行封装。具体来说，<strong>对于 UNIX 系的操作系统，是利用 Socket 文件系统，Socket 是一种特殊的文件——每个都是一个双向的管道。一端是应用，一端是缓冲</strong>区。</p><p>那么作为一个服务端的应用，如何知道有哪些 Socket 呢？也就是，哪些客户端连接过来了呢？这是就需要一种特殊类型的 Socket，也就是服务端 Socket 文件。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164233.png" alt="image-20210630164233524"></p><p>如上图所示，当有客户端连接服务端时，服务端 Socket 文件中会写入这个客户端 Socket 的文件描述符。进程可以通过 accept() 方法，从服务端 Socket 文件中读出客户端的 Socket 文件描述符，从而拿到客户端的 Socket 文件。</p><p>程序员实现一个网络服务器的时候，会先手动去创建一个服务端 Socket 文件。服务端的 Socket 文件依然会存在操作系统内核之中，并且会绑定到某个 IP 地址和端口上。以后凡是发送到这台机器、目标 IP 地址和端口号的连接请求，在形成了客户端 Socket 文件之后，文件的文件描述符都会被写入到服务端的 Socket 文件中。应用只要调用 accept 方法，就可以拿到这些客户端的 Socket 文件描述符，这样服务端的应用就可以方便地知道有哪些客户端连接了进来。</p><p>而每个客户端对这个应用而言，都是一个文件描述符。如果需要读取某个客户端的数据，就读取这个客户端对应的 Socket 文件。如果要向某个特定的客户端发送数据，就写入这个客户端的 Socket 文件。</p><p>以上就是 Socket 的编程模型。</p><h4 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h4><p>在上面的讨论当中，进程拿到了它关注的所有 Socket，也称作关注的集合（Intersting Set）。如下图所示，这种过程相当于进程从所有的 Socket 中，筛选出了自己关注的一个子集，但是这时还有一个问题没有解决：<strong>进程如何监听关注集合的状态变化，比如说在有数据进来，如何通知到这个进程</strong>？</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164829.png" alt="image-20210630164829024"></p><p>其实更准确地说，一个线程需要处理所有关注的 Socket 产生的变化，或者说消息。实际上一个线程要处理很多个文件的 I/O。<strong>所有关注的 Socket 状态发生了变化，都由一个线程去处理，构成了 I/O 的多路复用问题</strong>。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164854.png" alt="image-20210630164854049"></p><p>处理 I/O 多路复用的问题，需要操作系统提供内核级别的支持。Linux 下有三种提供 I/O 多路复用的 API，分别是：</p><ul><li>select</li><li>poll</li><li>epoll</li></ul><p>如下图所示，内核了解网络的状态。因此不难知道具体发生了什么消息，比如内核知道某个 Socket 文件状态发生了变化。但是内核如何知道该把哪个消息给哪个进程呢？</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164918.png" alt="image-20210630164918730"></p><p><strong>一个 Socket 文件，可以由多个进程使用；而一个进程，也可以使用多个 Socket 文件</strong>。进程和 Socket 之间是多对多的关系。<strong>另一方面，一个 Socket 也会有不同的事件类型</strong>。因此操作系统很难判断，将哪样的事件给哪个进程。</p><p>这样<strong>在进程内部就需要一个数据结构来描述自己会关注哪些 Socket 文件的哪些事件（读、写、异常等</strong>）。通常有两种考虑方向，<strong>一种是利用线性结构</strong>，比如说数组、链表等，这类结构的查询需要遍历。每次内核产生一种消息，就遍历这个线性结构。看看这个消息是不是进程关注的？<strong>另一种是索引结构</strong>，内核发生了消息可以通过索引结构马上知道这个消息进程关不关注。</p><h4 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h4><p>select 和 poll 都采用线性结构，select 允许用户传入 3 个集合。如下面这段程序所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fd_set read_fd_set, write_fd_set, error_fd_set;</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line"></span><br><span class="line">  select(..., &amp;read_fd_set, &amp;write_fd_set, &amp;error_fd_set); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>每次 select 操作会阻塞当前线程，在阻塞期间所有操作系统产生的每个消息，都会通过遍历的手段查看是否在 3 个集合当中</strong>。上面程序<code>read_fd_set</code>中放入的是当数据可以读取时进程关心的 Socket；<code>write_fd_set</code>是当数据可以写入时进程关心的 Socket；<code>error_fd_set</code>是当发生异常时进程关心的 Socket。</p><p><strong>用户程序可以根据不同集合中是否有某个 Socket 判断发生的消息类型，</strong>程序如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fd_set read_fd_set, write_fd_set, error_fd_set;</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line"></span><br><span class="line">  select(..., &amp;read_fd_set, &amp;write_fd_set, &amp;error_fd_set); </span><br><span class="line"></span><br><span class="line">  for (i = 0; i &lt; FD_SETSIZE; ++i)</span><br><span class="line"></span><br><span class="line">        if (FD_ISSET (i, &amp;read_fd_set))&#123;</span><br><span class="line"></span><br><span class="line">          // Socket可以读取</span><br><span class="line"></span><br><span class="line">        &#125; else if(FD_ISSET(i, &amp;write_fd_set)) &#123;</span><br><span class="line"></span><br><span class="line">          // Socket可以写入</span><br><span class="line"></span><br><span class="line">        &#125; else if(FD_ISSET(i, &amp;error_fd_set)) &#123;</span><br><span class="line"></span><br><span class="line">          // Socket发生错误</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序中的 FD_SETSIZE 是一个系统的默认设置，通常是 1024。可以看出，select 模式能够一次处理的文件描述符是有上限的，也就是 FD_SETSIZE。当并发请求过多的时候， select 就无能为力了。但是对单台机器而言，1024 个并发已经是一个非常大的流量了。</p><p>接下来我给出一个完整的、用 select 实现的服务端程序供你参考，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/Socket.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line"></span><br><span class="line">#define PORT    5555</span><br><span class="line"></span><br><span class="line">#define MAXMSG  512</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line"></span><br><span class="line">read_from_client (int filedes)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  char buffer[MAXMSG];</span><br><span class="line"></span><br><span class="line">  int nbytes;</span><br><span class="line"></span><br><span class="line">  nbytes = read (filedes, buffer, MAXMSG);</span><br><span class="line"></span><br><span class="line">  if (nbytes &lt; 0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      /* Read error. */</span><br><span class="line"></span><br><span class="line">      perror (&quot;read&quot;);</span><br><span class="line"></span><br><span class="line">      exit (EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  else if (nbytes == 0)</span><br><span class="line"></span><br><span class="line">    /* End-of-file. */</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      /* Data read. */</span><br><span class="line"></span><br><span class="line">      fprintf (stderr, &quot;Server: got message: `%s&apos;\n&quot;, buffer);</span><br><span class="line"></span><br><span class="line">      return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line"></span><br><span class="line">main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  extern int make_Socket (uint16_t port);</span><br><span class="line"></span><br><span class="line">  int sock;</span><br><span class="line"></span><br><span class="line">  fd_set active_fd_set, read_fd_set;</span><br><span class="line"></span><br><span class="line">  int i;</span><br><span class="line"></span><br><span class="line">  struct sockaddr_in clientname;</span><br><span class="line"></span><br><span class="line">  size_t size;</span><br><span class="line"></span><br><span class="line">  /* Create the Socket and set it up to accept connections. */</span><br><span class="line"></span><br><span class="line">  sock = make_Socket (PORT);</span><br><span class="line"></span><br><span class="line">  if (listen (sock, 1) &lt; 0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      perror (&quot;listen&quot;);</span><br><span class="line"></span><br><span class="line">      exit (EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* Initialize the set of active Sockets. */</span><br><span class="line"></span><br><span class="line">  FD_ZERO (&amp;active_fd_set);</span><br><span class="line"></span><br><span class="line">  FD_SET (sock, &amp;active_fd_set);</span><br><span class="line"></span><br><span class="line">  while (1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      /* Block until input arrives on one or more active Sockets. */</span><br><span class="line"></span><br><span class="line">      read_fd_set = active_fd_set;</span><br><span class="line"></span><br><span class="line">      if (select (FD_SETSIZE, &amp;read_fd_set, NULL, NULL, NULL) &lt; 0)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          perror (&quot;select&quot;);</span><br><span class="line"></span><br><span class="line">          exit (EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /* Service all the Sockets with input pending. */</span><br><span class="line"></span><br><span class="line">      for (i = 0; i &lt; FD_SETSIZE; ++i)</span><br><span class="line"></span><br><span class="line">        if (FD_ISSET (i, &amp;read_fd_set))</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">            if (i == sock)</span><br><span class="line"></span><br><span class="line">              &#123;</span><br><span class="line"></span><br><span class="line">                /* Connection request on original Socket. */</span><br><span class="line"></span><br><span class="line">                int new;</span><br><span class="line"></span><br><span class="line">                size = sizeof (clientname);</span><br><span class="line"></span><br><span class="line">                new = accept (sock,</span><br><span class="line"></span><br><span class="line">                              (struct sockaddr *) &amp;clientname,</span><br><span class="line"></span><br><span class="line">                              &amp;size);</span><br><span class="line"></span><br><span class="line">                if (new &lt; 0)</span><br><span class="line"></span><br><span class="line">                  &#123;</span><br><span class="line"></span><br><span class="line">                    perror (&quot;accept&quot;);</span><br><span class="line"></span><br><span class="line">                    exit (EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                fprintf (stderr,</span><br><span class="line"></span><br><span class="line">                         &quot;Server: connect from host %s, port %hd.\n&quot;,</span><br><span class="line"></span><br><span class="line">                         inet_ntoa (clientname.sin_addr),</span><br><span class="line"></span><br><span class="line">                         ntohs (clientname.sin_port));</span><br><span class="line"></span><br><span class="line">                FD_SET (new, &amp;active_fd_set);</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            else</span><br><span class="line"></span><br><span class="line">              &#123;</span><br><span class="line"></span><br><span class="line">                /* Data arriving on an already-connected Socket. */</span><br><span class="line"></span><br><span class="line">                if (read_from_client (i) &lt; 0)</span><br><span class="line"></span><br><span class="line">                  &#123;</span><br><span class="line"></span><br><span class="line">                    close (i);</span><br><span class="line"></span><br><span class="line">                    FD_CLR (i, &amp;active_fd_set);</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><p>从写程序的角度来看，select 并不是一个很好的编程模型。一个好的编程模型应该直达本质，当网络请求发生状态变化的时候，核心是会发生事件。<strong>一个好的编程模型应该是直接抽象成消息：用户不需要用 select 来设置自己的集合，而是可以通过系统的 API 直接拿到对应的消息，从而处理对应的文件描述符</strong>。</p><p>比如下面这段伪代码就是一个更好的编程模型，具体的分析如下：</p><ul><li>poll 是一个阻塞调用，它将某段时间内操作系统内发生的且进程关注的消息告知用户程序；</li><li>用户程序通过直接调用 poll 函数拿到消息；</li><li>poll 函数的第一个参数告知内核 poll 关注哪些 Socket 及消息类型；</li><li>poll 调用后，经过一段时间的等待（阻塞），就拿到了是一个消息的数组；</li><li>通过遍历这个数组中的消息，能够知道关联的文件描述符和消息的类型；</li><li>通过消息类型判断接下来该进行读取还是写入操作；</li><li>通过文件描述符，可以进行实际地读、写、错误处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">while(true) &#123;</span><br><span class="line"></span><br><span class="line">  events = poll(fds, ...)</span><br><span class="line"></span><br><span class="line">  for(evt in events) &#123;</span><br><span class="line"></span><br><span class="line">    fd = evt.fd;</span><br><span class="line"></span><br><span class="line">    type = evt.revents;</span><br><span class="line"></span><br><span class="line">    if(type &amp; POLLIN ) &#123;</span><br><span class="line"></span><br><span class="line">       // 有数据需要读，读取fd中的数据</span><br><span class="line"></span><br><span class="line">    &#125; else if(type &amp; POLLOUT) &#123;</span><br><span class="line"></span><br><span class="line">       // 可以写入数据</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    else ...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poll 虽然优化了编程模型，但是从性能角度分析，它和 select 差距不大。因为内核在产生一个消息之后，依然需要遍历 poll 关注的所有文件描述符来确定这条消息是否跟用户程序相关。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>为了解决上述问题，<strong>epoll 通过更好的方案实现了从操作系统订阅消息。epoll 将进程关注的文件描述符存入一棵二叉搜索树，通常是红黑树的实现</strong>。在这棵红黑树当中，Key 是 Socket 的编号，值是这个 Socket 关注的消息。因此，当内核发生了一个事件：比如 Socket 编号 1000 可以读取。这个时候，可以马上从红黑树中找到进程是否关注这个事件。</p><p><strong>另外当有关注的事件发生时，epoll 会先放到一个队列当中。当用户调用</strong><code>epoll_wait</code>时候，就会从队列中返回一个消息。epoll 函数本身是一个构造函数，只用来创建红黑树和队列结构。<code>epoll_wait</code>调用后，如果队列中没有消息，也可以马上返回。因此<code>epoll</code>是一个非阻塞模型。</p><p><strong>总结一下，select/poll 是阻塞模型，epoll 是非阻塞模型</strong>。<strong>当然，并不是说非阻塞模型性能就更好。在多数情况下，epoll 性能更好是因为内部有红黑树的实现</strong>。</p><p>最后我再贴一段用 epoll 实现的 Socket 服务给你做参考，这段程序的作者将这段代码放到了 Public Domain，你以后看到公有领域的代码可以放心地使用。</p><p>下面这段程序跟之前 select 的原理一致，对于每一个新的客户端连接，都使用 accept 拿到这个连接的文件描述符，并且创建一个客户端的 Socket。然后通过<code>epoll_ctl</code>将客户端的文件描述符和关注的消息类型放入 epoll 的红黑树。操作系统每次监测到一个新的消息产生，就会通过红黑树对比这个消息是不是进程关注的（当然这段代码你看不到，因为它在内核程序中）。</p><p><strong>非阻塞模型的核心价值，并不是性能更好。当真的高并发来临的时候，所有的 CPU 资源，所有的网络资源可能都会被用完。这个时候无论是阻塞还是非阻塞，结果都不会相差太大</strong>。（前提是程序没有写错）。</p><p><code>epoll</code>有 2 个最大的优势：</p><ol><li>内部使用红黑树减少了内核的比较操作；</li><li>对于程序员而言，非阻塞的模型更容易处理各种各样的情况。程序员习惯了写出每一条语句就可以马上得到结果，这样不容易出 Bug。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br></pre></td><td class="code"><pre><span class="line">// Asynchronous Socket server - accepting multiple clients concurrently,</span><br><span class="line"></span><br><span class="line">// multiplexing the connections with epoll.</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">// Eli Bendersky [http://eli.thegreenplace.net]</span><br><span class="line"></span><br><span class="line">// This code is in the public domain.</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/Socket.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;utils.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MAXFDS 16 * 1024</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef enum &#123; INITIAL_ACK, WAIT_FOR_MSG, IN_MSG &#125; ProcessingState;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define SENDBUF_SIZE 1024</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">  ProcessingState state;</span><br><span class="line"></span><br><span class="line">  uint8_t sendbuf[SENDBUF_SIZE];</span><br><span class="line"></span><br><span class="line">  int sendbuf_end;</span><br><span class="line"></span><br><span class="line">  int sendptr;</span><br><span class="line"></span><br><span class="line">&#125; peer_state_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Each peer is globally identified by the file descriptor (fd) it&apos;s connected</span><br><span class="line"></span><br><span class="line">// on. As long as the peer is connected, the fd is unique to it. When a peer</span><br><span class="line"></span><br><span class="line">// disconnects, a new peer may connect and get the same fd. on_peer_connected</span><br><span class="line"></span><br><span class="line">// should initialize the state properly to remove any trace of the old peer on</span><br><span class="line"></span><br><span class="line">// the same fd.</span><br><span class="line"></span><br><span class="line">peer_state_t global_state[MAXFDS];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Callbacks (on_XXX functions) return this status to the main loop; the status</span><br><span class="line"></span><br><span class="line">// instructs the loop about the next steps for the fd for which the callback was</span><br><span class="line"></span><br><span class="line">// invoked.</span><br><span class="line"></span><br><span class="line">// want_read=true means we want to keep monitoring this fd for reading.</span><br><span class="line"></span><br><span class="line">// want_write=true means we want to keep monitoring this fd for writing.</span><br><span class="line"></span><br><span class="line">// When both are false it means the fd is no longer needed and can be closed.</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">  bool want_read;</span><br><span class="line"></span><br><span class="line">  bool want_write;</span><br><span class="line"></span><br><span class="line">&#125; fd_status_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// These constants make creating fd_status_t values less verbose.</span><br><span class="line"></span><br><span class="line">const fd_status_t fd_status_R = &#123;.want_read = true, .want_write = false&#125;;</span><br><span class="line"></span><br><span class="line">const fd_status_t fd_status_W = &#123;.want_read = false, .want_write = true&#125;;</span><br><span class="line"></span><br><span class="line">const fd_status_t fd_status_RW = &#123;.want_read = true, .want_write = true&#125;;</span><br><span class="line"></span><br><span class="line">const fd_status_t fd_status_NORW = &#123;.want_read = false, .want_write = false&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fd_status_t on_peer_connected(int sockfd, const struct sockaddr_in* peer_addr,</span><br><span class="line"></span><br><span class="line">                              socklen_t peer_addr_len) &#123;</span><br><span class="line"></span><br><span class="line">  assert(sockfd &lt; MAXFDS);</span><br><span class="line"></span><br><span class="line">  report_peer_connected(peer_addr, peer_addr_len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Initialize state to send back a &apos;*&apos; to the peer immediately.</span><br><span class="line"></span><br><span class="line">  peer_state_t* peerstate = &amp;global_state[sockfd];</span><br><span class="line"></span><br><span class="line">  peerstate-&gt;state = INITIAL_ACK;</span><br><span class="line"></span><br><span class="line">  peerstate-&gt;sendbuf[0] = &apos;*&apos;;</span><br><span class="line"></span><br><span class="line">  peerstate-&gt;sendptr = 0;</span><br><span class="line"></span><br><span class="line">  peerstate-&gt;sendbuf_end = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Signal that this Socket is ready for writing now.</span><br><span class="line"></span><br><span class="line">  return fd_status_W;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fd_status_t on_peer_ready_recv(int sockfd) &#123;</span><br><span class="line"></span><br><span class="line">  assert(sockfd &lt; MAXFDS);</span><br><span class="line"></span><br><span class="line">  peer_state_t* peerstate = &amp;global_state[sockfd];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if (peerstate-&gt;state == INITIAL_ACK ||</span><br><span class="line"></span><br><span class="line">      peerstate-&gt;sendptr &lt; peerstate-&gt;sendbuf_end) &#123;</span><br><span class="line"></span><br><span class="line">    // Until the initial ACK has been sent to the peer, there&apos;s nothing we</span><br><span class="line"></span><br><span class="line">    // want to receive. Also, wait until all data staged for sending is sent to</span><br><span class="line"></span><br><span class="line">    // receive more data.</span><br><span class="line"></span><br><span class="line">    return fd_status_W;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  uint8_t buf[1024];</span><br><span class="line"></span><br><span class="line">  int nbytes = recv(sockfd, buf, sizeof buf, 0);</span><br><span class="line"></span><br><span class="line">  if (nbytes == 0) &#123;</span><br><span class="line"></span><br><span class="line">    // The peer disconnected.</span><br><span class="line"></span><br><span class="line">    return fd_status_NORW;</span><br><span class="line"></span><br><span class="line">  &#125; else if (nbytes &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">    if (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line"></span><br><span class="line">      // The Socket is not *really* ready for recv; wait until it is.</span><br><span class="line"></span><br><span class="line">      return fd_status_R;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      perror_die(&quot;recv&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool ready_to_send = false;</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; nbytes; ++i) &#123;</span><br><span class="line"></span><br><span class="line">    switch (peerstate-&gt;state) &#123;</span><br><span class="line"></span><br><span class="line">    case INITIAL_ACK:</span><br><span class="line"></span><br><span class="line">      assert(0 &amp;&amp; &quot;can&apos;t reach here&quot;);</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case WAIT_FOR_MSG:</span><br><span class="line"></span><br><span class="line">      if (buf[i] == &apos;^&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        peerstate-&gt;state = IN_MSG;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case IN_MSG:</span><br><span class="line"></span><br><span class="line">      if (buf[i] == &apos;$&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        peerstate-&gt;state = WAIT_FOR_MSG;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        assert(peerstate-&gt;sendbuf_end &lt; SENDBUF_SIZE);</span><br><span class="line"></span><br><span class="line">        peerstate-&gt;sendbuf[peerstate-&gt;sendbuf_end++] = buf[i] + 1;</span><br><span class="line"></span><br><span class="line">        ready_to_send = true;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Report reading readiness iff there&apos;s nothing to send to the peer as a</span><br><span class="line"></span><br><span class="line">  // result of the latest recv.</span><br><span class="line"></span><br><span class="line">  return (fd_status_t)&#123;.want_read = !ready_to_send,</span><br><span class="line"></span><br><span class="line">                       .want_write = ready_to_send&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fd_status_t on_peer_ready_send(int sockfd) &#123;</span><br><span class="line"></span><br><span class="line">  assert(sockfd &lt; MAXFDS);</span><br><span class="line"></span><br><span class="line">  peer_state_t* peerstate = &amp;global_state[sockfd];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if (peerstate-&gt;sendptr &gt;= peerstate-&gt;sendbuf_end) &#123;</span><br><span class="line"></span><br><span class="line">    // Nothing to send.</span><br><span class="line"></span><br><span class="line">    return fd_status_RW;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int sendlen = peerstate-&gt;sendbuf_end - peerstate-&gt;sendptr;</span><br><span class="line"></span><br><span class="line">  int nsent = send(sockfd, &amp;peerstate-&gt;sendbuf[peerstate-&gt;sendptr], sendlen, 0);</span><br><span class="line"></span><br><span class="line">  if (nsent == -1) &#123;</span><br><span class="line"></span><br><span class="line">    if (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line"></span><br><span class="line">      return fd_status_W;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      perror_die(&quot;send&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (nsent &lt; sendlen) &#123;</span><br><span class="line"></span><br><span class="line">    peerstate-&gt;sendptr += nsent;</span><br><span class="line"></span><br><span class="line">    return fd_status_W;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // Everything was sent successfully; reset the send queue.</span><br><span class="line"></span><br><span class="line">    peerstate-&gt;sendptr = 0;</span><br><span class="line"></span><br><span class="line">    peerstate-&gt;sendbuf_end = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Special-case state transition in if we were in INITIAL_ACK until now.</span><br><span class="line"></span><br><span class="line">    if (peerstate-&gt;state == INITIAL_ACK) &#123;</span><br><span class="line"></span><br><span class="line">      peerstate-&gt;state = WAIT_FOR_MSG;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return fd_status_R;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, const char** argv) &#123;</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, NULL, _IONBF, 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  int portnum = 9090;</span><br><span class="line"></span><br><span class="line">  if (argc &gt;= 2) &#123;</span><br><span class="line"></span><br><span class="line">    portnum = atoi(argv[1]);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Serving on port %d\n&quot;, portnum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  int listener_sockfd = listen_inet_Socket(portnum);</span><br><span class="line"></span><br><span class="line">  make_Socket_non_blocking(listener_sockfd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  int epollfd = epoll_create1(0);</span><br><span class="line"></span><br><span class="line">  if (epollfd &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">    perror_die(&quot;epoll_create1&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  struct epoll_event accept_event;</span><br><span class="line"></span><br><span class="line">  accept_event.data.fd = listener_sockfd;</span><br><span class="line"></span><br><span class="line">  accept_event.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">  if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listener_sockfd, &amp;accept_event) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">    perror_die(&quot;epoll_ctl EPOLL_CTL_ADD&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  struct epoll_event* events = calloc(MAXFDS, sizeof(struct epoll_event));</span><br><span class="line"></span><br><span class="line">  if (events == NULL) &#123;</span><br><span class="line"></span><br><span class="line">    die(&quot;Unable to allocate memory for epoll_events&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  while (1) &#123;</span><br><span class="line"></span><br><span class="line">    int nready = epoll_wait(epollfd, events, MAXFDS, -1);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nready; i++) &#123;</span><br><span class="line"></span><br><span class="line">      if (events[i].events &amp; EPOLLERR) &#123;</span><br><span class="line"></span><br><span class="line">        perror_die(&quot;epoll_wait returned EPOLLERR&quot;);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      if (events[i].data.fd == listener_sockfd) &#123;</span><br><span class="line"></span><br><span class="line">        // The listening Socket is ready; this means a new peer is connecting.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        struct sockaddr_in peer_addr;</span><br><span class="line"></span><br><span class="line">        socklen_t peer_addr_len = sizeof(peer_addr);</span><br><span class="line"></span><br><span class="line">        int newsockfd = accept(listener_sockfd, (struct sockaddr*)&amp;peer_addr,</span><br><span class="line"></span><br><span class="line">                               &amp;peer_addr_len);</span><br><span class="line"></span><br><span class="line">        if (newsockfd &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">          if (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line"></span><br><span class="line">            // This can happen due to the nonblocking Socket mode; in this</span><br><span class="line"></span><br><span class="line">            // case don&apos;t do anything, but print a notice (since these events</span><br><span class="line"></span><br><span class="line">            // are extremely rare and interesting to observe...)</span><br><span class="line"></span><br><span class="line">            printf(&quot;accept returned EAGAIN or EWOULDBLOCK\n&quot;);</span><br><span class="line"></span><br><span class="line">          &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            perror_die(&quot;accept&quot;);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">          make_Socket_non_blocking(newsockfd);</span><br><span class="line"></span><br><span class="line">          if (newsockfd &gt;= MAXFDS) &#123;</span><br><span class="line"></span><br><span class="line">            die(&quot;Socket fd (%d) &gt;= MAXFDS (%d)&quot;, newsockfd, MAXFDS);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          fd_status_t status =</span><br><span class="line"></span><br><span class="line">              on_peer_connected(newsockfd, &amp;peer_addr, peer_addr_len);</span><br><span class="line"></span><br><span class="line">          struct epoll_event event = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">          event.data.fd = newsockfd;</span><br><span class="line"></span><br><span class="line">          if (status.want_read) &#123;</span><br><span class="line"></span><br><span class="line">            event.events |= EPOLLIN;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (status.want_write) &#123;</span><br><span class="line"></span><br><span class="line">            event.events |= EPOLLOUT;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          if (epoll_ctl(epollfd, EPOLL_CTL_ADD, newsockfd, &amp;event) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            perror_die(&quot;epoll_ctl EPOLL_CTL_ADD&quot;);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // A peer Socket is ready.</span><br><span class="line"></span><br><span class="line">        if (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"></span><br><span class="line">          // Ready for reading.</span><br><span class="line"></span><br><span class="line">          int fd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">          fd_status_t status = on_peer_ready_recv(fd);</span><br><span class="line"></span><br><span class="line">          struct epoll_event event = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">          event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">          if (status.want_read) &#123;</span><br><span class="line"></span><br><span class="line">            event.events |= EPOLLIN;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (status.want_write) &#123;</span><br><span class="line"></span><br><span class="line">            event.events |= EPOLLOUT;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (event.events == 0) &#123;</span><br><span class="line"></span><br><span class="line">            printf(&quot;Socket %d closing\n&quot;, fd);</span><br><span class="line"></span><br><span class="line">            if (epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">              perror_die(&quot;epoll_ctl EPOLL_CTL_DEL&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            close(fd);</span><br><span class="line"></span><br><span class="line">          &#125; else if (epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            perror_die(&quot;epoll_ctl EPOLL_CTL_MOD&quot;);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else if (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line"></span><br><span class="line">          // Ready for writing.</span><br><span class="line"></span><br><span class="line">          int fd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">          fd_status_t status = on_peer_ready_send(fd);</span><br><span class="line"></span><br><span class="line">          struct epoll_event event = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">          event.data.fd = fd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          if (status.want_read) &#123;</span><br><span class="line"></span><br><span class="line">            event.events |= EPOLLIN;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (status.want_write) &#123;</span><br><span class="line"></span><br><span class="line">            event.events |= EPOLLOUT;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (event.events == 0) &#123;</span><br><span class="line"></span><br><span class="line">            printf(&quot;Socket %d closing\n&quot;, fd);</span><br><span class="line"></span><br><span class="line">            if (epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">              perror_die(&quot;epoll_ctl EPOLL_CTL_DEL&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            close(fd);</span><br><span class="line"></span><br><span class="line">          &#125; else if (epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            perror_die(&quot;epoll_ctl EPOLL_CTL_MOD&quot;);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重新思考：I-O-模型"><a href="#重新思考：I-O-模型" class="headerlink" title="重新思考：I/O 模型"></a>重新思考：I/O 模型</h4><p>在上面的模型当中，select/poll 是阻塞（Blocking）模型，epoll 是非阻塞（Non-Blocking）模型。<strong>阻塞和非阻塞强调的是线程的状态</strong>，所以阻塞就是触发了线程的阻塞状态，线程阻塞了就停止执行，并且切换到其他线程去执行，直到触发中断再回来。</p><p>还有一组概念是同步（Synchrounous）和异步（Asynchrounous），select/poll/epoll 三者都是同步调用。</p><p><strong>同步强调的是顺序，</strong>所谓同步调用，就是可以确定程序执行的顺序的调用。比如说执行一个调用，知道调用返回之前下一行代码不会执行。这种顺序是确定的情况，就是同步。</p><p>而异步调用则恰恰相反，<strong>异步调用不明确执行顺序</strong>。比如说一个回调函数，不知道何时会回来。异步调用会加大程序员的负担，因为我们习惯顺序地思考程序。因此，我们还会发明像协程的 yield 、迭代器等将异步程序转为同步程序。</p><p>由此可见，<strong>非阻塞不一定是异步，阻塞也未必就是同步</strong>。比如一个带有回调函数的方法，阻塞了线程 100 毫秒，又提供了回调函数，那这个方法是异步阻塞。例如下面的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">asleep(100ms, () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 100ms 或更多后到这里</span><br><span class="line"></span><br><span class="line">  // ...do some thing</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 100 ms 后到这里</span><br></pre></td></tr></table></figure><p>总结下，操作系统给大家提供各种各样的 API，是希望满足各种各样程序架构的诉求。但总体诉求其实是一致的：希望程序员写的单机代码，能够在多线程甚至分布式的环境下执行。这样你就不需要再去学习复杂的并发控制算法。从这个角度去看，非阻塞加上同步的编程模型确实省去了我们编程过程当中的很多思考。</p><p>但可惜的是，至少在今天这个时代，<strong>多线程、并发编程依然是程序员们的必修课</strong>。因此你在思考 I/O 模型的时候，还是需要结合自己的业务特性及系统自身的架构特点，进行选择。<strong>I/O 模型并不是选择效率，而是选择编程的手段</strong>。试想一个所有资源都跑满了的服务器，并不会因为是异步或者非阻塞模型就获得更高的吞吐量。</p><p><strong>select/poll/epoll 有什么区别</strong>？</p><p>这三者都是处理 I/O 多路复用的编程手段。select/poll 模型是一种阻塞模型，epoll 是非阻塞模型。select/poll 内部使用线性结构存储进程关注的 Socket 集合，因此每次内核要判断某个消息是否发送给 select/poll 需要遍历进程关注的 Socket 集合。</p><p>而 epoll 不同，epoll 内部使用二叉搜索树（红黑树），用 Socket 编号作为索引，用关注的事件类型作为值，这样内核可以在非常快的速度下就判断某个消息是否需要发送给使用 epoll 的线程。</p><h3 id="公私钥体系和网络安全：什么是中间人攻击？"><a href="#公私钥体系和网络安全：什么是中间人攻击？" class="headerlink" title="公私钥体系和网络安全：什么是中间人攻击？"></a><strong>公私钥体系和网络安全：什么是中间人攻击？</strong></h3><p>设想你和一个朋友签订了合同，双方各执一份。如果朋友恶意篡改了合同内容，比如替换了合同中的条款，最后大家闹到法院、各执一词。这个时候就需要专业鉴定机构去帮你鉴定合同的真伪，朋友花越多心思去伪造合同，那么鉴定的成本就会越高。</p><p>在网络安全领域有个说法：没有办法杜绝网络犯罪，只能想办法提高网络犯罪的成本。我们的目标是提高作案的成本，并不是杜绝这种现象。今天我将带你初探网络安全的世界，学习网络安全中最重要的一个安全体系——公私钥体系。</p><h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>一家具有公信力的机构对内部需要严格管理。那么当合同存储下来之后，为了防止内部人员篡改合同，这家机构需要做什么呢？</p><p>很显然，这家机构需要证明合同没有被篡改。一种可行的做法，就是将<strong>合同原文</strong>和<strong>摘要</strong>一起存储。你可以把摘要算法理解成一个函数，原文经过一系列复杂的计算后，产生一个<strong>唯一的散列值</strong>。只要原文发生一丁点的变动，这个散列值就会发生变化。</p><p>目前比较常见的摘要算法有<strong>消息摘要算法（\</strong>Message Digest Algorithm, MD5）和**安全散列算法**（Secure Hash Algorithm, SHA）。MD5 可以将任意长度的文章转化为一个 128 位的散列值。2004 年，MD5 被证实会发生碰撞，发生碰撞就是两篇原文产生了相同的摘要。这是非常危险的事情，这将允许黑客进行多种攻击手段，甚至可以伪造摘要。</p><p>因此在这之后，我们通常首选 SHA 算法。你不需要知道算法的准确运算过程，只需要知道 SHA 系的算法更加安全即可。在实现普通应用的时候可以使用 MD5，在计算对安全性要求极高的摘要时，就应该使用 SHA，比如订单、账号信息、证书等。</p><h4 id="安全保存的困难"><a href="#安全保存的困难" class="headerlink" title="安全保存的困难"></a>安全保存的困难</h4><p>采用摘要算法，从理论上来说就杜绝了篡改合同的内容的做法。但在现实当中，公司也有可能出现内鬼。我们不能假定所有公司内部员工的行为就是安全的。因此可以考虑将合同和摘要分开存储，并且设置不同的权限。这样就确保在机构内部，没有任何一名员工同时拥有合同和摘要的权限。但是即便如此，依然留下了巨大的安全隐患。比如两名员工串通一气，或者员工利用安全漏洞，和外部的不法分子进行非法交易。</p><p>那么现在请你思考这个问题：<strong>如何确保公司内部的员工不会篡改合同呢</strong>？当然从理论上来说是做不到的。没有哪个系统能够杜绝内部人员接触敏感信息，除非敏感信息本身就不存在。因此，可以考虑将原文存到合同双方的手中，第三方机构中只存摘要。但是这又产生了一个新的问题，会不会有第三方机构的员工和某个用户串通一气修改合同呢？</p><p>至此，事情似乎陷入了僵局。由第三方平台保存合同，背后同样有很大的风险。而由用户自己保存合同，就是签约双方交换合同原文及摘要。但是这样的形式中，摘要本身是没有公信力的，无法证明合同和摘要确实是对方给的。</p><p>因此我们还要继续思考最终的解决方案：类比我们交换合同，在现实世界当中，还伴随着签名的交换。那么在计算机的世界中，签名是什么呢？</p><h4 id="数字签名和证书"><a href="#数字签名和证书" class="headerlink" title="数字签名和证书"></a>数字签名和证书</h4><p>在计算机中，数字签名是一种很好的实现签名（模拟现实世界中签名）的方式。 所谓数字签名，就是对摘要进行加密形成的密文。</p><p>举个例子：现在 Alice 和 Bob 签合同。Alice 首先用 SHA 算法计算合同的摘要，然后用自己私钥将摘要加密，得到数字签名。Alice 将合同原文、签名，以及公钥三者都交给 Bob。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630170647.png" alt="image-20210630170647285"></p><p>Bob 如果想证明合同是 Alice 的，就要用 Alice 的公钥，将签名解密得到摘要 X。然后，Bob 计算原文的 SHA 摘要 Y。Bob 对比 X 和 Y，如果 X = Y 则说明数据没有被篡改过。</p><p>在这样的一个过程当中，Bob 不能篡改 Alice 合同。因为篡改合同不但要改原文还要改摘要，而摘要被加密了，如果要重新计算摘要，就必须提供 Alice 的私钥。所谓私钥，就是 Alice 独有的密码。所谓公钥，就是 Alice 公布给他人使用的密码。</p><p><strong>公钥加密的数据，只有私钥才可以解密。私钥加密的数据，只有公钥才可以解密</strong>。这样的加密方法我们称为<strong>非对称加密</strong>，基于非对称加密算法建立的安全体系，也被称作<strong>公私钥体系</strong>。用这样的方法，签约双方都不可以篡改合同。</p><h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>但是在上面描述的过程当中，仍然存在着一个非常明显的信任风险。这个风险在于，Alice 虽然不能篡改合同，但是可以否认给过 Bob 的公钥和合同。这样，尽管合同双方都不可以篡改合同本身，但是双方可以否认签约行为本身。</p><p>如果要解决这个问题，那么 Alice 提供的公钥，必须有足够的信誉。这就需要引入第三方机构和证书机制。</p><p><strong>证书为公钥提供方提供公正机制</strong>。证书之所以拥有信用，是因为证书的签发方拥有信用。假设 Alice 想让 Bob 承认自己的公钥。Alice 不能把公钥直接给 Bob，而是要提供第三方公证机构签发的、含有自己公钥的证书。如果 Bb 也信任这个第三方公证机构，信任关系和签约就成立。当然，法律也得承认，不然没法打官司。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630173215.png" alt="image-20210630173215247"></p><p>如上图所示，Alice 将自己的申请提交给机构，产生证书的原文。机构用自己的私钥签名 Alice 的申请原文（先根据原文内容计算摘要，再用私钥加密），得到带有签名信息的证书。Bob 拿到带签名信息的证书，通过第三方机构的公钥进行解密，获得 Alice 证书的摘要、证书的原文。有了 Alice 证书的摘要和原文，Bob 就可以进行验签。验签通过，Bob 就可以确认 Alice 的证书的确是第三方机构签发的。</p><p>用上面这样一个机制，合同的双方都无法否认合同。这个解决方案的核心在于<strong>需要第三方信用服务机构提供信用背书</strong>。这里产生了一个最基础的信任链，如果第三方机构的信任崩溃，比如被黑客攻破，那整条信任链条也就断裂了。</p><h4 id="信任链"><a href="#信任链" class="headerlink" title="信任链"></a>信任链</h4><p>为了固化信任关系，减少风险。最合理的方式就是<strong>在互联网中打造一条更长的信任链，环环相扣，避免出现单点的信任风险</strong>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630173421.png" alt="image-20210630173420927"></p><p>上图中，由信誉最好的根证书机构提供根证书，然后根证书机构去签发二级机构的证书；二级机构去签发三级机构的证书；最后有由三级机构去签发 Alice 证书。</p><ul><li>如果要验证 Alice 证书的合法性，就需要用三级机构证书中的公钥去解密 Alice 证书的数字签名。</li><li>如果要验证三级机构证书的合法性，就需要用二级机构的证书去解密三级机构证书的数字签名。</li><li>如果要验证二级结构证书的合法性，就需要用根证书去解密。</li></ul><p>以上，就构成了一个相对长一些的信任链。如果其中一方想要作弊是非常困难的，除非链条中的所有机构同时联合起来，进行欺诈。</p><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p>最后我们再来说说中间人攻击。在 HTTPS 协议当中，客户端需要先从服务器去下载证书，然后再通过信任链验证服务器的证书。当证书被验证为有效且合法时，客户端和服务器之间会利用非对称加密协商通信的密码，双方拥有了一致的密码和加密算法之后，客户端和服务器之间会进行对称加密的传输。</p><p>在上述过程当中，要验证一个证书是否合法，就必须依据信任链，逐级的下载证书。但是根证书通常不是下载的，它往往是随着操作系统预安装在机器上的。如果黑客能够通过某种方式在你的计算机中预装证书，那么黑客也可以伪装成中间节点。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630173726.png" alt="image-20210630173726736"></p><p>一方面，黑客向客户端提供伪造的证书，并且这个伪造的证书会在客户端中被验证为合法。因为黑客已经通过其他非法手段在客户端上安装了证书。举个例子，比如黑客利用 U 盘的自动加载程序，偷偷地将 U 盘插入客户端机器上一小段时间预装证书。</p><p>安装证书后，黑客一方面和客户端进行正常的通信，另一方面黑客和服务器之间也建立正常的连接。这样黑客在中间就可以拿到客户端到服务器的所有信息，并从中获利。</p><p><strong>什么是中间人攻击</strong>？</p><p>【<strong>解析</strong>】中间人攻击中，一方面，黑客利用不法手段，让客户端相信自己是服务提供方。另一方面，黑客伪装成客户端和服务器交互。这样黑客就介入了客户端和服务之间的连接，并从中获取信息，从而获利。在上述过程当中，黑客必须攻破信任链的体系，比如直接潜入对方机房现场暴力破解、诱骗对方员工在工作电脑中安装非法的证书等。</p><p>另外，有很多的网络调试工具的工作原理，和中间人攻击非常类似。为了调试网络的请求，必须先在客户端装上自己的证书。这样作为中间人节点的调试工具，才可以获取客户端和服务端之间的传输。</p><h3 id="IPv4-和-IPv6-有什么区别？"><a href="#IPv4-和-IPv6-有什么区别？" class="headerlink" title="IPv4 和 IPv6 有什么区别？"></a><strong>IPv4 和 IPv6 有什么区别</strong>？</h3><p> IPv4 和 IPv6 最大的区别是<strong>地址空间大小不同</strong>。</p><ul><li>IPv4 是用 32 位描述 IP 地址，理论极限约在 40 亿 IP 地址；</li><li>IPv6 是用 128 位描述 IP 地址，IPv6 可以大到给每个人都分配 40 亿个 IP 地址，甚至更多的 IP 地址。</li></ul><p><strong>IPv4 地址不够用，因此需要划分子网</strong>。比如公司的几千台机器（计算机、手机），复用一个出口 IP 地址。子网内部，就用 192.168 开头的 IP 地址。</p><p><strong>而 IPv6 地址够用</strong>，可以给全世界每台设备都分配一个地址，也可以给每一个组织（甚至家庭）都分配数以亿计的地址，目前不存在地址枯竭的问题。因此<strong>不需要像 IPv4 那样通过网络地址转换协议</strong>（NAT）去连接子网和外部网络。</p><p>因为<strong>地址数目的不同导致这两个协议在分配 IP 地址的时候行为也不一样</strong>。</p><p>IPv4 地址，空间小，如果没有一个中心的服务为所有设备分配地址，那么产生的冲突非常严重。所以<strong>IPv4 地址分配，是一种中心化的请求/返回的模式</strong>。客户端向服务端请求，分配地址。服务端，将计算好可以分配的地址返回给客户端。</p><p><strong>而 IPv6 可以采用先计算，再申请的模式</strong>。由客户端自己随机抽取得出一个 IP 地址（能这样做是因为闲置的 IP 地址太多，随机抽取一个大概率没有设备使用），然后再向这个 IP 地址发送信息。如果没有得到返回，那么说明这个 IP 地址还没有设备使用。大体来说，这就是 IPv6 邻居发现协议，但上述内容只是其中该协议的一小部分。</p><p>以上是 IPv4 和 IPv6 最重要的几个区别。如果你对这块内容比较感兴趣，比如 IPv6 具体的地址格式？127.0.0.1 是什么 IP 地址？封包有什么区别？可以查阅更多的资料，比如 IPv6 的 RFC 文档。</p><p><strong>SSH（Secure Shell）工具可不可以用 UDP 实现</strong>？</p><p><strong>SSH</strong>（<strong>Secure Shell</strong>）<strong>是一种网络加密协议，可以帮助我们在不安全的网络上构建安全的传输</strong>。和 HTTPS 类似，SSH 先用非对称加密。协商密钥和参数，在目标机器登录后。利用对称加密，建立加密通道（Channel）传输数据。</p><p><strong>通常的 SSH 协议的底层要求是 TCP 协议</strong>。但是如果你愿意用 UDP 实现 SSH 需要的可靠性，就可以替代原有 TCP 协议的能力。只不过因为 SSH 协议对吞吐量要求并不高，而 TCP 的延迟也足够用，所以这样做的收益也不会非常的高。<strong>如果想构建安全的远程桌面，可以考虑在 UDP 上实现专门的安全传输协议来提高吞吐量、降低延迟</strong>。</p><p>事实上，安全传输协议也有建立在 UDP 之上的。比如说IBM 的FASP（Fast and Secure Protocol）协议，它不像 TCP 一样自动去判断封包丢失，也不会给每一个封包一个响应，它只重传接收方显示指定没有收到的封包。因而这个协议在传输文件的时候，有更快的速度。</p><p><strong>如果用 epoll 架构一个Web 服务器应该是一个怎样的架构</strong>？</p><p>每一个客户端连接进来之后都是一个 Socket 文件。接下来，对于 Web 服务器而言，要处理的是文件的 I/O，以及在 I/O 结束之后进行数据、业务逻辑的处理。</p><ul><li><strong>I/O</strong>：这部分的主要开销在于从 Socket 文件中读出数据到用户空间。比如说读取出 HTTP 请求的数据并把它们存储到一个缓冲区当中。</li><li>**处理部分（Processing)**：这部分的开销有很多个部分。比如说，需要将 HTTP 请求从字节的表示转化为字符串的表示，然后再解析。还需要将 HTTP 请求的字符串，分成各个部分。头部（Header）是一个 Key-Value 的映射（Map）。Body 部分，可能是 QueryString，JSON,XML 等。完成这些处理之后，可能还会进行读写数据库、业务逻辑计算、远程调用等。</li></ul><p>我们先说<strong>处理部分（Processing）</strong> 的开销，目前主要有下面这样几种架构。</p><ol><li>为每一次处理创建一个线程。</li></ol><p>这样做<strong>线程之间的相互影响最小</strong>。只要有足够多的资源，就可以并发完成足够多的工作。但是缺点在于线程的、创建和销毁成本。虽然单次成本不高，但是积累起来非常也是一个不小的数字——比如每秒要处理 1 万个请求的情况。更关键的问题在于，在并发高的场景下，这样的设计可能会导致创建的线程太多，导致线程切换太频繁，最终大量线程阻塞，系统资源耗尽，最终引发雪崩。</p><ol start="2"><li>通过线程池管理线程。</li></ol><p>这样做最大的优势在于<strong>拥有反向压力</strong>。所谓反向压力（Back-Presure）就是当系统资源不足的时候可以阻塞生产者。对任务处理而言，生产者就是接收网络请求的 I/O 环节。当压力太大的时候，拒绝掉部分请求，从而缓解整个系统的压力。比如说我们可以控制线程池中最大的线程数量，一般会多于 CPU 的核数，小于造成系统雪崩的数量，具体数据需要通过压力测试得出。</p><ol start="3"><li>利用协程。</li></ol><p>在一个主线程中实现更轻量级的线程，通常是实现协程或者类似的东西。将一个内核级线程的执行时间分片，分配给 n 个协程。协程之间会互相转让执行资源，比如一个协程等待 I/O，就会将计算资源转让给其他的协程。转换过程不需要线程切换，类似函数调用的机制。这样最大程度地利用了计算资源，因此性能更好。</p><p>最后强调一下，GO 语言实现的不是协程，是轻量级的线程，但是效果也非常好。Node.js 实现了类似协程的单位，称为任务，效果也很不错。Java 新标准也在考虑支持协程，目前也有一些讨论——考虑用 Java 的异常处理机制实现协程。你可以根据自己的研究或者工作方向去查阅更多相关的资料。</p><p>接下来我们说说 I/O 部分的架构。I/O 部分就是将数据从 Socket 文件中读取出来存储到用户空间的内存中去。我们将所有需要监听的 Socket 文件描述符，都放到 epoll 红黑树当中，就进入了一种高性能的处理状态。但是读取文件的操作，还有几种选择。</p><ol><li><strong>单线程读取所有文件描述符的数据。</strong> 读取的过程利用异步 I/O，所以这个线程只需要发起 I/O 和响应中断。每次中断的时候，数据拷贝到用户空间，这个线程就将接收数据的缓冲区传递给处理模块。虽然这个线程要处理很多的 I/O，但因为只需要处理中断，所以压力并不大。</li><li><strong>多线程同步 I/O。</strong> 用很多个线程通过同步 I/O 的模式去处理文件描述符。这个方式在通常的情况下，可以完成工作。但是在高并发的场景下，会浪费很多的 CPU 资源。</li><li><strong>零拷贝技术，</strong> 通常和异步 I/O 结合使用。比如 mmap 处理过程——数据从磁盘文件读取到内核的过程不需要 CPU 的参与（DMA 技术），因此节省了大量开销。内核也不将数据再向用户空间拷贝，而是直接将缓冲区共享给用户空间，这样又节省了一次拷贝。但是需要注意，并不是所有的操作系统都支持这种模式。</li></ol><p><strong>由此可见，优化 Web 服务器底层是在优化 I/O 的模型；中间层是在优化处理数据、远程调用等的模型</strong>。这两个过程要分开来看，都需要优化。</p><p><strong>如何预防中间人攻击</strong>？</p><p><strong>中间人攻击最核心的就是要攻破信任链</strong>。比如说替换掉目标计算机中的验证程序，在目标计算机中安装证书，都可以作为中间人攻击的方式。因此在公司工作的时候，我们经常强调，要将电脑锁定再离开工位，防止有人物理破解。不要接收来历不明的邮件，防止一不小心被安装证书。也不要使用盗版的操作系统，以及盗版的软件。这些都是非法证书的来源。</p><p><strong>另外一种情况就是服务器被攻破</strong>。比如内部员工机器中毒，密码泄露，导致黑客远程拿到服务器的私钥。再比如说，数据库被攻击、网站被挂码，导致系统被 Root。在这种情况下，黑客就可以作为中间人解密所有消息，为所欲为了。</p><p>安全无小事，在这里我再多说一句，平时大家不要将密码交给同事，也不要在安全的细节上掉以轻心。安全是所有公司的一条红线，需要大家一同去努力维护。</p><h3 id="VMware-和-Docker-的区别？"><a href="#VMware-和-Docker-的区别？" class="headerlink" title="VMware 和 Docker 的区别？"></a><strong>VMware 和 Docker 的区别？</strong></h3><p>都说今天是一个云时代，其实云的本质就是由基础架构提供商提供基础架构，应用开发商不再关心基础架构。我们可以类比人类刚刚发明电的时候，工厂需要自己建电站，而现在只需要电线和插座就可以使用电。</p><p>云时代让我们可以在分钟、甚至秒级时间内获得计算、存储、操作系统等资源。设备不再论个卖，而是以一个虚拟化单位售卖，比如：</p><ul><li>用户可以买走一个 64 核 CPU 机器中的 0.25 个 CPU；</li><li>也可以买走一个 128GB 内存机器中的 512M 内存；</li><li>还可以买走 1/2 台机器三个小时了执行时间。</li></ul><p>实现以上这些，就需要虚拟化技术。这一讲我将以虚拟化技术中两种最具代表性的设计——VMware 和 Docker，为你解读解虚拟化技术。</p><h4 id="什么是“虚拟化”"><a href="#什么是“虚拟化”" class="headerlink" title="什么是“虚拟化”"></a>什么是“虚拟化”</h4><p>顾名思义，虚拟是相对于现实而言。虚拟化（Virutualization）通常是指构造真实的虚拟版本。不严谨地说，用软件模拟计算机，就是虚拟机；用数字模拟价值，就是货币；用存储空间模拟物理存储，就是虚拟磁盘。</p><p>VMware 和 Docker 是目前虚拟化技术中最具代表性的两种设计。<strong>VMware 为应用提供虚拟的计算机</strong>（<strong>虚拟机</strong>）；<strong>Docker 为应用提供虚拟的空间，被称作容器</strong>（<strong>Containe</strong>r），关于空间的含义，我们会在下文中详细讨论。</p><p><strong>VMware</strong>在 1998 年诞生，通过 Hypervisor 的设计彻底改变了虚拟化技术。2005 年，VMware 不断壮大，在全球雇用了 1000 名员工，<strong>成为世界上最大的云基础架构提供商</strong>。</p><p><strong>Docker</strong>则是 2013 年发布的一个社区产品，后来逐渐在程序员群体中流行了起来。大量程序员开始习惯使用 Docker，所以各大公司才决定使用它。在“<strong>38 讲</strong>”中我们要介绍的 Kubernates（K8s）容器编排系统，一开始也是将 Docker 作为主要容器。虽然业内不时有传出二者即将分道扬镳的消息，但是目前（2021 年）K8s 下的容器主要还是 Docker。</p><h4 id="虚拟机的设计"><a href="#虚拟机的设计" class="headerlink" title="虚拟机的设计"></a>虚拟机的设计</h4><p>接下来我们说说虚拟机设计。要虚拟一台计算机，要满足三个条件：<strong>隔离、仿真、高效</strong>。</p><p><strong>隔离（Isolation），</strong> 很好理解，<strong>指的是一台实体机上的所有的虚拟机实例不能互相影响</strong>。这也是早期设计虚拟机的一大动力，比如可以在一台实体机器上同时安装 Linux、Unix、Windows、MacOS 四种操作系统，那么一台实体机器就可以执行四种操作系统上的程序，这就节省了采购机器的开销。</p><p><strong>仿真（Simulation）指的是用起来像一台真的机器那样，包括开机、关机，以及各种各样的硬件设备</strong>。在虚拟机上执行的操作系统认为自己就是在实体机上执行。<strong>仿真主要的贡献是让进程可以无缝的迁移，也就是让虚拟机中执行的进程，真实地感受到和在实体机上执行是一样的</strong>——这样程序从虚拟机到虚拟机、实体机到虚拟机的应用迁移，就不需要修改源代码。</p><p><strong>高效（Efficient）的目标是减少虚拟机对 CPU、对硬件资源的占用</strong>。通常在虚拟机上执行指令需要额外负担 10~15% 的执行成本，这个开销是相对较低的。因为应用通常很少将 CPU 真的用满，在容器中执行 CPU 指令开销会更低更接近在本地执行程序的速度。</p><p>为了实现上述的三种诉求，最直观的方案就是将虚拟机管理程序 Hypervisor 作为操作系统，在虚拟机管理程序（Hypervisor）之上再去构建更多的虚拟机。像这种管理虚拟机的架构，也称为 Type-1 虚拟机，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184343.png" alt="image-20210630184343343"></p><p>我们通常把虚拟机管理程序（Virtual Machine Monitor，VMM）称为 Hypervisor。在 Type-1 虚拟机中，Hypervisor 一方面作为操作系统管理硬件，另一方面作为虚拟机的管理程序。在 Hypervisor 之上创建多个虚拟机，每个虚拟机可以拥有不同的操作系统（Guest OS）。</p><h4 id="二进制翻译"><a href="#二进制翻译" class="headerlink" title="二进制翻译"></a>二进制翻译</h4><p>通常硬件的设计假定是由单操作系统管理的。如果多个操作系统要共享这些设备，就需要通过 Hypervisor。当操作系统需要执行程序的时候，程序的指令就通过 Hypervisor 执行。早期的虚拟机设计当中，Hypervisor 不断翻译来自虚拟机的程序指令，将它们翻译成可以适配在目标硬件上执行的指令。这样的设计，我们称为二进制翻译。</p><p><strong>二进制翻译的弱点在于性能，所有指令都需要翻译</strong>。相当于在执行所有指令的时候，都会产生额外的开销。当然可以用动态翻译技术进行弥补，比如说预读指令进行翻译，但是依然会产生较大的性能消耗。</p><h4 id="世界切换和虚拟化支持"><a href="#世界切换和虚拟化支持" class="headerlink" title="世界切换和虚拟化支持"></a>世界切换和虚拟化支持</h4><p>另一种方式就是当虚拟机上的应用需要执行程序的时候，进行一次世界切换（World Switch）。<strong>所谓世界切换就是交接系统的控制权，比如虚拟机上的操作系统，进入内核接管中断，成为实际的机器的控制者</strong>。在这样的条件下，虚拟机上程序的执行就变成了本地程序的执行。相对来说，这种切换行为相较于二进制翻译，成本是更低的。</p><p>为了实现世界切换，虚拟机上的操作系统需要使用硬件设备，比如内存管理单元（MMR）、TLB、DMA 等。这些设备都需要支持虚拟机上操作系统的使用，比如说 TLB 需要区分是虚拟机还是实体机程序。虽然可以用软件模拟出这些设备给虚拟机使用，但是如果能让虚拟机使用真实的设备，性能会更好。现在的 CPU 通常都支持虚拟化技术，比如 Intel 的 VT-X 和 AMD 的 AMD-V（也称作 Secure Virtual Machine）。如果你对硬件虚拟化技术非常感兴趣，可以阅读<a href="https://www.mimuw.edu.pl/~vincent/lecture6/sources/amd-pacifica-specification.pdf" target="_blank" rel="noopener">这篇文档</a>。</p><h4 id="Type-2-虚拟机"><a href="#Type-2-虚拟机" class="headerlink" title="Type-2 虚拟机"></a>Type-2 虚拟机</h4><p>Type-1 虚拟机本身是一个操作系统，所以需要用户预装。为了方便用户的使用，VMware 还推出了 Type-2 虚拟机，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184512.png" alt="image-20210630184512346"></p><p>在第二种设计当中，虚拟机本身也作为一个进程。它和操作系统中执行的其他进程并没有太大的区别。但是<strong>为了提升性能，有一部分 Hypervisor 程序会作为内核中的驱动执行</strong>。<strong>当虚拟机操作系统（Guest OS）执行程序的时候，会通过 Hypervisor 实现世界切换</strong>。因此，虽然和 Type-1 虚拟机有一定的区别，但是从本质上来看差距不大，同样是需要二进制翻译技术和虚拟化技术。</p><h4 id="Hyper-V"><a href="#Hyper-V" class="headerlink" title="Hyper-V"></a>Hyper-V</h4><p>随着虚拟机的发展，现在也出现了很多混合型的虚拟机，比如微软的 Hyper-v 技术。从下图中你会看到，虚拟机的管理程序（Parent Partition）及 Windows 的核心程序，都会作为一个虚拟化的节点，拥有一个自己的 VMBus，并且通过 Hypervisor 实现虚拟化。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184649.png" alt="image-20210630184648970"></p><p>在 Hyper-V 的架构当中不存在一个主的操作系统。实际上，用户开机之后就在使用虚拟机，Windows 通过虚拟机执行。在这种架构下，其他的虚拟机，比如用 VMware 管理的虚拟机也可以复用这套架构。当然，你也可以直接把 Linux 安装在 Hyper-V 下，只不过安装过程没有 VMWare 傻瓜化，其实也是很不错的选择。</p><h4 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h4><p><strong>虚拟机虚拟的是计算机，容器虚拟的是执行环境</strong>。每个容器都是一套独立的执行环境，如下图所示，容器直接被管理在操作系统之内，并不需要一个虚拟机监控程序。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184722.png" alt="image-20210630184722320"></p><p><strong>和虚拟机有一个最大的区别就是：容器是直接跑在操作系统之上的，容器内部是应用，应用执行起来就是进程</strong>。这个进程和操作系统上的其他进程也没有本质区别，但这个架构设计没有了虚拟机监控系统。当然，容器有一个更轻量级的管理程序，用户可以从网络上下载镜像，启动起来就是容器。容器中预装了一些程序，比如说一个 Python 开发环境中，还会预装 Web 服务器和数据库。因为没有了虚拟机管理程序在中间的开销，因而性能会更高。而且因为不需要安装操作系统，因此容器安装速度更快，可以达到 ms 级别。</p><p><strong>容器依赖操作系统的能力直接实现，比如：</strong></p><ul><li><strong>Linux 的 Cgroups（Linux Control Groups）能力，可以用来限制某组进程使用的 CPU 资源和内存资源，控制进程的资源能使用；</strong></li><li>另外<strong>Linux 的 Namespace 能力，可以设置每个容器能看到能够使用的目录和文件</strong>。</li></ul><p>有了这两个能力，就可以基本控制容器间的隔离，容器中的应用直接以进程的身份执行即可。进程间的目录空间、 CPU 资源已经被隔离了，所以不用担心互相影响。</p><p><strong>VMware 和 Docker 的区别</strong>？</p><p><strong>【解析】</strong> VMware 提供虚拟机，Docker 提供容器。 虚拟机是一台完整的计算机，因此需要安装操作系统。虚拟机中的程序执行在虚拟机的操作系统上，为了让多个操作系统可以高效率地同时执行，虚拟机非常依赖底层的硬件架构提供的虚拟化能力。容器则是利用操作系统的能力直接实现隔离，容器中的程序可以以进程的身份直接执行。</p><h4 id="如何利用-K8s-和-Docker-Swarm-管理微服务？"><a href="#如何利用-K8s-和-Docker-Swarm-管理微服务？" class="headerlink" title="如何利用 K8s 和 Docker Swarm 管理微服务？"></a><strong>如何利用 K8s 和 Docker Swarm 管理微服务？</strong></h4><p>现在的面试官都喜欢问<strong>微服务相关的内容。微服务（Micro Service），指的是服务从逻辑上不可再分，是宏服务（Mono Service）的反义词。</strong></p><p>比如初学者可能认为交易相关的服务都应该属于交易服务，但事实上，交易相关的服务可能会有交易相关的配置服务、交易数据的管理服务、交易履约的服务、订单算价的服务、流程编排服务、前端服务……<br>所以到底什么是不可再分呢？</p><p>其实没有不可再分，永远都可以继续拆分下去。只不过从逻辑上讲，系统的拆分，应该结合公司部门组织架构的调整，反映公司的战斗结构编排。但总的来说，互联网上的服务越来越复杂，几个简单的接口就可能形成一个服务，这些服务都要上线。如果用实体机来承载这些服务，开销太大。如果用虚拟机来承载这些服务倒是不错的选择，但是创建服务的速度太慢，不适合今天这个时代的研发者们。</p><p>试想你的系统因为服务太多，该如何管理？尤其是在大型的公司，员工通过自发组织架构评审就可以上线微服务——天长日久，微服务越来越多，可能会有几万个甚至几十万个。那么这么多的微服务，如何分布到数万台物理机上工作呢？</p><p>如下图所示，为了保证微服务之间是隔离的，且可以快速上线。每个微服务我们都使用一个单独的容器，而一组容器，又包含在一个虚拟机当中，具体的关系如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185319.png" alt="image-20210630185318831"></p><p>上图中的微服务 C 因为只有一个实例存在单点风险，可能会引发单点故障。因此需要为微服务 C 增加副本，通常情况下，我们必须保证每个微服务至少有一个副本，这样才能保证可用性。</p><p>上述架构的核心就是要解决两个问题：</p><ol><li>减少 downtime（就是减少服务不可用的时间）；</li><li>支持扩容（随时都可以针对某个微服务增加容器）。</li></ol><p>因此，我们需要容器编排技术。容器编排技术指自动化地对容器进行部署、管理、扩容、迁移、保证安全，以及针对网络负载进行优化等一系列技术的综合体。Kubernetes 和 Docker Swarm 都是出色的容器编排方案。</p><h4 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h4><p>Kubernetes（K8s）是一个 Google 开源的容器编排方案。</p><h4 id="节点（Master-amp-Worker）"><a href="#节点（Master-amp-Worker）" class="headerlink" title="节点（Master&amp;Worker）"></a>节点（Master&amp;Worker）</h4><p><strong>K8s 通过集群管理容器</strong>。用户可以通过命令行、配置文件管理这个集群——从而编排容器；用户可以增加节点进行扩容，每个节点是一台物理机或者虚拟机。如下图所示，Kubernetes 提供了两种分布式的节点。Master 节点是集群的管理者，Worker 是工作节点，容器就在 Worker 上工作，一个 Worker 的内部可以有很多个容器。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185409.png" alt="image-20210630185409238"></p><p>在我们为一个微服务扩容的时候，首选并不是去增加 Worker 节点。可以增加这个微服务的容器数量，也可以提升每个容器占用的 CPU、内存存储资源。只有当整个集群的资源不够用的时候，才会考虑增加机器、添加节点。</p><p>Master 节点至少需要 2 个，但并不是越多越好。Master 节点主要是管理集群的状态数据，不需要很大的内存和存储空间。Worker 节点根据集群的整体负载决定，一些大型网站还有弹性扩容的手段，也可以通过 K8s 实现。</p><h4 id="单点架构"><a href="#单点架构" class="headerlink" title="单点架构"></a>单点架构</h4><p>接下来我们讨论一下 Worker 节点的架构。所有的 Worker 节点上必须安装 kubelet，它是节点的管理程序，负责在节点上管理容器。</p><p>Pod 是 K8s 对容器的一个轻量级的封装，每个 Pod 有自己独立的、随机分配的 IP 地址。Pod 内部是容器，可以 1 个或多个容器。目前，Pod 内部的容器主要是 Docker，但是今后可能还会有其他的容器被大家使用，主要原因是 K8s 和 Docker 的生态也存在着竞争关系。总的来说，如下图所示，kubelet 管理 Pod，Pod 管理容器。当用户创建一个容器的时候，实际上在创建 Pod。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185657.png" alt="image-20210630185657364"></p><p>虽然 K8s 允许同样的应用程序（比如微服务），在一个节点上创建多个 Pod。但是为了保证可用性，通常我们会考虑将微服务分散到不同的节点中去。如下图所示，如果其中一个节点宕机了，微服务 A，微服务 B 还能正常工作。当然，有一些微服务。因为程序架构或者编程语言的原因，只能使用单进程。这个时候，我们也可能会在单一的节点上部署多个相同的服务，去利用更多的 CPU 资源。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185709.png" alt="image-20210630185709284"></p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>Pod 的 IP 地址是动态的，如果要将 Pod 作为内部或者外部的服务，那么就需要一个能拥有静态 IP 地址的节点，这种节点我们称为服务（Service），服务不是一个虚拟机节点，而是一个虚拟的概念——或者理解成一段程序、一个组件。请求先到达服务，然后再到达 Pod，服务在这之间还提供负载均衡。当有新的 Pod 加入或者旧的 Pod 被删除，服务可以捕捉到这些状态，这样就大大降低了分布式应用架构的复杂度。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185721.png" alt="image-20210630185720941"></p><p>如上图所示，当我们要提供服务给外部使用时，对安全的考虑、对性能的考量是超过内部服务的。 K8s 解决方案：在服务的上方再提供薄薄的一层控制程序，为外部提供服务——这就是 Ingress。</p><p>以上，就是 K8s 的整体架构。 在使用的过程当中，相信你会感受到这个工具的魅力。比如说组件非常齐全，有数据加密、网络安全、单机调试、API 服务器等。如果你想了解更多的内容，可以查看<a href="https://kubernetes.io/docs/concepts/overview/" target="_blank" rel="noopener">这些资料</a>。</p><h4 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h4><p>Docker Swarm 是 Docker 团队基于 Docker 生态打造的容器编排引擎。下图是 Docker Swarm 整体架构图。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185800.png" alt="image-20210630185800434"></p><p>和 K8s 非常相似，节点被分成了 Manager 和 Worker。Manager 之间的状态数据通过 Raft 算法保证数据的一致性，Worker 内部是 Docker 容器。</p><p>和 K8s 的 Pod 类似，Docker Swarm 对容器进行了一层轻量级的封装——任务（Task），然后多个Task 通过服务进行负载均衡。</p><h4 id="容器编排设计思考"><a href="#容器编排设计思考" class="headerlink" title="容器编排设计思考"></a>容器编排设计思考</h4><p>这样的设计，用户只需要指定哪些容器开多少个副本，容器编排引擎自动就会在工作节点之中复制这些容器。而服务是容器的分组，多个容器共享一个服务。容器自动被创建，用户在维护的时候不需要维护到容器创建级别，只需要指定容器数目，并指定这类型的容器对应着哪个服务。至于之后，哪一个容器中的程序执行出错，编排引擎就会杀死这个出错的容器，并且重启一个新的容器。</p><p>在这样的设计当中，容器最好是<strong>无状态</strong>的，所以容器中最好不要用来运行 MySQL 这样的数据库。对于 MySQL 数据库，并不是多个实例都可以通过负载均衡来使用。有的实例只可以读，有的实例只可以写，中间还有 Binlog 同步。因此，虽然 K8s 提供了状态管理组件，但是使用起来可能不如虚拟机划算。</p><p>也是因为这种原因，我们现在倾向于进行无状态服务的开发。所有的状态都是存储在远程，应用本身并没有状态。当然，<strong>在开发测试环境，用容器来管理数据库是一个非常好的方案</strong>。这样可以帮助我们快速搭建、切换开发测试环境，并且可以做到一人一环境，互不影响，也可以做到开发环境、测试环境和线上环境统一。</p><p><strong>如何利用 K8s 和 Docker Swarm 管理微服务</strong>？</p><p>这两个容器编排引擎都可以用来管理微服务。K8s 和 Docker Swarm 在使用微服务的时候有许多共性的步骤。</p><ol><li><strong>制作容器镜像</strong>：我们就是要先制作容器，如果使用 Docker 作为容器，那就要写 DockerFile，然后生成容器镜像。</li><li><strong>上传镜像</strong>：制作好容器之后，我们往往会将容器上传到容器的托管平台。很多公司内部有自己的容器托管平台，这样下载容器的速度会非常快。</li><li><strong>搭建集群</strong>：再接下来，我们要搭建一个 K8s 或者 Docker Swarm 的集群，将节点添加进去。</li><li><strong>添加微服务 Pod/Task</strong>：然后我们要在集群中添加 Pod 的或者 Task，可以通过命令行工具，也可以通过书写配置文件。</li><li><strong>设置服务</strong>：为 Pod/Task 设置服务，之后都通过服务来访问容器内的应用。</li></ol><p>以上 5 个步骤是无论用哪个容器编排引擎都需要做的。具体使用过程当中，还有很多差异。比如，有的时候使用图形界面就可以完成上面的管理；不同的引擎配置文件，参数格式都会有差异。但是从整体架构到使用方式，它们都有着很大的相似性。因此你在学习容器编排引擎时，不应该着眼于学习某一个引擎，而是将它们看作一类知识，对比着学习。</p><h3 id="Linux-架构优秀在哪里"><a href="#Linux-架构优秀在哪里" class="headerlink" title="Linux 架构优秀在哪里?"></a><strong>Linux 架构优秀在哪里?</strong></h3><p>我们在面试的时候经常会和面试官聊架构，多数同学可能会认为架构是一个玄学问题，讨论的是“玄而又玄”的知识——如同道德经般的开头“玄之又玄、众妙之门”。<strong>其实架构领域也有通用的语言，有自己独有的词汇</strong>。虽然架构师经常为了系统架构争得面红耳赤，但是即使发生争吵，大家也会遵守架构思想准则。</p><p>这些优秀的架构思想和准则，很大一部分来自早期的黑客们对程序语言编译器实现的探索、对操作系统实现方案的探索，以及对计算机网络应用发展的思考，并且一直沿用至今。比如现在的面向对象编程、函数式编程、子系统的拆分和组织，以及分层架构设计，依然沿用了早期的架构思路。</p><p>其中有一部分非常重要的思想，被著名的计算机科学家、Unix 代码贡献者 Douglas McIlroy 誉为 Unix 哲学，也是 Linux 遵循的设计思想。今天我就和你一起讨论下，这部分前人留下的思想精华，希望可以帮助到你日后的架构工作。</p><h4 id="组合性设计（Composability）"><a href="#组合性设计（Composability）" class="headerlink" title="组合性设计（Composability）"></a>组合性设计（Composability）</h4><p><strong>Unix 系设计的哲学，都在和单体设计（Monolithic Design）和中心化唱反调</strong>。作为社区产品，开发者来自全世界不同的地方，这就构成了一个巨大的开发团队，自然会反对中心化。</p><p>而一个巨大的开发团队的管理，一定不能是 Mono 的。举个例子，如果代码仓库是Mono的，这意味着所有的代码都存放在一个仓库里。如果要上线项目中的一个功能，那所有项目中的代码都要一起上线，只要一个小地方出了问题，就会影响到全局。在我们设计这个系统的时候，应该允许不同的程序模块通过不同的代码仓库发布。</p><p>再比如说，整体的系统架构应该是可以组合的。比如文件系统的设计，每个目录可以有不同的文件系统，我们可以随时替换文件系统、接入新的文件系统。比如接入一个网络的磁盘，或者接入一个内存文件系统。</p><p>与其所有的程序工具模块都由自己维护，不如将这项权利分发给需要的人，让更多的人参与进来。让更多的小团队去贡献代码，这样才可以把更多的工具体验做到极致。</p><p>这个思想在面向对象以及函数式编程的设计中，同样存在。比如在面向对象中，我们会尽量使用组合去替代继承。<strong>因为继承是一种 Mono 的设计，一旦发生继承关系，就意味着父类和子类之间的强耦合</strong>。<strong>而组合是一种更轻量级的复用</strong>。对于函数式编程，我们有 Monad 设计（单子），本质上是让事物（对象）和处理事物（计算）的函数之间可以进行组合，这样就可以最小粒度的复用函数。</p><p>同理，Unix 系操作系统用管道组合进程，也是在最小粒度的复用程序。</p><h4 id="管道设计（Pipeline）"><a href="#管道设计（Pipeline）" class="headerlink" title="管道设计（Pipeline）"></a>管道设计（Pipeline）</h4><p>提到最小粒度的复用程序，就必然要提到管道（Pipeline）。Douglas McIlroy 在 Unix 的哲学中提到：<strong>一个应用的输出，应该是另一个应用的输入</strong>。<strong>这句话，其实道出了计算的本质</strong>。</p><p>计算其实就是将一个计算过程的输出给另一个计算过程作为输入。在构造流计算、管道运算、Monad 类型、泛型容器体系时——很大程度上，我们希望计算过程间拥有一定的相似性，比如泛型类型的统一。这样才可以把一个过程的输出给到另一个过程的输入。</p><h4 id="重构和丢弃"><a href="#重构和丢弃" class="headerlink" title="重构和丢弃"></a>重构和丢弃</h4><p>在 Unix 设计当中有一个非常有趣的哲学。<strong>就是希望每个应用都只做一件事情，并且把这件事情做到极致。如果当一个应用变得过于复杂的时候，就去重构这个应用，或者重新写一个应用。而不是在原有的应用上增加功能。</strong></p><p>上述逻辑和商业策略是否有相悖的地方？</p><p>关于这个问题，我觉得需要你自己进行思考，我不能给你答案，但欢迎把你的想法和答案写在留言区，我们一起交流。</p><p>设想一下，我们把微信的聊天工具、朋友圈、短视频、游戏都做成不同的应用，是不是会更好一些？</p><p>这是一个见仁见智的问题。但是目前来看，如果把短视频做成一个单独的应用，比如抖音，它在全球已经拥有 10 几亿的用户了；如果把游戏做成一个单独的应用，比如王者荣耀和 LoL，它们深受程序员们和广大上班族的喜爱。</p><p>还有，以我多年从事大型系统开发的经验来看，我宁愿重新做一些微服务，也不愿意去重构巨大的、复杂的系统。换句话说，我更乐意将新功能做到新系统里面，而不是在一个巨大的系统上不断地迭代和改进。这样不仅节省开发成本，还可以把事情做得更好。从这个角度看，我们进入微服务时代，是一个不可逆的过程。</p><p>另外多说一句，如果一定要在原有系统上增加功能，也应该多重构。<strong>重构和重写原有的系统有很多的好处</strong>，希望你不要有<strong>畏难情绪</strong>。优秀的团队，总是处在一个代码不断迭代的过程。一方面是因为业务在高速发展，旧代码往往承接不了新需求；另一方面，是因为程序员本身也在不断地追求更好的架构思路。</p><p>而重构旧代码，还经常可以看到业务逻辑中出问题的地方，看到潜在的隐患和风险，同时让程序员更加熟悉系统和业务逻辑。而且程序的复杂度，并不是随着需求量线性增长的。<strong>当需求量超过一定的临界值，复杂度增长会变快，类似一条指数曲线</strong>。<strong>因此，控制复杂度也是软件工程的一个核心问题。</strong></p><h4 id="写复杂的程序就是写错了"><a href="#写复杂的程序就是写错了" class="headerlink" title="写复杂的程序就是写错了"></a>写复杂的程序就是写错了</h4><p>我们经常听到优秀的架构师说，<strong>程序写复杂了，就是写错了。</strong>在 Unix 哲学中，也提出过这样的说法：<strong>写一个程序的时候，先用几周时间去构造一个简单的版本，如果发现复杂了，就重写它</strong>。</p><p>确实实际情景也是如此。我们在写程序的时候，如果一开始没有用对工具、没有分对层、没有选对算法和数据结构、没有用对设计模式，那么写程序的时候，就很容易陷入大量的调试，还会出现很多 Bug。<strong>优秀的程序往往是思考的过程很长，调试的时间很短，能够迅速地在短时间内完成测试和上线。</strong></p><p>所以当你发现一段代码，或者一段业务逻辑很消耗时间的时候，可能是你的思维方式出错了。想一想是不是少了必要的工具的封装，或者遗漏了什么中间环节。当然，也有可能是你的架构设计有问题，这就需要重新做架构了。</p><h4 id="优先使用工具而不是“熟练”"><a href="#优先使用工具而不是“熟练”" class="headerlink" title="优先使用工具而不是“熟练”"></a>优先使用工具而不是“熟练”</h4><p>关于优先使用工具这个哲学，我深有体会。</p><p>很多程序员在工作当中都忽略了去积累工具。比如说：</p><ul><li>你经常要重新配置自己的开发环境，也不肯做一个 Docker 的镜像；</li><li>你经常要重新部署自己的测试环境，而且有时候还会出现使用者太多而不够用的情况。即使这样的情况屡屡发生，也不肯做一下容器化的管理；</li><li>Git 的代码提交之后，不会触发自动化测试，需要人工去点鼠标，甚至需要由资深的测试手动去测。</li></ul><p>很多程序员都认为自己对某项技术足够熟练了。因此，宁愿长年累月投入更多的时间，也不愿意主动跳脱出固化思维。宁愿不断使用某一项技术，而不愿意将重复劳动转化成工具。比如写一个小型的 ORM 框架、缓存引擎、业务容器……总之，养成良好的习惯，可以让开发效率越来越高。</p><p>在 Unix 哲学当中，有这样一条规则：<strong>有些人使用“熟练”而不是使用工具来减轻工作，即便是临时需要去构造一个工具，你也应该尽可能去尝试实现。</strong></p><p>我们现在每天都用的 Git 版本控制工具，就是基于这样的哲学被构建出来的。当时刚好是 Linux 内核研发团队的商业代码管理工具到期了，Linux 的缔造者们基于这个经验教训，就自主研发了 Git 这款工具，不仅顺利地推进了后续的研发工作，还做成了一个巨大的程序员交友生态。</p><p>再给你讲一个我身边的故事：我刚刚工作的时候，我的老板自己写了一个小程序，去判断 HR 发过来简历是否符合他的用人条件。所以他每天可以看完几百份简历，并筛选出面试人选。而那些没有利用工具的技术 Leader，每天都在埋怨简历太多看不过来。</p><p>这些故事告诉我们，<strong>作为程序员，不仅仅需要完成工作，还要重视中间过程的工具缔造</strong>。</p><h4 id="其他优秀的原则"><a href="#其他优秀的原则" class="headerlink" title="其他优秀的原则"></a>其他优秀的原则</h4><p>我在学习 Unix 哲学的过程中，还看到很多有趣的规则，这里我摘选了一些和你分享。</p><p>比如：<strong>不要试图猜测程序可能的瓶颈在哪里，而是试图证明这个瓶颈，因为瓶颈会出现在出乎意料的地方</strong>。这句话告诉我们，要多写性能测试程序并且构造压力测试的场景。只有这样，才能让你的程序更健壮，承载更大的压力。</p><p>再比如：<strong>花哨的算法在业务规模小的时候通常运行得很慢，因此业务规模小的时候不要用花哨的算法。简单的算法，往往性能更高。如果你的业务规模很大，可以尝试去测试并证明需要用怎样的算法</strong>。</p><p>这也是我们在架构程序的时候经常会出错的地方。我们习惯性地选择用脑海中记忆的时间复杂度最低的算法，但是却忽略了<strong>时间复杂度只是一种增长关系，一个算法在某个场景中到底可不可行，是要以实际执行时收集数据为准的</strong>。</p><p>再比如：<strong>数据主导规则。当你的数据结构设计得足够好，那么你的计算方法就会深刻地反映出你系统的逻辑。这也叫作自证明代码。编程的核心是构造好的数据结构，而不是算法。</strong></p><p>尽管我们在学习的时候，算法和数据结构是一起学的。但是在大牛们看来，<strong>数据结构的抽象可以深刻反映系统的本质</strong>。比如抽象出文件描述符反应文件、抽象出页表反应内存、抽象出 Socket 反应连接——这些数据结构才是设计系统最核心的东西。</p><p>最后，再和你分享一句 Unix 的设计者Ken Thompson 的经典语录：<strong>搞不定就用蛮力</strong>。这是打破所有规则的规则。<strong>在我们开发的过程当中，首先要把事情搞定！只有把事情搞定，才有我们上面谈到的这一大堆哲学产生价值的可能性</strong>。事情没有搞定，一切都尘归尘土归土，毫无意义。</p><p>今天所讲的这些哲学，可以作为你平时和架构师们沟通的语言。架构有自己领域的语言，比如设计模式、编程范式、数据结构，等等。还有许多像 Unix 哲学这样——经过历史积淀，充满着人文气息的行业标准和规范。</p><p>如果你想仔细看看当时 Unix 的设计者都总结了哪些哲学，可以阅读<a href="http://www.catb.org/~esr/writings/taoup/html/ch01s06.html" target="_blank" rel="noopener">这篇文档</a>。</p><h3 id="商业操作系统：电商操作系统是不是一个噱头？"><a href="#商业操作系统：电商操作系统是不是一个噱头？" class="headerlink" title="商业操作系统：电商操作系统是不是一个噱头？"></a><strong>商业操作系统：电商操作系统是不是一个噱头？</strong></h3><p>关于电商操作系统是不是一个噱头？我觉得对于想要哄抬股价、营造风口的资本来说，这无疑是一场盛宴。但是对于从事多年业务架构，为了这件事情努力的架构师们而言，这似乎不是一个遥远的梦想，而是可以通过手中的键盘、白板上的图纸去付诸实践的目标。</p><p>我们暂且不为这个问题是不是噱头定性，不如先来聊一聊<strong>什么是商业操作系统</strong>，聊一聊它的设计思路和基本理念。</p><h4 id="进程的抽象"><a href="#进程的抽象" class="headerlink" title="进程的抽象"></a>进程的抽象</h4><p>你可以把一个大型的电商公司想象成一个商业操作系统，它的目标是为其中的每个参与者分配资源。这些资源不仅仅是计算资源，还会有市场资源、渠道资源、公关资源、用户资源，等等。</p><p>这样操作系统上的进程也被分成了几种类别，比如说内核程序，其实就是电商公司。应用程序就包括商家、供应商、品牌方、第三方支付、大数据分析公司等一系列组织的策略。</p><p>接下来，我们以<strong>商家</strong>为例讨论进程。在操作系统中进程是应用程序的执行副本。它不仅仅是在内核的进程表中留下一条记录，<strong>它更像拥有独立思考能力的人</strong>，它需要什么资源就会自己去操作系统申请。它会遵循操作系统的规则，为自己的用户服务，完成自己的商业目的。</p><p>所以如果上升到操作系统的高度来设计电商系统。我们不仅要考虑如何在数据库表中记录这个商家、如何实现跟这个商家相关的业务逻辑，还要让商家的行为是定制化的，可以自发地组织营业。同时，也要服从平台制定的规则，共同维护商业秩序，比如定价策略、物流标准、服务水平，等等。</p><p>你可能会说，要达到这点其实很容易。实现一个开放平台，将所有的平台能力做成 API。让商家可以自己开发程序，去调用这些 API 来完成自己的服务。商家可以利用这些接口自定义自己的办公自动化软件。</p><p>事实上很多电商公司也确实是这样去做的，但我认为这样做没有抓住问题的核心。一方面是系统的开发、对接成本会难住很多中小型商家。但最重要的并不是研发成本，而是开放的 API 平台通常只能提供基础能力——比如说订单查询、商品创建、活动创建，等等。这些能力是电商平台已有能力的一种投影，超不过商家本身能在后台中配置和使用的范畴，基于这样的 API 架构出来的应用程序，可以节省商家的时间，但是不能称为进程。因为独立性不够，且不够智能。</p><p>所以真正的发展方向和目标是商业的<strong>智能化</strong>。这里有一个在游戏领域常见的设计模式，可以实现智能化，叫作<strong>代理人</strong>（<strong>Agent</strong>）<strong>模式</strong>。就是为每一个商家提供一个或者多个代理（Agent）程序。这些代理人像机器人一样，会帮助商家运营自己的网店、客服、物流体系，等等。</p><p>代理人知道什么时候应该做什么，比如说：</p><ul><li>帮商家预约物流、为新老用户提供不同的服务；</li><li>通过分析数据决定是否需要花钱做活动；</li><li>当品牌方有活动的时候，帮助商家联系；</li><li>当线上商店经营出现问题的时候，主动帮商家分析；</li><li>……</li></ul><p>你可以把代理人理解成一个游戏的 AI，它们会根据一些配置选项自发地完成任务。而代理人的提供者，也就是<strong>程序员</strong>，只需要证明在某些方面，代理人比人更优秀即可。而在这些优秀的方面，就可以交给代理人处理。</p><p>这样，商家放弃了一部分的管理权限，也减轻了很大的负担，成了代理人决策中的某个节点——比如有时候需要邮件确认一些内容、有时候需要支付运营费用、有时候会遵循代理人的建议对商店进行装修等。</p><h4 id="资源和权限"><a href="#资源和权限" class="headerlink" title="资源和权限"></a>资源和权限</h4><p>对于一个计算机上的操作系统而言，我们对进程使用了什么样的资源并不是非常的敏感。而对于一个商业操作系统来说，我们就需要设计严格的权限控制。因为权限从某种意义上就代表着收入，代表着金钱。</p><p>资源是一个宽泛的概念。广告位是资源，可以带来直接的流量。基于用户的历史行为，每个用户看到的广告位是不同的，这个也叫作“千人千面”，所以一个广告位可以卖给很多个代理人。站内信、用户召回的权限也可以看作资源。 有权利建立自己的会员体系，可以看作资源。数据分析的权限可以看作资源。<strong>如果将商业系统看作一个操作系统，资源就是所有在这个系统中流通的有价值的东西</strong>。</p><p>有同学可能会认为，一切资源都可以用数据描述，那么<strong>权限控制</strong>也应该会比较简单。比如说某一个推广位到底给哪个商家、到底推广多长时间……</p><p>其实并不是这样，虽然有很多权限可以用数据描述但是并不好控制。比如一个商品，“商家最低可以设置多少价格”就是一件非常不好判断的事情。商品有标品也有非标品，标品的价格好控制，非标品的价格缺少参照。如果平台方不希望花费太多精力在价格治理上，就要想办法让这些不守规则的商家无法盈利。比如说一旦发现恶性价格竞争，或者虚报价格骗钱的情况，需要及时给予商家打击和处罚。</p><p><strong>和权限对应的就是资源</strong>。如果让商家以代理人的身份在操作系统中运行，那么这个代理人可以使用多少资源，就需要有一个访问权限控制列表（Access Control List,，ACL）。这里有一个核心的问题，在传统的 ACL 设计中，是基于权限的管控，而不是权限、内容的发现。而对于设计得优秀的代理人 （Agent），应该是订阅所有的可能性，知道如何获取、申请所有的权限，然后不断思考怎样做更好。对代理人而言，这不是一个权限申请的问题，而是一个最优化策略——思考如何盈利。</p><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><p>商家、组织在操作系统上化身成为代理人，也就是进程。商业操作系统的调度不仅仅体现在给这些代理人足够的计算、存储资源，更重要的是为这些代理人的决策提供上下文以及资源。</p><p>就好像真实的人一样：听到、看到、触摸到，然后做决策。做决策需要策略，一个好的策略可能是赚钱的，而一个坏的策略可能是灾难性的。从人做决策到机器做决策，有一个中间的过程。一开始的目标可以设立在让机器做少量的决策，比如说，机器通过观察近期来到商店用户的行为，决定哪些商品出现在店铺的首页上。但是在做这个决策之前，机器需要先咨询人的意愿。这样就把人当成了决策节点，机器变成了<strong>工具人</strong>。这样做一方面为人节省了时间，一方面也避免了错误。</p><p>再比如说机器可以通过数据预估一个广告位的收益，通过用户集群的画像得知在某个广告位投放店铺广告是否划算。如果机器得到一个正向的结果，可能会通知商家来完成付费和签约。那么问题来了，商家是否可以放心将付费和签约都交给机器呢？</p><p>当然不可以。如果家里急着用钱，可能就无法完成这笔看上去是划算的交易。另外，如果有其他的商家也看上了这个广告位。可能就需要竞价排名，所以需要人和机器的混合决策。</p><p>上述的模式会长期存在，例如设置价格是一个复杂的模型——疫情来了，口罩的销量会上升。机器可以理解这个口罩销量上升的过程，但是机器很难在疫情刚刚开始、口罩销量还没有上升的时候就预判到这个趋势。如果逻辑是确定的，那机器可以帮人做到极致，但如果逻辑不确定呢？如果很多判断是预判，是基于复杂的现实世界产生的思考，那么这就不是机器擅长的领域了。</p><p><strong>所以智能的目标并不是替代人，而是让人更像人、机器更像机器</strong>。</p><p>另外再和你聊一下我自己的观点，以自动驾驶为例。如果一个完全自动驾驶的汽车发生车祸，那么应该由汽车制造商、算法的提供方、自动驾驶设备的提供方、保险公司来共同来承担责任。类比下，如果策略可以售卖，那么提供策略的人就要承担相应的责任。比如说策略出现故障，导致营销券被大量套现，那提供策略方就需要承担相应的赔偿。</p><p>在可预见到的未来，策略也会成为一种可交易的资源。维护一个网上商店，从原材料到生产加工、渠道、物流体系、获客、销售环节，再到售后——以目前的技术水平，可以实现到一种半人工参与的状态。但这样也产生了很多非常现实的问题，比如说，既然开店变得如此容易，那资本为什么不自己开店。这样去培养合格、服务态度更好的店员不是更加容易吗？</p><p>这也是互联网让人深深担忧的原因之一。所有的东西被自动化之后，代表着一种时代的变迁，剩下不能够自动化的，都变成了“节点”。很多过程不需要人参与之后，人就变成了在某些机器无法完成工作的节点上不断重复劳动的工具——这也是近年来小朋友们经常说自己是“工具人”的原因了。</p><p>而且，我们程序员是在推动这样的潮流。因此你可以想象，未来对程序员的需求是很大的。一个普通的商店可能会雇佣一名程序员，花上半年匠心打造某个策略，收费标准可能会像现在的住房装修一样贵。这个策略成功之后还会进行微调，这就是后期的服务费用。完全做到配置化的策略，会因为不够差异化，无法永久盈利。最终在商业市场上竞争的，会是大量将人作为决策节点的 AI。</p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>商业是人类繁荣后的产物，电商是信息时代商业早期形式，未来的发展方向一定是像一个操作系统那样，让每个实体，都可以有自己的策略。用户可以写策略订餐，比如说我每天中午让 AI 帮助我挑选、并订一份午餐。商家写策略运营，比如运营网店。</p><p>至于商业操作系统到底是不是一个噱头？我觉得这是商业的发展方向。操作系统上的进程应该是策略，或者说是机器人。这样的未来也让我深深的焦虑过：它可能让人失去工作，让连接变得扁平，焦虑散播在加速——这些问题都需要解决，而解决需要时间、需要探索。</p><p>如果你有更多的想法可以把你的想法和方案写到留言区，和我一起交流。</p><p>这一讲就到这里，发现求知的乐趣，我是林䭽。感谢你学习本次课程，下一讲我们将学习本专栏的最后一节内容，加餐 | 练习题详解（八）。 再见！</p><p><strong>自己尝试用 Docker 执行一个自己方向的 Web 程序：比如 Spring/Django/Express 等？</strong></p><p>【<strong>解析</strong>】关于如何安装 Docker，你可以参考<a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">这篇文档</a>。然后这里还有一个不错的 SpringBoot+MySQL+Redis 例子，你可以参考<a href="https://github.com/tomoyane/springboot-bestpractice" target="_blank" rel="noopener">这篇内容</a>。</p><p>其他方向可以参考上面例子中的 Compose.yml 去定义自己的环境。 一般开发环境喜欢把所有工具链用 Compose 放到一起，上线的环境数据库一般不会用 Docker 容器。 Docker-Compose 是一个专门用来定义多容器任务的工具，你可以<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">在这里</a>得到。</p><p>国内镜像可以用 Aliyun 的，具体你可以参考<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">这篇文档</a>。</p><p>（注：需要一个账号并且登录）</p><p><strong>为什么会有多个容器共用一个 Pod 的需求</strong>？</p><p>【<strong>解析</strong>】Pod 内部的容器共用一个网络空间，可以通过 localhost 进行通信。另外多个容器，还可以共享一个存储空间。</p><p>比如一个 Web 服务容器，可以将日志、监控数据不断写入共享的磁盘空间，然后由日志服务、监控服务处理将日志上传。</p><p>再比如说一些跨语言的场景，比如一个 Java 服务接收到了视频文件传给一 个 OpenCV 容器进行处理。</p><p>以上这种设计模式，我们称为<strong>边车模式</strong>（Sidecar），边车模式将数个容器放入一个分组内（例如 K8s 的 Pod），让它们可以分配到相同的节点上。这样它们彼此间可以共用磁盘、网络等。</p><p>在边车模式中，有一类容器，被称为<strong>Ambassador Container</strong>，翻译过来是使节容器。对于一个主容器（Main Container）上的服务，可以通过 Ambassador Container 来连接外部服务。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630191158.png" alt="image-20210630191158345"></p><p>我们在开发的时候经常会配置不同的环境。如果每个 Web 应用都要实现一套环境探测程序，比如判断是开发、测试还是线上环境，从而连接不同的 MySQL、Redis 等服务，那么每个项目都需要引入一个公用的库，或者实现一套逻辑。这样我们可以使用一个边车容器，专门提供数据库连接的服务。让连接服务可以自动探测环境，并且从远程读取全局配置，这样每个项目的开发者不需要再关心数据库有多少套环境、如何配置了。</p><h2 id="计算机网络相关"><a href="#计算机网络相关" class="headerlink" title="计算机网络相关"></a>计算机网络相关</h2><h3 id="知识结构"><a href="#知识结构" class="headerlink" title="知识结构"></a>知识结构</h3><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702155902.png" alt="image-20210702155855223"></p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702160902.png" alt="image-20210702160902182"></p><p>模块一：互联网和传输层协议</p><p>介绍互联网的体系和整体框架，参与的硬件设备，以及它们的作用。还会介绍传输层协议 TCP 和 UDP，重点讨论它们的工作原理、算法和优化策略。这部分知识是计算机网络的基础，也最能体现网络设计的精髓。</p><p>模块二：网络层协议</p><p>围绕局域网和 IP 协议展开，包括 ARP、IPv4、IPv6、NAT 等基本概念，探讨 IPv6 的工作原理，以及 IPv6 和 IPv4 的兼容策略。IP 协议几乎是网络层的唯一协议，是大厂面试最为热门的内容之一。模块一和模块二属于基础篇，是计算机网络最底层的基础知识。</p><p>模块三：网络编程</p><p>围绕 Socket 讨论网络编程，介绍各种网络 I/O 模型和编程方式的优缺点，并以 RPC 框架设计为题去落地学到的这些知识和实现。讨论在不同的并发量、针对不同服务特性选择不同的 I/O 模型，调整 TCP 关联的参数，等等，进而帮助你学习如何优化自己系统的网络。这部分内容会为企业带来实际价值，因此面试官会重点提问。</p><p>模块四：Web 技术</p><p>讨论平时使用最多且最重要的应用层协议——HTTP 协议（包括 HTTP 2.0），并扩大讨论范围到 Web 技术生态，比如从 DNS 看缓存、从 CDN 看负载均衡、从 HTTP 协议看开发规范、从流媒体技术看协议选择，以及从爬虫技术看网络安全。</p><p>模块五：网络安全</p><p>讨论网络安全技术，一部分是基础设施，比如证书、加解密、公私钥体系、信任链等；另一部分是具体的攻击手段，比如 DDoS、XSS、SQL 注入、ARP 攻击、中间人攻击等，以及它们的防御手段。安全是所有互联网公司的高压线，学完这块内容能够帮助你屏蔽掉一些高危操作，在工作中避免出现安全问题。</p><p>构成应用程序的 7 种基本元素</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702161329.png" alt="image-20210702161329164"></p><h3 id="什么是蜂窝移动网络？"><a href="#什么是蜂窝移动网络？" class="headerlink" title="什么是蜂窝移动网络？"></a>什么是蜂窝移动网络？</h3><p>网络的组成<br>我们习惯称今天的时代为云时代，整个世界可以看作一张巨大的、立体的网。在这个时代里产生的各种服务，就好像水和电一样，打开即用。透过这张巨大的网去观察，里面还会有一个个小型的网络。你可以想象，用无数个节点构成一个个小型网络，再用小型网络组成中型网络，再组成大型网络，以此类推，最后组成完整的一个如星河般的世界。</p><p>公司内网<br>如果你仔细分析一个小型网络，比如一个公司网络，就会得到下图 1 所示的结构：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702162042.png" alt="image-20210702162042395"></p><p>公司网络从本地网络服务提供商 （Internet Service Provider） 接入，然后内部再分成一个个子网。上图 1 中，你看到的线路，也被称作通信链路（Communication Link），用于传输网络信号。你可以观察到，有的网络节点，同时接入了 2 条以上的链路，这个时候因为路径发生了分叉，数据传输到这些节点需要选择方向，因此我们在这些节点需要进行交换（Switch）。</p><p>数据发生交换的时候，会先从一条链路进入交换设备，然后缓存下来，再转发（切换）到另一条路径，如下图 2 所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702162145.png" alt="image-20210702162145176"></p><p>交换技术的本质，就是让数据切换路径。因为，网络中的数据是以分组或封包（Packet）的形式传输，因此这个技术也称作封包交换技术（Packet Switch）。</p><p>比如说，你要传递一首 2Mb 的 MP3 的歌曲，歌曲本身不是一次传输完成的，而是被拆分成很多个封包。每个封包只有歌曲中的一部分数据，而封包一旦遇到岔路口，就需要封包交换技术帮助每个封包选择最合理的路径。</p><p>在网络中，常见的具有交换能力的设备是路由器（Router）和链路层交换机（Link-Layer Switch）。通常情况下，两个网络可以通过路由器进行连接，多台设备可以通过交换机进行连接。但是路由器通常也具有交换机的功能。</p><p>在上图 1 中，公司内部网络也被分成了多级子网。每个路由器、交换机构成一级子网。最高级的路由器在公司网络的边缘，它可以将网络内部节点连接到其他的网络（网络外部）。本地网络提供商（ISP）提供的互联网先到达边缘的路由器，然后再渗透到内部的网络节点。公司内部的若干服务器可以通过交换机形成一个局域网络；公司内部的办公设备，比如电脑和笔记本，也可以通过无线路由器或者交换机形成局域网络。局域网络之间，可以通过路由器、交换机进行连接，从而构成一个更大的局域网。</p><h4 id="移动网络"><a href="#移动网络" class="headerlink" title="移动网络"></a>移动网络</h4><p>前面我们提到，网络传输需要通信链路（Communication Link），而通信链路是一个抽象概念。这里说的抽象，就是面向对象中抽象类和继承类的关系，比如同轴电缆是通信链路，无线信号的发送接收器可以构成通信链路，蓝牙信道也可以构成通信链路。</p><p>在移动网络中，无线信号构成了通信链路。在移动网络的设计中，通信的核心被称作蜂窝塔（Cellular Tower），有时候也称作基站（BaseStation）。之所以有这样的名称，是因为每个蜂窝塔只覆盖一个六边形的范围，如果要覆盖一个很大的区域就需要很多的蜂窝塔（六边形）排列在一起，像极了蜜蜂的巢穴。这种六边形的结构，可以让信号无死角地覆盖。想象一下，如果是圆形结构，那么圆和圆之间就会有间隙，造成一部分无法覆盖的信号死角，而六边形就完美地解决了这个问题。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163612.png" alt="image-20210702163612575"></p><p>对于构成移动网络最小的网络结构——蜂窝网络来说，构造大体如图</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163639.png" alt="image-20210702163639703"></p><p>图 4 中，国家或全球网络提供商将网络供给处于蜂窝网络边缘的路由器，路由器连接蜂窝塔，再通过蜂窝塔（基站）提供给处于六边形地区中的设备。通常是国家级别的网络服务提供商负责部署基站，比如中国电信、中国联通。将网络提供给一个子网的行为，通常称为网络提供（Network Provider），反过来，对一个子网连接提供商的网络，称为网络接入（Network Access）。</p><p>随着移动网络的发展，一个蜂窝网格中的设备越来越多，也出现了基站覆盖有重叠关系的网格，如下</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163658.png" alt="image-20210702163658239"></p><p>这样设计的好处是，当一个基站过载、出现故障，或者用户设备周边信号出现不稳定，就可以切换到另一个基站的网络，不影响用户继续使用网络服务。</p><p>另一方面，在一定范围内的区域，离用户较近的地方还可以部署服务器，帮助用户完成计算。这相当于计算资源的下沉，称为边缘计算。相比中心化的计算，边缘计算延迟低、链路短，能够将更好的体验带给距离边缘计算集群最近的节点。从而让用户享受到更优质、延迟更低、算力更强的服务。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163712.png" alt="image-20210702163712545"></p><h4 id="家用网络"><a href="#家用网络" class="headerlink" title="家用网络"></a>家用网络</h4><p>还有一个值得讨论的是家用网络。近些年，家用联网设备越来越多。比如说冰箱、空调、扫地机器人、灯光、电动窗帘……</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163732.png" alt="image-20210702163732253"></p><p>家用网络现在已经发展成一种网格状的连接。一方面家用网络会通过路由器接入本地 ISP 提供的网络服务。另一方面，一些设备，比如电脑、笔记本、手机、冰箱等都可以直接和路由器连接。路由器也承担了链路层网关的作用，作为家用电器之间信息的交换设备。</p><p>还有一些家用设备，比如说 10 多块钱的灯泡，不太适合内部再嵌入一个几十块钱可以接收 WI-FI 的芯片，这个时候就可以考虑用蓝牙控制电灯。路由器提供蓝牙不现实，因此一些家用电器也承担了蓝牙设备的控制器——比如说智能音箱。上图 7 中的智能音箱把家用网络带向了一个网格状，有的设备会同时连接路由器（WI-FI）和智能音箱，这样手机和音箱都可以直接控制这些设备。这样的设计，即便网络断开，仍然可以控制这些家用设备。</p><p>最顶部的全球或国家大型的 ISP 之间联网，构成了网络的主干。然后区域性的 ISP 承接主干网络，在这个基础之上再向家庭和公司提供接入服务。移动蜂窝网络因为部署复杂，往往也是由大型 ISP 直接提供。</p><h4 id="数据的传输"><a href="#数据的传输" class="headerlink" title="数据的传输"></a>数据的传输</h4><p>上述的网络结构中，由庞大数目的个人、公司、组织、基站，形成一个个网络。在这些网络中，传递数据不是一件容易的事情。</p><p>为了传递数据，在网络中有几个特别重要的抽象。最终提供服务或者享受服务的设备，称为终端（Terminal），或者端系统（End System），有时候简单称为主机（Host）。比如说：电脑、手机、冰箱、汽车等，我们都可以看作是一个主机（Host）。</p><p>然后，我们可以把网络传输分成两类，一类是端到端（Host-to-Host）的能力，由 TCP/IP 协议群提供。还有一类是广播的能力，是一对多、多对多的能力，可以看作是端到端（Host-to-Host）能力的延伸。</p><p>你可以思考一下，一个北京的主机（Host）向一个深圳的主机（Host）发送消息。那么，中间会穿越大量的网络节点，这些节点可以是路由器、交换机、基站等。在发送消息的过程中，可能跨越很多网络、通过很多边缘，也可能会通过不同的网络提供商提供的网络……而且，传输过程中，可能会使用不同材质的通信链路（Communication Link），比如同轴电缆、双绞线、光纤，或者通过无线传输的 WI-FI、卫星等。</p><p>网络基础设施往往不能一次性传输太大的数据量，因此通常会将数据分片传输。比如传输一个 MP3，我们会将 MP3 内容切分成很多个组，每个组也称作一个封包，英文都是 Packet。这样，如果一个封包损坏，只需要重发损坏的封包，而不需要重发所有数据。你可以类比下中文的活字印刷技术。</p><p>另一方面，网络中两点间的路径非常多，如果一条路径阻塞了，部分封包可以考虑走其他路径。发送端将数据拆分成封包（Packet），封包在网络中遇到岔路，由交换器和路由器节点决定走向，图 9 中是对封包交换技术的一个演示。</p><p><img src="https://s0.lgstatic.com/i/image6/M00/38/82/Cgp9HWB5WbqAVlGaAHeNbdcL7hg030.gif" alt="Packet_Switching.gif"></p><h3 id="TCP-为什么握手是-3-次、挥手是-4-次？"><a href="#TCP-为什么握手是-3-次、挥手是-4-次？" class="headerlink" title="TCP 为什么握手是 3 次、挥手是 4 次？"></a>TCP 为什么握手是 3 次、挥手是 4 次？</h3><p>TCP 协议<br>要想把开篇这道面试题回答得漂亮，我们有必要先说一下概念，然后我再逐字给你解读。</p><p>TCP（Transport Control Protocol）是一个传输层协议，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。</p><p>这里面牵涉很多概念，比如主机到主机、连接、会话、双工/单工及可靠性等，接下来我会为你逐一解释。</p><p>主机到主机（Host-To-Host）<br>TCP 提供的是 Host-To-Host 传输，一台主机通过 TCP 发送数据给另一台主机。这里的主机（Host）是一个抽象的概念，可以是手机、平板、手表等。收发数据的设备都是主机，所以双方是平等的。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703190417.png" alt="image-20210703190410119"></p><p>TCP 协议往上是应用到应用（Application-To-Application）的协议。什么是应用到应用的协议呢？比如你用微信发信息给张三，你的微信客户端、微信聊天服务都是应用。微信有自己的聊天协议，微信的聊天协议是应用到应用的协议；如果微信的聊天协议想要工作，就需要一个主机到主机的协议帮助它实现通信。</p><p>而 TCP 上层有太多的应用，不仅仅有微信，还有原神、抖音、网易云音乐……因此 TCP 上层的应用层协议使用 TCP 能力的时候，需要告知 TCP 是哪个应用——这就是端口号。端口号用于区分应用，下文中我们还会详细讨论。</p><p>TCP 要实现主机到主机通信，就需要知道主机们的网络地址（IP 地址），但是 TCP 不负责实际地址到地址（Address-To-Address）的传输，因此 TCP 协议把 IP 地址给底层的互联网层处理。</p><p>互联网层，也叫网络层（Network Layer），提供地址到地址的通信，IP 协议就在这一层工作。互联网层解决地址到地址的通信，但是不负责信号在具体两个设备间传递。因此，网络层会调用下方的链路层在两个相邻设备间传递信息。当信号在两个设备间传递的时候，科学家又设计出了物理层封装最底层的物理设备、传输介质等，由最下方的物理层提供最底层的传输能力。</p><p>以上的 5 层架构，我们称为互联网协议群，也称作 TCP/IP 协议群。总结下，主机到主机（Host-To-Host）为应用提供应用间通信的能力。</p><p>什么是连接和会话？<br>下一个关联的概念是连接（Connection）——连接是数据传输双方的契约。</p><p>连接是通信双方的一个约定，目标是让两个在通信的程序之间产生一个默契，保证两个程序都在线，而且尽快地响应对方的请求，这就是连接（Connection）。</p><p>设计上，连接是一种传输数据的行为。传输之前，建立一个连接。具体来说，数据收发双方的内存中都建立一个用于维护数据传输状态的对象，比如双方 IP 和端口是多少？现在发送了多少数据了？状态健康吗？传输速度如何？等。所以，连接是网络行为状态的记录。</p><p>和连接关联的还有一个名词，叫作会话（Session），会话是应用的行为。比如微信里张三和你聊天，那么张三和你建立一个会话。你要和张三聊天，你们创建一个聊天窗口，这个就是会话。你开始 Typing，开始传输数据，你和微信服务器间建立一个连接。如果你们聊一段时间，各自休息了，约定先不要关微信，1 个小时后再回来。那么连接会断开，因为聊天窗口没关，所以会话还在。</p><p>在有些系统设计中，会话会自动重连（也就是重新创建连接），或者帮助创建连接。 此外，会话也负责在多次连接中保存状态，比如 HTTP Session 在多次 HTTP 请求（连接）间保持状态（如用户信息）。</p><p>总结下，会话是应用层的概念，连接是传输层的概念。</p><p>双工/单工问题<br>接下来我们聊聊什么是双工/单工。</p><p>在任何一个时刻，如果数据只能单向发送，就是单工，所以单工需要至少一条线路。如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。最后，如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。当然这里的线路，是一个抽象概念，你可以并发地处理信号，达到模拟双工的目的。</p><p>TCP 是一个双工协议，数据任何时候都可以双向传输。这就意味着客户端和服务端可以平等地发送、接收信息。正因为如此，客户端和服务端在 TCP 协议中有一个平等的名词——Host（主机）。</p><p>什么是可靠性？<br>上文提到 TCP 提供可靠性，那么可靠性是什么？</p><p>可靠性指数据保证无损传输。如果发送方按照顺序发送，然后数据无序地在网络间传递，就必须有一种算法在接收方将数据恢复原有的顺序。另外，如果发送方同时要把消息发送给多个接收方，这种情况叫作多播，可靠性要求每个接收方都无损收到相同的副本。多播情况还有强可靠性，就是如果有一个消息到达任何一个接收者，那么所有接受者都必须收到这个消息。说明一下，本专栏中，我们都是基于单播讨论可靠性。</p><p>TCP 的握手和挥手<br>TCP 是一个连接导向的协议，设计有建立连接（握手）和断开连接（挥手）的过程。TCP 没有设计会话（Session），因为会话通常是一个应用的行为。</p><p>TCP 协议的基本操作<br>TCP 协议有这样几个基本操作：</p><p>如果一个 Host 主动向另一个 Host 发起连接，称为 SYN（Synchronization），请求同步；</p><p>如果一个 Host 主动断开请求，称为 FIN（Finish），请求完成；</p><p>如果一个 Host 给另一个 Host 发送数据，称为 PSH（Push），数据推送。</p><p>以上 3 种情况，接收方收到数据后，都需要给发送方一个 ACK（Acknowledgement）响应。请求/响应的模型是可靠性的要求，如果一个请求没有响应，发送方可能会认为自己需要重发这个请求。</p><p>建立连接的过程（三次握手）<br>因为要保持连接和可靠性约束，TCP 协议要保证每一条发出的数据必须给返回，返回数据叫作 ACK（也就是响应）。</p><p>按照这个思路，你可以看看建立连接是不是需要 3 次握手：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703190820.png" alt="image-20210703190819940"></p><p>客户端发消息给服务端（SYN）</p><p>服务端准备好进行连接</p><p>服务端针对客户端的 SYN 给一个 ACK</p><p>你可以能会问，到这里不就可以了吗？2 次握手就足够了。但其实不是，因为服务端还没有确定客户端是否准备好了。比如步骤 3 之后，服务端马上给客户端发送数据，这个时候客户端可能还没有准备好接收数据。因此还需要增加一个过程。</p><p>接下来还会发生以下操作：</p><p>服务端发送一个 SYN 给客户端</p><p>客户端准备就绪</p><p>客户端给服务端发送一个 ACK</p><p>你可能会问，上面不是 6 个步骤吗？ 怎么是 3 次握手呢？下面我们一起分析一下其中缘由。</p><p>步骤 1 是 1 次握手；</p><p>步骤 2 是服务端的准备，不是数据传输，因此不算握手；</p><p>步骤 3 和步骤 4，因为是同时发生的，可以合并成一个 SYN-ACK 响应，作为一条数据传递给客户端，因此是第 2 次握手；</p><p>步骤 5 不算握手；</p><p>步骤 6 是第 3 次握手。</p><p>为了方便你理解步骤 3 和步骤 4，这里我画了一张图。可以看到下图中 SYN 和 ACK 被合并了，因此建立连接一共需要 3 次握手，过程如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703190919.png" alt="image-20210703190919804"></p><p>从上面的例子中，你可以进一步思考 SYN、ACK、PSH 这些常见的标识位（Flag）在传输中如何表示。</p><p>一种思路是为 TCP 协议增加协议头。在协议头中取多个位（bit），其中 SYN、ACK、PSH 都占有 1 个位。比如 SYN 位，1 表示 SYN 开启，0 表示关闭。因此，SYN-ACK 就是 SYN 位和 ACK 位都置 1。这种设计，我们也称为标识（Flag）。标识位是放在 TCP 头部的，关于标识位和 TCP 头的内容，我会在“04 | TCP 的稳定性：滑动窗口和流速控制是怎么回事？”中详细介绍。</p><h4 id="断开连接的过程（4-次挥手）"><a href="#断开连接的过程（4-次挥手）" class="headerlink" title="断开连接的过程（4 次挥手）"></a>断开连接的过程（4 次挥手）</h4><p>继续上面的思路，如果断开连接需要几次握手？给你一些提示，你可以在脑海中这样构思。</p><p>客户端要求断开连接，发送一个断开的请求，这个叫作（FIN）。</p><p>服务端收到请求，然后给客户端一个 ACK，作为 FIN 的响应。</p><p>这里你需要思考一个问题，可不可以像握手那样马上传 FIN 回去？<br>其实这个时候服务端不能马上传 FIN，因为断开连接要处理的问题比较多，比如说服务端可能还有发送出去的消息没有得到 ACK；也有可能服务端自己有资源要释放。因此断开连接不能像握手那样操作——将两条消息合并。所以，服务端经过一个等待，确定可以关闭连接了，再发一条 FIN 给客户端。</p><p>客户端收到服务端的 FIN，同时客户端也可能有自己的事情需要处理完，比如客户端有发送给服务端没有收到 ACK 的请求，客户端自己处理完成后，再给服务端发送一个 ACK。</p><p>经过以上分析，就可以回答上面这个问题了。是不是刚刚好 4 次挥手？过程如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191322.png" alt="image-20210703191322634"></p><p>总结<br>在学习 3 次握手、4 次挥手时，你一定要理解为什么这么设计，而不是死记硬背。最后。我们一起总结一下今天的重点知识。</p><p>TCP 提供连接（Connection），让双方的传输更加稳定、安全。</p><p>TCP 没有直接提供会话，因为应用对会话的需求多种多样，比如聊天程序会话在保持双方的聊天记录，电商程序会话在保持购物车、订单一致，所以会话通常在 TCP 连接上进一步封装，在应用层提供。</p><p>TCP 是一个面向连接的协议（Connection -oriented Protocol），说的就是 TCP 协议参与的双方（Host）在收发数据之前会先建立连接。后面我们还会学习 UDP 协议，UDP 是一个面向报文（Datagram-oriented）的协议——协议双方不需要建立连接，直接传送报文（数据）。</p><p>最后，连接需要消耗更多的资源。比如说，在传输数据前，必须先协商建立连接。因此，不是每种场景都应该用连接导向的协议。像视频播放的场景，如果使用连接导向的协议，服务端每向客户端推送一帧视频，客户端都要给服务端一次响应，这是不合理的。</p><p>TCP 为什么是 3 次握手，4 次挥手？</p><p>【解析】TCP 是一个双工协议，为了让双方都保证，建立连接的时候，连接双方都需要向对方发送 SYC（同步请求）和 ACK（响应）。</p><p>握手阶段双方都没有烦琐的工作，因此一方向另一方发起同步（SYN）之后，另一方可以将自己的 ACK 和 SYN 打包作为一条消息回复，因此是 3 次握手——需要 3 次数据传输。</p><p>到了挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上响应（ACK），表示接收到了挥手请求。类比现实世界中，你收到一个 Offer，出于礼貌你先回复考虑一下，然后思考一段时间再回复 HR 最后的结果。最后等所有工作结束，再发送请求中断连接（FIN），因此是 4 次挥手。</p><h4 id="一台内存在-8G-左右的服务器，可以同时维护多少个连接？"><a href="#一台内存在-8G-左右的服务器，可以同时维护多少个连接？" class="headerlink" title="一台内存在 8G 左右的服务器，可以同时维护多少个连接？"></a>一台内存在 8G 左右的服务器，可以同时维护多少个连接？</h4><blockquote><p>tcp连接数上限其实受限于机器的内存，以8G内存为例，假设一个tcp连接需要占用的最小内存是8k（发送接收缓存各4k，当然还要考虑socket描述符），那么最大连接数为：8<em>1024</em>1024/8=1048576个，即约100万个tcp长连接。不过这只是理论数值，并未考虑实际业务。</p></blockquote><blockquote><p>http为什么是单工，ws是双工？</p><p>http应用层设计就请求/响应模型。这个模型比较好理解，或者说符合用户打开一次浏览器，开一张页面的逻辑。ws应用层设计是聊天用的，当然就得是双工。是需求解决的了最终的选择，而不能反过来思考。</p></blockquote><h3 id="TCP-为什么要粘包和拆包？"><a href="#TCP-为什么要粘包和拆包？" class="headerlink" title="TCP 为什么要粘包和拆包？"></a>TCP 为什么要粘包和拆包？</h3><p>如今，大半个互联网都建立在 TCP 协议之上，我们使用的 HTTP 协议、消息队列、存储、缓存，都需要用到 TCP 协议——这是因为 TCP 协议提供了可靠性。简单来说，可靠性就是让数据无损送达。但若是考虑到成本，就会变得非常复杂——因为还需要尽可能地提升吞吐量、降低延迟、减少丢包率。</p><p>TCP 协议具有很强的实用性，而可靠性又是 TCP 最核心的能力，所以理所当然成为面试官们津津乐道的问题。具体来说，从一个终端有序地发出多个数据包，经过一个复杂的网络环境，到达目的地的时候会变得无序，而可靠性要求数据恢复到原始的顺序。这里我先给你提出两个问题：</p><p>TCP 协议是如何恢复数据的顺序的？</p><p>拆包和粘包的作用是什么？</p><p>下面请你带着这两个问题开始今天的学习。</p><p>TCP 的拆包和粘包<br>TCP 是一个传输层协议。TCP 发送数据的时候，往往不会将数据一次性发送，像下图这样：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191719.png" alt="image-20210703191719119"></p><p>而是将数据拆分成很多个部分，然后再逐个发送。像下图这样：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191730.png" alt="image-20210703191730616"></p><p>同样的，在目的地，TCP 协议又需要逐个接收数据。请你思考，TCP 为什么不一次发送完所有的数据？比如我们要传一个大小为 10M 的文件，对于应用层而言，就是一次传送完成的。而传输层的协议为什么不选择将这个文件一次发送完呢？</p><p>这里有很多原因，比如为了稳定性，一次发送的数据越多，出错的概率越大。再比如说为了效率，网络中有时候存在着并行的路径，拆分数据包就能更好地利用这些并行的路径。再有，比如发送和接收数据的时候，都存在着缓冲区。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191833.png" alt="image-20210703191833025"></p><p>缓冲区是在内存中开辟的一块区域，目的是缓冲。因为大量的应用频繁地通过网卡收发数据，这个时候，网卡只能一个一个处理应用的请求。当网卡忙不过来的时候，数据就需要排队，也就是将数据放入缓冲区。如果每个应用都随意发送很大的数据，可能导致其他应用实时性遭到破坏。</p><p>还有一些原因我们在《重学操作系统》专栏的“24 | 虚拟内存 ：一个程序最多能使用多少内存？”中讨论过。比如内存的最小分配单位是页表，如果数据的大小超过一个页表，可能会存在页面置换问题，造成性能的损失。如果你对这一部分的知识感兴趣，可以学习我在拉勾教育推出的《重学操作系统》专栏。</p><p>总之，方方面面的原因：在传输层封包不能太大。这种限制，往往是以缓冲区大小为单位的。也就是 TCP 协议，会将数据拆分成不超过缓冲区大小的一个个部分。每个部分有一个独特的名词，叫作 TCP 段（TCP Segment）。</p><p>在接收数据的时候，一个个 TCP 段又被重组成原来的数据。</p><p>像这样，数据经过拆分，然后传输，然后在目的地重组，俗称拆包。所以拆包是将数据拆分成多个 TCP 段传输。那么粘包是什么呢？有时候，如果发往一个目的地的多个数据太小了，为了防止多次发送占用资源，TCP 协议有可能将它们合并成一个 TCP 段发送，在目的地再还原成多个数据，这个过程俗称粘包。所以粘包是将多个数据合并成一个 TCP 段发送。</p><p>TCP Segment<br>那么一个 TCP 段长什么样子呢？下图是一个 TCP 段的格式：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703192001.png" alt="image-20210703192000920"></p><p>我们可以看到，TCP 的很多配置选项和数据粘在了一起，作为一个 TCP 段。</p><p>显然，让你把每一部分都记住似乎不太现实，但是我会带你把其中最主要的部分理解。TCP 协议就是依靠每一个 TCP 段工作的，所以你每认识一个 TCP 的能力，几乎都会找到在 TCP Segment 中与之对应的字段。接下来我先带你认识下它们。</p><p>Source Port/Destination Port 描述的是发送端口号和目标端口号，代表发送数据的应用程序和接收数据的应用程序。比如 80 往往代表 HTTP 服务，22 往往是 SSH 服务……</p><p>Sequence Number 和 Achnowledgment Number 是保证可靠性的两个关键。具体见下文的讨论。</p><p>Data Offset 是一个偏移量。这个量存在的原因是 TCP Header 部分的长度是可变的，因此需要一个数值来描述数据从哪个字节开始。</p><p>Reserved 是很多协议设计会保留的一个区域，用于日后扩展能力。</p><p>URG/ACK/PSH/RST/SYN/FIN 是几个标志位，用于描述 TCP 段的行为。也就是一个 TCP 封包到底是做什么用的？</p><p>1）URG 代表这是一个紧急数据，比如远程操作的时候，用户按下了 Ctrl+C，要求终止程序，这种请求需要紧急处理。</p><p>2）ACK 代表响应，我们在“02 | 传输层协议 TCP：TCP 为什么握手是 3 次、挥手是 4 次？”讲到过，所有的消息都必须有 ACK，这是 TCP 协议确保稳定性的一环。</p><p>3）PSH 代表数据推送，也就是在传输数据的意思。</p><p>4）SYN 同步请求，也就是申请握手。</p><p>5）FIN 终止请求，也就是挥手。</p><p>特别说明一下：以上这 5 个标志位，每个占了一个比特，可以混合使用。比如 ACK 和 SYN 同时为 1，代表同步请求和响应被合并了。这也是 TCP 协议，为什么是三次握手的原因之一。</p><p>6） Window 也是 TCP 保证稳定性并进行流量控制的工具，我们会在“04 | TCP 的稳定性：滑动窗口和流速控制是怎么回事？”中详细介绍。</p><p>7）Checksum 是校验和，用于校验 TCP 段有没有损坏。</p><p>8）Urgent Pointer 指向最后一个紧急数据的序号（Sequence Number）。它存在的原因是：有时候紧急数据是连续的很多个段，所以需要提前告诉接收方进行准备。</p><p>9）Options 中存储了一些可选字段，比如接下来我们要讨论的 MSS（Maximun Segment Size）。<br>10）Padding 存在的意义是因为 Options 的长度不固定，需要 Pading 进行对齐。</p><h4 id="Sequence-Number-和-Acknowledgement-Number"><a href="#Sequence-Number-和-Acknowledgement-Number" class="headerlink" title="Sequence Number 和 Acknowledgement Number"></a>Sequence Number 和 Acknowledgement Number</h4><p>在 TCP 协议的设计当中，数据被拆分成很多个部分，部分增加了协议头。合并成为一个 TCP 段，进行传输。这个过程，我们俗称拆包。这些 TCP 段经过复杂的网络结构，由底层的 IP 协议，负责传输到目的地，然后再进行重组。</p><p>这里请你思考一个问题：稳定性要求数据无损地传输，也就是说拆包获得数据，又需要恢复到原来的样子。而在复杂的网络环境当中，即便所有的段是顺序发出的，也不能保证它们顺序到达，因此，发出的每一个 TCP 段都需要有序号。这个序号，就是 Sequence Number（Seq）。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703192457.png" alt="image-20210703192457555"></p><p>如上图所示。发送数据的时候，为每一个 TCP 段分配一个自增的 Sequence Number。接收数据的时候，虽然得到的是乱序的 TCP 段，但是可以通过 Seq 进行排序。</p><p>但是这样又会产生一个新的问题——接收方如果要回复发送方，也需要这个 Seq。而网络的两个终端，去同步一个自增的序号是非常困难的。因为任何两个网络主体间，时间都不能做到完全同步，又没有公共的存储空间，无法共享数据，更别说实现一个分布式的自增序号了。</p><p>其实这个问题的本质就好像两个人在说话一样，我们要确保他们说出去的话，和回答之间的顺序。因为 TCP 是一个双工的协议，两边可能会同时说话。所以聪明的科学家想到了确定一句话的顺序，需要两个值去描述——也就是发送的字节数和接收的字节数。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703211701.png" alt="image-20210703211701115"></p><p>我们重新定义一下 Seq（如上图所示），对于任何一个接收方，如果知道了发送者发送某个 TCP 段时，已经发送了多少字节的数据，那么就可以确定发送者发送数据的顺序。</p><p>但是这里有一个问题。如果接收方也向发送者发送了数据请求（或者说双方在对话），接收方就不知道发送者发送的数据到底对应哪一条自己发送的数据了。</p><p>举个例子：下面 A 和 B 的对话中，我们可以确定他们彼此之间接收数据的顺序。但是无法确定数据之间的关联关系，所以只有 Sequence Number 是不够的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A：今天天气好吗？</span><br><span class="line"></span><br><span class="line">A：今天你开心吗？</span><br><span class="line"></span><br><span class="line">B：开心</span><br><span class="line"></span><br><span class="line">B：天气不好</span><br></pre></td></tr></table></figure><p>人类很容易理解这几句话的顺序，但是对于机器来说就需要特别的标注。因此我们还需要另一个数据，就是每个 TCP 段发送时，发送方已经接收了多少数据。用 Acknowledgement Number 表示，下面简写为 ACK。</p><p>下图中，终端发送了三条数据，并且接收到四条数据，通过观察，根据接收到的数据中的 Seq 和 ACK，将发送和接收的数据进行排序。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210705220326.png" alt="image-20210705220326603"></p><p>例如上图中，发送方发送了 100 字节的数据，而接收到的（Seq = 0 和 Seq =100）的两个封包，都是针对发送方（Seq = 0）这个封包的。发送 100 个字节，所以接收到的 ACK 刚好是 100。说明（Seq= 0 和 Seq= 100）这两个封包是针对接收到第 100 个字节数据后，发送回来的。这样就确定了整体的顺序。</p><p><strong>注意，无论 S\</strong>**eq**<em>\</em> 还是 ACK，都是针对“对方”而言的。是对方发送的数据和对方接收到的数据**。我们在实际的工作当中，可以通过 Whireshark 调试工具观察两个 TCP 连接的 Seq和 ACK。</p><p>具体的使用方法，我会在“09 | TCP 实战：如何进行 TCP 抓包调试？”中和你讨论。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210705220350.png" alt="image-20210705220349944"></p><h4 id="MSS（Maximun-Segment-Size）"><a href="#MSS（Maximun-Segment-Size）" class="headerlink" title="MSS（Maximun Segment Size）"></a>MSS（Maximun Segment Size）</h4><p>接下来，我们讨论下 MSS，它也是面试经常会问到的一个 TCP Header 中的可选项（Options），这个可选项控制了 TCP 段的大小，它是一个协商字段（Negotiate）。协议是双方都要遵循的标准，因此配置往往不能由单方决定，需要双方协商。</p><p>TCP 段的大小（MSS）涉及发送、接收缓冲区的大小设置，双方实际发送接收封包的大小，对拆包和粘包的过程有指导作用，因此需要双方去协商。</p><p>如果这个字段设置得非常大，就会带来一些影响。</p><p>首先对方可能会拒绝，作为服务的提供方，你可能不会愿意接收太大的 TCP 段。<strong>因为大的 TCP 段，会降低性能，比如内存使用的性能</strong>。具体你可以参考<a href="https://shenceyun.lagou.com/t/Axo?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">《重学操作系统》</a>课程中关于页表的讨论。</p><ul><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4633&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">24 | 虚拟内存 ：一个程序最多能使用多少内存？</a></li><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4634&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">25 | 内存管理单元： 什么情况下使用大内存分页？</a></li><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4635&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">26 | 缓存置换算法： LRU 用什么数据结构实现更合理？</a></li></ul><p>还有就是<strong>资源的占用</strong>。一个用户占用服务器太多的资源，意味着其他的用户就需要等待或者降低他们的服务质量。</p><p><strong>其次，支持 TCP 协议工作的 IP 协议，工作效率会下降</strong>。TCP 协议不肯拆包，IP 协议就需要拆出大量的包。那么 IP 协议为什么需要拆包呢？这是因为在网络中，每次能够传输的数据不可能太大，这受限于具体的网络传输设备，也就是物理特性。但是 IP 协议，拆分太多的封包并没有意义。因为可能会导致属于同个 TCP 段的封包被不同的网络路线传输，这会加大延迟。同时，拆包，还需要消耗硬件和计算资源。</p><p>那是不是 MSS 越小越好呢？MSS 太小的情况下，会浪费传输资源（降低吞吐量）。因为数据被拆分之后，每一份数据都要增加一个头部。如果 MSS 太小，那头部的数据占比会上升，这让吞吐量成为一个灾难。<strong>所以在使用的过程当中，MSS 的配置，往往都是一个折中的方案</strong>。而根据 Unix 的哲学，不要去猜想什么样的方案是最合理的，而是要尝试去用实验证明它，一切都要用实验依据说话。</p><h4 id="TCP-协议是如何恢复数据的顺序的，TCP-拆包和粘包的作用是什么？"><a href="#TCP-协议是如何恢复数据的顺序的，TCP-拆包和粘包的作用是什么？" class="headerlink" title="TCP 协议是如何恢复数据的顺序的，TCP 拆包和粘包的作用是什么？"></a><strong>TCP 协议是如何恢复数据的顺序的，TCP 拆包和粘包的作用是什么</strong>？</h4><p>TCP 拆包的作用是将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力。拆包过程需要保证数据经过网络的传输，又能恢复到原始的顺序。这中间，需要数学提供保证顺序的理论依据。TCP 利用（发送字节数、接收字节数）的唯一性来确定封包之间的顺序关系。具体的算法，我们会在下一讲“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=837#/detail/pc?id=7268" target="_blank" rel="noopener">04 | TCP 的稳定性解决方案 ：滑动窗口和流量控制是怎么回事？</a>”中给出。粘包是为了防止数据量过小，导致大量的传输，而将多个 TCP 段合并成一个发送。</p><h3 id="滑动窗口和流速控制是怎么回事？"><a href="#滑动窗口和流速控制是怎么回事？" class="headerlink" title="滑动窗口和流速控制是怎么回事？"></a><strong>滑动窗口和流速控制是怎么回事？</strong></h3><p><strong>TCP 作为一个传输层协议，最核心的能力是传输。传输需要保证可靠性，还需要控制流速，这两个核心能力均由滑动窗口提供</strong>。而滑动窗口中解决的问题，是你在今后的工作中可以长期使用的，比如设计一个分布式的 RPC 框架、实现一个消息队列或者分布式的文件系统等。</p><p>所以请你带着今天的问题“<strong>滑动窗口和流速控制是怎么回事？</strong>”开始今天的学习吧！</p><h4 id="请求-响应模型"><a href="#请求-响应模型" class="headerlink" title="请求/响应模型"></a>请求/响应模型</h4><p>TCP 中每个发送的请求都需要响应。如果一个请求没有收到响应，发送方就会认为这次发送出现了故障，会触发重发。</p><p>大体的模型，和下图很像。但是如果完全和下图一样，每一个请求收到响应之后，再发送下一个请求，吞吐量会很低。因为这样的设计，会产生网络的空闲时间，说白了，就是浪费带宽。带宽没有用满，意味着可以同时发送更多的请求，接收更多的响应。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104250.png" alt="image-20210706104250605"></p><p>一种改进的方式，就是让发送方有请求就发送出去，而不是等待响应。通过这样的处理方式，发送的数据连在了一起，响应的数据也连在了一起，吞吐量就提升了。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104304.png" alt="image-20210706104304375"></p><p>但是如果可以同时发送的数据真的非常多呢？比如成百上千个 TCP 段都需要发送，这个时候带宽可能会不足。很多个数据封包都需要发送，该如何处理呢？</p><h4 id="排队（Queuing）"><a href="#排队（Queuing）" class="headerlink" title="排队（Queuing）"></a>排队（Queuing）</h4><p>在这种情况下，通常我们会考虑<strong>排队（Queuing）机制</strong>。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104409.png" alt="image-20210706104408978"></p><p>考虑这样一个模型，如上图所示，在 TCP 层实现一个队列。新元素从队列的一端（左侧）排队，作为一个未发送的数据封包。开始发送的数据封包，从队列的右侧离开。你可以思考一下，这个模型有什么问题吗？</p><p>这样做就需要多个队列，我们要将未发送的数据从队列中取出，加入发送中的队列。然后再将发送中的数据，收到 ACK 的部分取出，放入已接收的队列。而发送中的封包，何时收到 ACK 是一件不确定的事情，这样使用队列似乎也有一定的问题。</p><h4 id="滑动窗口（Sliding-Window）"><a href="#滑动窗口（Sliding-Window）" class="headerlink" title="滑动窗口（Sliding Window）"></a>滑动窗口（Sliding Window）</h4><p>在上面的模型当中，我们之所以觉得算法不好设计，是因为用错了数据结构。有个说法叫作如果程序写复杂了，那就是写错了。这里其实应该用一种叫作<strong>滑动窗口的数据结构</strong>去实现。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104440.png" alt="image-20210706104440133"></p><p>如上图所示：</p><ul><li>深绿色代表已经收到 ACK 的段</li><li>浅绿色代表发送了，但是没有收到 ACK 的段</li><li>白色代表没有发送的段</li><li>紫色代表暂时不能发送的段</li></ul><p>下面我们重新设计一下不同类型封包的顺序，将已发送的数据放到最左边，发送中的数据放到中间，未发送的数据放到右边。假设我们最多同时发送 5 个封包，也就是窗口大小 = 5。窗口中的数据被同时发送出去，然后等待 ACK。如果一个封包 ACK 到达，我们就将它标记为已接收（深绿色）。</p><p>如下图所示，有两个封包的 ACK 到达，因此标记为绿色。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104531.png" alt="image-20210706104531057"></p><p>这个时候滑动窗口可以向右滑动，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104544.png" alt="image-20210706104544432"></p><h4 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h4><p>如果发送过程中，部分数据没能收到 ACK 会怎样呢？这就可能发生重传。</p><p>如果发生下图这样的情况，段 4 迟迟没有收到 ACK。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104643.png" alt="image-20210706104643825"></p><p>这个时候滑动窗口只能右移一个位置，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104659.png" alt="image-20210706104659658"></p><p>在这个过程中，如果后来段 4 重传成功（接收到 ACK），那么窗口就会继续右移。如果段 4 发送失败，还是没能收到 ACK，那么接收方也会抛弃段 5、段 6、段 7。这样从段 4 开始之后的数据都需要重发。</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>在 TCP 协议中，如果接收方想丢弃某个段，可以选择不发 ACK。发送端超时后，会重发这个 TCP 段。而有时候，接收方希望催促发送方尽快补发某个 TCP 段，这个时候可以使用<strong>快速重传</strong>能力。</p><p>例如段 1、段 2、段 4 到了，但是段 3 没有到。 接收方可以发送多次段 3 的 ACK。如果发送方收到多个段 3 的 ACK，就会重发段 3。这个机制称为<strong>快速重传</strong>。这和超时重发不同，是一种催促的机制。</p><p>为了不让发送方误以为段 3 已经收到了，在快速重传的情况下，接收方即便收到发来的段 4，依然会发段 3 的 ACK（不发段 4 的 ACK），直到发送方把段 3 重传。</p><h4 id="窗口大小的单位是？"><a href="#窗口大小的单位是？" class="headerlink" title="窗口大小的单位是？"></a>窗口大小的单位是？</h4><p>请你思考另一个问题，窗口大小的单位是多少呢？在上面所有的图片中，窗口大小是 TCP 段的数量。<strong>实际操作中，每个 TCP 段的大小不同，限制数量会让接收方的缓冲区不好操作，因此实际操作中窗口大小单位是字节数</strong>。</p><h4 id="流速控制"><a href="#流速控制" class="headerlink" title="流速控制"></a>流速控制</h4><p><strong>发送、接收窗口的大小可以用来控制 TCP 协议的流速</strong>。窗口越大，同时可以发送、接收的数据就越多，支持的吞吐量也就越大。当然，窗口越大，如果数据发生错误，损失也就越大，因为需要重传越多的数据。</p><p>举个例子：我们用 RTT 表示 Round Trip Time，就是消息一去一回的时间。</p><p>假设 RTT = 1ms，带宽是 1mb/s。如果窗口大小为 1kb，那么 1ms 可以发送一个 1kb 的数据（含 TCP 头），1s 就可以发送 1mb 的数据，刚好可以将带宽用满。如果 RTT 再慢一些，比如 RTT = 10ms，那么这样的设计就只能用完 1/10 的带宽。 当然你可以提高窗口大小提高吞吐量，但是实际的模型会比这个复杂，因为还存在重传、快速重传、丢包等因素。</p><p>而实际操作中，也不可以真的把带宽用完，所以最终我们会使用折中的方案，在延迟、丢包率、吞吐量中进行选择，毕竟鱼和熊掌不可兼得。</p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>为了提高传输速率，TCP 协议选择将多个段同时发送，为了让这些段不至于被接收方拒绝服务，在发送前，双方要协商好发送的速率。但是我们不可能完全确定网速，所以协商的方式，就变成确定窗口大小。</p><p>有了窗口，发送方利用滑动窗口算法发送消息；接收方构造缓冲区接收消息，并给发送方 ACK。滑动窗口的实现只需要数组和少量的指针即可，是一个非常高效的算法。像这种算法，简单又实用，比如求一个数组中最大的连续 k 项和，就可以使用滑动窗口算法。如果你对这个问题感兴趣，不妨用你最熟悉的语言尝试解决一下。</p><p><strong>滑动窗口和流速控制是怎么回事</strong>？</p><p><strong>滑动窗口是 TCP 协议控制可靠性的核心</strong>。发送方将数据拆包，变成多个分组。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出（FIFO）的顺序，但是窗口中的分组会一次性发送。窗口中序号最小的分组如果收到 ACK，窗口就会发生滑动；如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送。</p><p>另一方面，在多次传输中，网络的平均延迟往往是相对固定的，这样 TCP 协议可以通过双方协商窗口大小控制流速。补充下，上面我们说的分组和 TCP 段是一个意思。</p><h3 id="TCP-协议和-UDP-协议的优势和劣势？"><a href="#TCP-协议和-UDP-协议的优势和劣势？" class="headerlink" title="TCP 协议和 UDP 协议的优势和劣势？"></a><strong>TCP 协议和 UDP 协议的优势和劣势？</strong></h3><p>TCP 和 UDP 是今天应用最广泛的传输层协议，拥有最核心的垄断地位。<strong>TCP 最核心的价值是提供了可靠性，而 UDP 最核心的价值是灵活，你几乎可以用它来做任何事情</strong>。例如：HTTP 协议 1.1 和 2.0 都基于 TCP，而到了 HTTP 3.0 就开始用 UDP 了。</p><p>如果你打开 <a href="https://tools.ietf.org/html/rfc793?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">TCP 协议的 RFC</a><a href="https://tools.ietf.org/html/rfc793?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">文档</a>，可以看到目录中一共有 85 页；如果你打开 <a href="https://tools.ietf.org/html/rfc768?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">UDP 的 RFC 文档</a>，会看到目录中只有 3 页。一个只有 3 页的协议，能够成为今天最主流的传输层协议之一，那么它一定有非常值得我们学习的地方。</p><h4 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h4><p>UDP（User Datagram Protocol），目标是在传输层提供直接发送报文（Datagram）的能力。Datagram 是数据传输的最小单位。UDP 协议不会帮助拆分数据，它的目标只有一个，就是发送报文。</p><p>有细心的同学可能会问： 为什么不直接调用 IP 协议呢？ 如果裸发数据，IP 协议不香吗？</p><p>这是因为传输层协议在承接上方应用层的调用，需要提供应用到应用的通信——因此要附上端口号。每个端口，代表不同的应用。传输层下层的 IP 协议，承接传输层的调用，将数据从主机传输到主机。IP 层不能区分应用，导致哪怕是在 IP 协议上进行简单封装，也需要单独一个协议。这就构成了 UDP 协议的市场空间。</p><h4 id="UDP-的封包格式"><a href="#UDP-的封包格式" class="headerlink" title="UDP 的封包格式"></a>UDP 的封包格式</h4><p>UDP 的设计目标就是在允许用户直接发送报文的情况下，最大限度地简化应用的设计。下图是 UDP 的报文格式。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802114305.png" alt="image-20210802114257947"></p><p>你可以看到，UDP 的报文非常简化，只有 5 个部分。</p><p>Source Port 是源端口号。因为 UDP 协议的特性（不需要 ACK），因此这个字段是可以省略的。但有时候对于防火墙、代理来说，Source Port 有很重要的意义，它们需要用这个字段行过滤和路由。</p><p>Destination Port 是目标端口号（这个字段不可以省略）。</p><p>Length 是消息体长度。</p><p>Checksum 是校验和，作用是检查封包是否出错。</p><p>Data octets 就是一个字节一个字节的数据，Octet 是 8 位。</p><p>下面我们先简单聊聊校验和（Checksum）机制，这个机制在很多的网络协议中都会存在，因为校验数据在传输过程中有没有丢失、损坏是一个普遍需求。在一次网络会话中，我们传输的内容可能是：“你好！”，但事实上传输的是 01 组成的二进制。请你思考这样一个算法，我们把数据分成一个一个 byte，然后将所有 byte 相加，再将最终的结果取反。</p><p>比如现在数据有 4 个 byte：a,b,c,d，那么一种最简单的校验和就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksum=(a+b+c+d) ^ 0xff</span><br></pre></td></tr></table></figure><p>如果发送方用上述方式计算出 Checksum，并将 a,b,c,d 和 Checksum 一起发送给接收方，接收方就可以用同样的算法再计算一遍，这样就可以确定数据有没有发生损坏（变化）。当然 Checksum 的做法，只适用于数据发生少量变化的情况。如果数据发生较大的变动，校验和也可能发生碰撞。</p><p>你可以看到 UDP 的可靠性保证仅仅就是 Checksum 一种。如果一个数据封包 Datagram 发生了数据损坏，UDP 可以通过 Checksum 纠错或者修复。 但是 UDP 没有提供再多的任何机制，比如 ACK、顺序保证以及流控等。</p><h4 id="UDP-与-TCP的区别"><a href="#UDP-与-TCP的区别" class="headerlink" title="UDP 与 TCP的区别"></a>UDP 与 TCP的区别</h4><p>接下来我们说说 UDP 和 TCP 的区别。</p><ol><li><p>目的差异<br>首先，这两个协议的目的不同：TCP 协议的核心目标是提供可靠的网络传输，而 UDP 的目标是在提供报文交换能力基础上尽可能地简化协议轻装上阵。</p></li><li><p>可靠性差异<br>TCP 核心是要在保证可靠性提供更好的服务。TCP 会有握手的过程，需要建立连接，保证双方同时在线。而且TCP 有时间窗口持续收集无序的数据，直到这一批数据都可以合理地排序组成连续的结果。</p></li></ol><p>UDP 并不具备以上这些特性，它只管发送数据封包，而且 UDP 不需要 ACK，这意味着消息发送出去成功与否 UDP 是不管的。</p><ol start="3"><li><p>连接 vs 无连接<br>TCP 是一个面向连接的协议（Connection-oriented Protocol），传输数据必须先建立连接。 UDP 是一个无连接协议（Connection-less Protocol），数据随时都可以发送，只提供发送封包（Datagram）的能力。</p></li><li><p>流控技术（Flow Control）<br>TCP 使用了流控技术来确保发送方不会因为一次发送过多的数据包而使接收方不堪重负。TCP 在发送缓冲区中存储数据，并在接收缓冲区中接收数据。当应用程序准备就绪时，它将从接收缓冲区读取数据。如果接收缓冲区已满，接收方将无法处理更多数据，并将其丢弃。UDP 没有提供类似的能力。</p></li><li><p>传输速度<br>UDP 协议简化，封包小，没有连接、可靠性检查等，因此单纯从传输速度上讲，UDP 更快。</p></li><li><p>场景差异<br>TCP 每个数据封包都需要确认，因此天然不适应高速数据传输场景，比如观看视频（流媒体应用）、网络游戏（TCP 有延迟）等。具体来说，如果网络游戏用 TCP，每个封包都需要确认，可能会造成一定的延迟；再比如音、视频传输天生就允许一定的丢包率；Ping 和 DNSLookup，这类型的操作只需要一次简单的请求/返回，不需要建立连接，用 UDP 就足够了。</p></li></ol><p>近些年有一个趋势，TCP/UDP 的边界逐渐变得模糊，UDP 应用越来越多。比如传输文件，如果考虑希望文件无损到达，可以用 TCP。如果考虑希望传输足够块，就可能会用 UDP。再比如 HTTP 协议，如果考虑请求/返回的可靠性，用 TCP 比较合适。但是像 HTTP 3.0 这类应用层协议，从功能性上思考，暂时没有找到太多的优化点，但是想要把网络优化到极致，就会用 UDP 作为底层技术，然后在 UDP 基础上解决可靠性。</p><p>所以理论上，任何一个用 TCP 协议构造的成熟应用层协议，都可以用 UDP 重构。这就好比，本来用一个工具可以解决所有问题，但是如果某一类问题体量非常大，就会专门为这类问题创造工具。因此，UDP 非常适合需要定制工具的场景。</p><p>下面我把场景分成三类，TCP 应用场景、UDP 应用场景、模糊地带（TCP、UDP 都可以考虑），你可以参考。</p><p>第一类：TCP 场景</p><p>远程控制（SSH）</p><p>File Transfer Protocol（FTP）</p><p>邮件（SMTP、IMAP）等</p><p>点对点文件传出（微信等）</p><p>第二类：UDP 场景</p><p>网络游戏</p><p>音视频传输</p><p>DNS</p><p>Ping</p><p>直播</p><p>第三类：模糊地带</p><p>HTTP（目前以 TCP 为主）</p><p>文件传输</p><p>以上我们从多个方面了解了 TCP 和 UDP 的区别，最后再来总结一下。UDP 不提供可靠性，不代表我们不能解决可靠性。UDP 的核心价值是灵活、轻量，构造了最小版本的传输层协议。在这个之上，还可以实现连接（Connection），实现会话（Session），实现可靠性（Reliability）……</p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>这一讲我们针对 UDP 协议的内容进行了探讨，到这里互联网协议群的传输层讲解就结束了。协议对于我们来说是非常重要的，协议的制定让所有参与者一致、有序地工作。</p><p>学习协议的设计，对你的工作非常有帮助。比如：</p><p>学习 TCP 协议可以培养你思维的缜密性——序号的设计、滑动窗口的设计、快速重发的设计、内在状态机的设计，都是非常精妙的想法；</p><p>学习 UDP 协议可以带动我们反思自己的技术架构，有时候简单的工具更受欢迎。Linux 下每个工具都是那么简单、专注，容易理解。相比 TCP 协议，UDP 更容易理解。</p><p>从程序架构上来说，今天我们更倾向于简单专注的设计，我们更期望有解决报文传输的工具、有解决可靠性的工具、有解决流量控制的工具、有解决连接和会话的工具……我相信这应该是未来的趋势——由大量优质的工具逐渐取代历史上沉淀下来完整统一的系统。从这个角度，我希望通过学习传输层的知识，能够帮助你重新审视自己的系统设计，看看自己还有哪些进步的空间。</p><h4 id="TCP-协议和-UDP-协议的优势和劣势？-1"><a href="#TCP-协议和-UDP-协议的优势和劣势？-1" class="headerlink" title="TCP 协议和 UDP 协议的优势和劣势？"></a>TCP 协议和 UDP 协议的优势和劣势？</h4><p>【解析】TCP 最核心的价值就是提供封装好的一套解决可靠性的优秀方案。 在前面 3 讲中，你可以看到解决可靠性是非常复杂的，要考虑非常多的因素。TCP 帮助我们在确保吞吐量、延迟、丢包率的基础上，保证可靠性。</p><p>历史上 TCP 也是靠可靠性起家的，有一次著名的实验，TCP 协议的设计者做了一次演示——利用 TCP 协议将数据在卫星和地面之间传播了很多次，没有发生任何数据损坏。从那个时候开始，研发人员开始大量选择 TCP 协议。然后随着生态的发展，逐渐提供了流控等能力。TCP 的成功在于它给人们提供了很多现成、好用的能力。</p><p>UDP 则不同，UDP 提供了最小版的实现，只支持 Checksum。UDP 最核心的价值是灵活、轻量、传输速度快。考虑到不同应用的特性，如果不使用一个大而全的方案，为自己的应用特性量身定做，可能会做得更好。比如网络游戏中游戏客户端不断向服务端发送玩家的位置，如果某一次消息丢失了，只要这个消息不影响最终的游戏结果，就可以只看下一个消息。不同应用有不同的特性，需要的可靠性级别不一样，这就是越来越多的应用开始使用 UDP 的原因之一。</p><p>其实对于我们来说，TCP 协议和 UDP 协议根本不存在什么优势和劣势，只不过是场景不同，选择不同而已。最后还有一个非常重要的考虑因素就是成本，如果没有足够专业的团队解决网络问题，TCP 无疑会是更好的选择。</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><h4 id="有哪些好用的压测工具？"><a href="#有哪些好用的压测工具？" class="headerlink" title="有哪些好用的压测工具？"></a>有哪些好用的压测工具？</h4><p>压力测试最常见的工具是 Apache Benchmark（简称 AB），在 Linux 下面可以通过包管理器安装 ab：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd-tools</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">apt-get install apache2-utils</span><br></pre></td></tr></table></figure><p>ab 安装好后，可以利用下面这条指令向某个网站发送并发 1000 的 10000 次请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 10000 -p 1000 https://example.com/</span><br></pre></td></tr></table></figure><p>ab 是用 C 语言写的，作为一个随手就可以用的工具，它的设计非常简单，是一个单线程的工作模型，因此如果遇到阻塞情况，可能直接导致 ab 工具自己积压崩溃。</p><p>所以。这里我给你推荐一个 Java 生态好用的工具“JMeter”，拥有可视化的界面</p><h4 id="既然发送方有窗口，那么接收方也需要有窗口吗？"><a href="#既然发送方有窗口，那么接收方也需要有窗口吗？" class="headerlink" title="既然发送方有窗口，那么接收方也需要有窗口吗？"></a><strong>既然发送方有窗口，那么接收方也需要有窗口吗？</strong></h4><p>我们一起思考下，接收方收到发送方的每个数据分组（或者称为 TCP Segment），接收方肯定需要缓存。举例来说，如果发送方发送了：1, 2, 3, 4。 那么接收方可能收到的一种情况是：1，4，3。注意，没有收到 2 的原因可能是延迟、丢包等。这个时候，接收方有两种选择。</p><p><strong>选择一：什么都不做</strong>（这样分组 2 的 ACK 就不会发送给发送方，发送方发现没有收到 2 的 ACK，过一段时间就有可能重发 2,3,4,5）。 当然具体设计还需要探讨，比如不重发整个分组，只重发已发送没有收到 ACK 的分组。</p><p>这种方法的缺陷是<strong>性能太差</strong>，重发了整个分组（或部分）。因此我们可以考虑另一种选择。</p><p><strong>选择二</strong>：如果<strong>重发一个窗口，或部分窗口</strong>，问题就不会太大了。虽然增加了网络开销，但是毕竟有进步（1 进步了，不会再重发）。</p><p>性能方面最大的开销是<strong>等待超时的时间</strong>，就是发送方要等到超时时间才重发窗口，这样操作性能太差。因此，TCP 协议有一个<strong>快速重传</strong>的机制——接收方发现接收到了 1，但是没有接收到 2，那么马上发送 3 个分组 2 的 ACK 给到发送方，这样发送方收到多个 ACK，就知道接收方没有收到 2，于是马上重发 2。</p><p>无论是上面哪种方案，接收方也维护一个滑动窗口，是一个不错的选择。接收窗口的状态，可以和发送窗口的状态相互对应了。</p><h4 id="Moba-类游戏的网络应该用-TCP-还是-UDP？"><a href="#Moba-类游戏的网络应该用-TCP-还是-UDP？" class="headerlink" title="Moba 类游戏的网络应该用 TCP 还是 UDP？"></a><strong>Moba 类游戏的网络应该用 TCP 还是 UDP</strong>？</h4><p>所有在线联机游戏都有件非常重要的事情需要完成，就是<strong>确定事件发生的唯一性</strong>，这个性质和聊天工具是类似的。听我这么说，是不是有点迷？请听我慢慢道来。</p><p>你在王者荣耀中控制后羿释放技能，这是一个事件。同时，王昭君放了大招，这是第二个事件。两个事件一定要有先后顺序吗？答案是当然要有。因为游戏在同一时刻只能有一个状态。</p><p>类比一下，多个线程同时操作内存，发生了竞争条件（具体分析可以参见[《重学操作系统》](<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4&amp;utm_source=zhuanlan" target="_blank" rel="noopener">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4&amp;utm_source=zhuanlan</a> article&amp;utm_medium=bottom&amp;utm_campaign=《计算机网络通关 29讲》专栏内嵌&amp;_channel_track_key=D2LoirKK#/content)专栏关于“线程”的内容），那么是不是意味着，内存在同一时刻有两个状态呢？当然不是，<strong>内存同时刻只能有一个状态，所以多个线程的操作必须有先有后</strong>。</p><p>回到 Moba 游戏的问题，每个事件，游戏服务器必须给一个唯一的时序编号，对应后羿的技能和王昭君的技能。所以，在线竞技类游戏，事实上是玩家在不断向服务器竞争一个自增序列号的过程。无论客户端发生怎样的行为，只有竞争到自增 ID 才能进步。也就是说，<strong>服务器要尽快响应多个客户端提交的事件，并以最快的速度分配自增序号，然后返回给客户端</strong>。</p><p><strong>所以，Moba 服务端的核心是自增序号的计算和尽量缩减延迟</strong>。从这个角度出发，你再来看看，应该用 TCP 协议还是 UDP 协议呢？</p><p>虽然TCP 协议有 3 次握手，但是连接上之后，双方就不会再有额外的传输成本，因此创建连接的成本，可以忽略不计。</p><p>同时，TCP 协议还提供稳定性支持，不需要自己实现稳定性。如果规模较小的在线竞技类游戏，TCP 完全适用。但是当游戏玩家体量上升后，TCP 协议的头部（数据封包）较大，会增加服务器额外的 I/O 压力。要发送更多的数据，自然有更大的 I/O 压力。从这个角度来看，UDP 就有了用武之地。</p><h3 id="路由和寻址的区别是什么？"><a href="#路由和寻址的区别是什么？" class="headerlink" title="路由和寻址的区别是什么？"></a><strong>路由和寻址的区别是什么？</strong></h3><p>如果说传输层协议，除了 TCP/UDP，我们还可以有其他选择，比如 Google 开发的 QUIC 协议，帮助在传输层支持 HTTP 3.0 传输。但是在网络层，IP 协议几乎一统天下。IP 协议目前主要有两个版本 IPv4 和 IPv6。这一讲我们先介绍 IPv4 协议。</p><p>根据 Google 统计，使用 IPv6 的Google 用户比例在 30% 左右。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802115634.png" alt="image-20210802115634522"></p><p>IPv4使用范围很大，平时工作中很容易遇到，比如开发场景、网络优化场景、解决线上问题场景等。相信你经常会碰到一些和 IP 协议相关的名词，比如说<strong>这一</strong>讲<strong>关联的面试题目：路由和寻址的区别是什么</strong>？</p><h4 id="什么是-IP-协议？"><a href="#什么是-IP-协议？" class="headerlink" title="什么是 IP 协议？"></a>什么是 IP 协议？</h4><p><strong>IP 协议</strong>（<strong>Internet Protocol</strong>）是一个处于垄断地位的网络层协议。 IPv4 就是 IP 协议的第 4 个版本，是目前互联网的主要网络层协议。IPv4 为传输层提供 Host-To-Host 的能力，IPv4 需要底层数据链路层的支持。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802115717.png" alt="image-20210802115716980"></p><p>IP 协议并不负责数据的可靠性。传输数据时，数据被切分成一个个数据封包。IP 协议上层的传输层协议会对数据进行一次拆分，IP 协议还会进一步进行拆分。进行两次拆分是为了适配底层的设备。</p><p>之前我们提到过， 数据在网络中交换（封包交换算法），并不需要预先建立一个连接，而是任由数据在网络中传输，每个节点通过路由算法帮助数据封包选择下一个目的地。</p><p>这里再复习一下可靠性，<strong>可靠性保证数据无损地到达目的地</strong>。可靠性是 IP 协议上方的 Host-To-Host 协议保证的，比如 TCP 协议通过应答机制、窗口等保证数据的可靠性。 IP 协议自身不能保证可靠性。比如 IP 协议可能会遇到下面这几个问题：</p><ul><li>封包损坏（数据传输过程中被损坏）；</li><li>丢包（数据发送过程中丢失）；</li><li>重发（数据被重发，比如中间设备通过 2 个路径传递数据）；</li><li>乱序（到达目的地时数据和发送数据不一致）。</li></ul><p>但是 IP 协议并不会去处理这些问题，因为网络层只专注解决网络层的问题， 而且不同特性的应用在不同场景下需要解决的问题不一样。对于网络层来说，这里主要有 3 个问题要解决：</p><ul><li>延迟</li><li>吞吐量</li><li>丢包率</li></ul><p>这三个是鱼和熊掌不能兼得，我们后续会讨论。</p><p>另外，IP 协议目前主要有两种架构，一种是 IPv4，是目前应用最广泛的互联网协议；另一种是 IPv6，目前世界各地正在积极地部署 IPv6。这块我们最后讨论。</p><h3 id="IP-协议的工作原理"><a href="#IP-协议的工作原理" class="headerlink" title="IP 协议的工作原理"></a>IP 协议的工作原理</h3><p><strong>IP 协议接收 IP 协议上方的 Host-To-Host 协议传来的数据，然后进行拆分，这个能力叫作分片（Fragmentation）</strong>。然后 IP 协议为每个片段（Fragment）增加一个 IP 头（Header），组成一个<strong>IP 封包</strong>（Datagram）。之后，IP 协议调用底层的局域网（数据链路层）传送数据。最后 IP 协议通过寻址和路由能力最终把封包送达目的地。接下来为你讲述完整的过程。</p><h4 id="分片（Fragmentation）"><a href="#分片（Fragmentation）" class="headerlink" title="分片（Fragmentation）"></a>分片（Fragmentation）</h4><p><strong>分片就是把数据切分成片</strong>。 IP 协议通过它下层的局域网（链路层）协议传输数据，因此需要适配底层传输网络的传输能力。数据太大通常就不适合底层网络传输，这就需要把大的数据切片。 当然也可能选择不切片，IP 协议提供了一个能力就是把封包标记为不切片，当底层网络看到不切片的封包，又没有能力传输的时候，就会丢弃这个封包。你要注意，在网络环境中往往存在多条路径，一条路径断了，说不定其他路径可以连通。</p><h4 id="增加协议头（IP-Header）"><a href="#增加协议头（IP-Header）" class="headerlink" title="增加协议头（IP Header）"></a>增加协议头（IP Header）</h4><p>切片完成之后，IP 协议会为每个切片（数据封包 Datagram）增加一个协议头。一个 IPv4 的协议头看上去就是如下图所示的样子：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802121021.png" alt="image-20210802121021809"></p><p>其中分成 4 个部分。</p><ul><li>最重要的是原地址和目标地址。IPv4 的地址是 4 组 8 位的数字，总共是 32 位。具体地址的作用我们在下面的“寻址部分”介绍。</li><li>Type Of Service 服务的类型，是为了响应不同的用户诉求，用来选择延迟、吞吐量和丢包率之间的关系。关于这块知识，本讲后半部分就会分析。</li><li>IHL（Internet Header Length）用来描述 IP 协议头的大小。所以 IP 协议头的大小是可变的。IHL 只有 4 位，最大值 1111 = 15。最大是 15 个双字（15*4 字节 = 60 字节）。</li><li>Total Length 定义报文（封包 Datagram）的长度。</li><li>Identification（报文的 ID），发送方分配，代表顺序。</li><li>Fragment offset 描述要不要分包（拆分），以及如何拆分。</li><li>Time To Live 描述封包存活的时间。因此每个 IP 封包发送出去后，就开始销毁倒计时。如果倒计时为 0，就会销毁。比如中间的路由器看到一个 TTL 为 0 的封包，就直接丢弃。</li><li>Protocol 是描述上层的协议，比如 TCP = 6，UDP = 17。</li><li>Options 代表可选项。</li><li>Checksum 用来检验封包的正确性，具体原理我们在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=837#/detail/pc?id=7269&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">05 | UDP 协议：TCP 协议和 UDP 协议的优势和劣势？</a>”中已经介绍过了，如果 Checksum 对不上，就需要选择丢弃这个封包。</li></ul><h4 id="“鱼和熊掌”不能兼得——延迟、吞吐量、丢包率"><a href="#“鱼和熊掌”不能兼得——延迟、吞吐量、丢包率" class="headerlink" title="“鱼和熊掌”不能兼得——延迟、吞吐量、丢包率"></a>“鱼和熊掌”不能兼得——延迟、吞吐量、丢包率</h4><p>上面我们看到 IPv4 协议中提供了一个叫作 Type of Service（服务类型）的字段。这个字段是为了在延迟、吞吐量和丢包率三者间选择。</p><p><strong>延迟（latency）</strong></p><p>延迟指的是 1 bit 的数据从网络的一个终端传送到另一个终端需要的时间。这个时间包括在发送端准备发送的时间、排队发送的时间、发送数据的时间、数据传输的时间等。</p><p><strong>吞吐量（Throughput）</strong></p><p>吞吐量指单位时间内可以传输的平均数据量。比如用 bit/s 作为单位，就是 bps。吞吐量和延迟没有联系，比如延迟很高的网络，有可能吞吐量很高。可以类比成水管很大流速很慢，对比水管很细流速很快，这两种情况，最终流量可以是相等的。</p><p><strong>丢包率（Packet loss）</strong></p><p>丢表率指发送出去的封包没有到达目的地的比例。 在最大流速确定的网络中，丢表率会直接影响吞吐量。</p><p>我们的网络有时候需要低延迟，比如玩一款 RTS 游戏或者 Moba 游戏，这种时候延迟非常重要。另外如果把延迟看作一个平均指标，丢包也会影响延迟——一个包丢了，需要重发。而有的应用需要高吞吐量，延迟不是很重要，比如说网盘下载文件。大部分应用期望丢包不能太严重，比如语音电话，少量丢包还能听清，大量丢包就麻烦了，根本听不清对方说什么。严格希望不丢包的应用比较少，只有极特殊的网络控制管理场景，才需要在互联网层要求不丢包。</p><p>当然这三个条件，通常不能同时满足。如果同时追求延迟、吞吐量、丢包率，那么对网络设备的要求就会非常高，说白了就会非常贵。因此 IP 协议头中的 Type of Service 字段里，有以下 4 种主要的类型可以选择：</p><ul><li>低延迟</li><li>高吞吐量</li><li>低丢包率</li><li>低成本</li></ul><h4 id="寻址（Addressing）"><a href="#寻址（Addressing）" class="headerlink" title="寻址（Addressing）"></a>寻址（Addressing）</h4><p>地址想要表达的是一个东西在哪里。寻址要做的就是：给一个地址，然后找到这个东西。IPv4 协议的寻址过程是逐级寻址。</p><p><strong>IPv4 地址</strong></p><p>IPv4 地址是 4 个 8 位（Octet）排列而成，总共可以编址 43 亿个地址。</p><p>比如 103.16.3.1 就是一个合法的 Ipv4 地址。4 组数字用<code>.</code>分开，是为了让人可读，实际上在内存和传输过程中，就是直接用 32 位。</p><p><strong>寻址过程</strong></p><p>寻址就是如何根据 IP 地址找到设备。因为 IPv4 的世界中，网络是一个树状模型。顶层有多个平行的网络，每个网络有自己的网络号。然后顶层网络下方又有多个子网，子网下方还有子网，最后才是设备。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802121620.png" alt="image-20210802121620755"></p><p>IP 协议的寻址过程需要逐级找到网络，最后定位设备。下面我们具体分析下这个过程。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802121802.png" alt="image-20210802121802780"></p><p>当然子网掩码也不一定都是<code>255</code>，比如这个子网掩码<code>255.240.0.0</code>也是可以的。但通常我们把 IPv4 的网络分成这样 4 层。</p><h4 id="路由（Routing）"><a href="#路由（Routing）" class="headerlink" title="路由（Routing）"></a>路由（Routing）</h4><p>在寻址过程中，数据总是存于某个局域网中。如果目的地在局域网中，就可以直接定位到设备了。如果目的地不在局域网中，这个时候，就需再去往其他网络。</p><p>由于网络和网络间是网关在连接，因此如果目的地 IP 不在局域网中，就需要为 IP 封包选择通往下一个网络的路径，其实就是选择其中一个网关。你可能会问：网关有多个吗？如果一个网络和多个网络接壤，那自然需要多个网关了。下图中，路由器在选择 IP 封包下一个应该是去往哪个 Gateway？</p><p>假如，我们要为 IP 地址 14.215.177.38 寻址，当前路由器所在的网络的编号是16.0.0.0。那么我们就需要知道去往 14.0.0.0 网络的 Gateway IP 地址。</p><p>如果你在当前网络中用<code>route</code>查看路由表，可能可以看到一条下面这样的记录。</p><ul><li>Destination：14.0.0.0</li><li>Gateway：16.12.1.100</li><li>Mask：255.0.0.0</li><li>Iface：16.12.1.1</li></ul><p>这条记录就说明如果你要去往 14.0.0.0 网络，IP 地址 14.215.177.38 先要和 255.0.0.0 进行位运算，然后再查表，看到 14.0.0.0，得知去往 Gateway 的网卡（IFace）是 16.12.1.1。</p><p>当封包去向下一个节点后，会进入新的路由节点，然后会继续上述路由过程，直到最终定位到设备。</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>这一讲我们学习了 IP 协议和 IP 协议的工作原理。首先 IP 协议会进行分片，将上游数据拆成一个个的封包（Datagram），然后为封包增加 IP 头部。封包发送出去后，就开始了寻址过程。寻址就是找到 IP 地址对应的设备。在局域网内，如果找不到设备，就需要路由。路由就是找到数据应该往哪里发送。最后通过层层路由定位到具体的设备。</p><h4 id="路由和寻址的区别是什么？-1"><a href="#路由和寻址的区别是什么？-1" class="headerlink" title="路由和寻址的区别是什么？"></a><strong>路由和寻址的区别是什么</strong>？</h4><p>【<strong>解析</strong>】寻址（Addressing）就是通过地址找设备。和现实生活中的寻址是一样的，比如根据地址找到一个公寓。在 IPv4 协议中，寻址找到的是一个设备所在的位置。</p><p>路由（Routing）本质是路径的选择。就好像知道地址，但是到了每个十字路口，还需要选择具体的路径。</p><p>所以，要做路由，就必须能够理解地址，也就是需要借助寻址的能力。要通过寻址找到最终的设备，又要借助路由在每个节点选择数据传输的线路。因此，路由和寻址，是相辅相成的关系。</p><h3 id="Tunnel-技术是什么？"><a href="#Tunnel-技术是什么？" class="headerlink" title="Tunnel 技术是什么？"></a><strong>Tunnel 技术是什么？</strong></h3><p>IPv4 用 32 位整数描述地址，最多只能支持 43 亿设备，显然是不够用的，这也被称作 IP 地址耗尽问题。</p><p>为了解决这个问题，有一种可行的方法是<strong>拆分子网</strong>。拆分子网，会带来很多问题，比如说内外网数据交互，需要网络地址转换协议（NAT 协议），增加传输成本。再比如说，多级网络会增加数据的路由和传输链路，降低网络的速度。理想的状态当然是所有设备在一个网络中，互相可以通过地址访问。</p><p>为了解决这个问题，1998 年互联网工程工作小组推出了全新款的 IP 协议——IPv6 协议。但是目前 IPv6 的普及程度还不够高，2019 年据中国互联网络信息中心（CNNIC）统计，IPv6 协议目前在我国普及率为 60%，已经位居世界首位。</p><p>既然不能做到完全普及，也就引出了<strong>本讲关联的一道面试题目：什么是 Tunnel 技术</strong>？下面请你带着这个问题，开启今天的学习吧！</p><h4 id="IPv4-和-IPv6-相似点"><a href="#IPv4-和-IPv6-相似点" class="headerlink" title="IPv4 和 IPv6 相似点"></a>IPv4 和 IPv6 相似点</h4><p>IPv6 的工作原理和 IPv4 类似，分成切片（Segmentation）、增加封包头、路由（寻址）这样几个阶段去工作。IPv6 同样接收上方主机到主机（Host-to-Host）协议传递来的数据，比如一个 TCP 段（Segment），然后将 TCP 段再次切片做成一个个的 IPv6 封包（Datagram or Packet），再调用底层局域网能力（数据链路层）传输数据。具体的过程如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802141337.png" alt="image-20210802141337083"></p><p><strong>作为网络层协议的 IPv6，最核心的能力是确保数据可以从发送主机到达接收主机</strong>。因此，和 IPv4 类似，IPv6同样需要定义地址的格式，以及路由算法如何工作。</p><h4 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h4><p>接下来我们重点说说地址格式的区别。</p><p>IPv4 的地址是 4 个 8 位（octet），总共 32 位。 IPv6 的地址是 8 个 16 位（hextet），总共 128 位。从这个设计来看，IPv6 可以支持的地址数量是 IPv4 的很多倍。就算将 IPv6 的地址分给每个人，每个人拥有的地址数量，依旧是今天总地址数量的很多倍。</p><p>格式上，IPv4 的地址用<code>.</code>分割，如<code>103.28.7.35</code>。每一个是 8 位，用 0-255 的数字表示。</p><p>IPv6 的地址用<code>:</code>分割，如<code>0123:4567:89ab:cdef:0123:4567:89ab:cdef</code>，总共 8 个 16 位的数字，通常用 16 进制表示。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802141549.png" alt="image-20210802141549211"></p><ul><li>Hexadecimal notation：十六进制表示</li><li>Quartet：16 位</li><li>Most significant：最高有效位</li><li>Binary notation：二进制表示</li></ul><p><code>::</code>只能出现一次，相当于省略了若干组<code>0000</code>。比如说<code>1111::2222</code>相当于中间省略了 6 组<code>0000</code>。为什么不能出现两个<code>::</code>呢？因为如果有两个<code>::</code>，就会对省略的<code>0000</code>的位置产生歧义。比如说<code>1111::2222:3333</code>，你就不知道究竟<code>0000</code>在<code>1111::2222</code>和<code>2222::3333</code>是怎么分布的。</p><p>开头的 0 也可以简写，就变成如下的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123:4567::123:4567:0:cdef</span><br></pre></td></tr></table></figure><p>还有一种情况我们想要后面部分都填<code>0</code>，比如说<code>3c4d::/16</code>，这个代表只有前<code>16</code>位有数据，后面是<code>0</code>；<code>1234:5878:abcd/64</code>代表只有左边<code>64</code>位有数据，后面是 0；再比如<code>ff00/8</code>，只有左边 8 位是有数据的。</p><h4 id="IPv6-的寻址"><a href="#IPv6-的寻址" class="headerlink" title="IPv6 的寻址"></a>IPv6 的寻址</h4><p>接下来我们讨论下寻址，和 IPv4 相同，寻址的目的是找到设备，以及规划到设备途经的路径。和 IPv4 相同，IPv6寻址最核心的内容就是要对网络进行划分。IPv6 地址很充裕，因此对网络的划分和 IPv4 有很显著的差异。</p><p>IPv6 的寻址分成了几种类型：</p><ul><li>全局单播寻址（和 IPv4 地址作用差不多，在互联网中通过地址查找一个设备，简单来说，单播就是 1 对 1）；</li><li>本地单播（类似 IPv4 里的一个内部网络，要求地址必须以<code>fe80</code>开头，类似我们 IPv4 中<code>127</code>开头的地址）；</li><li>分组多播（Group Multicast），类似今天我们说的广播，将消息发送给多个接收者；</li><li>任意播（Anycast），这个方式比较特殊，接下来我们会详细讲解。</li></ul><h4 id="全局单播"><a href="#全局单播" class="headerlink" title="全局单播"></a>全局单播</h4><p>全局单播，就是将消息从一个设备传到另一个设备，这和 IPv4 发送/接收消息大同小异。而全局单播地址，目标就是定位网络中的设备，这个地址和 IPv4 的地址作用相同，只不过格式略有差异。<strong>总的来说，IPv6 地址太多，因此不再需要子网掩码，而是直接将 IPv6 的地址分区即可</strong>。</p><p>在实现全局单播时，IPv6 地址通常分成 3 个部分：</p><ul><li>站点前缀（Site Prefix）48bit，一般是由 ISP（Internet Service Providor，运营商）或者RIR（Regional Internet Registry， 地区性互联网注册机构），RIR 将 IP 地址分配给运营商；</li><li>子网号（Subnet ID），16bit，用于站点内部区分子网；</li><li>接口号（Interface ID）， 64bit，用于站点内部区分设备。</li></ul><p>因此 IPv6 也是一个树状结构，站点前缀需要一定资质，子网号和接口号内部定义。IPv6 的寻址过程就是先通过站点前缀找到站点，然后追踪子网，再找到接口（也就是设备的网卡）。</p><p>从上面全局单播的分区，我们可以看出，IPv6 分给站点的地址非常多。一个站点，有 16bit 的子网，相当于 65535 个子网；每个子网中，还可以用 64 位整数表示设备。</p><h4 id="本地单播"><a href="#本地单播" class="headerlink" title="本地单播"></a>本地单播</h4><p>理论上，虽然 IPv6 可以将所有的设备都连入一个网络。但在实际场景中，很多公司还是需要一个内部网络的。这种情况在 IPv6 的设计中属于局域网络。</p><p>在局域网络中，实现设备到设备的通信，就是本地单播。IPv6 的本地单播地址组成如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802162709.png" alt="image-20210802162709355"></p><p>这种协议比较简单，本地单播地址必须以<code>fe80</code>开头，后面 64 位的 0，然后接上 54 位的设备编号。上图中的 Interface 可以理解成网络接口，其实就是网卡。</p><h4 id="分组多播"><a href="#分组多播" class="headerlink" title="分组多播"></a>分组多播</h4><p>有时候，我们需要实现广播。所谓广播，就是将消息同时发送给多个接收者。</p><p>IPv6 中设计了分组多播，来实现广播的能力。当 IP 地址以 8 个 1 开头，也就是<code>ff00</code>开头，后面会跟上一个分组的编号时，就是在进行分组多播。</p><p>这个时候，我们需要一个广播设备，在这个设备中已经定义了这些分组编号，并且拥有分组下所有设备的清单，这个广播设备会帮助我们将消息发送给对应分组下的所有设备。</p><h4 id="任意播（Anycast）"><a href="#任意播（Anycast）" class="headerlink" title="任意播（Anycast）"></a>任意播（Anycast）</h4><p>任意播，本质是将消息发送给多个接收方，并选择一条最优的路径。这样说有点抽象，接下来我具体解释一下。</p><p>比如说在一个网络中有多个授时服务，这些授时服务都共享了一个任播地址。当一个客户端想要获取时间，就可以将请求发送到这个任播地址。客户端的请求扩散出去后，可能会找到授时服务中的一个或者多个，但是距离最近的往往会先被发现。这个时候，客户端就使用它第一次收到的授时信息修正自己的时间。</p><h4 id="IPv6-和-IPv4-的兼容"><a href="#IPv6-和-IPv4-的兼容" class="headerlink" title="IPv6 和 IPv4 的兼容"></a>IPv6 和 IPv4 的兼容</h4><p>目前 IPv6 还没有完全普及，大部分知名的网站都是同时支持 IPv6 和 IPv4。这个时候我们可以分成 2 种情况讨论：</p><ol><li>一个 IPv4 的网络和一个 IPv6 的网络通信；</li><li>一个 IPv6 的网络和一个 IPv6 的网络通信，但是中间需要经过一个 IPv4 的网络。</li></ol><p>下面我们具体分析一下。</p><p><strong>情况 1：IPv4 网络和 IPv6 网络通信</strong></p><p>例如一个 IPv6 的客户端，想要访问 IPv4 的服务器，步骤如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802162809.png" alt="image-20210802162809719"></p><ol><li>客户端通过 DNS64 服务器查询 AAAA 记录。DNS64 是国际互联网工程任务组（IETF）提供的一种解决 IPv4 和 IPv6 兼容问题的 DNS 服务。这个 DNS 查询服务会把 IPv4 地址和 IPv6 地址同时返回。</li><li>DNS64 服务器返回含 IPv4 地址的 AAAA 记录。</li><li>客户端将对应的 IPv4 地址请求发送给一个 NAT64 路由器</li><li>由这个 NAT64 路由器将 IPv6 地址转换为 IPv4 地址，从而访问 IPv4 网络，并收集结果。</li><li>消息返回到客户端。</li></ol><p><strong>情况 2：两个 IPv6 网络被 IPv4 隔离</strong></p><p>这种情况在普及 IPv6 的过程中比较常见，IPv6 的网络一开始是一个个孤岛，IPv6 网络需要通信，就需要一些特别的手段。</p><p>不知道你有没有联想到坐火车穿越隧道的感觉，连接两个孤岛 IPv6 网络，其实就是在 IPv4 网络中建立一条隧道。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802162837.png" alt="image-20210802162837144"></p><p><strong>隧道的本质就是在两个 IPv6 的网络出口网关处，实现一段地址转换的程序</strong>。</p><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>总结下，<strong>IPv6 解决的是地址耗尽的问题</strong>。因为解决了地址耗尽的问题，所以很多其他问题也得到了解决，比如说减少了子网，更小的封包头部体积，最终提升了性能等。</p><p>除了本讲介绍的内容，下一讲你还会从局域网络中看到更多对 NAT 技术的解读、对路由器的作用的探讨。随着 IPv6 彻底普及，你可以想象一下，运营商可以给到每个家庭一大批固定的 IP 地址，发布网页似乎可以利用家庭服务器……总之，林䭽也不知道最终会发生什么，我也对未来充满了期待，让我们拭目以待吧。</p><p>那么，通过这一讲的学习，你可以尝试回答本讲关联的面试题目：Tunnel 技术是什么了吗？</p><p>【<strong>解析</strong>】Tunnel 就是隧道，这和现实中的隧道是很相似的。隧道不是只有一辆车通过，而是每天都有大量的车辆来来往往。两个网络，用隧道连接，位于两个网络中的设备通信，都可以使用这个隧道。隧道是两个网络间用程序定义的一种通道。具体来说，如果两个 IPv6 网络被 IPv4 分隔开，那么两个 IPv6 网络的出口处（和 IPv4 网络的网关处）就可以用程序（或硬件）实现一个隧道，方便两个网络中设备的通信。</p><p><strong>IPv6与IPv4的区别主要有以下几点</strong>：1.IPv6的地址空间更大。IPv4中规定IP地址长度为32,即有2^32-1个地址；而IPv6中IP地址的长度为128,即有2^128-1个地址。夸张点说就是，如果IPV6被广泛应用以后，全世界的每一粒沙子都会有相对应的一个IP地址。2.IPv6的路由表更小。IPv6的地址分配一开始就遵循聚类(Aggregation)的原则,这使得路由器能在路由表中用一条记录(Entry)表示一片子网,大大减小了路由器中路由表的长度,提高了路由器转发数据包的速度。3.IPv6的组播支持以及对流的支持增强。这使得网络上的多媒体应用有了长足发展的机会，为服务质量控制提供了良好的网络平台。4.IPv6加入了对自动配置的支持。这是对DHCP协议的改进和扩展，使得网络(尤其是局域网)的管理更加方便和快捷。5.IPv6具有更高的安全性。在使用IPv6网络中，用户可以对网络层的数据进行加密并对IP报文进行校验，这极大地增强了网络安全</p><h3 id="NAT-是如何工作的？"><a href="#NAT-是如何工作的？" class="headerlink" title="NAT 是如何工作的？"></a><strong>NAT 是如何工作的？</strong></h3><p><strong>数据到王者荣耀服务器可以通过寻址和路由找到目的地，但是数据从王者荣耀服务器回来的时候，王者荣耀服务器如何知道</strong><code>192.168</code>开头的地址应该如何寻址呢？</p><p>要想回答这个问题，就涉及网络地址转换协议（NAT 协议）。下面请你带着这个问题，开启今天的学习吧。</p><h4 id="内部网络和外部网络"><a href="#内部网络和外部网络" class="headerlink" title="内部网络和外部网络"></a>内部网络和外部网络</h4><p>对一个组织、机构、家庭来说，我们通常把内部网络称为局域网，外部网络就叫作外网。下图是一个公司多个部门的网络架构。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802171040.png" alt="image-20210802171040490"></p><h4 id="局域网数据交换（MAC-地址）"><a href="#局域网数据交换（MAC-地址）" class="headerlink" title="局域网数据交换（MAC 地址）"></a>局域网数据交换（MAC 地址）</h4><p>接下来我们讨论下同一个局域网中的设备如何交换消息。</p><p>首先，我们先明确一个概念，设备间通信的本质其实是设备拥有的网络接口（网卡）间的通信。<strong>为了区别每个网络接口，互联网工程任务组（IETF）要求每个设备拥有一个唯一的编号，这个就是 MAC 地址</strong>。</p><p><strong>你可能会问：IP 地址不也是唯一的吗</strong>？其实不然，一旦设备更换位置，比如你把你的电脑从北京邮寄的广州，那么 IP 地址就变了，而电脑网卡的 MAC 地址不会发生变化。总的来说，IP 地址更像现实生活中的地址，而 MAC 地址更像你的身份证号。</p><p>然后，我们再明确另一个基本的概念。<strong>在一个局域网中，我们不可以将消息从一个接口（网卡）发送到另一个接口（网卡），而是要通过交换机</strong>。为什么是这样呢？因为两个网卡间没有线啊！所以数据交换，必须经过交换机，毕竟线路都是由网卡连接交换机的。</p><p>总结下，数据的发送方，将自己的 MAC 地址、目的地 MAC 地址，以及数据作为一个分组（Packet），也称作 Frame 或者封包，发送给交换机。交换机再根据目的地 MAC 地址，将数据转发到目的地的网络接口（网卡）。</p><p><strong>最后一个问题，你可能问，这个分组或者 Frame，是不是 IP 协议的分组呢</strong>？——不是，这里提到的是链路层的数据交换，它支持 IP 协议工作，是网络层的底层。所以，<strong>如果 IP 协议要传输数据，就要将数据转换成为链路层的分组，然后才可以在链路层传输</strong>。</p><p>链路层分组大小受限于链路层的网络设备、线路以及使用了链路层协议的设计。你有时候可能会看到 MTU 这个缩写词，它指的是 Maximun Transmission Unit，最大传输单元，意思是链路层网络允许的最大传输数据分组的大小。<strong>因此 IP 协议要根据 MTU 拆分封包</strong>。</p><p>之前在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=837#/detail/pc?id=7268&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">04 | TCP 的稳定性：滑动窗口和流速控制是怎么回事？</a>”介绍 TCP 协议滑动窗口的时候，还提到过一个词，叫作 MSS，这里我们复习下。MSS（Maximun Segment Size，最大段大小）是 TCP 段，或者称为 TCP 分组（TCP Packet）的最大大小。<strong>MSS 是传输层概念，MTU 是链路层概念</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MTU = MSS + TCP Header + IP Header</span><br></pre></td></tr></table></figure><p><strong>这个思路有一定道理，但是不对</strong>。先说说这个思路怎么来的，你可能会这么思考：TCP 传输数据大于 MSS，就拆包。每个封包加上 TCP Header ，之后经过 IP 协议，再加上 IP Header。于是这个加上 IP 头的分组（Packet）不能超过 MTU。固然这个思路很有道理，可惜是错的。<strong>因为 TCP 解决的是广域网的问题，MTU 是一个链路层的概念，要知道不同网络 MTU 是不同的，所以二者不可能产生关联。这也是为什么 IP 协议还可能会再拆包的原因</strong>。</p><h4 id="地址解析协议（ARP）"><a href="#地址解析协议（ARP）" class="headerlink" title="地址解析协议（ARP）"></a>地址解析协议（ARP）</h4><p>上面我们讨论了 MAC 地址，链路层通过 MAC 地址定位网络接口（网卡）。在一个网络接口向另一个网络接口发送数据的时候，至少要提供这样 3 个字段：</p><ol><li>源 MAC 地址</li><li>目标 MAC 地址</li><li>数据</li></ol><p><strong>这里我们一起再来思考一个问题，对于一个网络接口，它如何能知道目标接口的 MAC 地址呢</strong>？我们在使用传输层协议的时候，清楚地知道目的地的 IP 地址，但是我们不知道 MAC 地址。这个时候，就需要一个中间服务帮助根据 IP 地址找到 MAC 地址——这就是地址解析协议（Address Resolution Protocol，ARP）。</p><p>整个工作过程和 DNS 非常类似，如果一个网络接口已经知道目标 IP 地址对应的 MAC 地址了，它会将数据直接发送给交换机，交换机将数据转发给目的地，这个过程如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174247.png" alt="image-20210802174246892"></p><p>那么如果网络接口不知道目的地地址呢？这个时候，地址解析协议就开始工作了。发送接口会发送一个广播查询给到交换机，交换机将查询转发给所有接口。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174259.png" alt="image-20210802174259362"></p><p>如果某个接口发现自己就是对方要查询的接口，则会将自己的 MAC 地址回传。接下来，会在交换机和发送接口的 ARP 表中，增加一个缓存条目。也就是说，接下来发送接口再次向 IP 地址 2.2.2.2 发送数据时，不需要再广播一次查询了。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174313.png" alt="image-20210802174313038"></p><p><strong>前面提到这个过程和 DNS 非常相似，采用的是逐级缓存的设计减少 ARP 请求</strong>。发送接口先查询本地的 ARP 表，如果本地没有数据，然后广播 ARP 查询。这个时候如果交换机中有数据，那么查询交换机的 ARP 表；如果交换机中没有数据，才去广播消息给其他接口。<strong>注意，ARP 表是一种缓存，也要考虑缓存的设计</strong>。通常缓存的设计要考虑缓存的失效时间、更新策略、数据结构等。</p><p>比如可以考虑用 TTL（Time To Live）的设计，为每个缓存条目增加一个失效时间。另外，更新策略可以考虑利用老化（Aging）算法模拟 LRU。</p><p>最后请你思考路由器和交换机的异同点。不知道你有没有在网上订购过家用无线路由器，通常这种家用设备也会提供局域网，具备交换机的能力。同时，这种设备又具有路由器的能力。所以，很多同学可能会分不清路由器和交换机。</p><p>总的来说，家用的路由器，也具备交换机的功能。但是当 ARP 表很大的时候，就需要专门的、能够承载大量网络接口的交换设备。就好比，如果用数组实现 ARP 表，数据量小的时候，遍历即可；但如果数据量大的话，就需要设计更高效的查询结构和设计缓存。</p><p>详细的缓存设计原理的介绍，可以参考<a href="https://shenceyun.lagou.com/t/Axo?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">《重学操作系统》</a>专栏中关于 CPU 缓存的设计，以及 MMU 中 TLB 的设计的内容，分别在以下 3 讲：</p><ul><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4610&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">05 | 存储器分级：L1 Cache 比内存和 SSD 快多少倍？</a></li><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4634&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">25 | 内存管理单元： 什么情况下使用大内存分页？</a></li><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4635&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">26 | 缓存置换算法： LRU 用什么数据结构实现更合理？</a></li></ul><h4 id="连接内网"><a href="#连接内网" class="headerlink" title="连接内网"></a>连接内网</h4><p>有时候，公司内部有多个子网。这个时候一个子网如果要访问另一个子网，就需要通过路由器。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174554.png" alt="image-20210802174554758"></p><p>也就是说，图中的路由器，其实充当了两个子网通信的桥梁。在上述过程中，发送接口不能直接通过 MAC 地址发送数据到接收接口，因为子网 1 的交换机不知道子网 2 的接口。这个时候，发送接口需要通过 IP 协议，将数据发送到路由器，再由路由器转发信息到子网 2 的交换机。这里提一个问题，<strong>子网 2 的交换机如何根据 IP 地址找到接收接口呢</strong>？答案是通过查询 ARP 表。</p><h4 id="连接外网（网络地址转换技术，NAT）"><a href="#连接外网（网络地址转换技术，NAT）" class="headerlink" title="连接外网（网络地址转换技术，NAT）"></a>连接外网（网络地址转换技术，NAT）</h4><p>最后我们讨论下连接外网的问题。</p><p>IPv4 协议因为存在网络地址耗尽的问题，不能为一个公司提供足够的地址，因此内网 IP 可能会和外网重复。比如内网 IP 地址<code>192.168.0.1</code>发送信息给<code>22.22.22.22</code>，这个时候，其实是跨着网络的。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174617.png" alt="image-20210802174616966"></p><p>跨网络必然会通过多次路由，最终将消息转发到目的地。但是这里存在一个问题，寻找的目标 IP 地址<code>22.22.22.22</code>是一个公网 IP，可以通过正常的寻址 + 路由算法定位。当<code>22.22.22.22</code>寻找<code>192.168.0.1</code>的时候，是寻找一个私网 IP，这个时候是找不到的。解决方案就是网络地址转换技术（Network Address Translation）。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174930.png" alt="image-20210802174930780"></p><p>NAT 技术转换的是 IP 地址，私有 IP 通过 NAT 转换为公网 IP 发送到服务器。服务器的响应，通过 NAT 转换为私有 IP，返回给客户端。通过这种方式，就解决了内网和外网的通信问题。</p><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p>总结一下，链路层发送数据靠的是 MAC 地址，MAC 地址就好像人的身份证一样。局域网中，数据不可能从一个终端直达另一个终端，而是必须经过交换机交换。交换机也叫作链路层交换机，它的工作就是不断接收数据，然后转发数据。<strong>通常意义上，交换机不具有路由功能，路由器往往具有交换功能</strong>。但是往往路由器交换的效率，不如交换机。已知 IP 地址，找到 MAC 地址的协议，叫作地址解析协议（ARP）。</p><p>网络和网络的衔接，必须有路由器（或者等价的设备）。一个网络的设备不能直接发送链路层分组给另一个网络的设备，而是需要通过 IP 协议让路由器转发。</p><p>那么，通过这一讲的学习，你可以来回答本讲关联的面试题目：网络地址转换协议是如何工作的？</p><p>【<strong>解析</strong>】网络地址解析协议（NAT）解决的是内外网通信的问题。NAT 通常发生在内网和外网衔接的路由器中，由路由器中的 NAT 模块提供网络地址转换能力。从设计上看，NAT 最核心的能力，就是能够将内网中某个 IP 地址映射到外网 IP，然后再把数据发送给外网的服务器。当服务器返回数据的时候，NAT 又能够准确地判断外网服务器的数据返回给哪个内网 IP。</p><p>你可以思考下 NAT 是如何做到这点的呢？需要做两件事。</p><ol><li>NAT 需要作为一个中间层替换 IP 地址。 发送的时候，NAT 替换源 IP 地址（也就是将内网 IP 替换为出口 IP）；接收的时候，NAT 替换目标 IP 地址（也就是将出口 IP 替换回内网 IP 地址）。</li><li>NAT 需要缓存内网 IP 地址和出口 IP 地址 + 端口的对应关系。也就是说，发送的时候，NAT 要为每个替换的内网 IP 地址分配不同的端口，确保出口 IP 地址+ 端口的唯一性，这样当服务器返回数据的时候，就可以根据出口 IP 地址 + 端口找到内网 IP。</li></ol><p>这里不去讨论更加详细复杂的情况，NAT技术又细分为静态动态等等几个情况。</p><h3 id="如何进行-TCP-抓包调试？"><a href="#如何进行-TCP-抓包调试？" class="headerlink" title="如何进行 TCP 抓包调试？"></a><strong>如何进行 TCP 抓包调试？</strong></h3><p>这一讲给你带来了一个<strong>网络调试工具——Wireshark</strong>。Wireshark 是世界上应用最广泛的网络协议分析器，它让我们在微观层面上看到整个网络正在发生的事情。</p><p>Wireshark 本身是一个开源项目，所以也得到了很多志愿者的支持。同时，Wireshark 具有丰富的功能集，包括：</p><ol><li>深入检查数百个协议，并不断添加更多协议；</li><li>实时捕获和离线分析；</li><li>支持 Windows、Linux、macOS、Solaris、FreeBSD、NetBSD，以及许多其他平台；</li><li>提供 GUI 浏览，也可以通过 TTY；</li><li>支持 VOIP；</li><li>支持 Gzip；</li><li>支持 IPSec。</li><li>……</li></ol><p>是不是觉得Wireshark非常强大？无论你从事哪种开发工作，它都可以帮到你，因此也是面试经常考察的内容。<strong>比如本讲关联的面试题：如何进行 TCP 抓包和调试</strong>？下面请你带着问题，开始今天的学习吧。</p><p><em>注：你可以到 Wireshark 的主页：</em><a href="https://www.wireshark.org/download.html?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">https://www.wireshark.org/download.html</a><em>下载 Wireshark。</em></p><p>如果你是一个黑客、网络安全工程师，或者你的服务总是不稳定，就需要排查，那么你会如何 hack 这些网络连接、网络接口以及分析网络接口的封包呢？</p><h4 id="接口列表"><a href="#接口列表" class="headerlink" title="接口列表"></a>接口列表</h4><p>Whireshark 可以帮你看到整个网络交通情况，也可以帮你深入了解每个封包。而且 Whireshark 在 macOS、Linux、Windows 上的操作都是一致的，打开 Wireshark 会先看到如下图所示的一个选择网络接口的界面。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183750.png" alt="image-20210802183750408"></p><p>我们要做的第一件事情就是<strong>选择一个网络接口</strong>（<strong>Network Interface</strong>）。Linux 下可以使用<code>ifconfig</code>指令看到所有的网络接口，Windows 下则使用 ipconfig。可以看到，上图中有很多网络接口，目前我教学这台机器上，连接路由器的接口是<strong>以太网 2</strong>。另外可以看到，我的机器上还有<code>VMware</code>的虚拟网络接口（你的机器可能和我的机器显示的不一样）。</p><h4 id="开启捕获功能"><a href="#开启捕获功能" class="headerlink" title="开启捕获功能"></a>开启捕获功能</h4><p>选择好接口之后，点击左上角的按钮就可以开启捕获，开启后看到的是一个个数据条目。</p><p>因为整个网络的数据非常多，大量的应用都在使用网络，你会看到非常多数据条目，每个条目是一次数据的发送或者接收。如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183809.png" alt="image-20210802183809553"></p><p>以下是具体捕获到的内容：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183828.png" alt="image-20210802183828623"></p><ul><li>序号（No.）是 Wireshark 分配的一个从捕获开始的编号。</li><li>时间（Time）是从捕获开始过去的时间戳，具体可以在视图中设置，比如可以设置成中文的年月日等。这里有很多配置需要你自己摸索一下，我就不详细介绍了。</li><li>源地址和目标地址（Source 和 Destination）是 IP 协议，注意这里有 IPv6 的地址，也有 IPV4 的地址。</li><li>协议可能有很多种，比如 TCP/UDP/ICMP 等，ICMP 是 IP 协议之上搭建的一个消息控制协议（Internet Control Message Protocol），比如 Ping 用的就是 ICMP；还有 ARP 协议（Address Resolution Protocol）用来在局域网广播自己的 MAC 地址。</li><li>Length 是消息的长度（Bytes）。</li><li>Info 是根据不同协议显示的数据，比如你可以看到在TCP 协议上看到Seq 和 ACK。这里的 Seq 和 ACK 已经简化过了，正常情况下是一个大随机数，Whireshark 帮你共同减去了一个初始值。</li></ul><h4 id="观察-TCP-协议"><a href="#观察-TCP-协议" class="headerlink" title="观察 TCP 协议"></a>观察 TCP 协议</h4><p>如果你具体选择一个 TCP 协议的捕获，可以看到如下图所示的内容：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183916.png" alt="image-20210802183916603"></p><p>然后在这下面可以观察到详情内容：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183939.png" alt="image-20210802183939049"></p><p>我们可以从不同的层面来看这次捕获。从传输层看是 TCP 段；从网络层来看是 IP 封包；从链路层来看是 Frame。</p><p>点开不同层面观察这个 TCP 段，就可以获得对它更具体的认识，例如下图是从 TCP 层面理解这次捕获：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802184039.png" alt="image-20210802184038793"></p><p>你可以看到这次捕获是一次 ACK（见 Flags）字段，从端口 58260 发往 443，那么大概率是 HTTPS 客户端给服务器的响应。</p><h4 id="消息视图"><a href="#消息视图" class="headerlink" title="消息视图"></a>消息视图</h4><p>如果你选中一条消息，下面会出现一个消息视图。还有一个二进制视图。二进制视图里面是数据的二进制形式，消息视图是对二进制形式的解读。</p><p>Whireshark 追溯的是最底层网卡传输的 Frame（帧），可以追溯到数据链路层。因此对二进制形式的解读，也就是我们的消息视图也要分层。因为对于同样的数据，不同层的解读是不同的。</p><ul><li>最上面是 Frame 数据，主要是关注数据的收发时间和大小。</li><li>接着是数据链路层数据，关注的是设备间的传递。你可以在这里看到源 MAC 地址和目标 MAC 地址。</li><li>然后是网络层数据，IP 层数据。这里有 IP 地址（源 IP 地址和目标 IP 地址）；也有头部的 Checksum（用来纠错的）。这里就不一一介绍了，你可以回到“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=837#/detail/pc?id=7271&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">06 | IPv4 协议：路由和寻址的区别是什么？</a>”复习这块内容。</li><li>最下面是传输层数据。 也就是 TCP 协议。关注的是源端口，目标端口，Seq、ACK 等。</li><li>有的传输层上还有一个 TLS 协议，这是因为用 HTTPS 请求了数据。TLS 也是传输层。TLS 是建立在 TCP 之上，复用了 TCP 的逻辑。</li></ul><h4 id="观察-HTTP-协议"><a href="#观察-HTTP-协议" class="headerlink" title="观察 HTTP 协议"></a>观察 HTTP 协议</h4><p>Wireshark 还可以用来观察其他的协议，比如说 HTTP 协议，下图是对 HTTP 协议的一次捕获：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802200225.png" alt="image-20210802200225492"></p><p>可以看到，Wireshark 不仅仅捕获了应用层，还可以看到这次 HTTP 捕获对应的传输层、网络层和链路层数据。</p><h4 id="过滤和筛选"><a href="#过滤和筛选" class="headerlink" title="过滤和筛选"></a>过滤和筛选</h4><p>Wireshark 还提供了捕获的过滤，我们只需要输入过滤条件，就可以只看符合条件的捕获。</p><p>比如我们想分析一次到百度的握手。首先开启捕获，然后在浏览器输入百度的网址，最后通过<code>ping</code>指令看下百度的 IP 地址，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802200313.png" alt="image-20210802200313749"></p><p>看到IP 地址之后，我们在 Wireshark 中输入表达式，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803112824.png" alt="image-20210803112823819"></p><p>这样看到的就是和百度关联的所有连接。上图中刚好是一次从建立 TCP 连接（3 次握手），到 HTTPS 协议传输握手的完整过程。你可以只看从<code>192.168.1.5</code>到<code>14.215.177.39</code>的请求。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803112917.png" alt="image-20210803112917193"></p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113019.png" alt="image-20210803113019378"></p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113046.png" alt="image-20210803113046506"></p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113103.png" alt="image-20210803113103219"></p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113115.png" alt="image-20210803113114942"></p><p>报文颜色<br>在抓包过程中，黑色报文代表各类报文错误；红色代表出现异常；其他颜色代表正常传输。</p><p>Wireshark 是个强大的工具，支持大量的协议。还有很多关于 Wireshark 的能力，希望你可以进一步探索，如下图中鼠标右键一次捕获，可以看到很多选项，都是可以深挖的。</p><h3 id="模块二加餐"><a href="#模块二加餐" class="headerlink" title="模块二加餐"></a>模块二加餐</h3><h4 id="下面这几个地址-127-0-0-1-localhost-0-0-0-0-有什么不同？"><a href="#下面这几个地址-127-0-0-1-localhost-0-0-0-0-有什么不同？" class="headerlink" title="下面这几个地址 127.0.0.1, localhost, 0.0.0.0 有什么不同？"></a>下面这几个地址 127.0.0.1, localhost, 0.0.0.0 有什么不同？</h4><p>127.0.0.1是本地回环地址（loopback），发送到 loopback 的数据会被转发到本地应用。</p><p>localhost 指代的是本地计算机，用于访问绑定在 loopback 上的服务。localhost 是一个主机名，不仅仅可以指向 IPv4 的本地回环地址，也可以指向 IPv6 的本地回环地址 [::1]。</p><p>0.0.0.0是一个特殊目的 IP 地址，称作不可路由 IP 地址，它的用途会被特殊规定。通常情况下，当我们把一个服务绑定到0.0.0.0，相当于把服务绑定到任意的 IP 地址。比如一台服务器上有多个网卡，不同网卡连接不同的网络，如果服务绑定到 0.0.0.0 就可以保证服务在多个 IP 地址上都可以用。</p><h4 id="IPv6-和-IPv4-究竟有哪些区别？"><a href="#IPv6-和-IPv4-究竟有哪些区别？" class="headerlink" title="IPv6 和 IPv4 究竟有哪些区别？"></a>IPv6 和 IPv4 究竟有哪些区别？</h4><p>IPv6 和 IPv4 最核心的区别是地址空间大小不同。IPv6 用 128 位地址，解决了 IP 地址耗尽问题。因为地址空间大小不同，它们对地址的定义，对路由寻址策略都有显著的差异。</p><p>在路由寻址策略上，IPv6 消除了设备间地址冲突的问题，改变了划分子网的方式。在 IPv4 网络中，一个局域网往往会共享一个公网 IP，因此需要 NAT 协议和外网连接。</p><p>在划分子网的时候，IPv4 地址少，需要子网掩码来处理划分子网。IPv6 有充足的地址，因此不需要局域网共享外网 IP。也正因为 IPv6 地址多，可以直接将 IPv6 地址划分成站点、子网、设备，每个段都有充足的 IP 地址。</p><p>因为 IPv6 支持的 IP 地址数量大大上升，一个子网可以有 248 个 IP 地址，这个子网可能是公司网络、家庭网络等。这样 IP 地址的分配方式也发生了变化，IPv4 网络中设备分配 IP 地址的方式是中心化的，由 DHCP（动态主机协议）为局域网中的设备分配 IP 地址。而在 IPv6 网络中，因为 IP 地址很少发生冲突，可以由设备自己申请自己的 IP 地址。</p><p>另外因为 IPv6 中任何一个节点都可以是一个组播节点，这样就可以构造一个对等的网络，也就是可以支持在没有中心化的路由器，或者一个网络多个路由器的情况下工作。节点可以通过向周围节点类似打探消息的方式，发现更多的节点。这是一个配套 IPv6 的能力，叫作邻居发现（ND）。</p><h4 id="IPv6-协议还需要-NAT-吗？"><a href="#IPv6-协议还需要-NAT-吗？" class="headerlink" title="IPv6 协议还需要 NAT 吗？"></a>IPv6 协议还需要 NAT 吗？</h4><p>IPv6 解决了 IP 耗尽的问题，为机构、组织、公司、家庭等网络提供了充足的 IP 资源，从这个角度看是不是就不需要 NAT 协议了呢？</p><p>在没有 IPv6 之前，NAT 是 IP 资源耗尽的主流解决方案。在一个内网中的全部设备通过 NAT 协议共享一个外网的 IPv4 地址，是目前内外网对接的主要方式。IPv6 地址资源充足，可以给全球每个设备一个独立的地址。从这个角度看 IPv6 的确不需要 NAT 协议。</p><p>但是目前的情况，是 IPv6 网络还没有完全普及。尽管很多公司已经支持自己的互联网产品可以使用 IPv6 访问，但是公司内部员工使用的内部网络还是 IPv4。如果要连接 IPv6 和 IPv4 网络，仍然需要 NAT 协议（NAT64），这个协议可以让多个 IPv6 的设备共享一个 IPv4 的公网地址。</p><h4 id="写一个-UDP-连接程序，然后用-Wireshark-抓包。"><a href="#写一个-UDP-连接程序，然后用-Wireshark-抓包。" class="headerlink" title="写一个 UDP 连接程序，然后用 Wireshark 抓包。"></a>写一个 UDP 连接程序，然后用 Wireshark 抓包。</h4><p>服务端程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> byte[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">    DatagramPacket packet</span><br><span class="line"></span><br><span class="line">            = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"try receive..."</span>);</span><br><span class="line"></span><br><span class="line">    socket.receive(packet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> address = packet.getAddress();</span><br><span class="line"></span><br><span class="line">    int port = packet.getPort();</span><br><span class="line"></span><br><span class="line">    packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length, address, port);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> received</span><br><span class="line"></span><br><span class="line">            = <span class="keyword">new</span> <span class="built_in">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line"></span><br><span class="line">    socket.send(packet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> buf = <span class="string">"Hello"</span>.getBytes();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> address = InetAddress.getByName(<span class="string">"localhost"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> packet</span><br><span class="line"></span><br><span class="line">          = <span class="keyword">new</span> DatagramPacket(buf, buf.length, address, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">  socket.send(packet);</span><br><span class="line"></span><br><span class="line">  socket.receive(packet);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> received = <span class="keyword">new</span> <span class="built_in">String</span>(</span><br><span class="line"></span><br><span class="line">          packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line"></span><br><span class="line">  System.out.format(<span class="string">"Server echo : %s\n"</span>, received);</span><br></pre></td></tr></table></figure><p>发现发送和接收的都是<code>Datagram</code>报文。而且服务端和客户端之间不需要建立连接。服务端可以通过读取客户端的地址区分客户端，客户端通过服务端地址和端口发送数据到服务端。</p><h3 id="Socket-编程：epoll-为什么用红黑树？"><a href="#Socket-编程：epoll-为什么用红黑树？" class="headerlink" title="Socket 编程：epoll 为什么用红黑树？"></a>Socket 编程：epoll 为什么用红黑树？</h3><p>从编程的角度来看，客户端将数据发送给在客户端侧的<strong>Socket 对象</strong>，然后客户端侧的 Socket 对象将数据发送给服务端侧的 Socket 对象。<strong>Socket 对象负责提供通信能力，并处理底层的 TCP 连接/UDP 连接</strong>。对服务端而言，每一个客户端接入，就会形成一个和客户端对应的 Socket 对象，如果服务器要读取客户端发送的信息，或者向客户端发送信息，就需要通过这个客户端 Socket 对象。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803144303.png" alt="image-20210803144303830"></p><p><strong>但是如果从另一个角度去分析，Socket 还是一种文件，准确来说是一种双向管道文件</strong>。什么是管道文件呢？管道会将一个程序的输出，导向另一个程序的输入。那么什么是双向管道文件呢？双向管道文件连接的程序是对等的，都可以作为输入和输出。</p><p>比如下面这段服务端侧程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">80</span>));</span><br></pre></td></tr></table></figure><p>看起来我们创建的是一个服务端 Socket 对象，但如果单纯看这个对象，它又代表什么呢？如果我们理解成代表服务端本身合不合理呢——这可能会比较抽象，在服务端存在一个服务端 Socket。但如果我们从管道文件的层面去理解它，就会比较容易了。其一，这是一个文件；其二，它里面存的是所有客户端 Socket 文件的文件描述符。</p><p>当一个客户端连接到服务端的时候，操作系统就会创建一个客户端 Socket 的文件。然后操作系统将这个文件的文件描述符写入服务端程序创建的服务端 Socket 文件中。服务端 Socket 文件，是一个管道文件。如果读取这个文件的内容，就相当于从管道中取走了一个客户端文件描述符。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803145544.png" alt="image-20210803145544248"></p><p>如上图所示，服务端 Socket 文件相当于一个客户端 Socket 的目录，线程可以通过 accept() 操作每次拿走一个客户端文件描述符。拿到客户端文件描述符，就相当于拿到了和客户端进行通信的接口。</p><p>前面我们提到 Socket 是一个双向的管道文件，当线程想要读取客户端传输来的数据时，就从客户端 Socket 文件中读取数据；当线程想要发送数据到客户端时，就向客户端 Socket 文件中写入数据。<strong>客户端 Socket 是一个双向管道，操作系统将客户端传来的数据写入这个管道，也将线程写入管道的数据发送到客户端</strong>。</p><p>有同学会说，那既然可以双向传送，这不就是两个单向管道被拼凑在了一起吗？这里具体的实现取决于操作系统，Linux 中的管道文件都是单向的，因此 Socket 文件是一种区别于原有操作系统管道的单独的实现。</p><p>总结下，Socket 首先是文件，存储的是数据。对服务端而言，分成服务端 Socket 文件和客户端 Socket 文件。服务端 Socket 文件存储的是客户端 Socket 文件描述符；客户端 Socket 文件存储的是传输的数据。读取客户端 Socket 文件，就是读取客户端发送来的数据；写入客户端文件，就是向客户端发送数据。对一个客户端而言， Socket 文件存储的是发送给服务端（或接收的）数据。</p><p><strong>综上，Socket 首先是文件，在文件的基础上，又封装了一段程序，这段程序提供了 API 负责最终的数据传输</strong>。</p><h4 id="服务端-Socket-的绑定"><a href="#服务端-Socket-的绑定" class="headerlink" title="服务端 Socket 的绑定"></a>服务端 Socket 的绑定</h4><p>为了区分应用，对于一个服务端 Socket 文件，我们要设置它监听的端口。比如 Nginx 监听 80 端口、Node 监听 3000 端口、SSH 监听 22 端口、Tomcat 监听 8080 端口。端口监听不能冲突，不然客户端连接进来创建客户端 Socket 文件，文件描述符就不知道写入哪个服务端 Socket 文件了。这样操作系统就会把连接到不同端口的客户端分类，将客户端 Socket 文件描述符存到对应不同端口的服务端 Socket 文件中。</p><p><strong>因此，服务端监听端口的本质，是将服务端 Socket 文件和端口绑定，这个操作也称为 bind</strong>。有时候我们不仅仅绑定端口，还需要绑定 IP 地址。这是因为有时候我们只想允许指定 IP 访问我们的服务端程序。</p><h4 id="扫描和监听"><a href="#扫描和监听" class="headerlink" title="扫描和监听"></a>扫描和监听</h4><p>对于一个服务端程序，可以定期扫描服务端 Socket 文件的变更，来了解有哪些客户端想要连接进来。如果在服务端 Socket 文件中读取到一个客户端的文件描述符，就可以将这个文件描述符实例化成一个 Socket 对象。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803152908.png" alt="image-20210803152908750"></p><p>之后，服务端可以将这个 Socket 对象加入一个容器（集合），通过定期遍历所有的客户端 Socket 对象，查看背后 Socket 文件的状态，从而确定是否有新的数据从客户端传输过来。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803153001.png" alt="image-20210803153001467"></p><p>上述的过程，我们通过一个线程就可以响应多个客户端的连接，也被称作<strong>I/O 多路复用技术</strong>。</p><h4 id="响应式（Reactive）"><a href="#响应式（Reactive）" class="headerlink" title="响应式（Reactive）"></a>响应式（Reactive）</h4><p>在 I/O 多路复用技术中，服务端程序（线程）需要维护一个 Socket 的集合（可以是数组、链表等），然后定期遍历这个集合。这样的做法在客户端 Socket 较少的情况下没有问题，但是如果接入的客户端 Socket 较多，比如达到上万，那么每次轮询的开销都会很大。</p><p>从程序设计的角度来看，像这样主动遍历，比如遍历一个 Socket 集合看看有没有发生写入（有数据从网卡传过来），称为<strong>命令式的程序</strong>。这样的程序设计就好像在执行一条条命令一样，程序主动地去查看每个 Socket 的状态。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803153240.png" alt="image-20210803153240124"></p><p>命令式会让负责下命令的程序负载过重，例如，在高并发场景下，上述讨论中循环遍历 Socket 集合的线程，会因为负担过重导致系统吞吐量下降。</p><p>与命令式相反的是响应式（Reactive），响应式的程序就不会有这样的问题。在响应式的程序当中，每一个参与者有着独立的思考方式，就好像拥有独立的人格，可以自己针对不同的环境触发不同的行为。</p><p>从响应式的角度去看 Socket 编程，应该是有某个观察者会观察到 Socket 文件状态的变化，从而通知处理线程响应。线程不再需要遍历 Socket 集合，而是等待观察程序的通知。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803153251.png" alt="image-20210803153251665"></p><p>当然，最合适的观察者其实是操作系统本身，因为只有操作系统非常清楚每一个 Socket 文件的状态。原因是对 Socket 文件的读写都要经过操作系统。在实现这个模型的时候，有几件事情要注意。</p><ol><li>线程需要告诉中间的观察者自己要观察什么，或者说在什么情况下才响应？比如具体到哪个 Socket 发生了什么事件？是读写还是其他的事件？这一步我们通常称为<strong>注册</strong>。</li><li>中间的观察者需要实现一个高效的数据结构（通常是基于红黑树的二叉搜索树）。这是因为中间的观察者不仅仅是服务于某个线程，而是服务于很多的线程。当一个 Socket 文件发生变化的时候，中间观察者需要立刻知道，究竟是哪个线程需要这个信息，而不是将所有的线程都遍历一遍。</li></ol><h4 id="为什么用红黑树？"><a href="#为什么用红黑树？" class="headerlink" title="为什么用红黑树？"></a>为什么用红黑树？</h4><p>关于为什么要红黑树，这里我给你再仔细解释一下。考虑到中间观察者最核心的诉求有两个。</p><p><strong>第一个核心诉求，是让线程可以注册自己关心的消息类型</strong>。比如线程对文件描述符 =123 的 Socket 文件读写都感兴趣，会去中间观察者处注册。当 FD=123 的 Socket 发生读写时，中间观察者负责通知线程，这是一个响应式的模型。</p><p><strong>第二个核心诉求，是当 FD=123 的 Socket 发生变化（读写等）时，能够快速地判断是哪个线程需要知道这个消息</strong>。</p><p>所以，中间观察者需要一个快速能插入（注册过程）、查询（通知过程）一个整数的数据结构，这个整数就是 Socket 的文件描述符。综合来看，能够解决这个问题的数据结构中，跳表和二叉搜索树都是不错的选择。</p><p>因此，在 Linux 的 epoll 模型中，选择了红黑树。红黑树是二叉搜索树的一种，红与黑是红黑树的实现者才关心的内容，对于我们使用者来说不用关心颜色，Java 中的 TreeMap 底层就是红黑树。</p><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p>总结一下，<strong>Socket 既是一种编程模型，或者说是一段程序，同时也是一个文件，一个双向管道文件</strong>。你也可以这样理解，Socket API 是在 Socket 文件基础上进行的一层封装，而 Socket 文件是操作系统提供支持网络通信的一种文件格式。</p><p>在服务端有两种 Socket 文件，每个客户端接入之后会形成一个客户端的 Socket 文件，客户端 Socket 文件的文件描述符会存入服务端 Socket 文件。通过这种方式，一个线程可以通过读取服务端 Socket 文件中的内容拿到所有的客户端 Socket。这样一个线程就可以负责响应所有客户端的 I/O，这个技术称为 I/O 多路复用。</p><p>主动式的 I/O 多路复用，对负责 I/O 的线程压力过大，因此通常会设计一个高效的中间数据结构作为 I/O 事件的观察者，线程通过订阅 I/O 事件被动响应，这就是响应式模型。在 Socket 编程中，最适合提供这种中间数据结构的就是操作系统的内核，事实上 epoll 模型也是在操作系统的内核中提供了红黑树结构。</p><h4 id="epoll-为什么用红黑树？"><a href="#epoll-为什么用红黑树？" class="headerlink" title="epoll 为什么用红黑树？"></a><strong>epoll 为什么用红黑树</strong>？</h4><p>【<strong>解析</strong>】在 Linux 的设计中有三种典型的 I/O 多路复用模型 select、poll、epoll。</p><p>select 是一个主动模型，需要线程自己通过一个集合存放所有的 Socket，然后发生 I/O 变化的时候遍历。在 select 模型下，操作系统不知道哪个线程应该响应哪个事件，而是由线程自己去操作系统看有没有发生网络 I/O 事件，然后再遍历自己管理的所有 Socket，看看这些 Socket 有没有发生变化。</p><p>poll 提供了更优质的编程接口，但是本质和 select 模型相同。因此千级并发以下的 I/O，你可以考虑 select 和 poll，但是如果出现更大的并发量，就需要用 epoll 模型。</p><p>epoll 模型在操作系统内核中提供了一个中间数据结构，这个中间数据结构会提供事件监听注册，以及快速判断消息关联到哪个线程的能力（红黑树实现）。因此在高并发 I/O 下，可以考虑 epoll 模型，它的速度更快，开销更小。</p><h3 id="流和缓冲区：缓冲区的-flip-是怎么回事？"><a href="#流和缓冲区：缓冲区的-flip-是怎么回事？" class="headerlink" title="流和缓冲区：缓冲区的 flip 是怎么回事？"></a>流和缓冲区：缓冲区的 flip 是怎么回事？</h3><p>计算机中，数据往往会被抽象成流，然后传输。比如读取一个文件，数据会被抽象成文件流；播放一个视频，视频被抽象成视频流。处理节点为了防止过载，又会使用缓冲区削峰（减少瞬间压力）。在传输层协议当中，应用往往先把数据放入缓冲区，然后再将缓冲区提供给发送数据的程序。发送数据的程序，从缓冲区读取出数据，然后进行发送。</p><h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>流代表数据，具体来说是随着时间产生的数据，类比自然界的河流。你不知道一个流什么时候会完结，直到你将流中的数据都读完。</p><p>读取文件的时候，文件被抽象成流。流的内部构造，决定了你每次能从文件中读取多少数据。从流中读取数据的操作，本质上是一种迭代器。流的内部构造决定了迭代器每次能读出的数据规模。比如你可以设计一个读文件的流，每次至少会读出 4k 大小，也可以设计一个读文件的程序，每次读出一个字节大小。</p><p>通常情况读取数据的流，是读取流；写入数据的流，是写入流。那么一个写入流还能被理解成随着时间产生的数据吗？其实是一样的，随着时间产生的数据，通过写入流写入某个文件，或者被其他线程、程序拿走使用。</p><p>这里请你思考一个问题：流中一定有数据吗？看上去的确是这样。对于文件流来说，打开一个文件，形成读取流。读取流的本质当然是内存中的一个对象。当用户读取文件内容的时候，实际上是通过流进行读取，看上去好像从流中读取了数据，而本质上读取的是文件的数据。从这个角度去观察整体的设计，数据从文件到了流，然后再到了用户线程，因此数据是经过流的。</p><p>但是仔细思考这个问题，可不可以将数据直接从文件传输到用户线程呢？比如流对象中只设计一个整数型指针，一开始指向文件的头部，每次发生读取，都从文件中读出内容，然后再返回给用户线程。做完这次操作，指针自增。通过这样的设计，流中就不需要再有数据了。可见，流中不一定要有数据。再举一个极端的例子，如果我们设计一个随机数的产生流，每次读取流中的数据，都调用随机数函数生成一个随机数并返回，那么流中也不需要有数据的存储。</p><h4 id="为什么要缓冲区？"><a href="#为什么要缓冲区？" class="headerlink" title="为什么要缓冲区？"></a>为什么要缓冲区？</h4><p>在上面的例子当中，我们讨论的时候发现，设计文件流时，可以只保留一个位置指针，不用真的将整个文件都读入内存，像下图这样：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805093142.png" alt="image-20210805093135218"></p><p>把文件看作是一系列线性排列连续字节的合集，用户线程调用流对象的读取数据方法，每次从文件中读取一个字节。流中只保留一个读取位置 position，指向下一个要读取的字节。</p><p>看上去这个方案可行，但实际上性能极差。因为从文件中读取数据这个操作，是一次磁盘的 I/O 操作，非常耗时。正确的做法是每次读取 2k、4k 这样大小的数据，这是因为操作系统中的内存分页通常是这样的大小，而磁盘的读写往往是会适配页表大小。而且现在的文件系统主要都是日志文件系统，存储的并不是原始数据本身，也就是说多数情况下你看到的文件并不是一个连续紧密的字节线性排列，而是日志。关于这块内容，具体可以参考《重学操作系统》中《30 | 文件系统的底层实现：FAT、NTFS 和 Ext3 有什么区别》。</p><p>如果你不想花时间再去完整地学习一遍“操作系统”相关的内容，我这里先给一个结论：当你向磁盘读取 2k 数据，读取到的不一定是 2k 实际的数据，很有可能会比 2k 少，这是因为文件内容是以日志形式存储，会有冗余。</p><p>我们用下面这张图来描述下需求：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805093848.png" alt="image-20210805093848249"></p><p>如上图所示，内核每次从文件系统中读取到的数据是确定的，但是里边的有效数据是不确定的。流对象的设计，至少应该支持两种操作：一种是读取一个字节，另一种是读取多个字节。而无论读取一个字节还是读取多个字节，都应该适配内核的底层行为。也就是说，每次流对象读取一个字节，内核可能会读取 2k、4k 的数据。这样的行为，才能真的做到减少磁盘的 I/O 操作。那么有同学可能会问：内核为什么不一次先读取几兆数据或者读取更大的数据呢？这有两个原因。</p><p>如果是高并发场景下，并发读取数据时内存使用是根据并发数翻倍的，如果同时读取的数据量过大，可能会导致内存不足。</p><p>读取比 2k/4k……大很多倍的数据，比如 1M/2M 这种远远大于内存分页大小的数据，并不能提升性能。</p><p>所以最后我们的解决办就是创建两个缓冲区。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805093929.png" alt="image-20210805093928925"></p><p>上图中内核中的缓冲区，用于缓冲读取文件中的数据。流中的缓冲区，用于缓冲内核中拷贝过来的数据。有同学可能不理解，为什么不把内核的缓冲区直接给到流呢？这是因为流对象工作在用户空间，内核中的缓冲区工作在内核空间。用户空间的程序不可以直接访问内核空间的数据，这是操作系统的一种保护策略。具体可以参考《重学操作系统》中《14 | 用户态和内核态：用户态线程和内核态线程有什么区别？》，这里不再赘述。</p><p>当然也存在一种叫作内存映射的方式，就是内核通过内存映射，直接将内核空间中的一块内存区域分享给用户空间只读使用，这样的方式可以节省一次数据拷贝。这个能力在 Java 的 NIO 中称作 DirectMemory，对应 C 语言是 mmap。</p><h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>上面的设计中，我们已经开始用缓冲区解决问题了。那么具体什么是缓冲区呢？缓冲区就是一块用来做缓冲的内存区域。在上面的例子当中，为了应对频繁的字节读取，我们在内存当中设置一个 2k 大小缓冲区。这样读取 2048 次，才会真的发生一次读取。同理，如果应对频繁的字节写入，也可以使用缓冲区。</p><p>不仅仅如此，比如说你设计一个秒杀系统，如果同时到达的流量过高，也可以使用缓冲区将用户请求先存储下来，再进行处理。这个操作我们称为削峰，削去流量的峰值。</p><p>缓冲区中的数据通常具有朴素的公平，说白了就是排队，先进先出（FIFO）。从数据结构的设计上，缓冲区像一个队列。在实际的使用场景中，缓冲区有一些自己特别的需求，比如说缓冲区需要被重复利用。多次读取数据，可以复用一个缓冲区，这样可以节省内存，也可以减少分配和回收内存的开销。</p><p>举个例子：读取一个流的数据到一个缓冲区，然后再将缓冲区中的数据交给另一个流。 比如说读取文件流中的数据交给网络流发送出去。首先，我们要将文件流的数据写入缓冲区，然后网络流会读取缓冲区中的数据。这个过程会反反复复进行，直到文件内容全部发送。</p><p>这个设计中，缓冲区需要支持这几种操作：</p><p>写入数据</p><p>读出数据</p><p>清空（应对下一次读写）</p><p>那么具体怎么设计这个缓冲区呢？首先，数据可以考虑存放到一个数组中，下图是可以存 8 个字节的缓冲区：</p><p>写入数据的时候，需要一个指针指向下一个可以写入的位置，如下图所示：</p><p>每次写入数据，position 增 1，比如我们顺序写入 a,b,c,d 后，缓冲区如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805112609.png" alt="image-20210805112609774"></p><p>那么如果这个时候，要切换到读取状态该怎么做呢？再增加一个读取指针吗？聪明的设计者想到了一个办法，增加一个 limit 指针，随着写入指针一起增长，如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805112645.png" alt="image-20210805112645759"></p><p>当需要切换到读取状态的时候，将 position 设置为 0，limit 不变即可。下图中，我们可以从 0 开始读取数据，每次读取 position 增 1。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805112658.png" alt="image-20210805112658630"></p><p>我们将 position 设置为 0，limit 不变的操作称为flip操作，flip 本意是翻转，在这个场景中是读、写状态的切换。</p><p>读取操作可以控制循环从 position 一直读取到 limit，这样就可以读取出 a,b,c,d。那么如果要继续写入应该如何操作呢？ 这个时候就需要用到缓冲区的clear操作，这个操作会清空缓冲区。具体来说，clear操作会把 position,limit 都设置为 0，而不需要真的一点点擦除缓冲区中已有的值，就可以做到重复利用缓冲区了。</p><p>写入过程从 position = 0 开始，position 和 limit 一起自增。读取时，用flip操作切换缓冲区读写状态。读取数据完毕，用clear操作重置缓冲区状态。</p><p>总结<br>总结一下，流是随着时间产生的数据。数据抽象成流，是因为客观世界存在着这样的现象。数据被抽象成流之后，我们不需要把所有的数据都读取到内存当中进行计算和迭代，而是每次处理或者计算一个缓冲区的数据。</p><p>缓冲区的作用是缓冲，它在高频的 I/O 操作中很有意义。针对不同场景，也不只有这一种缓冲区的设计，比如用双向链表实现队列（FIFO 结构）可以作为缓冲区；Redis 中的列表可以作为缓冲区；RocketMQ，Kafka 等也可以作为缓冲区。针对某些特定场景，比如高并发场景下的下单处理，可能会用订单队列表（MySQL 的表）作为缓冲区。</p><p>因此从这个角度来说，作为开发者我们首先要有缓冲的意识，去减少 I/O 的次数，提升 I/O 的性能，然后才是思考具体的缓冲策略。</p><p>那么通过这一讲的学习，你可以尝试来回答本讲关联的面试题目：缓冲区的 flip 操作是怎么回事？</p><p>【解析】flip 操作意味翻转，是切换缓冲区的读写状态，在 flip 操作中，通常将 position 指针置 0，limit 指针不变。</p><h3 id="网络-I-O-模型：BIO、NIO-和-AIO-有什么区别？"><a href="#网络-I-O-模型：BIO、NIO-和-AIO-有什么区别？" class="headerlink" title="网络 I/O 模型：BIO、NIO 和 AIO 有什么区别？"></a>网络 I/O 模型：BIO、NIO 和 AIO 有什么区别？</h3><p>从本质上说，讨论 BIO、NIO、AIO 的区别，其实就是在讨论 I/O 的模型，我们可以从下面 3 个方面来思考 。</p><p>编程模型：合理设计 API，让程序写得更舒服。</p><p>数据的传输和转化成本：比如减少数据拷贝次数，合理压缩数据等。</p><p>高效的数据结构：利用好缓冲区、红黑树等（见本讲后续讨论）。</p><h4 id="I-O-的编程模型"><a href="#I-O-的编程模型" class="headerlink" title="I/O 的编程模型"></a>I/O 的编程模型</h4><p>我们先从编程模型上讨论下 BIO、NIO 和 AIO 的区别。</p><p>BIO（Blocking I/O，阻塞 I/O），API 的设计会阻塞程序调用。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte a = readKey()</span><br></pre></td></tr></table></figure><p>假设<code>readKey</code>方法会从键盘中读取一个用户的按键，如果是阻塞 I/O 的设计，ReadKey 会阻塞当前用户线程直到用户按键。这个阻塞指的是线程进入<strong>阻塞态</strong>。进入阻塞态的线程，状态会被存在内存中，执行会被中断，也就是不会占用 CPU å资源。阻塞态的线程要恢复执行，先要进入<strong>就绪态</strong>排队，然后轮到自己才能够继续执行。从一个线程执行切换到另一个线程执行，也叫作<strong>线程的上下文切换</strong>（Context Switch），是一个相对耗时的操作。</p><p>再说说 NIO （None Blocking I/O，非阻塞 IO），API 的设计不会阻塞程序的调用，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte a = readKey()</span><br></pre></td></tr></table></figure><p>假设<code>readKey</code>方法从键盘读取一个按键，如果是非阻塞 I/O 的设计，<code>readKey</code>不会阻塞当前的线程。你可能会问：那如果用户没有按键怎么办？在阻塞 I/O 的设计中，如果用户没有按键线程会阻塞等待用户按键，在非阻塞 I/O 的设计中，线程不会阻塞，没有按键会返回一个空值，比如 null。</p><p>最后我们说说 AIO（Asynchronous I/O， 异步 I/O），API 的设计会多创造一条时间线。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func callBackFunction(byte keyCode) &#123;</span><br><span class="line">  // 处理按键</span><br><span class="line">&#125;</span><br><span class="line">readKey( callBackFunction )</span><br></pre></td></tr></table></figure><p>在异步 I/O 中，<code>readKey</code>方法会直接返回，但是没有结果。结果需要一个回调函数<code>callBackFunction</code>去接收。从这个角度看，其实有两条时间线。第一条是程序的主干时间线，<code>readKey</code>的执行到<code>readKey</code>下文的程序都在这条主干时间线中。而<code>callBackFunction</code>的执行会在用户按键时触发，也就是时间不确定，因此<code>callBackFunction</code>中的程序是另一条时间线也是基于这种原因产生的，我们称作<strong>异步</strong>，异步描述的就是这种时间线上无法同步的现象，你不知道<code>callbackFunction</code>何时会执行。</p><p>但是我们通常说某某语言提供了异步 I/O，不仅仅是说提供上面程序这种写法，上面的写法会产生一个叫作<strong>回调地狱</strong>的问题，本质是异步程序的时间线错乱，导致维护成本较高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request(&quot;/order/123&quot;, (data1) -&gt; &#123;</span><br><span class="line">  //..</span><br><span class="line">  request(&quot;/product/456&quot;, (data2) -&gt; &#123;</span><br><span class="line">    // ..</span><br><span class="line">    request(&quot;/sku/789&quot;, (data3) -&gt; &#123;</span><br><span class="line">      //...</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>比如上面这段程序（称作回调地狱）维护成本较高，因此通常提供异步 API 编程模型时，我们会提供一种将异步转化为同步程序的语法。比如下面这段伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future future1 = request(&quot;/order/123&quot;)</span><br><span class="line">Future future2 = request(&quot;/product/456&quot;)</span><br><span class="line">Future future3 = request(&quot;/sku/789&quot;)</span><br><span class="line">// ...</span><br><span class="line">// ...</span><br><span class="line">order = future1.get()</span><br><span class="line">product = future2.get()</span><br><span class="line">sku = future3.get()</span><br></pre></td></tr></table></figure><p>request 函数是一次网络调用，请求订单 ID=123 的订单数据。本身 request 函数不会阻塞，会马上执行完成，而网络调用是一次异步请求，调用不会在<code>request(&quot;/order/123&quot;)</code>下一行结束，而是会在未来的某个时间结束。因此，我们用一个 Future 对象封装这个异步操作。<code>future.get()</code>是一个阻塞操作，会阻塞直到网络调用返回。</p><p>在<code>request</code>和<code>future.get</code>之间，我们还可以进行很多别的操作，比如发送更多的请求。 像 Future 这样能够将异步操作再同步回主时间线的操作，我们称作<strong>异步转同步</strong>，也叫作<strong>异步编程</strong>。通常一门语言如果提供异步编程的能力，指的是提供异步转同步的能力，程序员更适应同步操作，同步程序更好维护。</p><h4 id="数据的传输和转化成本"><a href="#数据的传输和转化成本" class="headerlink" title="数据的传输和转化成本"></a>数据的传输和转化成本</h4><p>上面我们从编程的模型上对 I/O 进行了思考，接下来我们从内部实现分析下 BIO、NIO 和 AIO。无论是哪种 I/O 模型，都要将数据从网卡拷贝到用户程序（接收），或者将数据从用户程序传输到网卡（发送）。另一方面，有的数据需要编码解码，比如 JSON 格式的数据。还有的数据需要压缩和解压。数据从网卡到内核再到用户程序是 2 次传输。注意，将数据从内存中的一个区域拷贝到另一个区域，这是一个 CPU 密集型操作。数据的拷贝归根结底要一个字节一个字节去做。</p><p>从网卡到内核空间的这步操作，可以用 DMA（Direct Memory Access）技术控制。DMA 是一种小型设备，用 DMA 拷贝数据可以不使用 CPU，从而节省计算资源。遗憾的是，通常我们写程序的时候，不能直接控制 DMA，因此 DMA 仅仅用于设备传输数据到内存中。不过，从内核到用户空间这次拷贝，可以用内存映射技术，将内核空间的数据映射到用户空间。</p><blockquote><p>本文关于 DMA 技术和多线程讨论较浅，对这两个技术感兴趣的同学可以看下我在拉勾教育平台推出的<a href="https://shenceyun.lagou.com/t/Axo?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">《重学操作系统》</a>专栏。</p></blockquote><p>有同学会问：上面我们讨论的内容和 I/O 模型有什么关联吗？其实我是想告诉你，无论 I/O 的编程模型如何选择，数据传输和转化成本是逃不掉的。或者说不会因为选择某种模型，就减少数据传输、数据压缩解压、数据编码解码这方面的成本。但是通过 DMA 技术和内存映射技术，就可以节省这部分成本。<strong>之所以会特别强调这点，是因为网上很多的博文会把 DMA、内存映射技术和 BIO/AIO/NIO 等概念混为一谈。</strong></p><h4 id="数据结构运用"><a href="#数据结构运用" class="headerlink" title="数据结构运用"></a>数据结构运用</h4><p>在处理网络 I/O 问题的时候，还有一个重点问题要注意，就是数据结构的运用。</p><h4 id="缓冲区-1"><a href="#缓冲区-1" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>缓冲区是一种在处理 I/O 问题中常用的数据结构，<strong>一方面缓冲区起到缓冲作用</strong>，在瞬时 I/O 量较大的时候，利用排队机制进行处理。<strong>另一方面，缓冲区起到一个批处理的作用</strong>，比如 1000 次 I/O 请求进入缓冲区，可以合并成 50 次 I/O 请求，那么整体性能就会上一个档次。</p><p>举个例子，比如你有 1000 个订单要写入 MySQL，如果这个时候你可以将这 1000 次请求合并成 50 次，那么磁盘写入次数将大大减少。同理，假设有 10000 次网络请求，如果可以合并发送，会减少 TCP 协议握手时间，可以最大程度地复用连接；另一方面，如果这些请求都较小，还可以粘包复用 TCP 段。在处理 Web 网站的时候，经常会碰到将多个 HTTP 请求合并成一个发送，从而减少整体网络开销的情况。</p><p><strong>除了上述两方面原因，缓冲区还可以减少实际对内存的诉求</strong>。数据在网卡到内核，内核到用户空间的过程中，建议都要使用缓冲区。当收到的某个请求较大的时候，抽象成流，然后使用缓冲区可以减少对内存的使用压力。这是因为使用了缓冲区和流，就不需要真的准备和请求数据大小一致的内存空间了。可以将缓冲区大小规模的数据分成多次处理完，实际的内存开销是缓冲区的大小。</p><h4 id="I-O-多路复用模型"><a href="#I-O-多路复用模型" class="headerlink" title="I/O 多路复用模型"></a>I/O 多路复用模型</h4><p>在运用数据结构的时候，还要思考 I/O 的多路复用用什么模型。</p><p>假设你在处理一个高并发的网站，每秒有大量的请求打到你的服务器上，你用多少个线程去处理 I/O 呢？对于没有需要压缩解压的场景，处理 I/O 的主要开销还是数据的拷贝。那么一个 CPU 核心每秒可以完成多少次数据拷贝呢？</p><p>拷贝，其实就是将内存中的数据从一个地址拷贝到另一个地址。再加上有 DMA，内存映射等技术，拷贝是非常快的。不考虑 DMA 和内存映射，一个 3GHz 主频的 CPU 每秒可以拷贝的数据也是百兆级别的。当然，速度还受限于内存本身的速度。<strong>因此总的来说，I/O 并不需要很大的计算资源</strong>。通常我们在处理高并发的时候，也不需要大量的线程去进行 I/O 处理。</p><p>对于多数应用来说，处理 I/O 的成本小于处理业务的成本。处理高并发的业务，可能需要大量的计算资源。每笔业务也可能会需要更多的 I/O，比如远程的 RPC 调用等。</p><p><strong>因此我们在处理高并发的时候，一种常见的 I/O 多路复用模式就是由少量的线程处理大量的网络接收、发送工作。然后再由更多的线程，通常是一个线程池处理具体的业务工作</strong>。在这样一个模式下，有一个核心问题需要解决，就是当操作系统内核监测到一次 I/O 操作发生，它如何具体地通知到哪个线程调用哪段程序呢？</p><p>这时，一种高效的模型会要求我们将线程、线程监听的事件类型，以及响应的程序注册到内核。具体来说，比如某个客户端发送消息到服务器的时候，我们需要尽快知道哪个线程关心这条消息（处理这个数据）。例如 epoll 就是这样的模型，内部是红黑树。我们可以具体地看到文件描述符构成了一棵红黑树，而红黑树的节点上挂着文件描述符对应的线程、线程监听事件类型以及相应程序。</p><p>最后，你可能会问：老师你讲了这么多，和 BIO、AIO、NIO 有什么关系？这里有两个联系。</p><p><strong>首先是无论哪种编程模型都需要使用缓冲区，也就是说 BIO、AIO、NIO 都需要缓冲区</strong>，因此关系很大。在我们使用任何编程模型的时候，如果内部没有使用缓冲区，那么一定要在外部增加缓冲区。<strong>另一个联系是类似 epoll 这种注册+消息推送的方式，可以帮助我们节省大量定位具体线程以及事件类型的时间</strong>。这是一个通用技巧，并不是独有某种 I/O 模型才可以使用。</p><p>不过从能力上分析，使用类似 epoll 这种模型，确实没有必要让处理 I/O 的线程阻塞，因为操作系统会将需要响应的事件源源不断地推送给处理的线程，因此可以考虑不让处理线程阻塞（比如用 NIO）。</p><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><p>这一讲我们从 3 个方面讨论了 I/O 模型。</p><ul><li><strong>第一个是编程模型</strong>，阻塞、非阻塞、异步 3 者 API 的设计会有比较大的差异。通常情况下我们说的异步编程是异步转同步。异步转同步最大的价值，就是提升代码的可读性。可读，就意味着维护成本的下降以及扩展性的提升。</li><li>第二个在设计系统的 I/O 时，另一件<strong>需要考虑的就是数据传输以及转化的成本</strong>。传输主要是拷贝，比如可以使用内存映射来减少数据的传输。但是这里要注意一点，内存映射使用的内存是内核空间的缓冲区，因此千万不要忘记回收。因为这一部分内存往往不在我们所使用的语言提供的内存回收机制的管控范围之内。</li><li><strong>最后是关于数据结构的运用</strong>，针对不同的场景使用不同的缓冲区，以及选择不同的消息通知机制，也是处理高并发的一个核心问题。</li></ul><p>从上面几个角度去看 I/O 的模型，你会发现，编程模型是编程模型、数据的传输是数据的传输、消息的通知是消息的通知，它们是不同的模块，完全可以解耦，也可以根据自己不同的业务特性进行选择。虽然在一个完整的系统设计中，往往提出的是一套完整的解决方案（这也是很多网上的博文会将者 3 者混为一谈的原因），但实际上我们还是应该将它们分开去思考，这样可以产生更好的设计思路。</p><p><strong>那么现在你可以尝试来回答本讲关联的面试题目：BIO、NIO 和 AIO 有什么区别?</strong></p><p>【<strong>解析</strong>】总的来说，这三者是三个 I/O 的编程模型。BIO 接口设计会直接导致当前线程阻塞。NIO 的设计不会触发当前线程的阻塞。AIO 为 I/O 提供了异步能力，也就是将 I/O 的响应程序放到一个独立的时间线上去执行。但是通常 AIO 的提供者还会提供异步编程模型，就是实现一种对异步计算封装的数据结构，并且提供将异步计算同步回主线的能力。</p><p>通常情况下，这 3 种 API 都会伴随 I/O 多路复用。如果底层用红黑树管理注册的文件描述符和事件，可以在很小的开销内由内核将 I/O 消息发送给指定的线程。另外，还可以用 DMA，内存映射等方式优化 I/O。</p><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>零拷贝的核心是CPU不执行将数据从一个存储区复制到另一个存储区的任务。</p><p>可能你会说，那零拷贝是不是0次调用CPU消耗资源啊？既对也不对，为什么这样说呢？</p><p>实际上，零拷贝有广义和狭义之分。</p><h4 id="广义零拷贝"><a href="#广义零拷贝" class="headerlink" title="广义零拷贝"></a>广义零拷贝</h4><p>能减少拷贝次数，减少不必要的数据拷贝，就算作“零拷贝”。</p><p>这是目前，对零拷贝最为广泛的定义，我们需要知道的是，这是广义上的零拷贝，并不是操作系统意义上的零拷贝。</p><h4 id="狭义零拷贝"><a href="#狭义零拷贝" class="headerlink" title="狭义零拷贝"></a>狭义零拷贝</h4><p>Linux 2.4 内核新增 sendfile 系统调用，提供了零拷贝。磁盘数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer(socket buffer)，无需 CPU 拷贝。这是真正操作系统意义上的零拷贝(也就是狭义零拷贝)。</p><h4 id="Linux-I-O-机制"><a href="#Linux-I-O-机制" class="headerlink" title="Linux I/O 机制"></a><strong>Linux I/O 机制</strong></h4><p>介绍 DMA 之前，我们先来了解下 Linux I/O 机制。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808194717.png" alt="image-20210808194709993"></p><p>为了解决CPU的上下文切换，聪明的程序员们提出了 <code>DMA(Direct Memory Access，直接内存存取)</code>，是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。通俗点理解，就是让硬件可以跳过CPU的调度，直接访问主内存。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808195425.png" alt="image-20210808195425225"></p><p>DMA 控制器，接管了数据读写请求，减少 CPU 的负担。这样一来，CPU 能高效工作了。<br>现代硬盘基本都支持 DMA。</p><p>比如我们常见的磁盘控制器、显卡、网卡、声卡都是支持 DMA 的，可以说 DMA 已经彻底融入我们的计算机世界了。</p><h4 id="Linux-IO-流程"><a href="#Linux-IO-流程" class="headerlink" title="Linux IO 流程"></a><strong>Linux IO 流程</strong></h4><p>那么什么又是<strong>DMA</strong>拷贝呢？</p><p>因为对于一个IO操作而言，都是通过CPU发出对应的指令来完成，但是相比CPU来说，IO的速度太慢了，CPU有大量的时间处于等待IO的状态。</p><p>因此就产生了DMA（Direct Memory Access）直接内存访问技术，本质上来说他就是一块主板上独立的芯片，通过它来进行内存和IO设备的数据传输，从而减少CPU的等待时间。</p><p>但是无论谁来拷贝，频繁的拷贝耗时也是对性能的影响。</p><p>实际因此 IO 读取，涉及两个过程：</p><ul><li>DMA 等待数据准备好，把磁盘数据读取到操作系统内核缓冲区；</li><li>用户进程，将内核缓冲区的数据 copy 到用户空间。</li></ul><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808195528.png" alt="image-20210808195528165"></p><p>了解完 DMA 以及 Linux I/O 流程，相信你对 Linux I/O 机制有个大致的脉络了，但你可能会问，了解完这些，跟我们零拷贝技术有啥关联么？有的.</p><h4 id="传统-IO-的劣势"><a href="#传统-IO-的劣势" class="headerlink" title="传统 IO 的劣势"></a>传统 IO 的劣势</h4><p>我们刚学 Java 的时候，都会学 IO 和 网络编程，最常见的就是写个聊天程序或是群聊。</p><p>我们来写个简单的，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;index.html&quot;);</span><br><span class="line">RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line"> </span><br><span class="line">byte[] arr = new byte[(int) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"> </span><br><span class="line">Socket socket = new ServerSocket(8080).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure><p>服务端读取 html 里的内容后变成字节数组，然后监听 8080 端口，接收请求处理，将 html 里的字节流写到 socket 中，那么，我们调用read、write这两个方法，在 OS 底层发生了什么呢？</p><p>整个过程发生了<strong>4次用户态和内核态的上下文切换</strong>和<strong>4次拷贝</strong></p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808195704.png" alt="image-20210808195704164"></p><p>read 调用导致用户态到内核态的一次变化，同时，</p><ul><li>第一次复制开始：DMA（Direct Memory Access，直接内存存取，即不使用 CPU 拷贝数据到内存，而是 DMA 引擎传输数据到内存）引擎从磁盘读取 index.html 文件，并将数据放入到内核缓冲区。</li><li>发生第二次数据拷贝，即：将内核缓冲区的数据拷贝到用户缓冲区，同时，发生了一次用内核态到用户态的上下文切换。</li><li>发生第三次数据拷贝，我们调用 write 方法，系统将用户缓冲区的数据拷贝到 socket 缓冲区。此时，又发生了一次用户态到内核态的上下文切换。</li><li>第四次拷贝，数据异步的从 socket 缓冲区，使用 DMA 引擎拷贝到网络协议引擎。这一段，不需要进行上下文切换。<br>write 方法返回，再次从内核态切换到用户态。</li></ul><p>目的：减少 IO 流程中不必要的拷贝</p><p>零拷贝需要 OS 支持，也就是需要 kernel暴 露 api，虚拟机不能操作内核。</p><p><strong>Linux 支持的(常见)零拷贝</strong></p><p><strong>1、mmap 内存映射</strong></p><p>那我们这里先来了解下什么是mmap 内存映射。</p><p>在 Linux 中我们可以使用 mmap 用来在进程虚拟内存地址空间中分配地址空间，创建和物理内存的映射关系。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808202324.png" alt="image-20210808202323982"></p><p>映射关系可以分为两种</p><ul><li>文件映射：磁盘文件映射进程的虚拟地址空间，使用文件内容初始化物理内存。</li><li>匿名映射：初始化全为 0 的内存空间。<br>而对于映射关系是否共享又分为</li></ul><p>私有映射(MAP_PRIVATE) 多进程间数据共享，修改不反应到磁盘实际文件，是一个 copy-on- write(写时复制) 的映射方式。<br>共享映射(MAP_SHARED) 多进程间数据共享，修改反应到磁盘实际文件中。</p><p>因此总结起来有4种组合</p><ul><li>私有文件映射：多个进程使用同样的物理内存页进行初始化，但是各个进程对内存文件的修改不会共享，也不会反应到物理文件中。</li><li>私有匿名映射：mmap会创建一个新的映射，各个进程不共享，这种使用主要用于分配内存 (malloc分配大内存会调用mmap)。 例如开辟新进程时，会为每个进程分配虚拟的地址空间，这些虚拟地址映射的物理内存空间各个进程间读的时候共享，写的时候会 copy-on-write。</li><li>共享文件映射：多个进程通过虚拟内存技术共享同样的物理内存空间，对内存文件的修改会反应到实际物理文件中，他也是进程间通信(IPC)的一种机制。</li><li>共享匿名映射：这种机制在进行fork的时候不会采用写时复制，父子进程完全共享同样的物理内存页，这也就实现了父子进程通信(IPC)。</li></ul><p>mmap 只是在虚拟内存分配了地址空间，只有在第一次访问虚拟内存的时候才分配物理内存。</p><p>在 mmap 之后，并没有在将文件内容加载到物理页上，只上在虚拟内存中分配了地址空间。当进程在访问这段地址时，通过查找页表，发现虚拟内存对应的页没有在物理内存中缓存，则产生”缺页”，由内核的缺页异常处理程序处理，将文件对应内容，以页为单位(4096)加载到物理内存，注意是只加载缺页，但也会受操作系统一些调度策略影响，加载的比所需的多。</p><p><strong>mmap+write</strong></p><p>mmap+write简单来说就是使用<code>mmap</code>替换了read+write中的read操作，减少了一次CPU的拷贝。</p><p><code>mmap</code>主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次CPU拷贝。</p><p>整个过程发生了<strong>4次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong>，具体流程如下：</p><ol><li>用户进程通过<code>mmap()</code>方法向操作系统发起调用，上下文从用户态转向内核态</li><li>DMA控制器把数据从硬盘中拷贝到读缓冲区</li><li><strong>上下文从内核态转为用户态，mmap调用返回</strong></li><li>用户进程通过<code>write()</code>方法发起调用，上下文从用户态转为内核态</li><li><strong>CPU将读缓冲区中数据拷贝到socket缓冲区</strong></li><li>DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>write()</code>返回</li></ol><p><code>mmap</code>的方式节省了一次CPU拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。</p><p><strong>2、sendfile</strong></p><p>其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808205656.png" alt="image-20210808205656109"></p><p>如上图，我们进行 sendFile 系统调用时，数据被 DMA 引擎从文件复制到内核缓冲区，然后调用 write 方法时，从内核缓冲区进入到 socket，这时，是没有上下文切换的，因为都在内核空间。</p><p>最后，数据从 socket 缓冲区进入到协议栈。此时，数据经过了 3 次拷贝，2 次上下文切换。那么，还能不能再继续优化呢？ 例如直接从内核缓冲区拷贝到网络协议栈？</p><p><code>sendfile</code>是Linux2.1内核版本后引入的一个系统调用函数，通过使用<code>sendfile</code>数据可以直接在内核空间进行传输，因此避免了用户空间和内核空间的拷贝，同时由于使用<code>sendfile</code>替代了<code>read+write</code>从而节省了一次系统调用，也就是2次上下文切换。</p><p>整个过程发生了<strong>2次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong>，具体流程如下：</p><ol><li>用户进程通过<code>sendfile()</code>方法向操作系统发起调用，上下文从用户态转向内核态</li><li>DMA控制器把数据从硬盘中拷贝到读缓冲区</li><li>CPU将读缓冲区中数据拷贝到socket缓冲区</li><li>DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>sendfile</code>调用返回</li></ol><p><code>sendfile</code>方法IO数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。</p><p><strong>3、Sendfile With DMA Scatter/Gather Copy</strong></p><p>实际上，Linux 在 2.4 版本中，做了一些优化。</p><p>避免了从内核缓冲区拷贝到 socket buffer 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808205853.png" alt="image-20210808205853295"></p><p>Scatter/Gather 可以看作是 sendfile 的增强版，批量 sendfile。</p><p>现在，index.html 要从文件进入到网络协议栈，只需 2 次拷贝：第一次使用 DMA 引擎从文件拷贝到内核缓冲区，第二次从内核缓冲区将数据拷贝到网络协议栈；内核缓存区只会拷贝一些 offset 和 length 信息到 socket buffer，基本无消耗。</p><p>首先我们说零拷贝，是从操作系统的角度来说的(也就是我们上文所说的狭义零拷贝)。因为内核缓冲区之间，没有数据是重复的（只有 kernel buffer 有一份数据，sendFile 2.1 版本实际上有 2 份数据，算不上零拷贝(严谨点的话叫狭义零拷贝)）。例如我们刚开始的例子，内核缓存区和 socket 缓冲区的数据就是重复的。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808205946.png" alt="image-20210808205946299"></p><p>整个过程发生了<strong>2次用户态和内核态的上下文切换</strong>和<strong>2次拷贝</strong>，其中更重要的是完全没有CPU拷贝，具体流程如下：</p><ol><li>用户进程通过<code>sendfile()</code>方法向操作系统发起调用，上下文从用户态转向内核态</li><li>DMA控制器利用scatter把数据从硬盘中拷贝到读缓冲区离散存储</li><li>CPU把读缓冲区中的文件描述符和数据长度发送到socket缓冲区</li><li>DMA控制器根据文件描述符和数据长度，使用scatter/gather把数据从内核缓冲区拷贝到网卡</li><li><code>sendfile()</code>调用返回，上下文从内核态切换回用户态</li></ol><p><code>DMA gather</code>和<code>sendfile</code>一样数据对用户空间不可见，而且需要硬件支持，同时输入文件描述符只能是文件，但是过程中完全没有CPU拷贝过程，极大提升了性能。</p><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><p>传统的IO<code>read+write</code>方式会产生2次DMA拷贝+2次CPU拷贝，同时有4次上下文切换。</p><p>而通过<code>mmap+write</code>方式则产生2次DMA拷贝+1次CPU拷贝，4次上下文切换，通过内存映射减少了一次CPU拷贝，可以减少内存使用，适合大文件的传输。</p><p><code>sendfile</code>方式是新增的一个系统调用函数，产生2次DMA拷贝+1次CPU拷贝，但是只有2次上下文切换。因为只有一次调用，减少了上下文的切换，但是用户空间对IO数据不可见，适用于静态文件服务器。</p><p><code>sendfile+DMA gather</code>方式产生2次DMA拷贝，没有CPU拷贝，而且也只有2次上下文切换。虽然极大地提升了性能，但是需要依赖新的硬件设备支持。</p><h4 id="零拷贝在Java中的应用"><a href="#零拷贝在Java中的应用" class="headerlink" title="零拷贝在Java中的应用"></a>零拷贝在Java中的应用</h4><p><a href="https://blog.csdn.net/riemann_/article/details/114378152" target="_blank" rel="noopener">https://blog.csdn.net/riemann_/article/details/114378152</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;硬件相关&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Basic Knowledge" scheme="http://yoursite.com/tags/Basic-Knowledge/"/>
    
  </entry>
  
  <entry>
    <title>TTRSS + RSSHUB</title>
    <link href="http://yoursite.com/2021/06/18/TTRSS-RSSHUB/"/>
    <id>http://yoursite.com/2021/06/18/TTRSS-RSSHUB/</id>
    <published>2021-06-18T09:30:29.000Z</published>
    <updated>2021-06-21T23:34:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最快速的 TTRSS + RSSHUB 配置方式</p></blockquote><a id="more"></a> <h1 id="TTRSS-RSSHUB"><a href="#TTRSS-RSSHUB" class="headerlink" title="TTRSS + RSSHUB"></a>TTRSS + RSSHUB</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>git / vps / docker … 不再赘述</p><h3 id="TTRSS"><a href="#TTRSS" class="headerlink" title="TTRSS"></a>TTRSS</h3><p>vim docker-compose.yml</p><p>新建docker-compose.yml文件，其中的<code>localhost</code>，需要修改成自己的ip，在修改了IP之后这个也需要修改掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  service.rss:</span><br><span class="line">    image: wangqiru/ttrss:latest</span><br><span class="line">    container_name: ttrss</span><br><span class="line">    ports:</span><br><span class="line">      - 181:80</span><br><span class="line">    environment:</span><br><span class="line">      - SELF_URL_PATH=http://localhost:181/ # please change to your own domain</span><br><span class="line">      - DB_PASS=ttrss # use the same password defined in `database.postgres`</span><br><span class="line">    volumes:</span><br><span class="line">      - feed-icons:/var/www/feed-icons/</span><br><span class="line">    networks:</span><br><span class="line">      - public_access</span><br><span class="line">      - service_only</span><br><span class="line">      - database_only</span><br><span class="line">    stdin_open: true</span><br><span class="line">    tty: true</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">  service.mercury: # set Mercury Parser API endpoint to `service.mercury:3000` on TTRSS plugin setting page</span><br><span class="line">    image: wangqiru/mercury-parser-api:latest</span><br><span class="line">    container_name: mercury</span><br><span class="line">    networks:</span><br><span class="line">      - service_only</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">  database.postgres:</span><br><span class="line">    image: postgres:13-alpine</span><br><span class="line">    container_name: postgres</span><br><span class="line">    environment:</span><br><span class="line">      - POSTGRES_PASSWORD=ttrss # feel free to change the password</span><br><span class="line">    volumes:</span><br><span class="line">      - ~/postgres/data/:/var/lib/postgresql/data # persist postgres data to ~/postgres/data/ on the host</span><br><span class="line">    networks:</span><br><span class="line">      - database_only</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  public_access: # Provide the access for ttrss UI</span><br><span class="line">  service_only: # Provide the communication network between services only</span><br><span class="line">  database_only: # Provide the communication between ttrss and database only</span><br><span class="line">    internal: true</span><br><span class="line">volumes:</span><br><span class="line">  feed-icons:</span><br></pre></td></tr></table></figure><p>然后在相同文件夹下面先关掉docker-compose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>再次执行<code>sudo docker-compose up -d</code>来更新容器。</p><h3 id="RssHub"><a href="#RssHub" class="headerlink" title="RssHub"></a>RssHub</h3><p>根据Rsshub的新规则，（为了安全考虑）RssHub的端口必须为80，需要在docker-compose配置文件中进行配置1200端口映射到80端口。</p><p>RssHub的youtube，twitter等路由，如果想舒服的使用，需要直接分别向tw，tb官方申请api，过程有点麻烦，后续如果我使用的话，会详细得在这里附上使用教程。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最快速的 TTRSS + RSSHUB 配置方式&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="RSS" scheme="http://yoursite.com/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>Blog Note</title>
    <link href="http://yoursite.com/2021/01/28/Blog-Note/"/>
    <id>http://yoursite.com/2021/01/28/Blog-Note/</id>
    <published>2021-01-28T07:55:10.000Z</published>
    <updated>2025-07-30T06:36:40.706Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Blog Record</p></blockquote><blockquote><p>目的: 消化优秀的博文</p></blockquote><a id="more"></a> <h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><p><a href="https://medium.com/disney-streaming/a-step-by-step-guide-for-debugging-memory-leaks-in-spark-applications-e0dd05118958" target="_blank" rel="noopener">A step-by-step guide for debugging memory leaks in Spark Applications</a></p><blockquote><p>Spark内存调优Blog，特点就是非常详细，Disney有个Spark任务，每三天重启一次，从executor log查起，发现了存在两种OOM，一个是G1CG引起的，使用了Spark的配置参数<code>spark.executor.extraJavaOptions: -XX:+UseG1GC</code>解决了其中的一个OOM问题，然后又详细介绍了如何排查另一个OOM，使用Ganglia进行内存监控，得到了两个结论：</p><blockquote><ol><li><p>This was a stateful job so maybe we were not clearing out the <em>state</em> over time.</p></li><li><p>A memory leak could have occurred.</p></li></ol></blockquote><p>然后通过监控Streaming Metrics，得到一个结论:</p><blockquote><p>The conclusion: a memory leak occurred, and we needed to find it. To do so, we enabled the heap dump to see what is occupying so much memory.</p></blockquote><p>后续通过堆内存转储</p><blockquote><p>spark.executor.extraJavaOptions: -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/dbfs/heapDumps</p></blockquote><p>然后分别从SparkUI界面和YourKit分析 Heap Dumps，发现里面莫名其妙的HashMap特别多，不符合逻辑，然后针对这个问题</p><blockquote><p>A quick Google search and code analysis gave us our answer: we were not closing the connection correctly. The same issue has also been addressed on the <a href="https://github.com/aws/aws-sdk-java-v2/issues/1679" target="_blank" rel="noopener">aws-sdk Github issues</a>.</p></blockquote><p>哈哈 原来连Disney的工程师也是 Google 来的答案，我还以为要有什么顶级操作。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Blog Record&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;目的: 消化优秀的博文&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Blog" scheme="http://yoursite.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Dawn Dew-light Collected at Dusk 4 Python</title>
    <link href="http://yoursite.com/2021/01/14/Dawn-Dew-light-Collected-at-Dusk-4-Python/"/>
    <id>http://yoursite.com/2021/01/14/Dawn-Dew-light-Collected-at-Dusk-4-Python/</id>
    <published>2021-01-14T03:01:34.000Z</published>
    <updated>2025-07-30T06:38:40.013Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人生苦短，我选Python</p></blockquote><a id="more"></a> <hr><h1 id="Anaconda-环境问题"><a href="#Anaconda-环境问题" class="headerlink" title="Anaconda 环境问题"></a>Anaconda 环境问题</h1><h2 id="Anaconda-升级"><a href="#Anaconda-升级" class="headerlink" title="Anaconda 升级"></a>Anaconda 升级</h2><p>全局或者更换源的情况下，在Anaconda Prompt下输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update anaconda</span><br></pre></td></tr></table></figure><p>升级完毕后，默认只有在Base环境更新到了最新，我们为了让整个环境都能得到升级，还需要一条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update --all</span><br></pre></td></tr></table></figure><h2 id="Anaconda对环境的基本操作"><a href="#Anaconda对环境的基本操作" class="headerlink" title="Anaconda对环境的基本操作"></a>Anaconda对环境的基本操作</h2><p>首先在安装包之前需要建一个环境，新的环境叫做new_env（名字根据需要取）<br> 命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n new_env</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --prefix E:/anaconda_env -n 环境名称 python=[版本号]</span><br></pre></td></tr></table></figure><p>然后需要进入到这个环境看一下，进入之前需要激活该环境<br> Linux/mac os:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate new_env</span><br></pre></td></tr></table></figure><p>激活环境后，可以查看一下安装了什么包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br><span class="line">conda list -n [环境名称] #查看指定环境安装的包</span><br></pre></td></tr></table></figure><p>想安装需要的包，请使用安装命令，pack_name为需要的包名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pack_name</span><br></pre></td></tr></table></figure><p>需要更新一下包，使用更新命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update pack_name</span><br></pre></td></tr></table></figure><p>更新全部包，很方便，使用如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update --all</span><br></pre></td></tr></table></figure><p>如果不需要这个环境了，可以删除该环境，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env remove -n new_env</span><br></pre></td></tr></table></figure><p>列出当前所有环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure><p>退出环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>重命名环境</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create <span class="literal">-n</span> [新环境名] -<span class="literal">-clone</span> [旧环境名]</span><br></pre></td></tr></table></figure><p>导出环境</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env export &gt; [文件名].yaml</span><br></pre></td></tr></table></figure><p>使用导出的yaml创建环境</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env create <span class="operator">-f</span> [文件名].yaml</span><br></pre></td></tr></table></figure><h2 id="Jupyter-Notebook-命令行启动"><a href="#Jupyter-Notebook-命令行启动" class="headerlink" title="Jupyter Notebook 命令行启动"></a>Jupyter Notebook 命令行启动</h2><p>直接在anaconda里面进入环境之后，在命令行上输入<code>jupyter notebook</code></p><p>Tips:  如果想在局域网里面访问jupyter notebook的话需要改一下配置文件</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>这六中数据类型可以分成两类，不可变数据类型和可变数据类型：</p><ul><li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</li><li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li></ul><p><strong>数字型</strong>：</p><p>整型    浮点型    布尔型    复数型</p><p><strong>非数字型</strong>：</p><p>字符串 列表 元组 字典</p><h2 id="数据类型相关的函数"><a href="#数据类型相关的函数" class="headerlink" title="数据类型相关的函数"></a>数据类型相关的函数</h2><ul><li>Type()</li></ul><p>Tips: Python2里面整数分为int和long，在Python3里面则没有</p><ul><li>int(x)</li><li>float(x)</li></ul><p>转换函数</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;人生苦短，我选Python&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Tips4Python" scheme="http://yoursite.com/tags/Tips4Python/"/>
    
  </entry>
  
  <entry>
    <title>Dawn Dew-light Collected at Dusk 4 Scala</title>
    <link href="http://yoursite.com/2020/12/16/Dawn-Dew-light-Collected-at-Dusk-4-Scala/"/>
    <id>http://yoursite.com/2020/12/16/Dawn-Dew-light-Collected-at-Dusk-4-Scala/</id>
    <published>2020-12-16T09:24:43.000Z</published>
    <updated>2025-07-30T07:22:07.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>scala </p></blockquote><a id="more"></a> <h1 id="Scala-类型"><a href="#Scala-类型" class="headerlink" title="Scala 类型"></a>Scala 类型</h1><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gls6d1a89cj20of0gtta1.jpg" alt="1.png"></p><p>Scala中，所有的值都是类对象，而所有的类，包括值类型，都最终继承自一个统一的根类型Any。统一类型，是Scala的又一大特点。更特别的是，Scala中还定义了几个底层类（Bottom Class），比如Null和Nothing。</p><ol><li><p> Null是所有引用类型的子类型，而Nothing是所有类型的子类型。Null类只有一个实例对象，null，类似于Java中的null引用。null可以赋值给任意引用类型，但是不能赋值给值类型。</p></li><li><p> Nothing，可以作为没有正常返回值的方法的返回类型，非常直观的告诉你这个方法不会正常返回，而且由于Nothing是其他任意类型的子类，他还能跟要求返回值的方法兼容。</p></li><li><p> Unit类型用来标识过程，也就是没有明确返回值的函数。 由此可见，Unit类似于Java里的void。Unit只有一个实例，()，这个实例也没有实质的意义。</p></li></ol><h1 id="Option-Some-None"><a href="#Option-Some-None" class="headerlink" title="Option Some None"></a>Option Some None</h1><p><strong>设计目的</strong>：避免使用null</p><p>大多数语言都有一个特殊的关键字或者对象来表示一个对象引用的是“无”，在Java，它是null。在Java 里，null 是一个关键字，不是一个对象，所以对它调用任何方法都是非法的。但是这对语言设计者来说是一件令人疑惑的选择。为什么要在程序员希望返回一个对象的时候返回一个关键字呢？</p><p><strong>Scala鼓励在变量和函数返回值可能不会引用任何值的时候使用Option类型。在没有值的时候，使用None，这是Option的一个子类。如果有值可以引用，就使用Some来包含这个值。Some也是Option的子类。</strong><br> None被声明为一个对象，而不是一个类，因为我们只需要它的一个实例。这样，它多少有点像null关键字，但它却是一个实实在在的，有方法的对象。</p><p>Option类型的值通常作为Scala集合类型（List,Map等）操作的返回类型。比如Map的get方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> capitals = <span class="type">Map</span>(<span class="string">"France"</span>-&gt;<span class="string">"Paris"</span>, <span class="string">"Japan"</span>-&gt;<span class="string">"Tokyo"</span>, <span class="string">"China"</span>-&gt;<span class="string">"Beijing"</span>)</span><br><span class="line">capitals: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(<span class="type">France</span> -&gt; <span class="type">Paris</span>, <span class="type">Japan</span> -&gt; <span class="type">Tokyo</span>, <span class="type">China</span> -&gt; <span class="type">Beijing</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; capitals get <span class="string">"France"</span></span><br><span class="line">res0: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Some</span>(<span class="type">Paris</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; capitals get <span class="string">"North Pole"</span></span><br><span class="line">res1: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br></pre></td></tr></table></figure><p>Option有两个子类别，Some和None。当程序回传Some的时候，代表这个函式成功地给了你一个String，而你可以透过get()函数拿到那个String，如果程序返回的是None，则代表没有字符串可以给你。</p><p>在返回None，也就是没有String给你的时候，如果你还硬要调用get()来取得 String 的话，Scala一样是会抛出一个<code>NoSuchElementException</code>异常给你的。</p><p>我们也可以选用另外一个方法，<code>getOrElse</code>。这个方法在这个Option是Some的实例时返回对应的值，而在是None的实例时返回传入的参数。换句话说，传入<code>getOrElse</code>的参数实际上是默认返回值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; capitals get <span class="string">"North Pole"</span> get</span><br><span class="line">warning: there was one feature warning; re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</span><br><span class="line">java.util.<span class="type">NoSuchElementException</span>: <span class="type">None</span>.get</span><br><span class="line">  at scala.<span class="type">None</span>$.get(<span class="type">Option</span>.scala:<span class="number">347</span>)</span><br><span class="line">  at scala.<span class="type">None</span>$.get(<span class="type">Option</span>.scala:<span class="number">345</span>)</span><br><span class="line">  ... <span class="number">33</span> elided</span><br><span class="line"></span><br><span class="line">scala&gt; capitals get <span class="string">"France"</span> get</span><br><span class="line">warning: there was one feature warning; re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</span><br><span class="line">res3: <span class="type">String</span> = <span class="type">Paris</span></span><br><span class="line"></span><br><span class="line">scala&gt; (capitals get <span class="string">"North Pole"</span>) getOrElse <span class="string">"Oops"</span></span><br><span class="line">res7: <span class="type">String</span> = <span class="type">Oops</span></span><br><span class="line"></span><br><span class="line">scala&gt; capitals get <span class="string">"France"</span> getOrElse <span class="string">"Oops"</span></span><br><span class="line">res8: <span class="type">String</span> = <span class="type">Paris</span></span><br></pre></td></tr></table></figure><p>通过模式匹配分离可选值，如果匹配的值是Some的话，将Some里的值抽出赋给x变量：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showCapital</span></span>(x: <span class="type">Option</span>[<span class="type">String</span>]) = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(s) =&gt; s</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="string">"?"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Scala里Option[T]实际上是一个容器，就像数组或是List一样，你可以把他看成是一个可能有零到一个元素的List。<br> 当你的Option里面有东西的时候，这个List的长度是1（也就是 Some），而当你的Option里没有东西的时候，它的长度是0（也就是 None）。</p><h2 id="Tips4For-循环"><a href="#Tips4For-循环" class="headerlink" title="Tips4For 循环"></a>Tips4For 循环</h2><p>如果我们把Option当成一般的List来用，并且用一个for循环来走访这个Option的时候，如果Option是None，那这个for循环里的程序代码自然不会执行，于是我们就达到了<strong>不用检查Option是否为None这件事</strong>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> map1 = <span class="type">Map</span>(<span class="string">"key1"</span> -&gt; <span class="string">"value1"</span>)</span><br><span class="line">map1: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(key1 -&gt; value1)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> value1 = map1.get(<span class="string">"key1"</span>)</span><br><span class="line">value1: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Some</span>(value1)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> value2 = map1.get(<span class="string">"key2"</span>)</span><br><span class="line">value2: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">printContentLength</span></span>(x: <span class="type">Option</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">     |   <span class="keyword">for</span> (c &lt;- x)&#123;</span><br><span class="line">     |     println(c.length)</span><br><span class="line">     |   &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">printContentLength: (x: <span class="type">Option</span>[<span class="type">String</span>])<span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">scala&gt; printContentLength(value1)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"></span><br><span class="line">scala&gt; printContentLength(value2)</span><br></pre></td></tr></table></figure><h2 id="Tips4map操作"><a href="#Tips4map操作" class="headerlink" title="Tips4map操作"></a>Tips4map操作</h2><p>在函数式编程中有一个核心的概念之一是转换，所以大部份支持函数式编程语言，都支持一种叫map()的动作，这个动作是可以帮你把某个容器的内容，套上一些动作之后，变成另一个新的容器。<br> 现在我们考虑如何用Option的map方法实现<code>length: xxx</code>的输出形式：</p><blockquote><p>先算出 Option 容器内字符串的长度<br> 然后在长度前面加上 “length: “ 字样<br> 最后把容器走访一次，印出容器内的东西</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; value1.map(_.length).map(<span class="string">"length: "</span> + _).foreach(println)</span><br><span class="line">length: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">scala&gt; value1.map(<span class="string">"length: "</span> + _.length).foreach(println)</span><br><span class="line">length: <span class="number">6</span></span><br></pre></td></tr></table></figure><p>透过这样「转换」的方法，我们一样可以达成想要的效果，而且同样不用去做「是否为 None」的判断。</p><h1 id="Scala-Java-Map"><a href="#Scala-Java-Map" class="headerlink" title="Scala Java Map"></a>Scala Java Map</h1><h2 id="Scala内部Map转换："><a href="#Scala内部Map转换：" class="headerlink" title="Scala内部Map转换："></a>Scala内部Map转换：</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> im: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = scala.collection.immutable.<span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="string">"one"</span>,<span class="number">2</span>-&gt;<span class="string">"two"</span>) <span class="comment">//不可变map</span></span><br><span class="line">  <span class="keyword">val</span> imh: <span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">String</span>] = scala.collection.immutable.<span class="type">HashMap</span>(<span class="number">1</span>-&gt;<span class="string">"one"</span>,<span class="number">2</span>-&gt;<span class="string">"two"</span>) <span class="comment">//不可变hashmap</span></span><br><span class="line">  <span class="keyword">val</span> mu: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = scala.collection.mutable.<span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="string">"one"</span>,<span class="number">2</span>-&gt;<span class="string">"two"</span>) <span class="comment">//可变map</span></span><br><span class="line">  println(im,manOf(im))</span><br><span class="line">  println(imh,manOf(imh))</span><br><span class="line">  println(mu,manOf(mu))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mutable.Map 2 immutable.Map</span></span><br><span class="line">  <span class="keyword">val</span> mui: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = mu.toMap</span><br><span class="line">  println(mui,manOf(mui))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// immutable.Map 2 mutable.Map</span></span><br><span class="line">  <span class="keyword">val</span> immu: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = scala.collection.mutable.<span class="type">Map</span>(im.toSeq: _*)</span><br><span class="line">  println(immu,manOf(immu))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> imhmu: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = scala.collection.mutable.<span class="type">Map</span>(imh.toSeq: _*)</span><br><span class="line">  println(imhmu,manOf(imhmu))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(Map(1 -&gt; one, 2 -&gt; two),scala.collection.immutable.Map[Int, java.lang.String])</span><br><span class="line">(Map(1 -&gt; one, 2 -&gt; two),scala.collection.immutable.HashMap[Int, java.lang.String])</span><br><span class="line">(Map(2 -&gt; two, 1 -&gt; one),scala.collection.mutable.Map[Int, java.lang.String])</span><br><span class="line"></span><br><span class="line">(Map(2 -&gt; two, 1 -&gt; one),scala.collection.immutable.Map[Int, java.lang.String])</span><br><span class="line"></span><br><span class="line">(Map(2 -&gt; two, 1 -&gt; one),scala.collection.mutable.Map[Int, java.lang.String])</span><br><span class="line">(Map(2 -&gt; two, 1 -&gt; one),scala.collection.mutable.Map[Int, java.lang.String])</span><br></pre></td></tr></table></figure><h2 id="Java中-把Java-Map-转化成-Scala-Map"><a href="#Java中-把Java-Map-转化成-Scala-Map" class="headerlink" title="Java中 把Java Map 转化成 Scala Map"></a>Java中 把Java Map 转化成 Scala Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put(<span class="string">"1"</span>, <span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    scala.collection.mutable.Map&lt;String,String&gt; mapTest = JavaConverters.mapAsScalaMapConverter(map).asScala();</span><br><span class="line">    Object objTest = Map$.MODULE$.&lt;String,String&gt;newBuilder().$plus$plus$eq(mapTest.toSeq());</span><br><span class="line">    Object resultTest = ((scala.collection.mutable.Builder) objTest).result();</span><br><span class="line">    scala.collection.immutable.Map&lt;String,String&gt; resultTest2 = (scala.collection.immutable.Map)resultTest;</span><br><span class="line">    System.out.println(resultTest2.keySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微有点鸡肋，代码看不懂，笑</p><h2 id="Scala中的双向转换"><a href="#Scala中的双向转换" class="headerlink" title="Scala中的双向转换"></a>Scala中的双向转换</h2><p>Scala提供了大量的方法来隐式转换所有主要的Java和Scala容器类型。其中提供了如下的双向类型转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator               &lt;=&gt;     java.util.Iterator</span><br><span class="line">Iterator               &lt;=&gt;     java.util.Enumeration</span><br><span class="line">Iterable               &lt;=&gt;     java.lang.Iterable</span><br><span class="line">Iterable               &lt;=&gt;     java.util.Collection</span><br><span class="line">mutable.Buffer         &lt;=&gt;     java.util.List</span><br><span class="line">mutable.Set            &lt;=&gt;     java.util.Set</span><br><span class="line">mutable.Map            &lt;=&gt;     java.util.Map</span><br><span class="line">mutable.ConcurrentMap  &lt;=&gt;     java.util.concurrent.ConcurrentMap</span><br></pre></td></tr></table></figure><p>使用这些转换很简单，只需从JavaConverters对象中import它们即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import collection.JavaConverters._</span><br><span class="line">import collection.JavaConverters._</span><br></pre></td></tr></table></figure><p>import之后，通过扩展方法 asScala 和 asJava 就可以在Scala容器和与之对应的Java容器之间进行隐式转换了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import collection.mutable._</span><br><span class="line">import collection.mutable._</span><br><span class="line"></span><br><span class="line">scala&gt; val jul: java.util.List[Int] = ArrayBuffer(1, 2, 3).asJava</span><br><span class="line">jul: java.util.List[Int] = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">scala&gt; val buf: Seq[Int] = jul.asScala</span><br><span class="line">buf: scala.collection.mutable.Seq[Int] = ArrayBuffer(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; val m: java.util.Map[String, Int] = HashMap(&quot;abc&quot; -&gt; 1, &quot;hello&quot; -&gt; 2).asJava</span><br><span class="line">m: java.util.Map[String,Int] = &#123;abc=1, hello=2&#125;</span><br></pre></td></tr></table></figure><p>还有一些Scala容器类型可以转换成对应的Java类型，但是并没有将相应的Java类型转换成Scala类型的能力，它们是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Seq           =&gt;    java.util.List</span><br><span class="line">mutable.Seq   =&gt;    java.util.List</span><br><span class="line">Set           =&gt;    java.util.Set</span><br><span class="line">Map           =&gt;    java.util.Map</span><br></pre></td></tr></table></figure><p>因为Java并未区分可变容器不可变容器类型，所以，虽然能将<code>scala.immutable.List</code>转换成<code>java.util.List</code>，但所有的修改操作都会抛出“UnsupportedOperationException”。参见下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val jul = List(1, 2, 3).asJava</span><br><span class="line">jul: java.util.List[Int] = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">scala&gt; jul.add(7)</span><br><span class="line">java.lang.UnsupportedOperationException</span><br><span class="line">  at java.util.AbstractList.add(AbstractList.java:148)</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>完整的Java Map =&gt; Scala mutbale Map =&gt; Scala Immutable Map =&gt; Option =&gt; 模式匹配得到结果</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Java Map =&gt; mutable.Map =&gt; Scala Map</span></span><br><span class="line">  <span class="keyword">import</span> scala.collection.<span class="type">JavaConversions</span>._</span><br><span class="line">  <span class="keyword">val</span> javaMap: util.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = <span class="keyword">new</span> util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>]()</span><br><span class="line">  javaMap.put(<span class="string">"1"</span>,<span class="string">"2"</span>)</span><br><span class="line">  <span class="keyword">for</span> (m &lt;- javaMap) &#123;</span><br><span class="line">    println(m)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> scalaMuMap: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = javaMap.asScala</span><br><span class="line">  <span class="comment">// Predef里定义的map类型是一个类型别名，实际类型是immutable.Map</span></span><br><span class="line">  <span class="keyword">val</span> scalaImmuMap: <span class="type">Predef</span>.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = scalaMuMap.toMap</span><br><span class="line">  <span class="keyword">val</span> maybeString: <span class="type">Option</span>[<span class="type">String</span>] = scalaImmuMap.get(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> show = (x: <span class="type">Option</span>[<span class="type">String</span>]) =&gt; x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(str) =&gt; str</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="string">"?"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> str: <span class="type">String</span> = show(maybeString)</span><br><span class="line"></span><br><span class="line">  println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scala-mutable-Map-Test"><a href="#Scala-mutable-Map-Test" class="headerlink" title="Scala mutable Map Test"></a>Scala mutable Map Test</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试可变Map返回值类型 确认是Option</span></span><br><span class="line"><span class="keyword">val</span> muMapTest: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = mutable.<span class="type">Map</span>(<span class="string">"Alice"</span> -&gt; <span class="number">10</span>, <span class="string">"Bob"</span> -&gt; <span class="number">20</span>, <span class="string">"Kotlin"</span> -&gt; <span class="number">30</span>)</span><br><span class="line">muMapTest(<span class="string">"Alice"</span>) = <span class="number">99</span></span><br><span class="line">println(muMapTest(<span class="string">"Alice"</span>))</span><br><span class="line">muMapTest += (<span class="string">"Bob"</span> -&gt; <span class="number">98</span>)</span><br><span class="line">println(muMapTest) <span class="comment">// Map(Bob -&gt; 98, Kotlin -&gt; 30, Alice -&gt; 99)</span></span><br><span class="line">muMapTest -= (<span class="string">"Alice"</span>, <span class="string">"Kotlin"</span>)</span><br><span class="line">println(muMapTest) <span class="comment">// Map(Bob -&gt; 98)</span></span><br><span class="line">println(muMapTest.get(<span class="string">"Bob"</span>)) <span class="comment">// Some(98)</span></span><br></pre></td></tr></table></figure><h2 id="More-4-Scala-Map-Action"><a href="#More-4-Scala-Map-Action" class="headerlink" title="More 4 Scala Map Action"></a>More 4 Scala Map Action</h2><p>map1 ++ map2 (类似于Java Map的 putAll)</p><h1 id="Scala-的-Seq"><a href="#Scala-的-Seq" class="headerlink" title="Scala 的 Seq"></a>Scala 的 Seq</h1><p>Scala的 Seq将是Java的List，Scala 的 List将是Java的 LinkedList。</p><p>Seq是一个trait，它相当于Java的接口，但相当于即将到来的防御者方法。 </p><p>Scala的List是一个抽象类，由Nil和::扩展，这是List的具体实现。</p><p>所以，在Java的List是一个接口，Scala的List是一个实现。</p><p>除此之外，Scala的List是不可变的，这不是LinkedList的情况。事实上，Java没有等价的不可变集合(只读的东西只保证新的对象不能改变，但你仍然可以改变旧的，因此，“只读”一个)。<br>Scala的List是由编译器和库高度优化的，它是函数式编程中的基本数据类型。然而，它有限制，它不足以并行编程。这些天，Vector是一个比List更好的选择，但习惯是很难打破。<br>Seq是一个很好的泛化序列，所以如果你编程到接口，你应该使用它。注意，实际上有三个：collection.Seq，collection.mutable.Seq和collection.immutable.Seq，它是后一个是“默认”导入到范围。<br>还有GenSeq和ParSeq。后面的方法在可能的情况下并行运行，前者是Seq和ParSeq的父代，这是当代码的并行性无关紧要的合适的泛化。它们都是相对新引入的，因此人们不会使用它们。</p><h1 id="Scala-match"><a href="#Scala-match" class="headerlink" title="Scala match"></a>Scala match</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>模式匹配语法中，采用 match 关键字声明，每个分支采用 case 关键字进行声明，当需要匹配时， 会从第一个 case 分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下 一个分支进行判断。如果所有 case 都不匹配，那么会执行 case _ 分支，类似于 Java 中 default 语句。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol><li><p>如果所有 case 都不匹配，那么会执行 case _ 分支，类似于 Java 中 default 语句 </p></li><li><p>如果所有 case 都不匹配，又没有写 case _ 分支，那么会抛出 MatchError </p></li><li><p>每个 case 中，不用 break 语句，自动中断 case </p></li><li><p>可以在 match 中使用其它类型，而不仅仅是字符 </p></li><li><p>=&gt; 等价于 java swtich 的 : </p></li><li><p>=&gt; 后面的代码块到下一个 case， 是作为一个整体执行，可以使用{} 扩起来，也可以不扩</p></li></ol><h2 id="守卫"><a href="#守卫" class="headerlink" title="守卫"></a>守卫</h2><p>如果想要表达匹配某个范围的数据，那么就需要在模式匹配中增加守卫条件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MatchIfDemo01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span> (ch &lt;- <span class="string">"+-3!"</span>) &#123; <span class="comment">//是对"+-3!" 遍历</span></span><br><span class="line">      <span class="keyword">var</span> sign = <span class="number">0</span></span><br><span class="line">      <span class="keyword">var</span> digit = <span class="number">0</span></span><br><span class="line">      ch <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> '+' <span class="keyword">if</span> ch.toString.equals(<span class="string">"3"</span>) =&gt; sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> '-' =&gt; sign = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 说明..</span></span><br><span class="line">        <span class="comment">// 如果 case 后有 条件守卫即 if ,那么这时的 _ 不是表示默认匹配</span></span><br><span class="line">        <span class="comment">// 表示忽略 传入 的 ch</span></span><br><span class="line">        <span class="keyword">case</span> _ <span class="keyword">if</span> ch.toString.equals(<span class="string">"3"</span>) =&gt; digit = <span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> _ <span class="keyword">if</span> (ch &gt; <span class="number">1110</span> || ch &lt; <span class="number">120</span>) =&gt; println(<span class="string">"ch &gt; 10"</span>)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; sign = <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">      println(ch + <span class="string">" "</span> + sign + <span class="string">" "</span> + digit)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码值得一提的是ch是<code>‘+’</code>的时候，第一次匹配会匹配上 第一个判断，因为没有匹配上，所以接下来会匹配第三个，没有匹配上，匹配第四个，匹配上了，直接跳出。</p><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ch = '<span class="type">U</span>'</span><br><span class="line">ch <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> '+' =&gt; println(<span class="string">"ok~"</span>)</span><br><span class="line">  <span class="comment">// 下面 case mychar 含义是 mychar = ch   下面这个case就啥都可以匹配上.这样不好</span></span><br><span class="line">  <span class="keyword">case</span> mychar =&gt; println(<span class="string">"ok~"</span> + mychar)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println (<span class="string">"ok~~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> ch1 = '+'</span><br><span class="line"><span class="comment">//match 是一个表达式，因此可以有返回值</span></span><br><span class="line"><span class="comment">//返回值就是匹配到的代码块的最后一句话的值</span></span><br><span class="line"><span class="keyword">val</span> res1 = ch1 <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> '+' =&gt; &#123;</span><br><span class="line">    print(<span class="string">"使用这种方式,case里的最后一行就会返回结果给变量res,这种方式好,"</span>)</span><br><span class="line">    ch1 + <span class="string">" hello "</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 下面 case mychar 含义是 mychar = ch</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println (<span class="string">"ok~~"</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"res="</span> + res1)</span><br></pre></td></tr></table></figure><h2 id="类型匹配"><a href="#类型匹配" class="headerlink" title="类型匹配"></a>类型匹配</h2><p>可以匹配 对象的任意类型，这样做避免了使用 isInstanceOf 和 asInstanceOf 方法</p><p>类型匹配注意事项 </p><ol><li><p>Map[String, Int] 和 Map[Int, String]是两种不同的类型，其它类推。 </p></li><li><p>在进行类型匹配时，编译器会预先检测是否有可能的匹配，如果没有则报错.</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> obj = <span class="number">10</span></span><br><span class="line">    obj <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> a:<span class="type">Int</span> =&gt; a</span><br><span class="line"><span class="comment">//        编译报错</span></span><br><span class="line"><span class="comment">//      case b:Map[String, Int] =&gt; "map集合"</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="string">"啥也不是"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果 case _ 出现在 match 中间，则表示隐藏变量名，即不使用,而不是表示默认匹配</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">//说明 obj 实例的类型 根据 a 的值来返回</span></span><br><span class="line"><span class="keyword">val</span> obj1: <span class="type">Any</span> = <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) <span class="string">"2"</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>) <span class="type">BigInt</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>) <span class="type">Map</span>(<span class="string">"aa"</span> -&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">5</span>) <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="string">"aa"</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">6</span>)<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">7</span>)<span class="type">Array</span>(<span class="string">"aa"</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">8</span>)<span class="type">Array</span>(<span class="string">"aa"</span>)</span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 根据 obj 的类型来匹配</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="keyword">val</span> result = obj1 <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> a: <span class="type">Int</span> =&gt; a</span><br><span class="line">  <span class="keyword">case</span> b: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] =&gt; <span class="string">"对象是一个字符串-数字的 Map 集合"</span></span><br><span class="line">  <span class="keyword">case</span> c: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] =&gt; <span class="string">"对象是一个数字-字符串的 Map 集合"</span></span><br><span class="line">  <span class="keyword">case</span> d: <span class="type">Array</span>[<span class="type">String</span>] =&gt; d <span class="comment">//"对象是一个字符串数组"</span></span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">Array</span>[<span class="type">Int</span>] =&gt; <span class="string">"对象是一个数字数组"</span></span><br><span class="line">  <span class="keyword">case</span> _: <span class="type">BigInt</span> =&gt; <span class="type">Int</span>.<span class="type">MaxValue</span> <span class="comment">// 隐藏了变量名</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"啥也不是"</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><h2 id="匹配数组"><a href="#匹配数组" class="headerlink" title="匹配数组"></a>匹配数组</h2><ol><li>Array(0) 匹配只有一个元素且为 0 的数组。</li><li>Array(x,y) 匹配数组有两个元素，并将两个元素赋值为 x 和 y。当然可以依次类推 Array(x,y,z) 匹配数组有 3 个元素的等等….</li><li>Array(0,_*) 匹配数组以 0 开始</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arrs: <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">Int</span>]] =<span class="type">Array</span>(<span class="type">Array</span>(<span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (arr &lt;- arrs ) &#123;</span><br><span class="line">  <span class="keyword">val</span> result = arr <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>) =&gt; <span class="string">"0"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(x, y) =&gt; x + <span class="string">"="</span> + y</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>, _*) =&gt; <span class="string">"以 0 开头和数组"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"什么集合都不是"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// result = 0</span></span><br><span class="line">  <span class="comment">// result = 1 = 0</span></span><br><span class="line">  <span class="comment">// result = 以 0 开头和数组</span></span><br><span class="line">  <span class="comment">// result = 什么集合都不是</span></span><br><span class="line">  <span class="comment">// result = 什么集合都不是</span></span><br><span class="line">  println(<span class="string">"result = "</span> + result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给你一个数组集合，如果该数组时 Array(10,20) , 请使用默认匹配，返回 Array(20,10)</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"><span class="keyword">val</span> arrs2 = <span class="type">Array</span>(<span class="type">Array</span>(<span class="number">0</span>),<span class="type">Array</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> (arr &lt;- arrs2 ) &#123;</span><br><span class="line">  <span class="keyword">val</span> result = arr <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="comment">//caseArray(0) =&gt; "0"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(x,y)=&gt;<span class="type">ArrayBuffer</span>(y,x) <span class="comment">//?ArrayB(y,x)</span></span><br><span class="line">    <span class="comment">//caseArray(0, _*) =&gt; "以 0 开头和数组"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"不处理~~"</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配列表"><a href="#匹配列表" class="headerlink" title="匹配列表"></a>匹配列表</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  Nil 表示空列表  0 :: 连接上一个空列表 表示List中只有0</span></span><br><span class="line">    <span class="comment">//  println(s"x : $x  y: $y ")  拼接字符串,必须以s 开头, $ 取值</span></span><br><span class="line">    <span class="keyword">for</span> (list &lt;-<span class="type">Array</span>(<span class="type">List</span>(<span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">88</span>), <span class="type">List</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = list <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> :: <span class="type">Nil</span> =&gt; <span class="string">"0"</span> <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> x :: y :: <span class="type">Nil</span> =&gt; x + <span class="string">" "</span> + y <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> :: tail =&gt; <span class="string">"0 ..."</span> <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> x :: <span class="type">Nil</span> =&gt; x</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//      0</span></span><br><span class="line"><span class="comment">//      1 0</span></span><br><span class="line"><span class="comment">//      88</span></span><br><span class="line"><span class="comment">//      0 ...</span></span><br><span class="line"><span class="comment">//      something else</span></span><br><span class="line">      println(result)</span><br><span class="line"></span><br><span class="line">      println(<span class="string">"=================================="</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> site: immutable.<span class="type">Seq</span>[<span class="type">String</span>] = <span class="string">"Runoob"</span> :: (<span class="string">"Google"</span> :: (<span class="string">"Baidu"</span> :: <span class="type">Nil</span>))</span><br><span class="line">      <span class="keyword">val</span> site2 = site</span><br><span class="line">      site.foreach(println)</span><br><span class="line">      <span class="keyword">val</span> nums = <span class="number">1</span> :: (<span class="number">2</span> :: (<span class="number">3</span> :: (<span class="number">4</span> :: <span class="type">Nil</span>)))</span><br><span class="line">      <span class="keyword">val</span> nums2: <span class="type">List</span>[<span class="type">Int</span>] = nums</span><br><span class="line">      nums.foreach(println)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 二维列表</span></span><br><span class="line">      <span class="keyword">val</span> dim = (<span class="number">1</span> :: (<span class="number">0</span> :: (<span class="number">0</span> :: <span class="type">Nil</span>))) ::</span><br><span class="line">        (<span class="number">0</span> :: (<span class="number">1</span> :: (<span class="number">0</span> :: <span class="type">Nil</span>))) ::</span><br><span class="line">        (<span class="number">0</span> :: (<span class="number">0</span> :: (<span class="number">1</span> :: <span class="type">Nil</span>))) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> dim2: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = dim</span><br><span class="line">      dim.foreach(println)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>补充一部分列表操作：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> reslist0: <span class="type">List</span>[<span class="type">String</span>] = <span class="string">"A"</span>::<span class="string">"B"</span>::<span class="type">Nil</span>  <span class="comment">// List(A, B)</span></span><br><span class="line"><span class="keyword">val</span> reslist1: <span class="type">List</span>[<span class="type">String</span>] = <span class="string">"C"</span>+:<span class="string">"D"</span>+:<span class="type">Nil</span>  <span class="comment">// List(C, D)</span></span><br><span class="line"><span class="keyword">val</span> reslist2: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">Nil</span>:+<span class="string">"E"</span>:+<span class="string">"F"</span>  <span class="comment">// List(E, F)</span></span><br><span class="line">println(reslist0)</span><br><span class="line">println(reslist1)</span><br><span class="line">println(reslist2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> reslist3 = reslist0 ++ reslist1 <span class="comment">// List(A, B, C, D)</span></span><br><span class="line">println(reslist3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> reslist4 = reslist0 ::: reslist1 <span class="comment">// List(A, B, C, D)</span></span><br><span class="line">println(reslist4)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> reslist5 = reslist0 :: reslist1 <span class="comment">// List(List(A, B), C, D)</span></span><br><span class="line">println(reslist5)</span><br></pre></td></tr></table></figure><ul><li><code>::</code> 该方法被称为cons，意为构造，向队列的头部追加数据，创造新的列表。用法为 <code>x::list</code>,其中<code>x</code>为加入到头部的元素，无论<code>x</code>是列表与否，它都只将成为新生成列表的第一个元素，也就是说新生成的列表长度为list的长度＋1(btw, <code>x::list</code>等价于<code>list.::(x)</code>)</li><li><code>:+</code>和<code>+:</code> 两者的区别在于<code>:+</code>方法用于在尾部追加元素，<code>+:</code>方法用于在头部追加元素，和<code>::</code>很类似，但是<code>::</code>可以用于pattern match ，而<code>+:</code>则不行. 关于<code>+:</code>和<code>:+</code>,只要记住冒号永远靠近集合类型就OK了。</li><li><code>++</code> 该方法用于连接两个集合，<code>list1++list2</code></li><li><code>:::</code> 该方法只能用于连接两个List类型的集合</li></ul><h2 id="匹配元组"><a href="#匹配元组" class="headerlink" title="匹配元组"></a>匹配元组</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (pair &lt;- <span class="type">Array</span>((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">10</span>, <span class="number">30</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = pair <span class="keyword">match</span> &#123; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> (<span class="number">0</span>, _) =&gt; <span class="string">"0 ..."</span> <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> (y, <span class="number">0</span>) =&gt; y <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> (x, y) =&gt; (y, x) <span class="comment">//"匹配到(x,y)" + x + " " + y</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">"other"</span> <span class="comment">//.</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//      0 ...</span></span><br><span class="line"><span class="comment">//      1</span></span><br><span class="line"><span class="comment">//      (30,10)</span></span><br><span class="line"><span class="comment">//      (1,1)</span></span><br><span class="line"><span class="comment">//      other</span></span><br><span class="line">      println(result)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="对象匹配"><a href="#对象匹配" class="headerlink" title="对象匹配"></a>对象匹配</h2><p>基本介绍 对象匹配，什么才算是匹配呢？，规则如下: 1) case 中对象的 unapply 方法(对象提取器)返回 Some 集合则为匹配成功 2) 返回 None 集合则为匹配失败</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 对象匹配</span></span><br><span class="line">  <span class="keyword">val</span> number: <span class="type">Double</span> = <span class="type">Square</span>(<span class="number">5.0</span>)</span><br><span class="line">  number <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Square</span>(n) =&gt; println(<span class="string">"匹配成功 n="</span> + n)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">"nothing matched"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Object</span> <span class="type">Square</span>&#123;</span><br><span class="line">  <span class="comment">// 说明</span></span><br><span class="line">  <span class="comment">// unapply 是对象提取器</span></span><br><span class="line">  <span class="comment">// 接受 z:Double 类型</span></span><br><span class="line">  <span class="comment">// 返回类型是 Optionp[Double]</span></span><br><span class="line">  <span class="comment">// 返回值是 Some(math.sqrt(z)) 返回 z 的开平方的值，并放到Some(x)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(z:<span class="type">Double</span>): <span class="type">Option</span>[<span class="type">Double</span>] = &#123;</span><br><span class="line">    println(<span class="string">"unapple 被调用 z 是="</span> + z)</span><br><span class="line">    <span class="comment">//Some(z)  unapple 被调用 z 是=25.0 匹配成功 n=25.0</span></span><br><span class="line">    <span class="type">Some</span>(<span class="type">Math</span>.sqrt(z))</span><br><span class="line">    <span class="comment">// None</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(z:<span class="type">Double</span>):<span class="type">Double</span> = z * z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的unapply方法就是模式匹配中调用的方法。这个例子可以深刻的理解模式匹配和unapply的关系。</p><h3 id="对象匹配的特殊情况"><a href="#对象匹配的特殊情况" class="headerlink" title="对象匹配的特殊情况"></a>对象匹配的特殊情况</h3><ol><li><p>当 case 后面的对象提取器方法的参数为多个，则会默认调用 def unapplySeq() 方法 </p></li><li><p>如果 unapplySeq 返回是 Some，获取其中的值,判断得到的 sequence 中的元素的个数是否是三个 如果是三个，则把三个元素分别取出，赋值给 first，second 和 third </p></li><li><p>其它的规则不变.</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MatchObjectDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> namesString = <span class="string">"Alice,Bob,Thomas"</span> <span class="comment">//字符串</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    namesString <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="comment">// 当 执行 case Names(first, second, third)</span></span><br><span class="line">      <span class="comment">// 1. 会调用 unapplySeq（str）,把 "Alice,Bob,Thomas" 传入给 str</span></span><br><span class="line">      <span class="comment">// 2. 如果 返回的是 Some("Alice","Bob","Thomas"),分别给 （first, second, third）</span></span><br><span class="line">      <span class="comment">// 注意，这里的返回的值unapplySeq的个数需要和 case（first, second, third）要一样</span></span><br><span class="line">      <span class="comment">// 3. 如果返回的 None ,表示匹配失败</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Names</span>(first, second, third) =&gt; &#123;</span><br><span class="line">          println(<span class="string">"the string contains three people's names"</span>)</span><br><span class="line">        <span class="comment">// 打印字符串</span></span><br><span class="line">        println(<span class="string">s"<span class="subst">$first</span> <span class="subst">$second</span> <span class="subst">$third</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">"nothing matched"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//object</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Names</span> </span>&#123;</span><br><span class="line">  <span class="comment">//当构造器是多个参数时，就会触发这个对象提取器</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapplySeq</span></span>(str: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Seq</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.contains(<span class="string">","</span>)) <span class="type">Some</span>(str.split(<span class="string">","</span>))</span><br><span class="line">    <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量声明中的模式"><a href="#变量声明中的模式" class="headerlink" title="变量声明中的模式"></a>变量声明中的模式</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明中的模式匹配</span></span><br><span class="line"><span class="keyword">val</span> (x,y,z) = (<span class="number">1</span>,<span class="number">2</span>,<span class="string">"hello"</span>)</span><br><span class="line">println(<span class="string">"x="</span> + x)</span><br><span class="line"><span class="keyword">val</span> (q,r) = <span class="type">BigInt</span>(<span class="number">10</span>) /% <span class="number">3</span> <span class="comment">// 说明 q = BigInt(10) / 3 r = BigInt(10) % 3</span></span><br><span class="line">println(q,r)</span><br><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">Array</span>(first,second, _*) = arr <span class="comment">// 提取出arr的其哪两个元素</span></span><br><span class="line">println(first,second)</span><br></pre></td></tr></table></figure><h2 id="for表达式中的模式"><a href="#for表达式中的模式" class="headerlink" title="for表达式中的模式"></a>for表达式中的模式</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">"A"</span> -&gt; <span class="number">1</span>, <span class="string">"B"</span> -&gt; <span class="number">0</span>, <span class="string">"C"</span> -&gt; <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> ((k, v) &lt;- map) &#123;</span><br><span class="line">  println(k + <span class="string">" -&gt; "</span> + v) <span class="comment">// 出来三个 key-value ("A"-&gt;1), ("B"-&gt;0), ("C"-&gt;3)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明 : 只遍历出 value =0 的 key-value ,其它的过滤掉</span></span><br><span class="line">println(<span class="string">"--------------(k, 0) &lt;- map-------------------"</span>)</span><br><span class="line"><span class="keyword">for</span> ((k, <span class="number">0</span>) &lt;- map) &#123;</span><br><span class="line">  println(k + <span class="string">" --&gt; "</span> + <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明, 这个就是上面代码的另外写法, 只是下面的用法灵活和强大</span></span><br><span class="line">println(<span class="string">"--------------(k, v) &lt;- map if v == 0-------------------"</span>)</span><br><span class="line"><span class="keyword">for</span> ((k, v) &lt;- map <span class="keyword">if</span> v &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">  println(k + <span class="string">" ---&gt; "</span> + v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="样例类"><a href="#样例类" class="headerlink" title="样例类"></a>样例类</h2><ol><li><p>样例类仍然是类 </p></li><li><p>样例类用 case 关键字进行声明。 </p></li><li><p>样例类是为 模式匹配而优化的类 </p></li><li><p>构造器中的每一个参数都成为 val——除非它被显式地声明为 var（不建议这样做） </p></li><li><p>在样例类对应的伴生对象中提供 apply 方法让你不用 new 关键字就能构造出相应的对象 </p></li><li><p>提供 unapply 方法让模式匹配可以工作 </p></li><li><p>将自动生成 toString 、equals 、hashCode 和 和 copy 方法(有点类似模板类，直接给生成，供程序员使用) 8) 除上述外，样例类和其他类完全一样。你可以添加方法和字段，扩展它们</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CaseClassDemo02</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//该案例的作用就是体验使用样例类方式进行对象匹配简洁性</span></span><br><span class="line">    <span class="keyword">for</span> (amt &lt;- <span class="type">Array</span>(<span class="type">Dollar2</span>(<span class="number">1000.0</span>), <span class="type">Currency2</span>(<span class="number">1000.0</span>, <span class="string">"RMB"</span>), <span class="type">NoAmount2</span>)) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = amt <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Dollar2</span>(v) =&gt; <span class="string">"$"</span> + v <span class="comment">// $1000.0</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Currency2</span>(v, u) =&gt; v + <span class="string">" "</span> + u <span class="comment">// 1000.0 RMB</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">NoAmount2</span> =&gt; <span class="string">""</span> <span class="comment">// ""</span></span><br><span class="line">      &#125;</span><br><span class="line">      println(amt + <span class="string">": "</span> + result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Amount2</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Dollar2</span>(<span class="params">value: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Amount2</span> <span class="title">//样例类</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Currency2</span>(<span class="params">value: <span class="type">Double</span>, unit: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Amount2</span> <span class="title">//样例类</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">NoAmount2</span> <span class="keyword">extends</span> <span class="title">Amount2</span> <span class="title">//样例类</span></span></span><br></pre></td></tr></table></figure><p>语句的中置表达式</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>) <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> first :: second :: rest =&gt; println(first + <span class="string">" "</span> + second + <span class="string">" "</span> + rest.length + <span class="string">" "</span> + rest)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">"匹配不到..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：1 3 2 List(5, 9)</p><p>什么是中置表达式？1 + 2，这就是一个中置表达式。如果 unapply 方法产出一个元组，你可以在 case 语句中使用中置表示法。比如可以匹配一个 List 序列 </p><h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    密封类</span></span><br><span class="line"><span class="comment">    1.可以避免滥用继承</span></span><br><span class="line"><span class="comment">    2.用在模式匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>  <span class="title">Furniture</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span>  <span class="title">Couch</span>(<span class="params"></span>) <span class="keyword">extends</span>  <span class="title">Furniture</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span>  <span class="title">Chair</span>(<span class="params"></span>) <span class="keyword">extends</span>  <span class="title">Furniture</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SealedDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findPlaceTosit</span></span>(furniture: <span class="type">Furniture</span>):<span class="type">String</span>=furniture <span class="keyword">match</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> a:<span class="type">Couch</span>=&gt;<span class="string">"lie on the couch"</span></span><br><span class="line">    <span class="keyword">case</span> b:<span class="type">Chair</span>=&gt;<span class="string">"site on the chair"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> chair=<span class="type">Chair</span>()</span><br><span class="line">      <span class="keyword">val</span> sea=<span class="keyword">new</span> <span class="type">SealedDemo</span>()</span><br><span class="line">      println(sea.findPlaceTosit(chair))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Match-Example"><a href="#Match-Example" class="headerlink" title="Match Example"></a>Match Example</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Example 商品捆绑打折出售</span></span><br><span class="line"><span class="comment">//    1) 商品捆绑可以是单个商品，也可以是多个商品</span></span><br><span class="line"><span class="comment">//    2) 打折时按照折扣 x 元进行设计</span></span><br><span class="line"><span class="comment">//    3) 能够统计出所有捆绑商品打折后的最终价格</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设计的样例类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="title">//</span> <span class="title">项</span></span></span><br><span class="line"><span class="class">    <span class="title">case</span> <span class="title">class</span> <span class="title">Book</span>(<span class="params">description: <span class="type">String</span>, price: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class">    <span class="title">//Bundle</span> <span class="title">捆</span> <span class="title">，</span> <span class="title">discount</span></span>: <span class="type">Double</span> 折扣 ， item: <span class="type">Item</span>* ,可变参数</span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Bundle</span>(<span class="params">description: <span class="type">String</span>, discount: <span class="type">Double</span>, item: <span class="type">Item</span>*</span>) <span class="keyword">extends</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">//</span> <span class="title">打折案例</span> 120</span></span><br><span class="line"><span class="class">    <span class="title">val</span> <span class="title">sale</span> </span>= <span class="type">Bundle</span>(<span class="string">"书籍"</span>,<span class="number">10</span>,<span class="type">Book</span>(<span class="string">"漫画"</span>,<span class="number">40</span>),<span class="type">Bundle</span>(<span class="string">"文学作品"</span>, <span class="number">20</span>, <span class="type">Book</span>(<span class="string">"《阳关》"</span>, <span class="number">80</span>), <span class="type">Book</span>(<span class="string">"《围城》"</span>, <span class="number">30</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1- 使用case语句，得到"漫画"</span></span><br><span class="line">    <span class="keyword">val</span> demo = sale <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Bundle</span>(_, _, <span class="type">Book</span>(desc, _), _*) =&gt; desc</span><br><span class="line">    &#125;</span><br><span class="line">    println(demo)<span class="comment">// 漫画</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2- 通过@表示法将嵌套的值绑定到变量。 _* 绑定剩余 Item 到 rest</span></span><br><span class="line">    <span class="keyword">val</span> demo2 = sale <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="comment">//  如果我们进行对象匹配时，不想接受某些值，则使用_忽略即可， _* 代表所有</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Bundle</span>(_, _, art @ <span class="type">Book</span>(_,_),rest @ _*) =&gt; (art, rest)</span><br><span class="line">    &#125;</span><br><span class="line">    println(demo2) <span class="comment">//(Book(漫画,40.0),WrappedArray(Bundle(文学作品,20.0,WrappedArray(Book(《阳关》,80.0), Book(《围城》,30.0)))))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> demo3 = sale <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Bundle</span>(_,_,art3 @ <span class="type">Book</span>(_, _),rest3) =&gt; (art3, rest3)</span><br><span class="line">    &#125;</span><br><span class="line">    println(demo3) <span class="comment">//(Book(漫画,40.0),Bundle(文学作品,20.0,WrappedArray(Book(《阳关》,80.0), Book(《围城》,30.0))))</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span></span>(it:<span class="type">Item</span>):<span class="type">Double</span> = &#123;</span><br><span class="line">      it <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Book</span>(_,p) =&gt; p</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Bundle</span>(_,disc,its @ _*) =&gt; its.map(price).sum - disc</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"price="</span> + price(sale)) <span class="comment">// 120.0</span></span><br></pre></td></tr></table></figure><h2 id="模式匹配和if-else-的区别"><a href="#模式匹配和if-else-的区别" class="headerlink" title="模式匹配和if else 的区别"></a>模式匹配和if else 的区别</h2><p>模式匹配其实本质上是提供一个方便的解构 (Destructuring) 数据结构的方式，以 scala 为例， pattern matching 其实用到了 scala 中提取器的功能， 提取器其实就是类中的 unapply () 方法。</p><p>其实 if else 只是 pattern matching 中的一个典型的用法，但并非它的全部。</p><p>同时， pattern matching 允许你解耦两个并不真正属于彼此的东西，也使得你的代码更易于测试。</p><h2 id="apply-amp-unapply"><a href="#apply-amp-unapply" class="headerlink" title="apply() &amp; unapply()"></a>apply() &amp; unapply()</h2><ul><li><p>apply方法被称作注入方法，在类的伴生对象中做一个初始化操作</p></li><li><p>apply方法的参数列表不需要跟构造器的参数列表统一</p></li><li><p>apply方法是定义在伴生对象中的</p></li></ul><p>当Scala中类或者对象有一个主要用途的时候，apply方法就是很好的语法糖。</p><p>apply方法 =&gt; 类似 constructor4Java</p><p>unapply方法完全相反，unapply接受一个对象，从对象中提取出相应的值。</p><p>unapply方法主要用于模式匹配中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span>(<span class="params">val value: <span class="type">Double</span>, val country: <span class="type">String</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">Double</span>, country: <span class="type">String</span>) : <span class="type">Money</span> = <span class="keyword">new</span> <span class="type">Money</span>(value, country)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(money: <span class="type">Money</span>): <span class="type">Option</span>[(<span class="type">Double</span>, <span class="type">String</span>)] = &#123;</span><br><span class="line">        <span class="keyword">if</span>(money == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Some</span>(money.value, money.country)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testUnapply</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">val</span> money = <span class="type">Money</span>(<span class="number">10.1</span>, <span class="string">"RMB"</span>)</span><br><span class="line">    money <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Money</span>(num, <span class="string">"RMB"</span>) =&gt;  println(<span class="string">"RMB: "</span> + num)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; println(<span class="string">"Not RMB!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么只能在object对象定义main方法才能作为入口？"><a href="#为什么只能在object对象定义main方法才能作为入口？" class="headerlink" title="为什么只能在object对象定义main方法才能作为入口？"></a>为什么只能在object对象定义main方法才能作为入口？</h2><p>类比java中的main方法的修饰词public static得知main方法是static（静态的），在scala中静态方法或者属性是在object修改的对象中的，object修饰的对象是singleton，用于保存静态成员等。</p><h1 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span>.&#123;<span class="keyword">break</span>, breakable&#125;</span><br></pre></td></tr></table></figure><p>break:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">breakable(</span><br><span class="line">    <span class="keyword">for</span>(i&lt;<span class="number">-0</span> until <span class="number">10</span>) &#123;</span><br><span class="line">      println(i)</span><br><span class="line">      <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"> <span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p>continue:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i&lt;<span class="number">-0</span> until <span class="number">10</span>)&#123;</span><br><span class="line">      breakable&#123;</span><br><span class="line">      <span class="keyword">if</span>(i==<span class="number">3</span>||i==<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      println(i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0,1,2,3,5,7,8,9</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;scala &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Tips4Scala" scheme="http://yoursite.com/tags/Tips4Scala/"/>
    
  </entry>
  
  <entry>
    <title>Dawn Dew-light Collected at Dusk 4 Java</title>
    <link href="http://yoursite.com/2020/10/31/Dawn-Dew-light-Collected-at-Dusk-4-Java/"/>
    <id>http://yoursite.com/2020/10/31/Dawn-Dew-light-Collected-at-Dusk-4-Java/</id>
    <published>2020-10-31T02:55:40.000Z</published>
    <updated>2025-07-30T06:37:40.956Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JAVA 的随手PICK</p></blockquote><a id="more"></a> <h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>Java 8 引入了 Optional，目的主要是为了解决空值问题，这个Optional是借鉴的<code>Google Guava</code>类库的Optional类，捏妈的，谷歌好顶</p><h2 id="of"><a href="#of" class="headerlink" title="of"></a>of</h2><p>为非Null值创建一个Optional</p><p>of方法通过工厂方法创建Optional实例，需要注意的是传入的参数不能为null，否则抛出<code>NullPointerException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给与一个非空值</span></span><br><span class="line">Optional&lt;String&gt; username = Optional.of(<span class="string">"cwl"</span>);</span><br><span class="line"><span class="comment">// 传入参数为null，抛出NullPointerException.</span></span><br><span class="line">Optional&lt;String&gt; nullValue = Optional.of(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a>ofNullable</h2><p>为指定的值创建一个Optional,如果指定的值为null，则返回一个空的Optional。可为空的Optional</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面创建了一个不包含任何值的Optional实例</span></span><br><span class="line"><span class="comment">// 输出Optional.empty</span></span><br><span class="line">Optional empty = Optional.ofNullable(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a>isPresent</h2><p>如果值存在返回true,否则返回false<br>类似下面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isPresent方法用来检查Optional实例中是否包含值</span></span><br><span class="line"><span class="keyword">if</span> (username.isPresent()) &#123;</span><br><span class="line">    <span class="comment">//在Optional实例内调用get()返回已存在的值</span></span><br><span class="line">    System.out.println(username.get());      <span class="comment">//输出cwl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>如果Optional有值则将其返回，否则跑出<code>NoSuchElementException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行下面的代码抛出NoSuchElementException</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 在空的Optional实例上调用get()</span></span><br><span class="line">     System.out.println(empty.get());</span><br><span class="line"> &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">     System.out.println(ex.getMessage());         <span class="comment">// 输出：No value present</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a>ifPresent</h2><p>如果Optional实例有值则为其调用consumer ,否则不做处理。<br>要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。 Java8支持不用接口直接通过lambda表达式传入参数。<br>如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。类似下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ifPresent方法接受lambda表达式作为参数。</span></span><br><span class="line"><span class="comment">// lambda表达式对Optional的值调用consumer进行处理。</span></span><br><span class="line">username.ifPresent((value) -&gt; &#123;</span><br><span class="line">     System.out.println(<span class="string">"The length of the value is: "</span> + value.length());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h2><p>如果有值则将其返回，否则返回指定的其它值。<br>如果Optional实例有值则将其返回，否则返回orElse方法传入的参数。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果值不为null，orElse方法返回Optional实例的值,否则返回传入的消息</span></span><br><span class="line">System.out.println(empty.orElse(<span class="string">"There is no value present!"</span>));<span class="comment">// 输出：There is no value present!</span></span><br><span class="line">System.out.println(username.orElse(<span class="string">"There is some value!"</span>));  <span class="comment">// 输出：cwl</span></span><br></pre></td></tr></table></figure><h2 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a>orElseGet</h2><p>orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orElseGet与orElse方法类似，区别在于orElse传入的是默认值，</span></span><br><span class="line"><span class="comment">// orElseGet可以接受一个lambda表达式生成默认值。</span></span><br><span class="line"><span class="comment">// 输出：Default Value</span></span><br><span class="line">System.out.println(empty.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line"><span class="comment">// 输出：cwl</span></span><br><span class="line">System.out.println(username.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br></pre></td></tr></table></figure><h2 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a>orElseThrow</h2><p>如果有值则将其返回，否则抛出supplier接口创建的异常。<br>在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// orElseThrow与orElse方法类似。与返回默认值不同，</span></span><br><span class="line">    <span class="comment">// orElseThrow会抛出lambda表达式或方法生成的异常</span></span><br><span class="line">    empty.orElseThrow(ValueAbsentException::<span class="keyword">new</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">//输出: No value present in the Optional instance</span></span><br><span class="line">    System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ValueAbsentException</code>定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueAbsentException</span> <span class="keyword">extends</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ValueAbsentException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValueAbsentException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"No value present in the Optional instance"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。<br>map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。如果你不熟悉Function接口，可以参考这篇博客。map方法示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map方法执行传入的lambda表达式参数对Optional实例的值进行修改。</span></span><br><span class="line"><span class="comment">// 为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。</span></span><br><span class="line">Optional&lt;String&gt; upperName = username.map((value) -&gt; value.toUpperCase());  </span><br><span class="line">System.out.println(upperName.orElse(<span class="string">"No value found"</span>));      <span class="comment">//输出: CWL</span></span><br></pre></td></tr></table></figure><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。<br>参照map函数，使用flatMap重写的示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flatMap与map（Function）非常类似，区别在于传入方法的lambda表达式的返回类型。</span></span><br><span class="line"><span class="comment">// map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 </span></span><br><span class="line"><span class="comment">// 但flatMap方法中的lambda表达式返回值必须是Optionl实例。 </span></span><br><span class="line"> upperName = username.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line"> System.out.println(upperName.orElse(<span class="string">"No value found"</span>));<span class="comment">//输出 CWL</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter个方法通过传入限定条件对Optional实例的值进行过滤。文档描述如下：<br>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。<br>读到这里，可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了Predicate接口的lambda表达式。如果你不熟悉Predicate接口，可以参考 这篇文章。<br>现在我来看看filter的各种用法，下面的示例介绍了满足限定条件和不满足两种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter方法检查给定的Option值是否满足某些条件。</span></span><br><span class="line"><span class="comment">// 如果满足则返回同一个Option实例，否则返回空Optional。</span></span><br><span class="line">Optional&lt;String&gt; longName = username.filter((value) -&gt; value.length() &gt; <span class="number">2</span>);</span><br><span class="line">System.out.println(longName.orElse(<span class="string">"The name is less than 2 characters"</span>));<span class="comment">//cwl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子是Optional值不满足filter指定的条件。</span></span><br><span class="line">Optional&lt;String&gt; anotherName = Optional.of(<span class="string">"y"</span>);</span><br><span class="line">Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 输出：The name is less than 2 characters</span></span><br><span class="line">System.out.println(shortName.orElse(<span class="string">"The name is less than 2 characters"</span>));</span><br></pre></td></tr></table></figure><h1 id="双冒号"><a href="#双冒号" class="headerlink" title="双冒号"></a>双冒号</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>双冒号运算操作符是类方法的句柄，lambda表达式的一种简写，这种简写的学名叫eta-conversion或者叫η-conversion。</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a><strong>理解</strong></h2><p>英文格式双冒号<code>::</code>，读：double colon，双冒号（::）运算符在Java 8中被用作<strong>方法引用</strong>（method reference），方法引用是与lambda表达式相关的一个重要特性。它提供了一种执行方法的方法,为此，方法引用需要由兼容的函数式接口组成的目标类型上下文。</p><p>使用lambda表达式会创建匿名函数， 但有时候需要使用一个lambda表达式只调用一个已经存在的方法（不做其它）， 所以这才有了方法引用！</p><table><thead><tr><th>类型</th><th>引用语法</th><th>案例</th></tr></thead><tbody><tr><td>引用静态方法</td><td>类名::静态方法名</td><td>Integer::parseInt</td></tr><tr><td>引用特定对象实例方法</td><td>对象::实例方法名</td><td>System.out::println</td></tr><tr><td>引用特定类型的任意对象的实例方法</td><td>特定类型::实例方法名</td><td>String::compareTolgnoreCase</td></tr><tr><td>引用父类实例方法</td><td>super::方法名</td><td></td></tr><tr><td>引用类构造方法</td><td>类名::new</td><td>ArrayList::new</td></tr><tr><td>引用数组构造方法</td><td>数组类型[]::new</td><td>String[]::new</td></tr></tbody></table><h2 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">//静态方法引用  ClassName::methodName</span></span><br><span class="line">        list.forEach(Colon::print);</span><br><span class="line">        <span class="comment">//上一行等价于</span></span><br><span class="line">        <span class="comment">//list.forEach((x)-&gt;Colon.print(x));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">//实例方法引用  instanceRef::methodName</span></span><br><span class="line">        list.forEach(<span class="keyword">new</span> Colon()::print);</span><br><span class="line">        <span class="comment">//上一行等价于</span></span><br><span class="line">        <span class="comment">//list.forEach((x)-&gt;new Colon().print(x));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String[] arr = &#123; <span class="string">"Barbara"</span>, <span class="string">"James"</span>, <span class="string">"Mary"</span>, <span class="string">"John"</span>,</span><br><span class="line">                <span class="string">"Patricia"</span>, <span class="string">"Robert"</span>, <span class="string">"Michael"</span>, <span class="string">"Linda"</span> &#125;;</span><br><span class="line">        <span class="comment">//引用String类型的任意对象的compareToIgnoreCase方法实现忽略大小写排序</span></span><br><span class="line">        Arrays.sort(arr, String::compareToIgnoreCase);</span><br><span class="line">        <span class="comment">//上一行等价于</span></span><br><span class="line">        <span class="comment">//Arrays.sort(arr, (a,b)-&gt;a.compareToIgnoreCase(b));</span></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span>(String s:arr)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：不要和引用静态方法搞混，认为为什么<code>compareToIgnoreCase</code>是非静态方法却可以使用类名去引用，这两者根本不是一回事，双冒号前的类含义也不同，就是两个应用方向</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span> <span class="keyword">extends</span> <span class="title">BaseColon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">//实例方法引用  instanceRef::methodName</span></span><br><span class="line">        list.forEach(<span class="keyword">super</span>::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseColon</span></span>&#123;</span><br><span class="line">    <span class="comment">//实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：该类无需实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colon</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//无参构造引用</span></span><br><span class="line">        ColonNoParam cnp = Colon::<span class="keyword">new</span>;</span><br><span class="line">        Colon c1 = cnp.createColon();</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        <span class="comment">//有参构造引用</span></span><br><span class="line">        ColonWithParam cwp = Colon::<span class="keyword">new</span>;</span><br><span class="line">        Colon c2 = cwp.createColon(<span class="string">"小明"</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//生成toString方法打印查看</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Colon&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ColonNoParam</span></span>&#123;</span><br><span class="line">    <span class="comment">//无参方法提供对象</span></span><br><span class="line">    <span class="function">Colon <span class="title">createColon</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ColonWithParam</span></span>&#123;</span><br><span class="line">    <span class="comment">//有参方法提供对象（数据类型要与Colon有参构造函数对应）</span></span><br><span class="line">    <span class="function">Colon <span class="title">createColon</span><span class="params">(String s,<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;Integer,Colon[]&gt; function = Colon[]::<span class="keyword">new</span>;</span><br><span class="line">        <span class="comment">//调用apply方法创建数组，这里的5是数组的长度</span></span><br><span class="line">        Colon[] arr = function.apply(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//循环输出-初始都为null</span></span><br><span class="line">        <span class="keyword">for</span>(Colon c:arr)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyArrayFunction&lt;Integer,Colon[]&gt; function = Colon[]::<span class="keyword">new</span>;</span><br><span class="line">        <span class="comment">//调用apply方法创建数组，这里的5是数组的长度</span></span><br><span class="line">        Colon[] arr = function.apply(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//循环输出-初始都为null</span></span><br><span class="line">        <span class="keyword">for</span>(Colon c:arr)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyArrayFunction</span>&lt;<span class="title">A</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">apply</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Expansion"><a href="#Expansion" class="headerlink" title="Expansion"></a>Expansion</h2><p>上面的写法里面我有个疑惑的地方就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ColonNoParam cnp = Colon::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><p>为什么这个地方能直接实例化接口，其实这个是一个匿名内部类+Lamda复合的实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ColonWithParam cwp = Colon::<span class="keyword">new</span>;</span><br><span class="line">Colon c2 = cwp.createColon(<span class="string">"小明"</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>这个和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 整了一个匿名内部函数，同时这里只是定义了函数内容，并没有执行，在下面一行createColon的时候才执行了</span></span><br><span class="line">ColonWithParam colonWithParam = <span class="keyword">new</span> ColonWithParam() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Colon <span class="title">createColon</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Colon(s, i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      Colon colon1 = colonWithParam.createColon(<span class="string">"321"</span>,<span class="number">123</span>);</span><br><span class="line">      System.out.println(colon1);</span><br></pre></td></tr></table></figure><p>这样的写法是等价的，属实让人有点摸不清楚，</p><p>这里还涉及一个Lamda的注释<code>@FunctionalInterface</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface 是 Java 8 新加入的一种接口，用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。Java 8 还声明了一些 Lambda 表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用 @FunctionalInterface 解决编译层面的错误。</span><br></pre></td></tr></table></figure><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>String 内部实际存储结构为 char 数组，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于存储字符串的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">// 缓存字符串的 hash code</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    <span class="comment">// ......其他内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>String 字符串有以下 4 个重要的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// char[] 为参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuilder 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer StringBuilder char[] 和 String</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对象引用相同直接返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断需要对比的值是否为 String 类型，如果不是则直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="comment">// 把两个字符串都转换为 char 数组对比</span></span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 循环比对两个字符串的每一个字符</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果其中有一个字符不相等就 true false，否则继续对比</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 类型重写了 Object 中的 equals() 方法，equals() 方法需要传递一个 Object 类型的参数值，在比较时会先通过 instanceof 判断是否为 String 类型.</p><p>还有一个和 equals() 比较类似的方法 equalsIgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。</p><h2 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h2><p>compareTo() 方法用于比较两个字符串，返回的结果为 int 类型的值，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="comment">// 获取到两个字符串长度最短的那个 int 值</span></span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对比每一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="comment">// 有字符不相等就返回差值</span></span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，compareTo() 方法会循环对比所有的字符，当两个字符串中有任意一个字符不相同时，则 return char1-char2。比如，两个字符串分别存储的是 1 和 2，返回的值是 -1；如果存储的是 1 和 1，则返回的值是 0 ，如果存储的是 2 和 1，则返回的值是 1。</p><p>还有一个和 compareTo() 比较类似的方法 compareToIgnoreCase()，用于忽略大小写后比较两个字符串。</p><p>可以看出 compareTo() 方法和 equals() 方法都是用于比较两个字符串的，但它们有两点不同：</p><ul><li>equals() 可以接收一个 Object 类型的参数，而 compareTo() 只能接收一个 String 类型的参数；</li><li>equals() 返回值为 Boolean，而 compareTo() 的返回值则为 int。</li></ul><p>它们都可以用于两个字符串的比较，当 equals() 方法返回 true 时，或者是 compareTo() 方法返回 0 时，则表示两个字符串完全相同。</p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><ul><li>indexOf()：查询字符串首次出现的下标位置</li><li>lastIndexOf()：查询字符串最后出现的下标位置</li><li>contains()：查询字符串中是否包含另一个字符串</li><li>toLowerCase()：把字符串全部转换成小写</li><li>toUpperCase()：把字符串全部转换成大写</li><li>length()：查询字符串的长度</li><li>trim()：去掉字符串首尾空格</li><li>replace()：替换字符串中的某些字符</li><li>split()：把字符串分割并返回字符串数组</li><li>join()：把字符串数组转为字符串</li></ul><p>个人不太熟悉的就是join()了 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String message = String.join(<span class="string">"-"</span>, <span class="string">"Java"</span>, <span class="string">"is"</span>, <span class="string">"cool"</span>);</span><br><span class="line"><span class="comment">// message returned is: "Java-is-cool"</span></span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="为什么-String-类型要用-final-修饰？"><a href="#为什么-String-类型要用-final-修饰？" class="headerlink" title="为什么 String 类型要用 final 修饰？"></a>为什么 String 类型要用 final 修饰？</h3><blockquote><p>从 String 类的源码我们可以看出 String 是被 final 修饰的不可继承类</p><p>Java 语言之父 James Gosling 的回答是，他会更倾向于使用 final，因为它能够缓存结果，当你在传参时不需要考虑谁会修改它的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。– 性能</p><p>James Gosling 还说迫使 String 类设计成不可变的另一个原因是<strong>安全</strong>，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，它的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使 String 类设计成不可变类的一个重要原因。 – 安全</p></blockquote><blockquote><p>另外只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glwoovq0i5j20ge092dfw.jpg" alt="undefined"></p><p>试想一下如果 String 是可变的，那当 s1 的值修改之后，s2 的值也跟着改变了，这样就和我们预期的结果不相符了，因此也就没有办法实现字符串常量池的功能了。</p><p>因为final修饰了，1.所以String天生线程安全 2. 非常适合做HashMap的key 3.利用不可变性实现字符串常量池</p></blockquote><h3 id="和-equals-的区别是什么？"><a href="#和-equals-的区别是什么？" class="headerlink" title="== 和 equals 的区别是什么？"></a>== 和 equals 的区别是什么？</h3><blockquote><p>== 对于<strong>基本数据类型</strong>来说，是用于比较 “值”是否相等的；而对于<strong>引用类型</strong>来说，是用于比较引用地址是否相同的。</p></blockquote><h3 id="String-和-StringBuilder、StringBuffer-有什么区别？"><a href="#String-和-StringBuilder、StringBuffer-有什么区别？" class="headerlink" title="String 和 StringBuilder、StringBuffer 有什么区别？"></a>String 和 StringBuilder、StringBuffer 有什么区别？</h3><blockquote><p>因为 String 类型是不可变的，所以在字符串拼接的时候如果使用 String 的话性能会很低，因此我们就需要使用另一个数据类型 StringBuffer，它提供了 append 和 insert 方法可用于字符串的拼接，它使用 synchronized 来保证线程安全，如下源码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">&gt;     toStringCache = <span class="keyword">null</span>;</span><br><span class="line">&gt;     <span class="keyword">super</span>.append(String.valueOf(obj));</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">&gt;     toStringCache = <span class="keyword">null</span>;</span><br><span class="line">&gt;     <span class="keyword">super</span>.append(str);</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>因为它使用了 synchronized 来保证线程安全，所以性能不是很高，于是在 JDK 1.5 就有了 StringBuilder，它同样提供了 append 和 insert 的拼接方法，但它没有使用 synchronized 来修饰，因此在性能上要优于 StringBuffer，所以在非并发操作的环境下可使用 StringBuilder 来进行字符串拼接。</p></blockquote><h3 id="String-的-intern-方法有什么含义？"><a href="#String-的-intern-方法有什么含义？" class="headerlink" title="String 的 intern() 方法有什么含义？"></a>String 的 intern() 方法有什么含义？</h3><blockquote><p>new String都是在堆上创建字符串对象。当调用 intern() 方法时，编译器会将字符串添加到常量池中（stringTable维护），并返回指向该常量的引用。</p></blockquote><h3 id="String-类型在-JVM（Java-虚拟机）中是如何存储的？编译器对-String-做了哪些优化？"><a href="#String-类型在-JVM（Java-虚拟机）中是如何存储的？编译器对-String-做了哪些优化？" class="headerlink" title="String 类型在 JVM（Java 虚拟机）中是如何存储的？编译器对 String 做了哪些优化？"></a>String 类型在 JVM（Java 虚拟机）中是如何存储的？编译器对 String 做了哪些优化？</h3><blockquote><p>String 常见的创建方式有两种，new String() 的方式和直接赋值的方式，直接赋值的方式会先去字符串常量池中查找是否已经有此值，如果有则把引用地址直接指向此值，否则会先在常量池中创建，然后再把引用指向此值；而 new String() 的方式一定会先在堆上创建一个字符串对象，然后再去常量池中查询此字符串的值是否已经存在，如果不存在会先在常量池中创建此字符串，然后把引用的值指向此字符串，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; String s1 = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br><span class="line">&gt; String s2 = s1.intern();</span><br><span class="line">&gt; String s3 = <span class="string">"Java"</span>;</span><br><span class="line">&gt; System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">&gt; System.out.println(s2 == s3); <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>它们在 JVM 存储的位置，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glwosriy2gj20l00990th.jpg" alt="undefined"></p><p>小贴士：JDK 1.7 之后把永生代换成的元空间，把字符串常量池从方法区移到了 Java 堆上。</p><p>除此之外编译器还会对 String 字符串做一些优化，例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; String s1 = <span class="string">"Ja"</span> + <span class="string">"va"</span>;</span><br><span class="line">&gt; String s2 = <span class="string">"Java"</span>;</span><br><span class="line">&gt; System.out.println(s1 == s2);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>虽然 s1 拼接了多个字符串，但对比的结果却是 true，我们使用反编译工具，看到的结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; Compiled from <span class="string">"StringExample.java"</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lagou</span>.<span class="title">interview</span>.<span class="title">StringExample</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">public</span> com.lagou.interview.StringExample();</span><br><span class="line">&gt;     Code:</span><br><span class="line">&gt;        <span class="number">0</span>: aload_0</span><br><span class="line">&gt;        1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">&gt;        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">&gt;     LineNumberTable:</span><br><span class="line">&gt;       line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">&gt;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">&gt;     Code:</span><br><span class="line">&gt;        0: ldc           #2                  // String Java</span><br><span class="line">&gt;        <span class="number">2</span>: astore_1</span><br><span class="line">&gt;        3: ldc           #2                  // String Java</span><br><span class="line">&gt;        <span class="number">5</span>: astore_2</span><br><span class="line">&gt;        6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">&gt;        <span class="number">9</span>: aload_1</span><br><span class="line">&gt;       <span class="number">10</span>: aload_2</span><br><span class="line">&gt;       <span class="number">11</span>: if_acmpne     <span class="number">18</span></span><br><span class="line">&gt;       <span class="number">14</span>: iconst_1</span><br><span class="line">&gt;       <span class="number">15</span>: goto          <span class="number">19</span></span><br><span class="line">&gt;       <span class="number">18</span>: iconst_0</span><br><span class="line">&gt;       19: invokevirtual #4                  // Method java/io/PrintStream.println:(Z)V</span><br><span class="line">&gt;       <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">&gt;     LineNumberTable:</span><br><span class="line">&gt;       line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">&gt;       line <span class="number">6</span>: <span class="number">3</span></span><br><span class="line">&gt;       line <span class="number">7</span>: <span class="number">6</span></span><br><span class="line">&gt;       line <span class="number">8</span>: <span class="number">22</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap 底层是如何实现的？在 JDK 1.8 中它都做了哪些优化？</p><p>在 JDK 1.7 中 HashMap 是以数组加链表的形式组成的, JDK 1.8 之后新增了红黑树的组成结构，当链表大于 8 并且容量大于 64 时， 链表结构会转换成红黑树结构，它的组成结构如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glzamaae9rj20ne0evwez.jpg" alt="undefined"></p><p>数组中的元素我们称之为哈希桶, JDK 1.8 之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap 的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><ul><li>JDK 1.8 HashMap 扩容时做了哪些优化？</li></ul><blockquote><p>JDK 1.8 则新增了红黑树结构，当链表长度达到 8 并且容器达到 64 时会转换为红黑树存储，以提升元素的操作性能。</p></blockquote><ul><li>加载因子为什么是 0.75？</li></ul><blockquote><p>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是 0.5，HashMap 的初始化容量是 16，那么当 HashMap 中有 16*0.5=8 个元素时，HashMap 就会进行扩容。</p><p>那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？</p><p>这其实是出于容量和性能之间平衡的结果：</p><p>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生 Hash 冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</p><p>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</p><p>所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p></blockquote><ul><li>当有哈希冲突时，HashMap 是如何查找并确认元素的？</li></ul><blockquote><p>当哈希冲突时我们需要通过判断 key 值是否相等，才能确认此元素是不是我们想要的元素。</p></blockquote><ul><li>HashMap 源码中有哪些重要的方法？</li></ul><blockquote><p>下方源码</p></blockquote><ul><li>HashMap 是如何导致死循环的？</li></ul><blockquote><p>以 JDK 1.7 为例，假设 HashMap 默认大小为 2，原本 HashMap 中有一个元素 key(5)，我们再使用两个线程：t1 添加元素 key(3)，t2 添加元素 key(7)，当元素 key(3) 和 key(7) 都添加到 HashMap 中之后，线程 t1 在执行到 Entry&lt;K,V&gt; next = e.next; 时，交出了 CPU 的使用权，源码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程一执行此处</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么此时线程 t1 中的 e 指向了 key(3)，而 next 指向了 key(7) ；之后线程 t2 重新 rehash 之后链表的顺序被反转，链表的位置变成了 key(5) → key(7) → key(3)，其中 “→” 用来表示下一个元素。</p></blockquote><blockquote><p>当 t1 重新获得执行权之后，先执行 newTalbe[i] = e 把 key(3) 的 next 设置为 key(7)，而下次循环时查询到 key(7) 的 next 元素为 key(3)，于是就形成了 key(3) 和 key(7) 的循环引用，因此就导致了死循环的发生，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glzaxp7o0aj20jt0f0gm1.jpg" alt="undefined"></p><p>当然发生死循环的原因是 JDK 1.7 链表插入方式为首部倒序插入，这个问题在 JDK 1.8 得到了改善，变成了尾部正序插入。</p><p>有人曾经把这个问题反馈给了 Sun 公司，但 Sun 公司认为这不是一个问题，<strong>因为 HashMap 本身就是非线程安全的，如果要在多线程下，建议使用 ConcurrentHashMap 替代</strong>，但这个问题在面试中被问到的几率依然很大，所以在这里需要特别说明一下。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>HashMap 源码中包含了以下几个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 最大长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的加载因子 (扩容因子)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当链表长度大于此值且容量大于 64 时</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换链表的临界值，当元素小于此值时，会将红黑树结构转换成链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小树容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY =</span><br></pre></td></tr></table></figure><p>HashMap 源码中三个重要方法：<strong>查询、新增</strong>和<strong>数据扩容</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个元素是否是要查询的元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 下一个节点非空判断</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果第一节点是树结构，则使用 getTreeNode 直接获取相应的数据</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">// 非树结构，循环节点判断</span></span><br><span class="line">                <span class="comment">// hash 相等并且 key 相同，则返回此节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，当哈希冲突时我们需要通过判断 key 值是否相等，才能确认此元素是不是我们想要的元素。</p><p>HashMap 第二个重要方法：<strong>新增方法</strong>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 哈希表为空则创建表</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据 key 的哈希值计算出要插入的数组索引 i</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果 table[i] 等于 null，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果 key 已经存在了，直接覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果 key 不存在，判断是否为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 红黑树直接插入键值对</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 为链表结构，循环准备插入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 下一个元素为空时</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  key 已经存在直接覆盖 value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过最大容量，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增方法的执行流程，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glzars7sxoj20jk0mwt99.jpg" alt="undefined"></p><p>HashMap 第三个重要的方法是<strong>扩容方法</strong>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容前的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容前的数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预定义新数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩大容量为当前容量的两倍，但不能超过 MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前数组没有数据，使用初始化的值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 如果初始化的值为 0，则使用默认的初始化容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的容量等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threshold = newThr; </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始扩容，将新的容量赋值给 table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 原数据不为空，将原数据复制到新 table 中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据容量循环数组，复制非空元素到新 table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果链表只有一个，则进行直接赋值</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 红黑树相关的操作</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表复制，JDK 1.8 扩容优化部分</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将原索引放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将原索引 + oldCap 放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，JDK 1.8 在扩容时并没有像 JDK 1.7 那样，重新计算每个元素的哈希值，而是通过高位运算（e.hash &amp; oldCap）来确定元素是否需要移动，比如 key1 的信息如下：</p><ul><li>key1.hash = 10 0000 1010</li><li>oldCap = 16 0001 0000</li></ul><p>使用 e.hash &amp; oldCap 得到的结果，高一位为 0，当结果为 0 时表示元素在扩容时位置不会发生任何变化，而 key 2 信息如下：</p><ul><li>key2.hash = 10 0001 0001</li><li>oldCap = 16 0001 0000</li></ul><p>这时候得到的结果，高一位为 1，当结果为 1 时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glzaw5h0vwj20le0byt8q.jpg" alt="undefined"></p><p>其中红色的虚线图代表了扩容时元素移动的位置。</p><h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><p>线程（Thread）是并发编程的基础，也是程序执行的最小单元，它依托进程而存在。一个进程中可以包含多个线程，多线程可以共享一块内存空间和一组系统资源，因此线程之间的切换更加节省资源、更加轻量化，也因此被称为轻量级的进程。</p><p>线程的状态在 JDK 1.5 之后以枚举的方式被定义在 Thread 的源码中，它总共包含以下 6 个状态：</p><blockquote><p>NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；<br>RUNNABLE，就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；<br>BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法；<br>WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了 Object.wait() 方法，那它就在等待另一个线程调用 Object.notify() 或 Object.notifyAll() 方法；<br>TIMED_WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；<br>TERMINATED，终止状态，表示线程已经执行完成。</p></blockquote><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gm4ggmh9ohj20j90ntaba.jpg" alt="微信图片_20201229090916.png"></p><p>线程的工作模式是，首先先要创建线程并指定线程需要执行的业务方法，然后再调用线程的 start() 方法，此时线程就从 NEW（新建）状态变成了 RUNNABLE（就绪）状态，此时线程会判断要执行的方法中有没有 synchronized 同步代码块，如果有并且其他线程也在使用此锁，那么线程就会变为 BLOCKED（阻塞等待）状态，当其他线程使用完此锁之后，线程会继续执行剩余的方法。</p><p>当遇到 Object.wait() 或 Thread.join() 方法时，线程会变为 WAITING（等待状态）状态，如果是带了超时时间的等待方法，那么线程会进入 TIMED_WAITING（计时等待）状态，当有其他线程执行了 notify() 或 notifyAll() 方法之后，线程被唤醒继续执行剩余的业务方法，直到方法执行完成为止，此时整个线程的流程就执行完了，执行流程如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gm3xhm2bxaj21af0kd764.jpg" alt="undefined"></p><p>转化图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gm4gvpumgjj20q00ccaag.jpg" alt="undefined"></p><h2 id="重点问题"><a href="#重点问题" class="headerlink" title="重点问题"></a>重点问题</h2><h3 id="为什么State里面没有Running状态"><a href="#为什么State里面没有Running状态" class="headerlink" title="为什么State里面没有Running状态"></a>为什么State里面没有Running状态</h3><blockquote><p>有人常觉得 Java 线程状态中还少了个 running 状态，这其实是把两个不同层面的状态混淆了。对 Java 线程状态而言，不存在所谓的running 状态，它的 runnable 状态包含了 running 状态。</p><p>我们可能会问，为何 JVM 中没有去区分这两种状态呢？现在的<strong>时分</strong>（time-sharing）<strong>多任务</strong>（multi-task）操作系统架构通常都是用所谓的“<strong>时间分片</strong>（time quantum or time slice）”方式进行<strong>抢占式</strong>（preemptive）轮转调度（round-robin式）。</p><blockquote><p>更复杂的可能还会加入优先级（priority）的机制。</p></blockquote><p>这个时间分片通常是很小的，一个线程一次最多只能在 cpu 上运行比如10-20ms 的时间（此时处于 running 状态），也即大概只有0.01秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）</p><p>这一切换的过程称为线程的<strong>上下文切换</strong>（context switch），当然 cpu 不是简单地把线程踢开就完了，还需要把被相应的执行状态保存到内存中以便后续的恢复执行。显然，10-20ms 对人而言是很快的，</p><blockquote><p>不计切换开销（每次在1ms 以内），相当于1秒内有50-100次切换。事实上时间片经常没用完，线程就因为各种原因被中断，实际发生的切换次数还会更多。</p></blockquote><p>也这正是<strong>单核 *CPU 上实现所谓的“</strong>并发*（concurrent）”的基本原理，但其实是快速切换所带来的假象，这有点类似一个手脚非常快的杂耍演员可以让好多个球同时在空中运转那般。</p><p>时间分片也是可配置的，如果不追求在多个线程间很快的响应，也可以把这个时间配置得大一点，以减少切换带来的开销。如果是多核CPU，才有可能实现真正意义上的并发，这种情况通常也叫<strong>并行</strong>（pararell），不过你可能也会看到这两词会被混着用，这里就不去纠结它们的区别了。</p><p>通常，Java的线程状态是服务于监控的，如果线程切换得是如此之快，那么区分 ready 与 running 就没什么太大意义了。</p><p>当你看到监控上显示是 running 时，对应的线程可能早就被切换下去了，甚至又再次地切换了上来，也许你只能看到 ready 与 running 两个状态在快速地闪烁。当然，对于精确的性能评估而言，获得准确的 running 时间是有必要的。</p><p>现今主流的 JVM 实现都把 Java 线程一一映射到操作系统底层的线程上，把调度委托给了操作系统，我们在虚拟机层面看到的状态实质是对底层状态的映射及包装。JVM 本身没有做什么实质的调度，把底层的 ready 及 running 状态映射上来也没多大意义，因此，统一成为runnable 状态是不错的选择。</p><blockquote><p>我们将看到，Java 线程状态的改变通常只与自身显式引入的机制有关。</p></blockquote><p>我们知道传统的I/O都是阻塞式（blocked）的，原因是I/O操作比起cpu来实在是太慢了，可能差到好几个数量级都说不定。如果让 cpu 去等I/O 的操作，很可能时间片都用完了，I/O 操作还没完成呢，不管怎样，它会导致 cpu 的利用率极低。所以，解决办法就是：一旦线程中执行到 I/O 有关的代码，相应线程立马被切走，然后调度 ready 队列中另一个线程来运行。这时执行了 I/O 的线程就不再运行，即所谓的被阻塞了。它也不会被放到调度队列中去，因为很可能再次调度到它时，I/O 可能仍没有完成。线程会被放到所谓的等待队列中，处于上图中的 waiting 状态：</p><p>当然了，我们所谓阻塞只是指这段时间 cpu 暂时不会理它了，但另一个部件比如硬盘则在努力地为它服务。cpu 与硬盘间是并发的。如果把线程视作为一个 job，这一 job 由 cpu 与硬盘交替协作完成，当在 cpu 上是 waiting 时，在硬盘上却处于 running，只是我们在操作系统层面讨论线程状态时通常是围绕着 cpu 这一中心去述说的。而当 I/O 完成时，则用一种叫<strong>中断</strong>（interrupt）的机制来通知 cpu：也即所谓的“<strong>中断驱动</strong>（interrupt-driven）”，现代操作系统基本都采用这一机制。某种意义上，这也是<strong>控制反转</strong>（IoC）机制的一种体现，cpu不用反复去询问硬盘，这也是所谓的“好莱坞原则”—Don’t call us, we will call you.好莱坞的经纪人经常对演员们说：“别打电话给我，（有戏时）我们会打电话给你。”在这里，硬盘与 cpu 的互动机制也是类似，硬盘对 cpu 说：”别老来问我 IO 做完了没有，完了我自然会通知你的“当然了，cpu 还是要不断地检查中断，就好比演员们也要时刻注意接听电话，不过这总好过不断主动去询问，毕竟绝大多数的询问都将是徒劳的。cpu 会收到一个比如说来自硬盘的中断信号，并进入中断处理例程，手头正在执行的线程因此被打断，回到 ready 队列。而先前因 I/O 而waiting 的线程随着 I/O 的完成也再次回到 ready 队列，这时 cpu 可能会选择它来执行。另一方面，所谓的时间分片轮转本质上也是由一个定时器定时中断来驱动的，可以使线程从 running 回到 ready 状态.</p><p>现在我们再看一下 Java 中定义的线程状态，嘿，它也有 BLOCKED（阻塞），也有 WAITING（等待），甚至它还更细，还有TIMED_WAITING：</p><p><strong>现在问题来了，进行阻塞式 I/O 操作时，Java 的线程状态究竟是什么？是 BLOCKED？还是 WAITING？</strong></p><p>可能你已经猜到，既然放到 RUNNABLE 这一主题下讨论，其实状态还是 RUNNABLE。我们也可以通过一些测试来验证这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">@Test</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInBlockedIOState</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">&gt;     Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">&gt;     <span class="comment">// 创建一个名为“输入输出”的线程t</span></span><br><span class="line">&gt;     Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt;         <span class="meta">@Override</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;             <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                 <span class="comment">// 命令行中的阻塞读</span></span><br><span class="line">&gt;                 String input = in.nextLine();</span><br><span class="line">&gt;                 System.out.println(input);</span><br><span class="line">&gt;             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&gt;                 e.printStackTrace();</span><br><span class="line">&gt;             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&gt;               IOUtils.closeQuietly(in);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;, <span class="string">"输入输出"</span>); <span class="comment">// 线程的名字</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt;     <span class="comment">// 启动</span></span><br><span class="line">&gt;     t.start();</span><br><span class="line">&gt;  </span><br><span class="line">&gt;     <span class="comment">// 确保run已经得到执行</span></span><br><span class="line">&gt;     Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&gt;  </span><br><span class="line">&gt;     <span class="comment">// 状态为RUNNABLE</span></span><br><span class="line">&gt;     assertThat(t.getState()).isEqualTo(Thread.State.RUNNABLE);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在最后的语句上加一断点，监控上也反映了这一点：</p><p>网络阻塞时同理，比如socket.accept，我们说这是一个“阻塞式(blocked)”式方法，但线程状态还是 RUNNABLE。</p><p>当然，Java 很早就引入了所谓 nio（新的IO）包，至于用 nio 时线程状态究竟是怎样的，这里就不再一一具体去分析了。</p><blockquote><p>至少我们看到了，进行传统上的 IO 操作时，口语上我们也会说“阻塞”，但这个“阻塞”与线程的 BLOCKED 状态是两码事！</p></blockquote><p><u>如何看待RUNNABLE状态？</u></p><p>要分两个层面看待，JVM层面和OS层面</p><p>当进行阻塞式的 IO 操作时，或许底层的操作系统线程确实处在阻塞状态，但我们关心的是 JVM 的线程状态。</p><blockquote><p>JVM 并不关心底层的实现细节，什么时间分片也好，什么 IO 时就要切换也好，它并不关心。</p></blockquote><p>前面说到，“处于 runnable 状态下的线程正在* Java 虚拟机<strong>中执行，但它</strong>可能正在等待*来自于操作系统的其它资源，比如处理器。”</p><p>JVM 把那些都视作资源，cpu 也好，硬盘，网卡也罢，有东西在为线程服务，它就认为线程在“执行”。</p><p>处于 IO 阻塞，只是说 cpu 不执行线程了，但网卡可能还在监听呀，虽然可能暂时没有收到数据：</p><p>所以 JVM 认为线程还在执行。而操作系统的线程状态是围绕着 cpu 这一核心去述说的，这与 JVM 的侧重点是有所不同的。</p><p>前面我们也强调了“Java 线程状态的改变通常只与自身显式引入的机制有关”，如果 JVM 中的线程状态发生改变了，通常是自身机制引发的。</p><p>比如 synchronize 机制有可能让线程进入BLOCKED 状态，sleep，wait等方法则可能让其进入 WATING 之类的状态。</p><p>它与传统的线程状态的对应可以如下来看：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gm4jjiq30vj20k10bkgnf.jpg" alt="1.png"></p></blockquote><h3 id="BLOCKED-和-WAITING-的区别"><a href="#BLOCKED-和-WAITING-的区别" class="headerlink" title="BLOCKED 和 WAITING 的区别"></a>BLOCKED 和 WAITING 的区别</h3><p>虽然 BLOCKED 和 WAITING 都有等待的含义，但二者有着本质的区别，首先它们状态形成的调用方法不同，其次 BLOCKED 可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而 WAITING 则是因为自身调用了 Object.wait() 或着是 Thread.join() 又或者是 LockSupport.park() 而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了 Object.wait() 而进入 WAITING 状态之后，则需要等待另一个线程执行 Object.notify() 或 Object.notifyAll() 才能被唤醒。</p><h3 id="start-和-run-的区别"><a href="#start-和-run-的区别" class="headerlink" title="start() 和 run() 的区别"></a>start() 和 run() 的区别</h3><p>首先从 Thread 源码来看，start() 方法属于 Thread 自身的方法，并且使用了 synchronized 来保证线程安全，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态验证，不等于 NEW 的状态会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    <span class="comment">// 通知线程组，此线程即将启动</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">// 不处理任何异常，如果 start0 抛出异常，则它将被传递到调用堆栈上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run() 方法为 Runnable 的抽象方法，必须由调用类重写此方法，重写的 run() 方法其实就是此线程要执行的业务方法</p><p>从执行的效果来说，start() 方法可以开启多线程，让线程从 NEW 状态转换成 RUNNABLE 状态，而 run() 方法只是一个普通的方法。</p><p>其次，它们可调用的次数不同，start() 方法不能被多次调用，否则会抛出 java.lang.IllegalStateException；而 run() 方法可以进行多次调用，因为它只是一个普通的方法而已。</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在 Thread 源码中和线程优先级相关的属性有 3 个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程可以拥有的最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 线程默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 线程可以拥有的最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>线程的优先级可以理解为线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。</p><p>在程序中我们可以通过 Thread.setPriority() 来设置优先级，setPriority() 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">// 先验证优先级的合理性</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优先级如果超过线程组的最高优先级，则把优先级设置为线程组的最高优先级</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>在一个线程中调用 other.join() ，这时候当前线程会让出执行权给 other 线程，直到 other 线程执行完或者过了超时时间之后再继续执行当前线程，join() 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 超时时间不能小于 0</span></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等于 0 表示无限等待，直到线程执行完为之</span></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断子线程 (其他线程) 为活跃线程，则一直等待</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 循环判断</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            wait(delay);</span><br><span class="line"></span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出 join() 方法底层还是通过 wait() 方法来实现的。</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>看 Thread 的源码可以知道 yield() 为本地方法，也就是说 yield() 是由 C 或 C++ 实现的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>yield() 方法表示给线程调度器一个当前线程愿意出让 CPU 使用权的暗示，但是线程调度器可能会忽略这个暗示。</p><p>比如我们执行这段包含了 yield() 方法的代码，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Runnable runnable = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.println(&quot;线程：&quot; +</span><br><span class="line">                        Thread.currentThread().getName() + &quot; I：&quot; + i);</span><br><span class="line">                if (i == 5) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(runnable, &quot;T1&quot;);</span><br><span class="line">    Thread t2 = new Thread(runnable, &quot;T2&quot;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把这段代码执行多次之后会发现，每次执行的结果都不相同，这是因为 yield() 执行非常不稳定，线程调度器不一定会采纳 yield() 出让 CPU 使用权的建议，从而导致了这样的结果。</p><h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><p>线程池是为了避免线程频繁的创建和销毁带来的性能消耗，而建立的一种池化技术，它是把已创建的线程放入“池”中，当有任务来临时就可以重用已有的线程，无需等待创建的过程，这样就可以有效提高程序的响应速度。但如果要说线程池的话一定离不开 ThreadPoolExecutor ，在阿里巴巴的《Java 开发手册》中是这样规定线程池的：</p><blockquote><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明：Executors 返回的线程池对象的弊端如下：</p><p>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。<br>CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></blockquote><p>其实当我们去看 Executors 的源码会发现，Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor() 和 Executors.newCachedThreadPool() 等方法的底层都是通过 ThreadPoolExecutor 实现的，所以本课时我们就重点来了解一下 ThreadPoolExecutor 的相关知识，比如它有哪些核心的参数？它是如何工作的？</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210101205249.png" alt="image-20210101205249848"></p><p>第 1 个参数：corePoolSize 表示线程池的常驻核心线程数。如果设置为 0，则表示在没有任何任务时，销毁线程池；如果大于 0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程（创建和销毁的原因会在本课时的下半部分讲到）；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。</p><p>第 2 个参数：maximumPoolSize 表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于 0，也必须大于等于 corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。</p><p>第 3 个参数：keepAliveTime 表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于 corePoolSize 为止，如果 maximumPoolSize 等于 corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。</p><p>第 4 个参数：unit 表示存活时间的单位，它是配合 keepAliveTime 参数共同使用的。</p><p>第 5 个参数：workQueue 表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。</p><p>第 6 个参数：threadFactory 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程，源代码如下</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210101205426.png" alt="image-20210101205426204"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Executors.defaultThreadFactory() 为默认的线程创建工厂</span></span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的线程创建工厂，需要实现 ThreadFactory 接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon()) </span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>); <span class="comment">// 创建一个非守护线程</span></span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY); <span class="comment">// 线程优先级设置为默认值</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以自定义一个线程工厂，通过实现 ThreadFactory 接口来完成，这样就可以自定义线程的名称或线程执行的优先级了。</p><p>第 7 个参数：<strong>RejectedExecutionHandler</strong> 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。</p><p>线程池的工作流程要从它的执行方法 <strong>execute()</strong> 说起，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前工作的线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 创建新的线程执行此任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池是否处于运行状态，如果是则把任务添加到队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再出检查线程池是否处于运行状态，防止在第一次校验通过后线程池关闭</span></span><br><span class="line">        <span class="comment">// 如果是非运行状态，则将刚加入队列的任务移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池的线程数为 0 时（当 corePoolSize 设置为 0 时会发生）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 新建线程执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程都在忙且队列都已爆满，尝试新启动一个线程执行失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) </span><br><span class="line">        <span class="comment">// 执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以自定义一个线程工厂，通过实现 ThreadFactory 接口来完成，这样就可以自定义线程的名称或线程执行的优先级了。</p><p>第 7 个参数：RejectedExecutionHandler 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。</p><p>线程池的工作流程要从它的执行方法 execute() 说起，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前工作的线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 创建新的线程执行此任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池是否处于运行状态，如果是则把任务添加到队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再出检查线程池是否处于运行状态，防止在第一次校验通过后线程池关闭</span></span><br><span class="line">        <span class="comment">// 如果是非运行状态，则将刚加入队列的任务移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池的线程数为 0 时（当 corePoolSize 设置为 0 时会发生）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 新建线程执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程都在忙且队列都已爆满，尝试新启动一个线程执行失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) </span><br><span class="line">        <span class="comment">// 执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本课时的这道面试题考察的是你对于线程池和 ThreadPoolExecutor 的掌握程度，也属于 Java 的基础知识，几乎所有的面试都会被问到，其中线程池任务执行的主要流程，可以参考以下流程图：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210101210115.png" alt="image-20210101210115668"></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="ThreadPoolExecutor-的执行方法有几种？它们有什么区别？"><a href="#ThreadPoolExecutor-的执行方法有几种？它们有什么区别？" class="headerlink" title="ThreadPoolExecutor 的执行方法有几种？它们有什么区别？"></a>ThreadPoolExecutor 的执行方法有几种？它们有什么区别？</h3><blockquote><p>execute() VS submit()</p></blockquote><blockquote><p>execute() 和 submit() 都是用来执行线程池任务的，它们最主要的区别是，submit() 方法可以接收线程池执行的返回值，而 execute() 不能接收返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10L</span>,</span><br><span class="line">&gt;         TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">20</span>));</span><br><span class="line">&gt; <span class="comment">// execute 使用</span></span><br><span class="line">&gt; executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"Hello, execute."</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// submit 使用</span></span><br><span class="line">&gt; Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"Hello, submit."</span>);</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="string">"Success"</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt; </span><br><span class="line">&gt; System.out.println(future.get());</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>程序执行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; Hello, submit.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Hello, execute.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Success</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>从以上结果可以看出 submit() 方法可以配合 Futrue 来接收线程执行的返回值。它们的另一个区别是 execute() 方法属于 Executor 接口的方法，而 submit() 方法则是属于 ExecutorService 接口的方法，它们的继承关系如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210101210323.png" alt="image-20210101210323524"></p></blockquote><h3 id="什么是线程的拒绝策略？"><a href="#什么是线程的拒绝策略？" class="headerlink" title="什么是线程的拒绝策略？"></a>什么是线程的拒绝策略？</h3><blockquote><p>当线程池中的任务队列已经被存满，再有任务添加时会先判断当前线程池中的线程数是否大于等于线程池的最大值，如果是，则会触发线程池的拒绝策略。</p></blockquote><h3 id="拒绝策略的分类有哪些？"><a href="#拒绝策略的分类有哪些？" class="headerlink" title="拒绝策略的分类有哪些？"></a>拒绝策略的分类有哪些？</h3><p>Java 自带的拒绝策略有 4 种：</p><ul><li><strong>AbortPolicy</strong>，终止策略，线程池会抛出异常并终止执行，它是默认的拒绝策略；</li><li><strong>CallerRunsPolicy</strong>，把任务交给当前线程来执行；</li><li><strong>DiscardPolicy</strong>，忽略此任务（最新的任务）；</li><li><strong>DiscardOldestPolicy</strong>，忽略最早的任务（最先加入队列的任务）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()); <span class="comment">// 添加 AbortPolicy 拒绝策略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line"></span><br><span class="line">pool-1-thread-1</span><br><span class="line"></span><br><span class="line">pool-1-thread-1</span><br><span class="line"></span><br><span class="line">pool-1-thread-3</span><br><span class="line"></span><br><span class="line">pool-1-thread-2</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.lagou.interview.ThreadPoolExample$$Lambda$1/1096979270@448139f0 rejected from java.util.concurrent.ThreadPoolExecutor@7cca494b[Running, pool size = 3, active threads = 3, queued tasks = 2, completed tasks = 0]</span><br><span class="line"></span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)</span><br><span class="line"></span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)</span><br><span class="line"></span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)</span><br><span class="line"></span><br><span class="line"> at com.lagou.interview.ThreadPoolExample.rejected(ThreadPoolExample.java:35)</span><br><span class="line"></span><br><span class="line"> at com.lagou.interview.ThreadPoolExample.main(ThreadPoolExample.java:26)</span><br></pre></td></tr></table></figure><p>可以看出当第 6 个任务来的时候，线程池则执行了 AbortPolicy  拒绝策略，抛出了异常。因为队列最多存储 2 个任务，最大可以创建 3 个线程来执行任务（2+3=5），所以当第 6 个任务来的时候，此线程池就“忙”不过来了。</p><h3 id="如何自定义拒绝策略？"><a href="#如何自定义拒绝策略？" class="headerlink" title="如何自定义拒绝策略？"></a>如何自定义拒绝策略？</h3><blockquote><p>自定义拒绝策略只需要新建一个 RejectedExecutionHandler 对象，然后重写它的 rejectedExecution() 方法即可，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">&gt;         TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">&gt;         <span class="keyword">new</span> RejectedExecutionHandler() &#123;  <span class="comment">// 添加自定义拒绝策略</span></span><br><span class="line">&gt;             <span class="meta">@Override</span></span><br><span class="line">&gt;             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">&gt;                 <span class="comment">// 业务处理方法</span></span><br><span class="line">&gt;                 System.out.println(<span class="string">"执行自定义拒绝策略"</span>);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;);</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">&gt;     executor.execute(() -&gt; &#123;</span><br><span class="line">&gt;         System.out.println(Thread.currentThread().getName());</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可以看出线程池执行了自定义的拒绝策略，我们可以在 rejectedExecution 中添加自己业务处理的代码。</p></blockquote><h3 id="ThreadPoolExecutor-能不能实现扩展？如何实现扩展？"><a href="#ThreadPoolExecutor-能不能实现扩展？如何实现扩展？" class="headerlink" title="ThreadPoolExecutor 能不能实现扩展？如何实现扩展？"></a>ThreadPoolExecutor 能不能实现扩展？如何实现扩展？</h3><blockquote><p>ThreadPoolExecutor 的扩展主要是通过重写它的 beforeExecute() 和 afterExecute() 方法实现的，我们可以在扩展方法中添加日志或者实现数据统计，比如统计线程的执行时间，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExtend</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">&gt;         <span class="comment">// 线程池扩展调用</span></span><br><span class="line">&gt;         MyThreadPoolExecutor executor = <span class="keyword">new</span> MyThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">&gt;                 TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue());</span><br><span class="line">&gt;         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">&gt;             executor.execute(() -&gt; &#123;</span><br><span class="line">&gt;                 Thread.currentThread().getName();</span><br><span class="line">&gt;             &#125;);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;      * 线程池扩展</span></span><br><span class="line"><span class="comment">&gt;      */</span></span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">&gt;         <span class="comment">// 保存线程执行开始时间</span></span><br><span class="line">&gt;         <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; localTime = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt;                             TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;         <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;          * 开始执行之前</span></span><br><span class="line"><span class="comment">&gt;          * <span class="doctag">@param</span> t 线程</span></span><br><span class="line"><span class="comment">&gt;          * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">&gt;          */</span></span><br><span class="line">&gt;         <span class="meta">@Override</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">&gt;             Long sTime = System.nanoTime(); <span class="comment">// 开始时间 (单位：纳秒)</span></span><br><span class="line">&gt;             localTime.set(sTime);</span><br><span class="line">&gt;             System.out.println(String.format(<span class="string">"%s | before | time=%s"</span>,</span><br><span class="line">&gt;                     t.getName(), sTime));</span><br><span class="line">&gt;             <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;          * 执行完成之后</span></span><br><span class="line"><span class="comment">&gt;          * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">&gt;          * <span class="doctag">@param</span> t 抛出的异常</span></span><br><span class="line"><span class="comment">&gt;          */</span></span><br><span class="line">&gt;         <span class="meta">@Override</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">&gt;             Long eTime = System.nanoTime(); <span class="comment">// 结束时间 (单位：纳秒)</span></span><br><span class="line">&gt;             Long totalTime = eTime - localTime.get(); <span class="comment">// 执行总时间</span></span><br><span class="line">&gt;             System.out.println(String.format(<span class="string">"%s | after | time=%s | 耗时：%s 毫秒"</span>,</span><br><span class="line">&gt;                     Thread.currentThread().getName(), eTime, (totalTime / <span class="number">1000000.0</span>)));</span><br><span class="line">&gt;             <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>以上程序的执行结果如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">1</span> | before | time=<span class="number">4570298843700</span></span><br><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">2</span> | before | time=<span class="number">4570298840000</span></span><br><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">1</span> | after | time=<span class="number">4570327059500</span> | 耗时：<span class="number">28.2158</span> 毫秒</span><br><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">2</span> | after | time=<span class="number">4570327138100</span> | 耗时：<span class="number">28.2981</span> 毫秒</span><br><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">1</span> | before | time=<span class="number">4570328467800</span></span><br><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">1</span> | after | time=<span class="number">4570328636800</span> | 耗时：<span class="number">0.169</span> 毫秒</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="独占锁、共享锁、更新锁，乐观锁、悲观锁"><a href="#独占锁、共享锁、更新锁，乐观锁、悲观锁" class="headerlink" title="独占锁、共享锁、更新锁，乐观锁、悲观锁"></a>独占锁、共享锁、更新锁，乐观锁、悲观锁</h1><h2 id="从数据库系统的角度来看，锁分为以下三种类型"><a href="#从数据库系统的角度来看，锁分为以下三种类型" class="headerlink" title="从数据库系统的角度来看，锁分为以下三种类型"></a>从数据库系统的角度来看，锁分为以下三种类型</h2><h3 id="独占锁（Exclusive-Lock）"><a href="#独占锁（Exclusive-Lock）" class="headerlink" title="独占锁（Exclusive Lock）"></a>独占锁（Exclusive Lock）</h3><p>   独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。执行数据更新命令，即INSERT、 UPDATE 或DELETE 命令时，SQL Server 会自动使用独占锁。但当对象上有其它锁存在时，无法对其加独占锁。独占锁一直到事务结束才能被释放。</p><h3 id="共享锁（Shared-Lock）"><a href="#共享锁（Shared-Lock）" class="headerlink" title="共享锁（Shared Lock）"></a>共享锁（Shared Lock）</h3><p>   共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。在SELECT 命令执行时，SQL Server 通常会对对象进行共享锁锁定。通常加共享锁的数据页被读取完毕后，共享锁就会立即被释放。</p><h3 id="更新锁（Update-Lock）"><a href="#更新锁（Update-Lock）" class="headerlink" title="更新锁（Update Lock）"></a>更新锁（Update Lock）</h3><p>   更新锁是为了防止死锁而设立的。当SQL Server 准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到SQL Server 确定要进行更新数据操作时，它会自动将更新锁换为独占锁。但当对象上有其它锁存在时，无法对其作更新锁锁定。</p><h2 id="从程序员的角度看，锁分为以下两种类型"><a href="#从程序员的角度看，锁分为以下两种类型" class="headerlink" title="从程序员的角度看，锁分为以下两种类型"></a>从程序员的角度看，锁分为以下两种类型</h2><h3 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）"></a>悲观锁（Pessimistic Lock）</h3><p>   悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><h3 id="乐观锁（Optimistic-Lock）"><a href="#乐观锁（Optimistic-Lock）" class="headerlink" title="乐观锁（Optimistic Lock）"></a>乐观锁（Optimistic Lock）</h3><p>   相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。<br>   而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><h1 id="synchronized-amp-ReentrantLock"><a href="#synchronized-amp-ReentrantLock" class="headerlink" title="synchronized &amp; ReentrantLock"></a>synchronized &amp; ReentrantLock</h1><p>在 JDK 1.5 之前共享对象的协调机制只有 synchronized 和 volatile，在 JDK 1.5 中增加了新的机制 ReentrantLock，该机制的诞生并不是为了替代 synchronized，而是在 synchronized 不适用的情况下，提供一种可以选择的高级功能。</p><p>synchronized 属于独占式悲观锁，是通过 JVM 隐式实现的，synchronized 只允许同一时刻只有一个线程操作资源。</p><p>在 Java 中每个对象都隐式包含一个 monitor（监视器）对象，加锁的过程其实就是竞争 monitor 的过程，当线程进入字节码 monitorenter 指令之后，线程将持有 monitor 对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor 对象时，则需要阻塞等待获取该对象。</p><p>ReentrantLock 是 Lock 的默认实现方式之一，它是基于 AQS（Abstract Queued Synchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个 state 的状态字段用于表示锁是否被占用，如果是 0 则表示锁未被占用，此时线程就可以把 state 改为 1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。</p><p>synchronized 和 ReentrantLock 都提供了锁的功能，具备互斥性和不可见性。在 JDK 1.5 中 synchronized 的性能远远低于  ReentrantLock，但在 JDK 1.6 之后  synchronized 的性能略低于  ReentrantLock，它的区别如下：</p><blockquote><p>synchronized 是 JVM 隐式实现的，而 ReentrantLock 是 Java 语言提供的 API；<br>ReentrantLock 可设置为公平锁，而 synchronized 却不行；<br>ReentrantLock 只能修饰代码块，而 synchronized 可以用于修饰方法、修饰代码块等；<br>ReentrantLock 需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而 synchronized 无需手动释放锁；<br>ReentrantLock 可以知道是否成功获得了锁，而 synchronized  却不行。</p></blockquote><p>synchronized 和 ReentrantLock 是比线程池还要高频的面试问题，因为它包含了更多的知识点，且涉及到的知识点更加深入，对面试者的要求也更高，前面我们简要地介绍了 synchronized 和 ReentrantLock 的概念及执行原理，但很多大厂会更加深入的追问更多关于它们的实现细节，比如：</p><p>ReentrantLock 的具体实现细节是什么？<br>JDK 1.6 时锁做了哪些优化？</p><p>首先来看 ReentrantLock 的两个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(); <span class="comment">// 非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参的构造函数创建了一个非公平锁，用户也可以根据第二个构造函数，设置一个 boolean 类型的值，来决定是否使用公平锁来实现线程的调度。</p><p><strong>公平锁 VS 非公平锁</strong></p><p>公平锁的含义是线程需要按照请求的顺序来获得锁；而非公平锁则允许“插队”的情况存在，所谓的“插队”指的是，线程在发送请求的同时该锁的状态恰好变成了可用，那么此线程就可以跳过队列中所有排队的线程直接拥有该锁。</p><p>而公平锁由于有挂起和恢复所以存在一定的开销，因此性能不如非公平锁，所以 ReentrantLock 和 synchronized 默认都是非公平锁的实现方式。</p><p>ReentrantLock 是通过 lock() 来获取锁，并通过 unlock() 释放锁，使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">//......业务处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 中的 lock() 是通过 sync.lock() 实现的，但 Sync 类中的 lock() 是一个抽象方法，需要子类 NonfairSync 或 FairSync 去实现，NonfairSync 中的 lock() 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 将当前线程设置为此锁的持有者</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync 中的 lock() 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出非公平锁比公平锁只是多了一行 compareAndSetState 方法，该方法是尝试将 state 值由 0 置换为 1，如果设置成功的话，则说明当前没有其他线程持有该锁，不用再去排队了，可直接占用该锁，否则，则需要通过 acquire 方法去排队。</p><p>acquire 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire 方法尝试获取锁，如果获取锁失败，则把它加入到阻塞队列中，来看 tryAcquire 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 公平锁比非公平锁多了一行代码 !hasQueuedPredecessors() </span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//尝试获取锁</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">// 获取成功，标记被抢占</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc); <span class="comment">// set state=state+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于此方法来说，公平锁比非公平锁只多一行代码 !hasQueuedPredecessors()，它用来查看队列中是否有比它等待时间更久的线程，如果没有，就尝试一下是否能获取到锁，如果获取成功，则标记为已经被占用。</p><p>如果获取锁失败，则调用 addWaiter 方法把线程包装成 Node 对象，同时放入到队列中，但 addWaiter 方法并不会尝试获取锁，acquireQueued 方法才会尝试获取锁，如果获取失败，则此节点会被挂起，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列中的线程尝试获取锁，失败则会被挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// 获取锁是否成功的状态标识</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 线程是否被中断</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前一个节点（前驱节点）</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 当前节点为头节点的下一个节点时，有权尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node); <span class="comment">// 获取成功，将当前节点设置为 head 节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// 原 head 节点出队，等待被 GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">// 获取成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断获取锁失败后是否可以挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 线程若被中断，返回 true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会使用 for(;;) 无限循环的方式来尝试获取锁，若获取失败，则调用 shouldParkAfterFailedAcquire 方法，尝试挂起当前线程，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断线程是否可以被挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的状态为 SIGNAL，当前线程可以被挂起（阻塞）</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 若前驱节点状态为 CANCELLED，那就一直往前找，直到找到一个正常等待的状态为止</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 并将当前节点排在它后边</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 把前驱节点的状态修改为 SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程入列被挂起的前提条件是，前驱节点的状态为 SIGNAL，SIGNAL 状态的含义是后继节点处于等待状态，当前节点释放锁后将会唤醒后继节点。所以在上面这段代码中，会先判断前驱节点的状态，如果为 SIGNAL，则当前线程可以被挂起并返回 true；如果前驱节点的状态 &gt;0，则表示前驱节点取消了，这时候需要一直往前找，直到找到最近一个正常等待的前驱节点，然后把它作为自己的前驱节点；如果前驱节点正常（未取消），则修改前驱节点状态为 SIGNAL。</p><p>到这里整个加锁的流程就已经走完了，最后的情况是，没有拿到锁的线程会在队列中被挂起，直到拥有锁的线程释放锁之后，才会去唤醒其他的线程去获取锁资源，整个运行流程如下图所示</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210102210705.png" alt="image-20210102210705684"></p><p>unlock 相比于 lock 来说就简单很多了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放成功</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁的释放流程为，先调用 tryRelease 方法尝试释放锁，如果释放成功，则查看头结点的状态是否为 SIGNAL，如果是，则唤醒头结点的下个节点关联的线程；如果释放锁失败，则返回 false。</p><p>tryRelease 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试释放当前线程占有的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 释放锁后的状态，0 表示释放锁成功</span></span><br><span class="line">    <span class="comment">// 如果拥有锁的线程不是当前线程的话抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 锁被成功释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">// 清空独占线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c); <span class="comment">// 更新 state 值，0 表示为释放锁成功</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 tryRelease 方法中，会先判断当前的线程是不是占用锁的线程，如果不是的话，则会抛出异常；如果是的话，则先计算锁的状态值 getState() - releases 是否为 0，如果为 0，则表示可以正常的释放锁，然后清空独占的线程，最后会更新锁的状态并返回执行结果。</p><h4 id="JDK-1-6-锁优化"><a href="#JDK-1-6-锁优化" class="headerlink" title="JDK 1.6 锁优化"></a>JDK 1.6 锁优化</h4><p><strong>自适应自旋锁</strong></p><p>JDK 1.5 在升级为 JDK 1.6 时，HotSpot 虚拟机团队在锁的优化上下了很大功夫，比如实现了自适应式自旋锁、锁升级等。</p><p>JDK 1.6 引入了自适应式自旋锁意味着自旋的时间不再是固定的时间了，比如在同一个锁对象上，如果通过自旋等待成功获取了锁，那么虚拟机就会认为，它下一次很有可能也会成功 (通过自旋获取到锁)，因此允许自旋等待的时间会相对的比较长，而当某个锁通过自旋很少成功获得过锁，那么以后在获取该锁时，可能会直接忽略掉自旋的过程，以避免浪费 CPU 的资源，这就是<strong>自适应自旋锁</strong>的功能。</p><p><strong>锁升级</strong></p><p>锁升级其实就是从偏向锁到轻量级锁再到重量级锁升级的过程，这是 JDK 1.6 提供的优化功能，也称之为锁膨胀。</p><p><strong>偏向锁</strong>是指在无竞争的情况下设置的一种锁状态。偏向锁的意思是它会偏向于第一个获取它的线程，当锁对象第一次被获取到之后，会在此对象头中设置标示为“01”，表示偏向锁的模式，并且在对象头中记录此线程的 ID，这种情况下，如果是持有偏向锁的线程每次在进入的话，不再进行任何同步操作，如 Locking、Unlocking 等，直到另一个线程尝试获取此锁的时候，偏向锁模式才会结束，偏向锁可以提高带有同步但无竞争的程序性能。但如果在多数锁总会被不同的线程访问时，偏向锁模式就比较多余了，此时可以通过 -XX:-UseBiasedLocking 来禁用偏向锁以提高性能。</p><p><strong>轻量锁</strong>是相对于重量锁而言的，在 JDK 1.6 之前，synchronized 是通过操作系统的互斥量（mutex lock）来实现的，这种实现方式需要在用户态和核心态之间做转换，有很大的性能消耗，这种传统实现锁的方式被称之为<strong>重量锁。</strong></p><p>而<strong>轻量锁</strong>是通过比较并交换（CAS，Compare and Swap）来实现的，它对比的是线程和对象的 Mark Word（对象头中的一个区域），如果更新成功则表示当前线程成功拥有此锁；如果失败，虚拟机会先检查对象的 Mark Word 是否指向当前线程的栈帧，如果是，则说明当前线程已经拥有此锁，否则，则说明此锁已经被其他线程占用了。当两个以上的线程争抢此锁时，轻量级锁就膨胀为重量级锁，这就是锁升级的过程，也是 JDK 1.6 锁优化的内容。</p><p>synchronized 刚开始为偏向锁，随着锁竞争越来越激烈，会升级为轻量级锁和重量级锁。如果大多数锁被不同的线程所争抢就不建议使用偏向锁了。</p><h1 id="对锁的理解"><a href="#对锁的理解" class="headerlink" title="对锁的理解"></a>对锁的理解</h1><p>在并发编程中有两个重要的概念：<strong>线程和锁</strong>，多线程是一把双刃剑，它在提高程序性能的同时，也带来了编码的复杂性，对开发者的要求也提高了一个档次。而锁的出现就是为了保障多线程在同时操作一组资源时的数据一致性，当我们给资源加上锁之后，只有拥有此锁的线程才能操作此资源，而其他线程只能排队等待使用此锁。</p><p>如何手动模拟一个死锁？谈谈你对锁的理解。</p><h3 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h3><p>死锁是指两个线程同时占用两个资源，又在彼此等待对方释放锁资源，如下图所示</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210103233851.png" alt="image-20210103233851837"></p><p>死锁的代码演示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">public class LockExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        deadLock(); // 死锁</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 死锁</span><br><span class="line">     */</span><br><span class="line">    private static void deadLock() &#123;</span><br><span class="line">        Object lock1 = new Object();</span><br><span class="line">        Object lock2 = new Object();</span><br><span class="line">        // 线程一拥有 lock1 试图获取 lock2</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock1) &#123;</span><br><span class="line">                System.out.println(&quot;获取 lock1 成功&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // 试图获取锁 lock2</span><br><span class="line">                synchronized (lock2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        // 线程二拥有 lock2 试图获取 lock1</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock2) &#123;</span><br><span class="line">                System.out.println(&quot;获取 lock2 成功&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // 试图获取锁 lock1</span><br><span class="line">                synchronized (lock1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取 lock1 成功</span><br><span class="line">获取 lock2 成功</span><br></pre></td></tr></table></figure><p>可以看出当我们使用线程一拥有锁 lock1 的同时试图获取 lock2，而线程二在拥有 lock2 的同时试图获取 lock1，这样就会造成彼此都在等待对方释放资源，于是就形成了<strong>死锁</strong>。</p><p>锁是指在并发编程中，当有多个线程同时操作一个资源时，为了保证数据操作的正确性，我们需要让多线程排队一个一个地操作此资源，而这个过程就是给资源加锁和释放锁的过程，就好像去公共厕所一样，必须一个一个排队使用，并且在使用时需要锁门和开门一样。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>锁的概念不止出现在 Java 语言中，比如<strong>乐观锁和悲观锁</strong>其实很早就存在于数据库中了。锁的概念其实不难理解，但要真正地了解锁的原理和实现过程，才能打动面试官。</p><p>和锁相关的面试问题，还有以下几个：</p><ul><li>什么是乐观锁和悲观锁？它们的应用都有哪些？乐观锁有什么问题？</li><li>什么是可重入锁？用代码如何实现？它的实现原理是什么？</li><li>什么是共享锁和独占锁？</li></ul><h3 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h3><h4 id="1-悲观锁和乐观锁"><a href="#1-悲观锁和乐观锁" class="headerlink" title="1. 悲观锁和乐观锁"></a>1. 悲观锁和乐观锁</h4><p>悲观锁指的是数据对外界的修改采取保守策略，它认为线程很容易会把数据修改掉，因此在整个数据被修改的过程中都会采取锁定状态，直到一个线程使用完，其他线程才可以继续使用。</p><p>我们来看一下悲观锁的实现流程，以 synchronized 为例，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class LockExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        synchronized (LockExample.class) &#123;</span><br><span class="line">            System.out.println(&quot;lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用反编译工具查到的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;LockExample.java&quot;</span><br><span class="line">public class com.lagou.interview.ext.LockExample &#123;</span><br><span class="line">  public com.lagou.interview.ext.LockExample();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"> </span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // class com/lagou/interview/ext/LockExample</span><br><span class="line">       2: dup</span><br><span class="line">       3: astore_1</span><br><span class="line">       4: monitorenter // 加锁</span><br><span class="line">       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       8: ldc           #4                  // String lock</span><br><span class="line">      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      13: aload_1</span><br><span class="line">      14: monitorexit // 释放锁</span><br><span class="line">      15: goto          23</span><br><span class="line">      18: astore_2</span><br><span class="line">      19: aload_1</span><br><span class="line">      20: monitorexit</span><br><span class="line">      21: aload_2</span><br><span class="line">      22: athrow</span><br><span class="line">      23: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           5    15    18   any</span><br><span class="line">          18    21    18   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出被 synchronized 修饰的代码块，在执行之前先使用 monitorenter 指令加锁，然后在执行结束之后再使用 monitorexit 指令释放锁资源，在整个执行期间此代码都是锁定的状态，这就是<strong>典型悲观锁的实现流程</strong>。</p><p>乐观锁和悲观锁的概念恰好相反，乐观锁认为一般情况下数据在修改时不会出现冲突，所以在数据访问之前不会加锁，只是在数据提交更改时，才会对数据进行检测。</p><p>Java 中的乐观锁大部分都是通过 CAS（Compare And Swap，比较并交换）操作实现的，CAS 是一个多线程同步的原子指令，CAS 操作包含三个重要的信息，即内存位置、预期原值和新值。如果内存位置的值和预期的原值相等的话，那么就可以把该位置的值更新为新值，否则不做任何修改。</p><p>CAS 可能会造成 ABA 的问题，ABA 问题指的是，线程拿到了最初的预期原值 A，然而在将要进行 CAS 的时候，被其他线程抢占了执行权，把此值从 A 变成了 B，然后其他线程又把此值从 B 变成了 A，然而此时的 A 值已经并非原来的 A 值了，但最初的线程并不知道这个情况，在它进行 CAS 的时候，只对比了预期原值为 A 就进行了修改，这就造成了 ABA 的问题。</p><p>以警匪剧为例，假如某人把装了 100W 现金的箱子放在了家里，几分钟之后要拿它去赎人，然而在趁他不注意的时候，进来了一个小偷，用空箱子换走了装满钱的箱子，当某人进来之后看到箱子还是一模一样的，他会以为这就是原来的箱子，就拿着它去赎人了，这种情况肯定有问题，因为箱子已经是空的了，这就是 ABA 的问题。</p><p>ABA 的常见处理方式是添加版本号，每次修改之后更新版本号，拿上面的例子来说，假如每次移动箱子之后，箱子的位置就会发生变化，而这个变化的位置就相当于“版本号”，当某人进来之后发现箱子的位置发生了变化就知道有人动了手脚，就会放弃原有的计划，这样就解决了 ABA 的问题。</p><p>JDK 在 1.5 时提供了 AtomicStampedReference 类也可以解决 ABA 的问题，此类维护了一个“版本号” Stamp，每次在比较时不止比较当前值还比较版本号，这样就解决了 ABA 的问题。</p><p>相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicStampedReference&lt;V&gt; &#123;</span><br><span class="line">    private static class Pair&lt;T&gt; &#123;</span><br><span class="line">        final T reference;</span><br><span class="line">        final int stamp; // “版本号”</span><br><span class="line">        private Pair(T reference, int stamp) &#123;</span><br><span class="line">            this.reference = reference;</span><br><span class="line">            this.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;</span><br><span class="line">            return new Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 比较并设置</span><br><span class="line">    public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                                 V   newReference,</span><br><span class="line">                                 int expectedStamp, // 原版本号</span><br><span class="line">                                 int newStamp) &#123; // 新版本号</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        return</span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line">    //.......省略其他源码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出它在修改时会进行原值比较和版本号比较，当比较成功之后会修改值并修改版本号。</p><blockquote><p>小贴士：乐观锁有一个优点，它在提交的时候才进行锁定的，因此不会造成死锁。</p></blockquote><h4 id="2-可重入锁"><a href="#2-可重入锁" class="headerlink" title="2. 可重入锁"></a>2. 可重入锁</h4><p>可重入锁也叫<strong>递归锁</strong>，指的是同一个线程，如果外面的函数拥有此锁之后，内层的函数也可以继续获取该锁。在 Java 语言中 ReentrantLock 和 synchronized 都是可重入锁。</p><p>下面我们用 synchronized 来演示一下什么是可重入锁，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LockExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        reentrantA(); // 可重入锁</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 可重入锁 A 方法</span><br><span class="line">     */</span><br><span class="line">    private synchronized static void reentrantA() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;：执行 reentrantA&quot;);</span><br><span class="line">        reentrantB();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 可重入锁 B 方法</span><br><span class="line">     */</span><br><span class="line">    private synchronized static void reentrantB() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;：执行 reentrantB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main：执行 reentrantA</span><br><span class="line">main：执行 reentrantB</span><br></pre></td></tr></table></figure><p>从结果可以看出 reentrantA 方法和 reentrantB 方法的执行线程都是“main” ，我们调用了 reentrantA 方法，它的方法中嵌套了 reentrantB，如果 synchronized 是不可重入的话，那么线程会被一直堵塞。</p><p>可重入锁的实现原理，是在锁内部存储了一个线程标识，用于判断当前的锁属于哪个线程，并且锁的内部维护了一个计数器，当锁空闲时此计数器的值为 0，当被线程占用和重入时分别加 1，当锁被释放时计数器减 1，直到减到 0 时表示此锁为空闲状态。</p><h4 id="3-共享锁和独占锁"><a href="#3-共享锁和独占锁" class="headerlink" title="3. 共享锁和独占锁"></a>3. 共享锁和独占锁</h4><p>只能被单线程持有的锁叫<strong>独占锁</strong>，可以被多线程持有的锁叫<strong>共享锁</strong>。</p><p>独占锁指的是在任何时候最多只能有一个线程持有该锁，比如 synchronized 就是独占锁，而 ReadWriteLock 读写锁允许同一时间内有多个线程进行读操作，它就属于共享锁。</p><p>独占锁可以理解为悲观锁，当每次访问资源时都要加上互斥锁，而共享锁可以理解为乐观锁，它放宽了加锁的条件，允许多线程同时访问该资源。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>悲观锁和乐观锁，悲观锁的典型应用为 synchronized，它的特性为独占式互斥锁；而乐观锁相比于悲观锁而言，拥有更好的性能，但乐观锁可能会导致 ABA 的问题，常见的解决方案是添加版本号来防止 ABA 问题的发生。同时，还讲了可重入锁，在 Java 中，synchronized 和 ReentrantLock 都是可重入锁。最后，讲了独占锁和共享锁，其中独占锁可以理解为悲观锁，而共享锁可以理解为乐观锁。</p><p>我对共享锁和排它锁有不同理解共享锁，又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据。排他锁，又称为写锁、独占锁。获准排他锁后，既能读数据，又能修改数据.</p><p>有个问题不太明白，cas既然是原子操作，为什么在a线程取到期望值之后没有比较，而被b线程抢占了执行权，我理解的原子操作，在执行过程中不会受任何的干扰，不知道哪里理解不太对，还请老师指点</p><p><strong>答案</strong>： CAS 保证了原子性，但存在 ABA 的问题。可以理解为原子操作只能保证一个步骤执行的完整性，但ABA问题是组合操作，所以会存在问题。</p><h1 id="Java-Clone"><a href="#Java-Clone" class="headerlink" title="Java Clone"></a>Java Clone</h1><p>Java中的克隆存在两种 深克隆和浅克隆</p><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210105105310.png" alt="image-20210105105310861"></p><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210105105405.png" alt="image-20210105105405266"></p><p>在 Java 语言中要实现克隆则需要实现 Cloneable 接口，并重写 Object 类中的 clone() 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被赋值对象</span></span><br><span class="line">        People p1 = <span class="keyword">new</span> People();</span><br><span class="line">        p1.setId(<span class="number">1</span>);</span><br><span class="line">        p1.setName(<span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆 p1 对象</span></span><br><span class="line">        People p2 = (People) p1.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印名称</span></span><br><span class="line">        System.out.println(<span class="string">"p2:"</span> + p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性</span></span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2:Java</span><br></pre></td></tr></table></figure><h2 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h2><h3 id="在-java-lang-Object-中对-clone-方法的约定有哪些？"><a href="#在-java-lang-Object-中对-clone-方法的约定有哪些？" class="headerlink" title="在 java.lang.Object 中对 clone() 方法的约定有哪些？"></a>在 java.lang.Object 中对 clone() 方法的约定有哪些？</h3><p>要想真正的了解克隆，首先要从它的源码入手，代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns a copy of this object.  The precise meaning</span></span><br><span class="line"><span class="comment"> * of "copy" may depend on the class of the object. The general</span></span><br><span class="line"><span class="comment"> * intent is that, for any object &#123;<span class="doctag">@code</span> x&#125;, the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be true, and that the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment"> * While it is typically the case that:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the returned object should be obtained by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> super.clone&#125;.  If a class and all of its superclasses (except</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object&#125;) obey this convention, it will be the case that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> x.clone().getClass() == x.getClass()&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment"> * of this object (which is being cloned).  To achieve this independence,</span></span><br><span class="line"><span class="comment"> * it may be necessary to modify one or more fields of the object returned</span></span><br><span class="line"><span class="comment"> * by &#123;<span class="doctag">@code</span> super.clone&#125; before returning it.  Typically, this means</span></span><br><span class="line"><span class="comment"> * copying any mutable objects that comprise the internal "deep structure"</span></span><br><span class="line"><span class="comment"> * of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment"> * objects with references to the copies.  If a class contains only</span></span><br><span class="line"><span class="comment"> * primitive fields or references to immutable objects, then it is usually</span></span><br><span class="line"><span class="comment"> * the case that no fields in the object returned by &#123;<span class="doctag">@code</span> super.clone&#125;</span></span><br><span class="line"><span class="comment"> * need to be modified.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>从以上源码的注释信息中我们可以看出，Object 对 clone() 方法的约定有三条：</p><ul><li>对于所有对象来说，x.clone() !=x 应当返回 true，因为克隆对象与原对象不是同一个对象；</li><li>对于所有对象来说，x.clone().getClass() == x.getClass() 应当返回 true，因为克隆对象与原对象的类型是一样的；</li><li>对于所有对象来说，x.clone().equals(x) 应当返回 true，因为使用 equals 比较时，它们的值都是相同的。</li></ul><p>除了注释信息外，我们看 clone() 的实现方法，发现 clone() 是使用 native 修饰的本地方法，因此执行的性能会很高，并且它返回的类型为 Object，因此在调用克隆之后要把对象强转为目标类型才行。</p><h3 id="Arrays-copyOf-是深克隆还是浅克隆？"><a href="#Arrays-copyOf-是深克隆还是浅克隆？" class="headerlink" title="Arrays.copyOf() 是深克隆还是浅克隆？"></a>Arrays.copyOf() 是深克隆还是浅克隆？</h3><p>如果是数组类型，我们可以直接使用 Arrays.copyOf() 来实现克隆，实现代码如下：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">People[] o1 = &#123;new People(1, &quot;Java&quot;)&#125;;</span><br><span class="line">People[] o2 = Arrays.copyOf(o1, o1.length);</span><br><span class="line">// 修改原型对象的第一个元素的值</span><br><span class="line">o1[0].setName(&quot;Jdk&quot;);</span><br><span class="line">System.out.println(&quot;o1:&quot; + o1[0].getName());</span><br><span class="line">System.out.println(&quot;o2:&quot; + o2[0].getName());</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o1:Jdk</span><br><span class="line">o2:Jdk</span><br></pre></td></tr></table></figure><p>从结果可以看出，我们在修改克隆对象的第一个元素之后，原型对象的第一个元素也跟着被修改了，这说明 Arrays.copyOf() 其实是一个浅克隆。</p><p>因为数组比较特殊数组本身就是引用类型，因此在使用 Arrays.copyOf() 其实只是把引用地址复制了一份给克隆对象，如果修改了它的引用对象，那么指向它的（引用地址）所有对象都会发生改变，因此看到的结果是，修改了克隆对象的第一个元素，原型对象也跟着被修改了。</p><h3 id="深克隆的实现方式有几种？"><a href="#深克隆的实现方式有几种？" class="headerlink" title="深克隆的实现方式有几种？"></a>深克隆的实现方式有几种？</h3><p>深克隆的实现方式有很多种，大体可以分为以下几类：</p><ul><li>所有对象都实现克隆方法；</li><li>通过构造方法实现深克隆；</li><li>使用 JDK 自带的字节流实现深克隆；</li><li>使用第三方工具实现深克隆，比如 Apache Commons Lang；</li><li>使用 JSON 工具类实现深克隆，比如 Gson、FastJSON 等。</li></ul><p>接下来我们分别来实现以上这些方式，在开始之前先定义一个公共的用户类，代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address; <span class="comment">// 包含 Address 引用对象</span></span><br><span class="line">    <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出在 People 对象中包含了一个引用对象 Address。</p><p><strong>1.所有对象都实现克隆</strong></p><p>这种方式我们需要修改 People 和 Address 类，让它们都实现 Cloneable 的接口，让所有的引用对象都实现克隆，从而实现 People 类的深克隆，代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">          <span class="comment">// 创建被赋值对象</span></span><br><span class="line">          Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">          People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">          <span class="comment">// 克隆 p1 对象</span></span><br><span class="line">          People p2 = p1.clone();</span><br><span class="line">          <span class="comment">// 修改原型对象</span></span><br><span class="line">          p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">          <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">          System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                  <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> People <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            People people = (People) <span class="keyword">super</span>.clone();</span><br><span class="line">            people.setAddress(<span class="keyword">this</span>.address.clone()); <span class="comment">// 引用类型克隆赋值</span></span><br><span class="line">            <span class="keyword">return</span> people;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Address <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1:西安 p2:北京</span><br></pre></td></tr></table></figure><p>从结果可以看出，当我们修改了原型对象的引用属性之后，并没有影响克隆对象，这说明此对象已经实现了深克隆。</p><p><strong>2.通过构造方法实现深克隆</strong></p><p>《Effective Java》 中推荐使用构造器（Copy Constructor）来实现深克隆，如果构造器的参数为基本数据类型或字符串类型则直接赋值，如果是对象类型，则需要重新 new 一个对象，实现代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        <span class="comment">// 调用构造函数克隆对象</span></span><br><span class="line">        People p2 = <span class="keyword">new</span> People(p1.getId(), p1.getName(),</span><br><span class="line">                <span class="keyword">new</span> Address(p1.getAddress().getId(), p1.getAddress().getCity()));</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1:西安 p2:北京</span><br></pre></td></tr></table></figure><p>从结果可以看出，当我们修改了原型对象的引用属性之后，并没有影响克隆对象，这说明此对象已经实现了深克隆。</p><p><strong>3.通过字节流实现深克隆</strong></p><p>通过 JDK 自带的字节流实现深克隆的方式，是先将要原型对象写入到内存中的字节流，然后再从这个字节流中读出刚刚存储的信息，来作为一个新的对象返回，那么这个新对象和原型对象就不存在任何地址上的共享，这样就实现了深克隆，代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        <span class="comment">// 通过字节流实现克隆</span></span><br><span class="line">        People p2 = (People) StreamClone.clone(p1);</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过字节流实现克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamClone</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(People obj)</span> </span>&#123;</span><br><span class="line">            T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 写入字节流</span></span><br><span class="line">                ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">                oos.writeObject(obj);</span><br><span class="line">                oos.close();</span><br><span class="line">                <span class="comment">// 分配内存,写入原始对象,生成新对象</span></span><br><span class="line">                ByteArrayInputStream bi = <span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());<span class="comment">//获取上面的输出字节流</span></span><br><span class="line">                ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">                <span class="comment">// 返回生成的新对象</span></span><br><span class="line">                cloneObj = (T) oi.readObject();</span><br><span class="line">                oi.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cloneObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1:西安 p2:北京</span><br></pre></td></tr></table></figure><p>此方式需要注意的是，由于是通过字节流序列化实现的深克隆，因此每个对象必须能被序列化，必须实现 Serializable 接口，标识自己可以被序列化，否则会抛出异常 (java.io.NotSerializableException)。</p><p><strong>4.通过第三方工具实现深克隆</strong></p><p>本课时使用 Apache Commons Lang 来实现深克隆，实现代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.SerializationUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深克隆实现方式四：通过 apache.commons.lang 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FourthExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        <span class="comment">// 调用 apache.commons.lang 克隆对象</span></span><br><span class="line">        People p2 = (People) SerializationUtils.clone(p1);</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1:西安 p2:北京</span><br></pre></td></tr></table></figure><p>可以看出此方法和第三种实现方式类似，都需要实现 Serializable 接口，都是通过字节流的方式实现的，只不过这种实现方式是第三方提供了现成的方法，让我们可以直接调用。</p><p><strong>5.通过 JSON 工具类实现深克隆</strong></p><p>本课时我们使用 Google 提供的 JSON 转化工具 Gson 来实现，其他 JSON 转化工具类也是类似的，实现代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深克隆实现方式五：通过 JSON 工具实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FifthExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        <span class="comment">// 调用 Gson 克隆对象</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        People p2 = gson.fromJson(gson.toJson(p1), People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1:西安 p2:北京</span><br></pre></td></tr></table></figure><p>使用 JSON 工具类会先把对象转化成字符串，再从字符串转化成新的对象，因为新对象是从字符串转化而来的，因此不会和原型对象有任何的关联，这样就实现了深克隆，其他类似的 JSON 工具类实现方式也是一样的。</p><h3 id="Java-中的克隆为什么要设计成，既要实现空接口-Cloneable，还要重写-Object-的-clone-方法？"><a href="#Java-中的克隆为什么要设计成，既要实现空接口-Cloneable，还要重写-Object-的-clone-方法？" class="headerlink" title="Java 中的克隆为什么要设计成，既要实现空接口 Cloneable，还要重写 Object 的 clone() 方法？"></a>Java 中的克隆为什么要设计成，既要实现空接口 Cloneable，还要重写 Object 的 clone() 方法？</h3><p>从源码中可以看出 Cloneable 接口诞生的比较早，JDK 1.0 就已经存在了，因此从那个时候就已经有克隆方法了，那我们怎么来标识一个类级别对象拥有克隆方法呢？克隆虽然重要，但我们不能给每个类都默认加上克隆，这显然是不合适的，那我们能使用的手段就只有这几个了：</p><ul><li>在类上新增标识，此标识用于声明某个类拥有克隆的功能，像 final 关键字一样；</li><li>使用 Java 中的注解；</li><li>实现某个接口；</li><li>继承某个类。</li></ul><p>先说第一个，为了一个重要但不常用的克隆功能， 单独新增一个类标识，这显然不合适；再说第二个，因为克隆功能出现的比较早，那时候还没有注解功能，因此也不能使用；第三点基本满足我们的需求，第四点和第一点比较类似，为了一个克隆功能需要牺牲一个基类，并且 Java 只能单继承，因此这个方案也不合适。采用排除法，无疑使用实现接口的方式是那时最合理的方案了，而且在 Java 语言中一个类可以实现多个接口。</p><p>那为什么要在 Object 中添加一个 clone() 方法呢？</p><p>因为 clone() 方法语义的特殊性，因此最好能有 JVM 的直接支持，既然要 JVM 直接支持，就要找一个 API 来把这个方法暴露出来才行，最直接的做法就是把它放入到一个所有类的基类 Object 中，这样所有类就可以很方便地调用到了。</p><hr><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h2 id="普通类-抽象类-接口区别"><a href="#普通类-抽象类-接口区别" class="headerlink" title="普通类 抽象类 接口区别"></a>普通类 抽象类 接口区别</h2><p>1.普通类可以实例化,接口都不能被实例化（它没有构造方法）,抽象类如果要实例化,抽象类必须指向实现所有抽象方法的子类对象(抽象类可以直接实例化，直接重写自己的抽象方法),接口必须指向实现所有所有接口方法的类对象。</p><p>2.抽象类要被子类继承,接口要被子类实现。</p><p>3.接口只能做方法的声明,抽象类可以做方法的声明,也可以做方法的实现。</p><p>4.接口里定义的变量只能是公共的静态常量,抽象类中定义的变量是普通变量。</p><p>5.抽象类里的抽象方法必须全部被子类所实现,如果子类不能全部实现父类的抽象方法,那么该子类只能是抽象类。同样，一个实现接口的时候，如果不能全部实现接口方法，那么该类只能是抽象类。<br>6.抽象方法只能声明，不能实现。接口是设计的结果，抽象类是重构的结果。<br>7.抽象类里可以没有抽象方法。<br>8.如果一个类里有抽象方法，那么该类只能是抽象类。<br>9.抽象方法要被实现，所以不能是静态的，也不能是私有的。<br>10.接口可以继承接口，并可多继承接口，但类只能单继承。（重要啊）<br>11.接口中的常量：有固定的修饰符-publicstaticfinal（不能用private和protected修饰/本质上都<br>是static的而且是final类型的，不管加不加static修饰）。<br>12.接口中的抽象方法：有固定的修饰符-publicabstract。<br>注意：<br>①抽象类和接口都是用来抽象具体的对象的，但是接口的抽象级别更高。<br>②抽象类可以有具体的方法和属性，接口只能有抽象方法和静态常量。<br>③抽象类主要用来抽象级别，接口主要用来抽象功能。<br>④抽象类中，且不包含任何的实现，派生类必须覆盖它们。接口中所有方法都必须是未实现的。<br>⑤接口方法，访问权限必须是公共的public。<br>⑥接口内只能有公共方法，不能存在成员变量。<br>⑦接口内只能包含未被实现的方法，也叫抽象方法，但是不能用abstract关键字。<br>⑧抽象类的访问速度比接口要快，接口是稍微有点慢，因为它需要时间去寻找在类中实现的方法。<br>⑨抽象类，除了不能被实例化外，与普通java类没有任何区别。<br>⑩抽象类可以有main方法，接口没有main方法。<br>⑪抽象类可以用构造器，接口没有。<br>⑫抽象方法可以有public、protected和default这些修饰符，接口只能使用默认public。<br>⑬抽象类，添加新方法可以提供默认的实现，不需要改变原有代码。接口添加新方法，子类必须实现。<br>⑭抽象类的子类用extends关键字继承，接口用implements来实现。</p><h2 id="可以作为GCRoot的对象有哪些？"><a href="#可以作为GCRoot的对象有哪些？" class="headerlink" title="可以作为GCRoot的对象有哪些？"></a>可以作为GCRoot的对象有哪些？</h2><p>1.Systemclass<br>2.JNIclass<br>3.JNIglobal<br>4.ThreadBlock<br>5.Thread.（examplenewThread().start()）<br>6.Javalocal<br>7.NativeStack<br>8.JavastackFrame</p><h2 id="spring中Bean的作用域"><a href="#spring中Bean的作用域" class="headerlink" title="spring中Bean的作用域"></a>spring中Bean的作用域</h2><p>1.singleton：SpringIoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。Singleton作用域是Spring中的缺省作用域。<br>2.prototype：每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。<br>3.request：在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前HttpRequest内有效。<br>4.session：在一次HttpSession中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。<br>5.globalSession：在一个全局的HttpSession中，容器会返回该Bean的同一个实例，仅在使用portletcontext时有效。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;JAVA 的随手PICK&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Tips4Java" scheme="http://yoursite.com/tags/Tips4Java/"/>
    
  </entry>
  
  <entry>
    <title>Flink Source Code</title>
    <link href="http://yoursite.com/2020/10/28/Flink%20Source%20Code/"/>
    <id>http://yoursite.com/2020/10/28/Flink%20Source%20Code/</id>
    <published>2020-10-27T20:47:54.000Z</published>
    <updated>2025-07-30T07:27:47.046Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>菜鸟的Apache源码阅读之路</p></blockquote><a id="more"></a> <h1 id="Flink-源码阅读"><a href="#Flink-源码阅读" class="headerlink" title="Flink 源码阅读"></a>Flink 源码阅读</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>很久之前我就在想怎么阅读源码，大佬的回答总是出奇的一致</p><p>“耐心”</p><p>哈哈，仿佛有了耐心就是万能的</p><p>于是菜逼那会去Github Clone了一份源码，结果在第一步就卡了好久，笑，在第一步学会了使用Git设置代理，学会了去官方文档寻找编译需要的环境（环境真的坑死人），需要合适的JDK版本，需要合适的Mvn版本，否则你是永远不可能编译成功的</p><p>涉及UI的Apache项目一般来说还会依赖很多东西，比如说Node Js之类的，他们会在POM中的自动脚本插件里面附上一些bash操作，对于不同的电脑环境来说未必是能成功的，里面涉及到一些Mvn项目的改动，那段时间确切得感受到了Mac的便利</p><p>终于把基本环境搞定了，接下来一个大型Apache项目中会有大量的代码，从哪阅读，怎么阅读也是个问题，首先要懂一点设计模式对吧，不然光看那些不知所以然的解耦就不知道写代码的人在做什么，满脸懵逼而已，核心的代码，看着26个英文字母都懂，组合在一起就不知道这些代码在干锤子了</p><p>后来又刷了一波LeeCode，终于明白了人和人的差距，连LeeCode这么简单的算法，都有各种巧妙的实现方式，有时候配上注释都要看半天，更别说各种精妙的算法在工程里面的实现了，释然了，这事情只能慢慢去补，如果是梳理框架，使用的话，先从架构层面，理解源码，每个东西在代码中的作用先了然，再谈实现方式，我尝试着尽量不在细节上面纠结，这样阅读代码的收获和成就感会强得多，才能支持自己读下去，书和博客都是梳理架构的好途径</p><p>只要能坚持，总能从优秀的Apache 代码里面学到越来越多的东西，理解应该也会越来越多，上面的是截止到目前为止，菜逼的一些简单感悟，后面如果有新的看法会过来更新<br>剩下需要的就是耐心和时间  :）</p></blockquote><h1 id="源码阅读入口"><a href="#源码阅读入口" class="headerlink" title="源码阅读入口"></a>源码阅读入口</h1><p>Flink提供了系列shell脚本用于flink集群管理、job提交等，通过分析这些脚本找到自己所关心的核心链路入口是比较合适的。</p><p>Flink提供了两个启动脚本：<code>bin/start-local.sh</code> 用于启动单机模式的Flink；<code>bin/start-cluster.sh</code> 用于启动集群模式的Flink。</p><p>（1）start-local.sh</p><ul><li>解析提取flink-yaml.xml中的配置项，各配置项的含义可参考<a href="https://ci.apache.org/projects/flink/flink-docs-master/ops/config.html%E3%80%82" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-master/ops/config.html。</a></li><li>以daemon模式启动jobmanager进程（并分出一个线程启动taskmanager）。</li></ul><p>（2）start-cluster.sh</p><ul><li>解析提取flink-yaml.xml中的配置项。</li><li>通过ssh远程启动各master机器上的jobmaster进程（需要在conf/masters中配置master机器的ip地址，默认是localhost:8081）。</li><li>启动taskmanager进程（需要在conf/slaves配置slave机器的ip地址，通常是localhost）。</li></ul><p>由flink-daemon.sh可知，Flink中各主要进程的入口对应关系如下：</p><table><thead><tr><th>jobmanager</th><th>org.apache.flink.runtime.jobmanager.JobManager</th></tr></thead><tbody><tr><td>taskmanager</td><td>org.apache.flink.runtime.taskmanager.TaskManager</td></tr><tr><td>内置zookeeper</td><td>org.apache.flink.runtime.zookeeper.FlinkZooKeeperQuorumPeer</td></tr><tr><td>historyserver</td><td>org.apache.flink.runtime.webmonitor.history.HistoryServer</td></tr></tbody></table><p>Flink提供的CLI脚本是bin/flink，可以通过该脚本提交Job、创建Savepoint等。</p><p>脚本的主要流程：</p><ul><li>解析提取flink-yaml.xml中的配置项。</li><li>通过Client入口org.apache.flink.client.CliFrontend连接到JobManager并发送消息。</li></ul><p>DUBUG主要流程：</p><p>将源码导入到IDE中（如IDEA），本地debug基本方法如下：</p><p>1、在jvm启动参数中添加远程调试参数</p><p>（1）如果是调试Client，可以将上述参数加到bin/flink脚本的最后一行中，形如：<br>JVM_REMOTE_DEBUG_ARGS=’-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005’<br>exec $JAVA_RUN $JVM_ARGS $JVM_REMOTE_DEBUG_ARGS “${log_setting[@]}” -classpath “<code>manglePathList &quot;$CC_CLASSPATH:$INTERNAL_HADOOP_CLASSPATHS&quot;</code>“ org.apache.flink.client.CliFrontend “$@”<br>（2）如果是调试JobManager或TaskManager，可以在conf/flink-conf.yaml中添加：</p><p>env.java.opts: -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5006</p><p>2、启动flink client或jobmanager或taskmanager，此时程序会suspend等待debuger连接（通过suspend=y来配置）。</p><p>3、配置IDEA中的remote：host配置为localhost，配置port（参考1中的配置的address端口）。</p><p>4、在Flink源码中设置断点，连接远程host，然后就可以开始debug跟踪了。</p><h1 id="Flink-Annotations"><a href="#Flink-Annotations" class="headerlink" title="Flink Annotations"></a>Flink Annotations</h1><p>flink-annotations模块定义了一些flink项目中需要用到的注解。Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。该模块主要包括的注解类型有：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk764ocwdcj20tr08xaah.jpg" alt="undefined"></p><p>flink annotations下包含了docs相关的三种注解：ConfigGroup，ConfigGroups和Documentation。然后还有其他5种注解：Experimental，Internal， Public，PublicEnvolving和VisableForTesting。下面分别简单地介绍下这些注解的作用。</p><h2 id="docs相关的三个注解"><a href="#docs相关的三个注解" class="headerlink" title="docs相关的三个注解"></a>docs相关的三个注解</h2><h3 id="ConfigGroup"><a href="#ConfigGroup" class="headerlink" title="ConfigGroup"></a>ConfigGroup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;&#125;)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigGroup &#123;</span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">keyPrefix</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解的作用是指定一组配置选项的类。该组的name将被用作生成的HTML文件的文件名。</p><h3 id="ConfigGroups"><a href="#ConfigGroups" class="headerlink" title="ConfigGroups"></a>ConfigGroups</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigGroups &#123;</span><br><span class="line">ConfigGroup[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解是提供了一种根据key的最大前缀来把配置选项拆分为不同的组。</p><h3 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h3><p>这个类主要是修改文档生成器的行为的注解集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Documentation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于配置选项字段的以重写已记录的默认值</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OverrideDefault &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 用于配置选项字段的注释，以便将它们包括在“公共选项”部分中。</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CommonOption &#123;</span><br><span class="line"><span class="keyword">int</span> POSITION_MEMORY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_PARALLELISM_SLOTS = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_FAULT_TOLERANCE = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_HIGH_AVAILABILITY = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_SECURITY = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> <span class="keyword">default</span> Integer.MAX_VALUE</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 在配置选项字段上使用的注释，以从文档中排除配置选项。</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExcludeFromDocumentation &#123;</span><br><span class="line"> </span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Documentation</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Experimental"><a href="#Experimental" class="headerlink" title="Experimental"></a>Experimental</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Experimental &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标注类为实验阶段。带有此注释的类既没有经过严格的测试，也还不稳定，并且可以更改或删除在未来版本中。</p><h2 id="Internal"><a href="#Internal" class="headerlink" title="Internal"></a>Internal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Internal &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解用于将稳定的公共API中的方法标记为内部开发人员API。开发人员API是稳定的，但仅仅是在Flink内部，但是在发布版本有可能有些变化。</p><h2 id="Public"><a href="#Public" class="headerlink" title="Public"></a>Public</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Public &#123;&#125;</span><br></pre></td></tr></table></figure><p>标注类为开放和稳定的。类，方法或者属性被这个这个注解修饰时，表示在小版本迭代中，都维持稳定。</p><h2 id="PublicEvolving"><a href="#PublicEvolving" class="headerlink" title="PublicEvolving"></a>PublicEvolving</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PublicEvolving &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解用来标注公共的但有不断发展的接口依赖的类或者方法。带有此注释的类和方法用于公共使用，并且具有稳定的行为。但是，它们的接口和签名不被认为是稳定的，并且当跨版本时可能会变化。</p><h2 id="VisibleForTesting"><a href="#VisibleForTesting" class="headerlink" title="VisibleForTesting"></a>VisibleForTesting</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> VisibleForTesting &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个注解申明有些函数，属性，构造函数或整个类型值是在test时才是可见的。当例如方法应该是编码阶段，通常附加这个注释（因为它不打算在外部调用），但不能声明为私有，因为一些测试需要访问它。</p><h1 id="ParameterTool"><a href="#ParameterTool" class="headerlink" title="ParameterTool"></a>ParameterTool</h1><p>先从简单的看起，这个是Flink自带的工具类, 位置：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk616mdhn7j20ix0roq4t.jpg" alt="73E97217-CF9B-4d73-A33A-5AD2140FA487.png"></p><p>结构：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk61j80jj3j20bc0bggru.jpg" alt="未命名1603941927.png"></p><p>ParameterTool 里面的可以从多种数据来源创建</p><p>比如方法：</p><p><code>fromPropertiesFile</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@link</span> ParameterTool&#125; for the given &#123;<span class="doctag">@link</span> Properties&#125; file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path Path to the properties file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> ParameterTool&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException If the file does not exist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Properties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterTool <span class="title">fromPropertiesFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File propertiesFile = <span class="keyword">new</span> File(path);</span><br><span class="line"><span class="keyword">return</span> fromPropertiesFile(propertiesFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到下面调用了工具类里面的另外一个函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@link</span> ParameterTool&#125; for the given &#123;<span class="doctag">@link</span> Properties&#125; file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file File object to the properties file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> ParameterTool&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException If the file does not exist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Properties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterTool <span class="title">fromPropertiesFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Properties file "</span> + file.getAbsolutePath() + <span class="string">" does not exist"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(file)) &#123;</span><br><span class="line"><span class="keyword">return</span> fromPropertiesFile(fis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续向下套娃</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@link</span> ParameterTool&#125; for the given InputStream from &#123;<span class="doctag">@link</span> Properties&#125; file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputStream InputStream from the properties file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> ParameterTool&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException If the file does not exist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Properties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterTool <span class="title">fromPropertiesFile</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(inputStream);</span><br><span class="line"><span class="keyword">return</span> fromMap((Map) props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@link</span> ParameterTool&#125; for the given map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map A map of arguments. Both Key and Value have to be Strings</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> ParameterTool&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterTool <span class="title">fromMap</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">Preconditions.checkNotNull(map, <span class="string">"Unable to initialize from empty map"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ParameterTool(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边调用了ParameterTool的构造器，然后窜入了参数 最终构造出了这个 ParameterTool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ParameterTool</span><span class="params">(Map&lt;String, String&gt; data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = Collections.unmodifiableMap(<span class="keyword">new</span> HashMap&lt;&gt;(data));</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.defaultData = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(data.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.unrequestedParameters = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(data.size()));</span><br><span class="line"></span><br><span class="line">unrequestedParameters.addAll(data.keySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程里面，<code>inputStream</code> 转化成了 <code>Map&lt;String,String&gt;</code>直到最后的传入。</p><p>工具类的源码比较简单，代码也比较工整，很容易看懂。</p><p>FromArgs用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ParameterTool parameters = ParameterTool.fromArgs(args);</span><br><span class="line">String local_path = parameters.get(<span class="string">"local_path"</span>,<span class="keyword">null</span>);  <span class="comment">//指定参数名：local_path</span></span><br><span class="line"><span class="comment">//读取配置文件</span></span><br><span class="line">ParameterTool paramFromProps = ParameterTool.fromPropertiesFile(local_path);</span><br></pre></td></tr></table></figure><p>代码打包完成jar，在服务器启动Flink任务时，需要添加自定义参数local_path，指定配置文件的绝对路径。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flink run flink.jar -local_path ./config.properties</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>开源发布的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Alpha、Beta、Gamma版本</span><br><span class="line"></span><br><span class="line">以下三者，在系统、架包、软件的开发过程中，使用。</span><br><span class="line">Alpha：内测版，BUG多，开发人员开发过程中使用，希腊字母α，第一，指最初版</span><br><span class="line">Beta：早期版本，有缺陷，无大BUG，可能加入新功能，进一步开发完善。</span><br><span class="line">Gamma: 经beta 版，完善修改，成为正式发布的候选版本（Release Candidate）</span><br><span class="line"></span><br><span class="line">RC、GA、R版本</span><br><span class="line">RC：(Release Candidate)：候选版本，几乎就是正式版了，</span><br><span class="line">GA：（Ggeneral Availability）：发行稳定版，官方推荐使用此版本。</span><br><span class="line">R，RELEASE：正式版，等价于GA</span><br><span class="line"></span><br><span class="line">SNAPSHOT版本</span><br><span class="line">SNAPSHOT：快照版，可以稳定使用，且仍在继续改进版本。</span><br><span class="line"></span><br><span class="line">snapshot多见于架包依赖中，使用Maven时，需要的架包回去仓库Nexus中找，，一个仓库一般分为RELEASE仓和SNAPSHOT仓快照版，前者理解，稳定正式版本，后者如何？Maven在构建项目时，会优先去远程仓库中查看是否有最新的example-1.0-SNAPSHOT.jar，如果有则下载下来使用。即使本地仓库中已经有了example-1.0-SNAPSHOT.jar，它也会尝试去远程仓库中查看同名的jar是否是最新的。</span><br><span class="line"></span><br><span class="line">有的人可能会问，这样不就不能充分利用本地仓库的缓存机制了吗？别着急，Maven比我们想象中的要聪明。在配置Maven的Repository的时候中有个配置项，可以配置对于SNAPSHOT版本向远程仓库中查找的频率。频率共有四种，分别是always、daily、interval、never。当本地仓库中存在需要的依赖项目时，always是每次都去远程仓库查看是否有更新，daily是只在第一次的时候查看是否有更新，当天的其它时候则不会查看；interval允许设置一个分钟为单位的间隔时间，在这个间隔时间内只会去远程仓库中查找一次，never是不会去远程仓库中查找（这种就和正式版本的行为一样了）。</span><br><span class="line"></span><br><span class="line">其他版本</span><br><span class="line">Alpha：内部测试版</span><br><span class="line">Beta：外部测试版</span><br><span class="line">Build：修正版</span><br><span class="line">Corporation或Enterprise：企业版</span><br><span class="line">Delux：豪华版</span><br><span class="line">DEMO：演示版，有功能限制</span><br><span class="line">Free：免费版</span><br><span class="line">Full：完全版</span><br><span class="line">Final：正式版</span><br><span class="line">Pro(professional)：专业版</span><br><span class="line">Plus：加强版</span><br><span class="line">Retail：零售版</span><br><span class="line">Release：发行版，有时间限制</span><br><span class="line">Shareware：共享版，虽然不会要求注册但是一般也有功能限制</span><br><span class="line">SR：修正版</span><br><span class="line">Trial：试用版（一般有时间或者功能限制）</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;菜鸟的Apache源码阅读之路&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Apache Flink" scheme="http://yoursite.com/tags/Apache-Flink/"/>
    
  </entry>
  
  <entry>
    <title>BookTool</title>
    <link href="http://yoursite.com/2020/10/24/BookTool/"/>
    <id>http://yoursite.com/2020/10/24/BookTool/</id>
    <published>2020-10-24T06:59:34.000Z</published>
    <updated>2025-07-30T06:36:52.789Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>读书笔记。</p></blockquote><a id="more"></a> <h1 id="设计数据密集型应用-Designing-Data-Intensive-Application"><a href="#设计数据密集型应用-Designing-Data-Intensive-Application" class="headerlink" title="设计数据密集型应用 Designing Data-Intensive Application"></a>设计数据密集型应用 Designing Data-Intensive Application</h1><h2 id="第一章：可靠性-可拓展性-可维护性"><a href="#第一章：可靠性-可拓展性-可维护性" class="headerlink" title="第一章：可靠性 可拓展性 可维护性"></a>第一章：可靠性 可拓展性 可维护性</h2><blockquote><p>Data System</p></blockquote><h3 id="可靠性-Reliability"><a href="#可靠性-Reliability" class="headerlink" title="可靠性 Reliability"></a>可靠性 Reliability</h3><p>系统在adversity中任然可以正常工作。</p><p>可靠性的总结：</p><ul><li>程序表现出用户所期望的功能</li><li>允许用户犯错，允许用户以出乎意料的方式使用软件</li><li>在预期的负载和数据量下，性能满足要求</li><li>系统能防止未经授权的访问和滥用</li></ul><p>故障（fault） 容错（fault-tolerant） 韧性（resilient）</p><p>硬件故障、软件错误、人为错误</p><h3 id="可拓展性-Scalability"><a href="#可拓展性-Scalability" class="headerlink" title="可拓展性 Scalability"></a>可拓展性 Scalability</h3><p>有合理的办法应对系统的增长（数据量 流量复杂性）</p><p><strong>描述负载</strong>    tw为例</p><p><strong>描述性能</strong>    </p><p>对于hadoop 关心吞吐（throughput） </p><p>对于在线系统，关心响应时间（response time）对响应时间的比较良好的数据：百分位点（percentiles）和中位数（median）而不是算术平均值（arithmetic mean） </p><p>尾部延迟（tail latecies）在某些场景下非常重要，比如亚马逊–用户掏钱了</p><p><strong>应对负载</strong></p><p>纵向拓展 scaling up 垂直拓展 vertival scaling 转向更强大的机器</p><p>横向拓展 scaling out 水平拓展 horizontal scaling 将负载分不到多台小机器上</p><p>有些系统是弹性的（elastic），但是会造成额外的复杂度，手动扩容会简单很多 如果系统是极难预测的，则弹性扩容可能会很有用（highly unpredictable）</p><p>跨多台机器部署无状态服务（stateless service）非常简单。</p><p>没有通用的可拓展框架（万金油 magic scaling sauce）</p><p>一个适配良好的可拓展框架，是围绕假设（assumption）建立的</p><h3 id="可维护性-Maintainability"><a href="#可维护性-Maintainability" class="headerlink" title="可维护性 Maintainability"></a>可维护性 Maintainability</h3><p>许多不同的人在不同的声明周期，都高效的在系统中工作</p><p>在设计软件指出就尽量考虑尽可能减少维护期间的痛苦，从而避免自己的软件系统编程遗留系统。</p><p>为此，我们将特别关注软件系统的三个设计原则：</p><p><strong>可操作性</strong></p><p>便于运维团队保持系统平稳运行</p><p><strong>简单性</strong></p><p>从系统中消除尽可能多的复杂度（complexity）</p><p><strong>可演化性</strong></p><p>可拓展性（extensibility） 可修改性（modifiability）可塑性（plasticity）</p><h2 id="数据模型与查询语言"><a href="#数据模型与查询语言" class="headerlink" title="数据模型与查询语言"></a>数据模型与查询语言</h2><p>数据模型不仅仅影响着软件编写方式，而且影响着我们的解题思路。</p><p>数据模型种类繁多，每个数据模型都带有如何使用的设想，有些用法很容易，有些则不支持如此。</p><p>掌握一个数据模型需要花费很多精力，所以选择一个适合的数据模型是非常重要的。</p><h3 id="关系模型与文档模型"><a href="#关系模型与文档模型" class="headerlink" title="关系模型与文档模型"></a>关系模型与文档模型</h3><p><strong>SQL</strong></p><p>现在最著名的数据模型可能是SQL，它基于Edgar Codd在1970年提出的关系模型：数据被组织称关系（SQL中称作表），每个关系是元组的无需集合。</p><p><strong>NoSQL</strong></p><p>NoSQL被追溯性的重新解释为不仅是SQL（Not Only SQL）</p><p>驱动NoSQL诞生的原因是：</p><ul><li>需要比关系型数据库更好的可拓展性，包括非常大的数据集或非常高的写入吞吐量</li><li>相比商业数据库产品，免费和开源更手滑你用</li><li>关系模型不能很好地支持一些特殊查询</li><li>受挫与关系模型的限制性，渴望一种更多动态性与表现力的数据模型</li></ul><p>在可预见的未来，关系型数据库似乎可能会继续与各种非关系型数据库一起使用，这种想法有时被称为混合持久化(polyglot persistence)</p><p><strong>对象关系不匹配</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Paxos从入门到学会Raft</title>
    <link href="http://yoursite.com/2020/10/22/Paxos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AD%A6%E4%BC%9ARaft/"/>
    <id>http://yoursite.com/2020/10/22/Paxos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AD%A6%E4%BC%9ARaft/</id>
    <published>2020-10-22T12:18:11.000Z</published>
    <updated>2025-07-30T06:46:02.376Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分布式一致性协议把分布式的系统连接到了一起，就像蚁群有个统一的大脑一样，蚁群应该也有这种系统吧。</p><p>除了Paxos，类似的算法还有Bully 算法 Zab算法</p><p>文章来自网络，后续会补上自己的看法。</p></blockquote><a id="more"></a> <h1 id="Paxos从入门到学会Raft"><a href="#Paxos从入门到学会Raft" class="headerlink" title="Paxos从入门到学会Raft"></a>Paxos从入门到学会Raft</h1><p>我觉得学习Paxos/Raft的最大障碍并不是算法本身复杂，而是难以理解。就好像某些数学结论，证明过程不难，但是结论却很难从直观上去理解。本文就是希望能借助一个假想中的系统，逐步加强约束，引导到Paxos/Raft，希望能一定程度上解释“为啥要用共识算法”以及“不用共识算法会怎样”的问题。</p><p>本文结构在很大程度上参考了<a href="https://weibo.com/drdrxp" target="_blank" rel="noopener">drdrxp</a>阁下的一个PPT，他的微博主页上也有对应一篇很棒的<a href="https://weibo.com/ttarticle/p/show?id=2309404510981786042616" target="_blank" rel="noopener">关于Paxos的文章</a>，这里表示感谢及一并推荐给大家。不过因为理解角度不同，本文很多地方有诸多差异，例如关于半同步复制为什么不可行，本文给出了另一种解释，另外这里没有讲Fast Paxos，但是多了关于Raft的内容，希望读者可以进行比较阅读：）</p><h2 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h2><p>我们假想一个抢购手机的网络服务，因为这款手机的用户都比较发烧，所以一次只卖一个手机。在活动之前，系统会给每个用户分配一个E码作为唯一标识，抢购时间到达之后，所有用户通过客户端发送E码到服务器，服务器把手机分配给一个用户。</p><p>第一版设计我们使用单机服务器模式：搞一台主机作为服务器，当收到第一个请求后，保存这个用户的E码，并给客户端返回“抢购成功”，对于后续的所有请求，只要E码跟保存的不一样，一律返回“抢购失败”。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye19zpv1g20dw07iq3w.gif" alt="undefined"></p><p>单机模式的缺陷大家都耳熟能详了，就是不能容忍节点发生故障。仅有的一台服务一旦故障，整个服务就不能用了，这个指的是可用性。还有一个批判的角度是容灾性，如果这台服务器的数据损坏了，我们将无从判断这台手机是否已经被卖给了某个用户。</p><h2 id="备份（异步复制）"><a href="#备份（异步复制）" class="headerlink" title="备份（异步复制）"></a>备份（异步复制）</h2><p>大家都知道用户数据是非常重要的资产，万万不能丢，一定要备份。</p><p>所谓备份，就是定期把数据拷贝一份放在别的地方。还有一个概念叫异步复制，其实本质上差别不大，我们放在一起讨论。这里说异步，指的是最新的数据并不是与备份副本实时同步的。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye1mnmsug20dw07b755.gif" alt="undefined"></p><p>备份能解决一部分数据容灾的问题。这里限定说“一部分”，是因为异步模式存在一个不同步的时间窗口。如果Master在(3)OK返回给客户端之后故障了，E的值将不能被复制到Slave。之后如果使用Slave数据来恢复服务，手机将再次被卖给另外一个人，也就是一致性被破坏了。</p><h2 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h2><p>异步的不行，那同步的怎么样呢？</p><p>如图所示，Master收到请求后，先同步给Slave，Slave存盘后返回OK，然后Master再存盘并给客户端返回OK。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye1vol49g20dw07c3zi.gif" alt="undefined"></p><p>如果Slave故障了，我们把Master切换成单机模式继续提供服务。如果Master故障了，我们就把Slave切换成Master提供服务。因为是同步的，两种情况都不会产生数据丢失。</p><p>注意这里假设Slave在存完盘返回消息之前故障，也不算丢数据，因为此时Master并没有给客户端返回OK，所以手机是可以再卖给另一个人的，只需要在Slave恢复之后，Master再把新值同步过去就行了。</p><p>看上去就很完美了，可用性和一致性都能得到保证，只需要有一个负责任的工程师来盯着服务器，故障的时候切一下状态就行了。</p><p>问题就出在这个工程师身上。</p><p>我们必须要把工程师这个人也算成分布式系统的一部分，要考虑到人也会故障的（生病，意外，手机欠费失联，突然想去看看世界），而且通常管理员也是通过网络来运维管理，当服务器节点之前网络中断时，管理员也很可能无法访问某些节点。实际上我们完全可以把工程师看作集群里的一个故障检测程序来分析问题。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye267j7yj20dw0d6js9.jpg" alt="undefined"></p><p>如图(A)，假如Admin节点离Master比较近，那么当他们一起故障时，Slave无法被提升成Master。同理(图B)，Admin跟Slave一起故障时，Master也无法切换成单机模式。</p><p>那我多搞几个Admin，分别跟Master/Slave部署在一起行不行？也是不行的，这样看起来Master/Slave不管谁故障了，另一个没故障的总有Admin来操作。但是假如发生了网络隔离，如果Admin判断对面故障了，贸然切换状态，可能会出现两都是Master同时提供服务，一致性被破坏。</p><p>还有一种打补丁的思路，就是引入一个仲裁者(图D)的角色，Master和Slave不断心跳上报状态，发现对面失联想切换状态时，也要向Meta申请。这样一来，当Master和Slave断开时，取决于谁跟Meta是连着的，以及谁能更快地把状态切换请求发给Meta。</p><p>不过这里的问题在于，如何保证Meta的高可用和容灾性呢？（禁止套娃）</p><h2 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h2><p>回顾一下上面提到的各种方案，我们能发现一个有趣的现象：每次都是跪在系统中的特殊节点上面。比如仲裁者Meta，或者负责切换状态的Admin，还可以包括单机模式下的那个唯一单点。由于特殊节点的不可替代性，一旦故障了，牵一发动全身，整个系统就离挂掉不远了。</p><p>说明一下，这里从可用性来分析，我们不认为Master是特殊节点，因为Master和Slave是可以相互替代的。</p><p>从消除特殊节点的思路出发，我们把之前方案里的仲裁者Meta换成Slave，就得到了半同步复制模式。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye2f051wg20dw09qgn3.gif" alt="undefined"></p><p>具体来说，Master收到消息先本地持久化，然后同时同步给两个Slave，当其中任意一个Slave完成持久化并返回OK后，Master返回OK给客户端。</p><p>不难分析，任意一个Slave故障时，都不会影响服务。假如Master故障，则需要两个Slave挑一个出来当新的Master，此时可能只有一个Slave同步到数据，我们需要选择有数据的节点当Master。如果两个Slave都没数据，那任选一个就行。</p><p>这里的Slave其实同时承载了“仲裁节点”的角色，当Master和另一个Slave断连时，如果此Slave能连上Master，则支持Master继续提供服务，反之如果此Slave只能连到另一个Slave，那这两个Slave放弃旧Master选个新的出来。</p><p>如此这般，这个方案能很好地满足单节点故障时的可用性和一致性，而且规则简单，不需要人工介入就能自动完成。可惜它还是有缺陷的，前面我们其实只分析了单次故障的情形，如果连续多次故障，就不行了。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye2yvsexg20dw09hadn.gif" alt="undefined"></p><p>如图，Master本地写完E=1后故障了，Slave选出新的Master然后写入E=2，随后新Master也故障同时旧Master又活过来了，然后剩下的两个节点都有数据，还都不一样，你瞧瞧我，我瞧瞧你，不知道谁来当Master合适。</p><p>你可能想说，我们改下流程，写入时先在Slave持久化，OK返回给Master后再在Master持久化，这样是不是就行了？这样也是不行的，因为Slave可能在刚持久化之后就故障了，随后另外两个节点写入新值并再次故障，最后结果是一样的。</p><p>半同步复制还可以进一步打补丁，不过这里我们先放一放，来看一下另一个思路。</p><h2 id="多写"><a href="#多写" class="headerlink" title="多写"></a>多写</h2><p>如果我们进一步消除节点的特殊性，即不再区分Master和Slave，可以得到另一个方案：客户端把请求同时发向3个节点，当其中2个节点返回OK后，就认为写入成功。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye3bpzq4g20dw0bvtbr.gif" alt="undefined"></p><p>如图所示，Node1和Node2成功持久化了E=1并返回OK，之后Client2再尝试写入E=2时，最多只能写入Node3一个节点，因此无法成功写入，这样我们就保证了手机不可能被卖给2个人。</p><p>这里我们利用了“鸽巢原理”：client1和client2要想都写入成功，需要各收到2个OK，而每个节点都只会给第一个请求的客户端发送OK，也就是说总共只能发出去3个OK，因此只有一个客户端能写入成功。</p><p>这个规律也可以推广至更多数量的节点，只要规定要求写入的节点数大于一半，就只能写成功一个。</p><p>还有一种表述是，两个包含大多数成员的子集，一定至少有一个公共节点。这个性质十分重要，后面我们还会用到。</p><p>这个方案的问题在于，它能保证手机不被卖给多个人，但是保证不了手机一定能卖出去。比如3个节点收到的第一个请求分别来自不同的客户端，此时任何一个客户端都无法收集到足够数量的OK。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye3kmdsgg20dw0bo0ue.gif" alt="undefined"></p><p>此外的矛盾之处在于：一方面，节点应该避免先后被多次写入来确保手机不被卖给多人；另一方面，节点又需要能“擦除”已经写入的数据来使得手机最终一定能被卖出。</p><p>不难发现，能被安全擦除的值，一定是没有成功写入大多数节点的，一旦写入了大多数节点，客户端就认为写入成功，如果再允许其他客户端写入成功，手机也就被卖给多个人了。</p><p>在多写模式下，不存在Master那样的特殊节点，最后手机卖给谁了，不取决于某一个节点，而是由集群中的大多数节点决定。</p><h2 id="WRN"><a href="#WRN" class="headerlink" title="WRN"></a>WRN</h2><p>多写模式下应该如何去读取数据，DynamoDB和Cassandra所用的WRN模型给出了一个思路。所谓WRN，是指有N个节点的集群，写入时同时写入W个节点，读取时查询R个节点，当保证W+R&gt;N时，同样根据“鸽巢原理”，我们能知道W和R一定至少有一个公共节点，因此先写入的值一定会被后面的读取“看到”。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye3uptr8g20dw0bt776.gif" alt="undefined"></p><p>大家都知道，DynamoDB和Cassandra都是最终一致性的。它们的弱一致性，主要体现在写入进行的过程中进行多次读取，可能有时能读到写入的数据，有时又读不到，根据读取所查询的节点不同而得到不同的结果。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye4586zlg20dw0c6gp9.gif" alt="undefined"></p><p>此外，写入成功的值一定会被读到，不意味着读到的值一定写入成功或将要写入成功。假设客户端只写入了一个节点就故障了，数据仍然可能被其他客户端读取到。</p><p>WRN还给了我们一点提示，想要集群节点的两个子集有公共节点，不一定要取两个大多数节点，只需要加起一起数量大于N就行了。从高可用的角度来看，W和R分别取刚好超过一半节点通常是一个好选择，因为这样可以容忍最多不超过一半的节点故障。当然了，假如业务只关心写入请求的高可用，完全可以让W=1,R=N，此时只要连上一个节点就能写入，但是不同节点可能写入不同的值，需要在读的时候处理冲突，这就是典型的CAP理论中牺牲C来换取A了。</p><h2 id="多读-多写"><a href="#多读-多写" class="headerlink" title="多读+多写"></a>多读+多写</h2><p>基于此我们有了改进思路：服务器端总是允许用新值覆盖旧值；客户端使用一种两阶段的流程，在写入之前先进行一轮读取，如果发现已经有值被写入了大多数节点，就说明手机已经被卖出去了，否则可以尝试写入新值。</p><p>很显然，与WRN类似，这个方案也有并发问题。当client2发起读取时，client1的写入还没有开始或者进行到一半，此时client2认为没有旧值被成功写入，于是发起写入，而在client2写入成功之前，client1也写入成功了，这样，手机又被卖给了两个人。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye4e2woxg20dw0c7770.gif" alt="undefined"></p><p>这个方案不能成功的原因是，第一阶段的读取的结果不能保持到第二阶段的写入，写入请求到达服务器时，前置条件已经不成立了。</p><p>一种可能的改进方法是使用某种锁机制，第一阶段读取时，把读过的节点上锁，第二阶段写入时再解锁。只是这么做的副作用也很显然，一旦上完锁之后客户端崩溃，或者与某些节点的网络断开，某些节点将没有机会被解锁。</p><p>我们要做的是把这个锁换成一种“活锁”。</p><h2 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h2><p>在现实生活中有一个活锁的例子，就是拍卖。拍卖的时候，报价是不断上涨的，每当竞拍人给出一个报价时，之前所有更低的报价就失效了，同时产生了一个交易确认窗口期，如果没有人出更高报价，交易就会被确认。</p><p>Paxos的工作方式是类似的。每个客户端可以不断生成递增且互不重复的proposal id，写入分为读写两阶段，分别叫_prepare_和_accept_，如果两个阶段之间没有被更大的proposal id打断，写入就能成功。</p><p>Paxos把我们之前描述的抢手机的问题抽象为“多个节点共同确认一个值”的问题，把我们的服务器节点叫acceptor，客户端叫proposer，当一个proposer把值写入超过半数的acceptor后，这个值就被确认了。</p><p>Paxos的工作过程是，在读取阶段，需要写入数据的proposer向所有acceptor发送自己的proposal id，acceptor保证一旦返回自己的状态，便不再接受proposal id更小的请求了。</p><p>我们尝试站在proposer的视角，来推断其收到大多数acceptor回复后，可能遇到的3种情况：</p><ol><li>这些节点都没有value，说明此时没有value被确定，而且将来也不会有value被更小的proposal id确定（理由是大多数acceptor已经不再接受proposal id更小的请求了）。此时该proposer可以尝试发送accept消息来写入新值。</li><li>这些节点都返回了相同的value和proposal id，说明此时value已经被确定了。此时该proposer应该拒绝掉待写入的新值。</li><li>只有部分结果有value，或者这些节点返回的proposal id不完全一样。此时不确定是否有value已经或即将被更小的proposal id所确认，该proposer也不能写入新值。不过，能确定的是，如果已经有value已经或即将被提交，那么该value一定是所有acceptor返回的消息中proposal id最大的那一个（原因参考情况1，某个proposer写入了该value，意味着更小的proposal id都不可能成功）。此时为了得到确定的值，我们只能选择发送accept消息写入旧值。</li></ol><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye4mwucjj20dw0gj750.jpg" alt="undefined"></p><p>在第二阶段，proposer把待写入的新值或旧值放在accept消息中发给所有的acceptor，再一次，当收到大多acceptor的返回消息后，该值就被确定了。如果在两个阶段之间插入了proposal id更大的prepare消息，写入将不会成功。这时proposer需要选择更大的proposal id并再次尝试两阶段写入。</p><p>这就是Paxos的基本过程了，其实是很容易理解的。</p><p>它能保证一致性的关键之处在于，两个阶段都要求得到大多数节点的确认，对于任意两个有潜在冲突可能的二阶段过程，我们假设proposal id较小的是X，另一个是Y。在X的accept阶段与之交互的acceptor集合和在Y的prepare阶段与之交互的acceptor集合，一定至少有一个公共节点，如果这个节点先收到X的accept，那么Y的prepare将会读到X所写入的值，反之如果这个节点先收到Y的prepare，那么X的accept一定不会成功。</p><p>考虑高可用和容灾能力的话，两个阶段都只需要大多数节点参与，因此Paxos能半数以下的节点故障或数据丢失。</p><h2 id="Naive-Raft"><a href="#Naive-Raft" class="headerlink" title="Naive Raft"></a>Naive Raft</h2><p>之前我们介绍了，半同步复制模式还可以进一步优化，接下来就给出一个能真正解决问题的方案。</p><p>为了阐明Raft与Paxos之间的内在联系，这里我们引入一个简化版本的Raft算法，即只确定一个值的Raft，不妨叫Naive Raft。为了配合Raft中的术语，接下来我们把半同步复制中的Master改叫Leader，Slave改叫Follower。</p><p>回顾半同步复制不可行的场景，是在节点多次隔离或故障之后，剩余节点上存储的是不同的数据，无法判断谁的数据可能被确定了，也就无法决定谁去覆盖谁。</p><p>解决的方法也很简单，就是仿照Paxos，给不同的value定一个偏序的覆盖关系。由于半同步复制模型中，value总是由leader写入的，说白了就是要给不同的leader定一个覆盖顺序。</p><p>具体做法是这样的。每个节点存储一个整数term，表示选举轮次，初始时term都为0。当follower发现leader心跳超时，则会递增自己的term，并互相发消息投票选新leader。投票的限制条件是：</p><ol><li>节点只会给大于自己本地存储的term投票</li><li>节点给某个term投完票后，就不会再投给相同或更小的term投票，也不再接受term更小的数据同步</li><li>节点收到大多数节点的投票后，即成为leader，可以开始接受数据写入。如果超时没能选出leader，则会过一段时间再次递增term发起选举。</li></ol><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye4zpjqeg20dw0cigqq.gif" alt="undefined"></p><p>Naive Raft能保证一致性的关键，同样在于两个大多数节点集合有交集。其一是leader选举时所有给leader投票的节点集合，一个是数据复制是所有参与同步数据的节点集合。这二者有交集，意味着如果上一任leader确认了一个值，这个值必然会出现在下一任leader上，反之如果某一任leader选出时，节点上不存在一个value，那么上一任leader的数据复制将一定不能成功。</p><p>与Paxos类似，也是半数以上节点在线就能提供服务。</p><h2 id="Basic-Paxos和Naive-Raft的内在联系"><a href="#Basic-Paxos和Naive-Raft的内在联系" class="headerlink" title="Basic Paxos和Naive Raft的内在联系"></a>Basic Paxos和Naive Raft的内在联系</h2><p>不难发现，这两个算法有很大程度上的相似性。比如Paxos中“只响应proposal id更大的请求”和Raft中“只给大于本地term的节点投票”，比如Paxos中“选择proposal id最大的数据写入”和Raft中“选择term最大的节点当leader”，比如二者都利用了大多数节点子集相交的性质……</p><p>这两者的对应关系是这样的。Raft的term和Paxos的proposal id本质上是一个东西，Raft leader选举等效于Paxos的prepare，Raft leader相当于完成了第一阶段prepare的Paxos proposer，Raft的数据复制对应于Paxos的第二阶段accept。</p><p>其中最不明显的对应关系是Raft leader选举和Paxos的prepare。Paxos的prepare阶段通过收集大多数acceptor的状态，来判断是否可能有value已经被确定，如果有则该value一定会接下来被accept。在Raft中，leader选举本质上也是一个读取过程，通过数据交换来判断是否可能有value在更小的term被确定，如果有则保证该value一定出现在下一任leader上。</p><p>另外，Paxos的第一阶段跟要写入的value是没有任何关系的，所以理论上prepare完全可以像Raft一样提前做了，等什么时候要写入的值来了，再做第二阶段。当然实际上不可行，因为多个proposer会互相覆盖，可以找一个proposer做完prepare，再不断给其他proposer发心跳阻止被覆盖，如此一来就更像Raft了。</p><p>还有一点，在我们的Native Raft中，第一任leader一开始就可以直接写入的，不需要第一阶段选举（注意真正的Raft不是这样，因为不在初始配置区分Leader/Follower，启动时也是需要选举的）。这是因为term 0是初始化配置，不可能有比term 0更早的写入，因此可以省掉第一阶段。同理在Paxos中，假如我们规定proposal id最小是0，那么对应proposal id为0的proposer也不用走第一阶段，直接写入就行。</p><h2 id="Quorum"><a href="#Quorum" class="headerlink" title="Quorum"></a>Quorum</h2><p>不管是Paxos还是Raft，反复出现的一个要素是“大多数节点”，也就是所谓Quorum。Quorum的最重要的一个性质就是所有节点的两个Quorum一定至少有一个交集，共识算法就是在一个节点随时会挂或重启的极端不稳定的环境中，构建出这样一个稳定的交集来保证一致性。</p><p>实际上，关于Quorum的一切结论都来源于“两个Quorum必相交”这个性质。其实，“大多数”并不是Quorum的本质，“相交”才是。具体来说，共识算法两阶段所涉及的节点集合，必须要有交集。</p><p>基于这个认知，我们可以设置很多种不同的Quorum方案来适应不同场景，这里试举几例。</p><p>第一种是加权重。Quorum设置为Majority的一个重要理由是使得集群能承受最多数量的节点故障，不过假如因为某种原因节点故障的概率是不同的，我们就可以给节点赋予不同的权重，越是稳定的节点权重越大，Quorum则定义成超过总权重的一半，这么做同样可以保证相交。</p><p>第二种是考虑地理拓扑结构。比如6个节点分布在3个数据中心，如果使用Majority数据必须要复制到4个节点，需要跨数据中心。我们可以将两阶段的Quorum分别定义成“每个中心的至少一个节点”和“某个中心的全部节点”，也就是读取阶段必须读完每个中心，写入阶段必须写完单个中心的全部节点，写入时不用跨数据中心。</p><p>还有一种更泛化的方式是把所有节点放进一个矩阵，然后第一阶段要求完成任意一行，第二阶段要求完成任意一列。比如9个节点，按常规方法两阶段都需要完成5个节点，如果放入3x3的矩阵，那么两个阶段都是最少完成3节点就够了。</p><h2 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi-Paxos"></a>Multi-Paxos</h2><p>到目前为止，我们都只卖一台手机，也就是算法只用来确定一个值。实际场景中往往需要的是确定一系列的值，比如我们可能要卖100台手机。</p><p>最简单的做法就是同时运行100个Paxos实例，每个实例只卖一台手机。不过这也不符合现实场景的需要，比如100台手机一起卖，无法判断E码是不是被重复使用了。更常见的做法是顺序地依次运行100次，最后被确定的是一个连续的日志队列，记录每个手机的卖出记录。</p><p>如何保证“顺序依次运行”呢？我们可以把100台手机想象成100个待确定的“坑”，当proposer在尝试写入一条记录之前，需要找到第一个空闲的坑，并把这个坑之前待确认的坑都给确认了。</p><p>类似Basic Paxos，proposer准备写入一个value时，先生成proposal id放在prepare消息发送给所有acceptor，每个accetpor把自己本地100个坑位的情况回复给proposer。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye5dp5v2j20dw07wq33.jpg" alt="undefined"></p><p>当proposer收到大多数acceptor的回复后，假如此时收到的回复中，有数据的最大的坑位编号是i，则我们应该把数据写入i+1号坑位。不过，此时i号坑位可能并没有被确认（除非所有acceptor返回的i号坑位的状态是一样的），我们需要先用Basic Paxos的方法把i号确认了（也就是挑选其中proposal id最大的，发送accept并确保收到大多数accepter回复的OK），然后再次使用Basic Paxos的方法把自己的数据填入i+1号坑位。</p><p>有一点需要说明一下，待确认的坑位最多只可能有最大的那一个，因为按照流程如果i之前有未被确认的坑位，i这个位置根本不可能有数据。</p><p>接下来我们来看一下Multi-Paxos一个十分关键的优化。前面介绍，在写入一条记录时，可能需要两次Paxos过程，一次用来确认潜在的未完成的最后一条记录，一次用来写入新记录。实际上，第二次Paxos过程不用做全套，只用做第二阶段就行了。</p><p>怎么做到呢？我们先对proposal id做点小手脚，把proposal id改成递增的proposal id和坑位号的组合，即&lt;proposal_id, index&gt;，比较大小的时候先比较proposal id，再比较index，这样确认完i号坑，准备写i+1号坑时，就不用递增proposal id了，因为index加了1，起到了组合变大的效果。此时如果另一个proposer发过来更大的proposal id，仍然可以打断当前proposer，即&lt;100,0&gt;大于&lt;99,42&gt;。</p><p>接下来我们思考一下，第二轮Paxos里prepare阶段的目的是什么？是为了确保没有更小的proposal id可能确认i+1号坑位，而我们在accept第i号坑位时，已经成功地保证了这一点。（因为我们知道大多数acceptor已经不再接受小于&lt;proposal_id, i+1&gt;的请求了）。</p><p>同样的道理，这个proposer写完i+1号坑之后，可以继续直接accept i+2号坑位，i+3号坑位……直到其他proposer生成出更大的proposal id将其打断。</p><p>因此，在Multi-Paxos中，只要保证同一时刻只有一个proposer，就能做到一次prepare，然后不断进行accept，宏观上来看，写入一个值平均只需要一个阶段。至于如何保证同一时刻只有一个proposer，可以使用类似raft的心跳机制，只要当前工作的proposer能不断发出心跳，其他proposer就不会尝试写入数据。</p><p>Multi-Paxos还有一个优化是pipeline。经过前面的优化，虽然每次写入只需要一阶段RPC，但是连续的写入中完全串行的，前一轮发送accept，收集到多数回复OK确认后，下一轮才开始，即流程是“写入index1 -&gt; 确认index1 -&gt; 写入index2 -&gt; 确认index2”，pipeline的过程就是前一条日志确认之前就开始下一条，即流程变成“写入index1 -&gt; 写入index2 -&gt; 确认index1 -&gt; 确认index2”。</p><p>不过pipeline时要求两条日志是没什么关系的，如果后面的操作依赖前面完成后的结果，就不行了。而且，下一任proposer写入之前，待确认的日志可能就不止最后一条了，处理起来麻烦一些，这里就不展开了。</p><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>最后为了不标题党简单讲一下Raft。个人觉得Raft其实并不比Paxos容易理解，但是肯定比Paxos要易于实现，大体上可以认为Raft就是工程化之后的Multi-Paxos，二者类似图灵机和冯诺尹曼机的关系。</p><p>为啥Paxos不好实现呢？Google Chubby论文里也讲了很多了，主要原因就是Paxos本来就是偏理论的，没太考虑实现上的事情，更倾向于怎么让它更好证明。举个例子，Basic Paxos中第一阶段发出的proposal id如果过小，acceptor会直接抛弃消息，proposer在超时后增加proposal id并重试，当然此时可能还是过小。从工程化的视角出发，为了避免不必要的重试，让acceptor返回自己见过的最大proposal id显然是个好主意。而Paxos不这么干的原因也很简单：反正发消息也可能会丢失，而且不论怎样最终总能递增到一个合适的值，本质上是没有区别的。</p><p>Raft的重要特色就是工程化。这不仅在于其算法本身考虑到了很多实现层面的现实问题，例如节点长时间断连后如何快速追上进度，还在于它在达成共识日志的基础上实现了更为实用的<a href="https://zh.wikipedia.org/wiki/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6" target="_blank" rel="noopener">复制状态机</a>，并提供了几乎等同于伪代码程度的数据结构及算法描述。</p><p>我们还是把注意力聚焦在Raft算法如何生成达成共识的日志队列（Raft Log）。算法核心主要分成两个部分，Leader Election和Log Replication。</p><p>Raft节点在初始化时不指定角色，而是通过投票选举选出Leader，与Naive Raft类似，节点只会给term更大且含有更多日志的节点投票。因此，Leader Election也隐含了读取数据的过程，体现就是leader一定会出现在包含有最新已确认的日志的节点上。与之相比，Multi-Paxos的leader则没有这个限制，选leader只是为了减少冲突，不影响正确性。</p><p>在Log Replication阶段，Leader先把要追加的数据写入本地，然后再通过RPC同步给所有Follower，当收到大多数Follower的回复后，数据就写入成功了。与Multi-Paxos类似，只要不发生leader切换，整体上写入都是一阶段的。</p><p>相比于Multi-Paxos最大的差异是，Raft保证<strong>在每个节点上</strong>，如果第i个坑位的值是被确认的，那么第i个坑位之前的所有坑位就一定都是被确认的。也就是说，不用为每个坑位单独维护状态了，并且节点间通信的消息也简化了，大多数情况下只需要关心最后一个坑位。</p><p>有一种常见的质疑是说这个优化使得Raft无法“并行提交”。比如3个节点，写第一条记录时一个follower卡了一下，写第二条记录时另一个follower也卡住了，此时leader需要等其中一个follower把两条记录都补上，才能继续推进。而在Multi-Paxos中，是可以允许日志出现空洞的，即某一个follower可以把第一条记录先空着，直接确认第二条记录。不过，支持并行提交带来的优势是否值得为此付出的复杂度代价，也是个问题。况且，现实业务往往需要拿到全部日志再做决定，就说卖手机吧，如果之前的日志有空洞，就没法判断当前这个人是不是已经买过手机了。</p><p>Raft有个细节很多人都不理解，就是Raft中新leader选出来后，需要写一条空记录。实际上对照Multi-Paxos就清楚了，这无非就是Multi-Paxos中写入之前确认最后一条记录的过程嘛，只不过Multi-Paxos中是使用当前的proposal id去写旧值，在Raft里面，旧日志的Term无法改成新的，所以就用新Term提交一条空日志，这样顺带就把旧日志一并提交了。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>本文就到此为止了，还有更多高级主题，比如config change什么的因为我也不懂就打住不讲了。啥时候搞懂了可以再写写，嘿嘿嘿。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;分布式一致性协议把分布式的系统连接到了一起，就像蚁群有个统一的大脑一样，蚁群应该也有这种系统吧。&lt;/p&gt;
&lt;p&gt;除了Paxos，类似的算法还有Bully 算法 Zab算法&lt;/p&gt;
&lt;p&gt;文章来自网络，后续会补上自己的看法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="分布式一致性协议" scheme="http://yoursite.com/tags/分布式一致性协议/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://yoursite.com/2020/10/21/Docker/"/>
    <id>http://yoursite.com/2020/10/21/Docker/</id>
    <published>2020-10-21T12:05:07.000Z</published>
    <updated>2025-07-30T06:45:01.748Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>类比：</p><p>蓝色的大海： 宿主机系统（win mac linux）</p><p>鲸鱼：docker</p><p>集装箱：容器实例 from 我们的镜像模版</p></blockquote><a id="more"></a> <h1 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h1><h2 id="为什么会有docker出现"><a href="#为什么会有docker出现" class="headerlink" title="为什么会有docker出现"></a>为什么会有docker出现</h2><p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说吧，Java/Tomcat/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。 传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</p><blockquote><p>也就是 容器化部署环境，一个DockerFile，一次构建，四处部署。 和Java的虚拟机的思想有点类似。</p></blockquote><h2 id="Docker理念"><a href="#Docker理念" class="headerlink" title="Docker理念"></a>Docker理念</h2><p> Docker是基于Go语言实现的云开源项目。Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</p><blockquote><p>解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p></blockquote><h2 id="之前的虚拟机技术"><a href="#之前的虚拟机技术" class="headerlink" title="之前的虚拟机技术"></a>之前的虚拟机技术</h2><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。 虚拟机的缺点：</p><ol><li> 资源占用多        </li><li> 冗余步骤多         </li><li> 启动慢</li></ol><h2 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h2><p> 由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。 比较了 Docker 和传统虚拟化方式的不同之处：<em>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</em>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。* 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p><h2 id="开发-运维"><a href="#开发-运维" class="headerlink" title="开发/运维"></a>开发/运维</h2><h3 id="一次构建、随处运行"><a href="#一次构建、随处运行" class="headerlink" title="一次构建、随处运行"></a>一次构建、随处运行</h3><h4 id="更快速的应用交付和部署"><a href="#更快速的应用交付和部署" class="headerlink" title="更快速的应用交付和部署"></a>更快速的应用交付和部署</h4><p>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</p><h4 id="更便捷的升级和扩缩容"><a href="#更便捷的升级和扩缩容" class="headerlink" title="更便捷的升级和扩缩容"></a>更便捷的升级和扩缩容</h4><p>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</p><h4 id="更简单的系统运维"><a href="#更简单的系统运维" class="headerlink" title="更简单的系统运维"></a>更简单的系统运维</h4><p>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</p><h4 id="更高效的计算资源利用"><a href="#更高效的计算资源利用" class="headerlink" title="更高效的计算资源利用"></a>更高效的计算资源利用</h4><p>Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p><h3 id="Docker官网"><a href="#Docker官网" class="headerlink" title="Docker官网"></a>Docker官网</h3><p>docker官网：<a href="http://www.docker.com/" target="_blank" rel="noopener">http://www.docker.com</a></p><p>docker中文网站：<a href="https://www.docker-cn.com/" target="_blank" rel="noopener">https://www.docker-cn.com/</a></p><p>Docker Hub官网: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h1 id="Docker怎么用"><a href="#Docker怎么用" class="headerlink" title="Docker怎么用"></a>Docker怎么用</h1><h2 id="基本环境说明"><a href="#基本环境说明" class="headerlink" title="基本环境说明"></a>基本环境说明</h2><p>CentOS Docker 安装Docker支持以下的CentOS版本：<code>CentOS 7 (64-bit) CentOS 6.5 (64-bit)</code> 或更高的版本 前提条件目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。 查看自己的内核uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。 查看已安装的CentOS版本信息（CentOS6.8有，CentOS7无该命令）</p><h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><h3 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像     Image"></a>镜像     Image</h3><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 </p><h3 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器     Container"></a>容器     Container</h3><p>Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。 它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><h3 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库     Repository"></a>仓库     Repository</h3><p>仓库（Repository）是集中存放镜像文件的场所。仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)%EF%BC%8C%E5%AD%98%E6%94%BE%E4%BA%86%E6%95%B0%E9%87%8F%E5%BA%9E%E5%A4%A7%E7%9A%84%E9%95%9C%E5%83%8F%E4%BE%9B%E7%94%A8%E6%88%B7%E4%B8%8B%E8%BD%BD%E3%80%82%E5%9B%BD%E5%86%85%E7%9A%84%E5%85%AC%E5%BC%80%E4%BB%93%E5%BA%93%E5%8C%85%E6%8B%AC%E9%98%BF%E9%87%8C%E4%BA%91" target="_blank" rel="noopener">https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云</a> 、网易云 等</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>TODO</p><p>Mac 直接下载安装，后续有别的系统需要安装会补充</p><h1 id="简单原理"><a href="#简单原理" class="headerlink" title="简单原理"></a>简单原理</h1><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjx8j6cq9sj20fe07ndg0.jpg" alt="undefined"></p><p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是常说的集装箱。</p><h2 id="为什么Docker比普通虚拟机要快"><a href="#为什么Docker比普通虚拟机要快" class="headerlink" title="为什么Docker比普通虚拟机要快"></a>为什么Docker比普通虚拟机要快</h2><p>(1) docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。 </p><p>(2) docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。</p><h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><blockquote><p>docker version</p></blockquote><blockquote><p>docker info</p></blockquote><blockquote><p>docker –help</p></blockquote><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><blockquote><p>docker images</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">各个选项说明:</span><br><span class="line">    REPOSITORY：表示镜像的仓库源</span><br><span class="line">    TAG：镜像的标签</span><br><span class="line">    IMAGE ID：镜像ID</span><br><span class="line">    CREATED：镜像创建时间</span><br><span class="line">    SIZE：镜像大小 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a :列出本地所有的镜像（含中间映像层）</span><br><span class="line">-q :只显示镜像ID。</span><br><span class="line">--digests :显示镜像的摘要信息</span><br><span class="line">--no-trunc :显示完整的镜像信息</span><br></pre></td></tr></table></figure><blockquote><p>docker search 某个XXX镜像名字</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不配置镜像的话，从 https://hub.docker.com 上面下载镜像</span><br><span class="line"></span><br><span class="line">docker search [OPTIONS] 镜像名字</span><br><span class="line">OPTIONS说明：</span><br><span class="line">--no-trunc : 显示完整的镜像描述</span><br><span class="line">-s : 列出收藏数不小于指定值的镜像。</span><br><span class="line">--automated : 只列出 automated build类型的镜像；</span><br></pre></td></tr></table></figure><blockquote><p>docker pull 某个XXX镜像名字</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名字[:TAG]</span><br></pre></td></tr></table></figure><blockquote><p>docker rmi 某个XXX镜像名字ID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi  -f 镜像ID</span><br><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG </span><br><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>有镜像才能创建容器，这是根本前提</strong></p><blockquote><p>docker pull centos</p></blockquote><p>新建并启动容器</p><blockquote><p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS说明（常用）：</span><br><span class="line">有些是一个减号，有些是两个减号 </span><br><span class="line">--name=&quot;容器新名字&quot;: 为容器指定一个名称；</span><br><span class="line">-d: 后台运行容器，并返回容器ID，也即启动守护式容器；</span><br><span class="line">-i：以交互模式运行容器，通常与 </span><br><span class="line">-t 同时使用；-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">-P: 随机端口映射；-p: 指定端口映射，有以下四种格式      ip:hostPort:containerPort      ip::containerPort      hostPort:containerPort      containerPort</span><br></pre></td></tr></table></figure><p>#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。docker run -it centos /bin/bash </p><p>列出当前所有正在运行的容器</p><blockquote><p>docker ps [OPTIONS]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS说明（常用）： </span><br><span class="line">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line">-n：显示最近n个创建的容器。</span><br><span class="line">-q :静默模式，只显示容器编号。</span><br><span class="line">--no-trunc :不截断输出。</span><br></pre></td></tr></table></figure><p>退出容器</p><blockquote><p>exit</p></blockquote><blockquote><p>ctrl+P+Q (容器不停止退出)</p></blockquote><p>启动容器</p><blockquote><p>docker start 容器ID或者容器名</p></blockquote><p>重启容器</p><blockquote><p>docker restart 容器ID或者容器名</p></blockquote><p>停止容器</p><blockquote><p>docker stop 容器ID或者容器名</p></blockquote><p>强制停止容器</p><blockquote><p>docker kill 容器ID或者容器名</p></blockquote><p>删除已停止的容器</p><blockquote><p>docker rm 容器ID</p></blockquote><p>一次性删除多个容器</p><blockquote><p>docker rm -f $(docker ps -a -q)</p></blockquote><blockquote><p>docker ps -a -q | xargs docker rm</p></blockquote><p>停止所有容器</p><blockquote><p>docker stop $(docker ps -aq)</p></blockquote><p>删除所有容器</p><blockquote><p>docker rm $(docker ps -aq)</p></blockquote><p>删除所有镜像</p><blockquote><p>docker rmi $(docker images -q)</p></blockquote><h3 id="重要容器命令"><a href="#重要容器命令" class="headerlink" title="重要容器命令"></a>重要容器命令</h3><p>启动守护式容器</p><blockquote><p>docker run -d 容器名</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#使用镜像centos:latest以后台模式启动一个容器docker run -d centos 问题：然后docker ps -a 进行查看, 会发现容器已经退出很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。 这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如service nginx start但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行</span><br></pre></td></tr></table></figure><p>查看容器日志</p><blockquote><p>docker logs -f -t –tail 容器ID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-t 是加入时间戳</span><br><span class="line"></span><br><span class="line">-f 跟随最新的日志打印</span><br><span class="line"></span><br><span class="line">--tail 数字 显示最后多少条</span><br></pre></td></tr></table></figure><p>查看容器内运行的进程</p><blockquote><p>docker top 容器ID</p></blockquote><p>查看容器内部细节, 生成一个非常长的容器字符串</p><blockquote><p>docker inspect 容器ID</p></blockquote><p>进入正在运行的容器并以命令行交互</p><blockquote><p>docker exec -it 容器ID bashShell</p></blockquote><p>exec 是在容器中打开新的终端，并且可以启动新的进程</p><blockquote><p>重新进入docker attach 容器ID</p></blockquote><p>attach 直接进入容器启动命令的终端，不会启动新的进程</p><p>从容器内拷贝文件到主机上</p><blockquote><p>docker cp  容器ID:容器内路径 目的主机路径</p></blockquote><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">attach   Attach to a running container         # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line"></span><br><span class="line">build   Build an image from a Dockerfile        # 通过 Dockerfile 定制镜像</span><br><span class="line"></span><br><span class="line">commit   Create a new image from a container changes  # 提交当前容器为新的镜像</span><br><span class="line"></span><br><span class="line">cp     Copy files/folders from the containers filesystem to the host path  #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line"></span><br><span class="line">create   Create a new container             # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line"></span><br><span class="line">diff    Inspect changes on a container&apos;s filesystem  # 查看 docker 容器变化</span><br><span class="line"></span><br><span class="line">events   Get real time events from the server      # 从 docker 服务获取容器实时事件</span><br><span class="line"></span><br><span class="line">exec    Run a command in an existing container     # 在已存在的容器上运行命令</span><br><span class="line"></span><br><span class="line">export   Stream the contents of a container as a tar archive  # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line"></span><br><span class="line">history  Show the history of an image          # 展示一个镜像形成历史</span><br><span class="line"></span><br><span class="line">images   List images                  # 列出系统当前镜像</span><br><span class="line"></span><br><span class="line">import   Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line"></span><br><span class="line">info    Display system-wide information        # 显示系统相关信息</span><br><span class="line"></span><br><span class="line">inspect  Return low-level information on a container  # 查看容器详细信息</span><br><span class="line"></span><br><span class="line">kill    Kill a running container            # kill 指定 docker 容器</span><br><span class="line"></span><br><span class="line">load    Load an image from a tar archive        # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line"></span><br><span class="line">login   Register or Login to the docker registry server   # 注册或者登陆一个 docker 源服务器</span><br><span class="line"></span><br><span class="line">logout   Log out from a Docker registry server      # 从当前 Docker registry 退出</span><br><span class="line"></span><br><span class="line">logs    Fetch the logs of a container         # 输出当前容器日志信息</span><br><span class="line"></span><br><span class="line">port    Lookup the public-facing port which is NAT-ed to PRIVATE_PORT   # 查看映射端口对应的容器内部源端口</span><br><span class="line"></span><br><span class="line">pause   Pause all processes within a container     # 暂停容器</span><br><span class="line"></span><br><span class="line">ps     List containers                # 列出容器列表</span><br><span class="line"></span><br><span class="line">pull    Pull an image or a repository from the docker registry server  # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line"></span><br><span class="line">push    Push an image or a repository to the docker registry server   # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line"></span><br><span class="line">restart  Restart a running container          # 重启运行的容器</span><br><span class="line"></span><br><span class="line">rm     Remove one or more containers         # 移除一个或者多个容器</span><br><span class="line"></span><br><span class="line">rmi    Remove one or more images       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line"></span><br><span class="line">run    Run a command in a new container        # 创建一个新的容器并运行一个命令</span><br><span class="line"></span><br><span class="line">save    Save an image to a tar archive         # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class="line"></span><br><span class="line">search   Search for an image on the Docker Hub     # 在 docker hub 中搜索镜像</span><br><span class="line"></span><br><span class="line">start   Start a stopped containers           # 启动容器</span><br><span class="line"></span><br><span class="line">stop    Stop a running containers           # 停止容器</span><br><span class="line"></span><br><span class="line">tag    Tag an image into a repository         # 给源中镜像打标签</span><br><span class="line"></span><br><span class="line">top    Lookup the running processes of a container  # 查看容器中运行的进程信息</span><br><span class="line"></span><br><span class="line">unpause  Unpause a paused container           # 取消暂停容器</span><br><span class="line"></span><br><span class="line">version  Show the docker version information      # 查看 docker 版本号</span><br><span class="line"></span><br><span class="line">wait    Block until a container stops, then print its exit code  # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;类比：&lt;/p&gt;
&lt;p&gt;蓝色的大海： 宿主机系统（win mac linux）&lt;/p&gt;
&lt;p&gt;鲸鱼：docker&lt;/p&gt;
&lt;p&gt;集装箱：容器实例 from 我们的镜像模版&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Flink Advanced</title>
    <link href="http://yoursite.com/2020/10/21/Flink-Advanced/"/>
    <id>http://yoursite.com/2020/10/21/Flink-Advanced/</id>
    <published>2020-10-21T01:42:56.000Z</published>
    <updated>2025-07-30T06:45:22.394Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Flink进阶的知识点和文章整理</p></blockquote><a id="more"></a> <h1 id="Flink的应用场景"><a href="#Flink的应用场景" class="headerlink" title="Flink的应用场景"></a>Flink的应用场景</h1><p>前段时间被人问了一个很简单的问题，那就是Flink应该使用在什么应用场景下</p><p>乍一听很简单的问题，我却没法提供让我自己满意的回答，只是说需要用到实时计算的地方都刻意用Flink，表述的不够明确，OK，这边有空来用专业的术语和详细的例子总结一下</p><ul><li>事件驱动型应用</li><li>数据分析型应用</li><li>数据管道型应用</li></ul><h2 id="事件驱动型应用场景"><a href="#事件驱动型应用场景" class="headerlink" title="事件驱动型应用场景"></a>事件驱动型应用场景</h2><h3 id="社交领域"><a href="#社交领域" class="headerlink" title="社交领域"></a>社交领域</h3><p>比如在twitter上，我们点击关注某人，点击之后，点击作为一个事件，以数据的方式被接受计算，被关注者的粉丝数量+1，关注者的关注数量+1，两个数据收到了影响，这个就叫事件驱动型应用。</p><h3 id="电商"><a href="#电商" class="headerlink" title="电商"></a>电商</h3><p>当刷单者疯狂买东西然后每天给很多个好评，持续很多天的时候，这个事件作为一条数据被抛出警告，提醒淘宝平台这个账号有问题，可能在刷单，这也是事件驱动。</p><p>如果某个商家收到来自不同用户的大量投诉，那么可能是店出现了问题，同样提醒淘宝平台。</p><p>在淘宝的推荐系统中</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkoqzw3ghyj20u30guk85.jpg" alt="微信截图_20201114154629.png"></p><p>购买东西作为事件，可以看到会实时触发淘宝的推荐系统进行类似推荐。</p><h3 id="金融行业"><a href="#金融行业" class="headerlink" title="金融行业"></a>金融行业</h3><p>比如说，有人在银行ATM机里面通过摄像头被算法识别到遮挡面部或者遮挡摄像头等特征的时候，会触发一些事件，比如说通知安保人员等等。</p><blockquote><p>事件驱动型应用是一类具有<strong>状态</strong>的应用，该应用会根据事件流中的时间触发计算，更新状态或进行外部系统操作。事件驱动型应用常见于实时计算业务中，比如上面的：实时推荐系统，金融反欺诈系统，实时规则预警系统等。</p></blockquote><p>上述的这种场景毫无疑问是优先于Flink出现而出现的，那么我们来看一下原来我们是如何解决这些问题的</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkoyk15s9qj20zg0hst9j.jpg" alt="微信截图_20201114200806.png"></p><p>这个是我们最开始的解决此类问题的架构</p><p>对于一些数据规模是很大，实时性要求不是很高的场景来说，效果是很好的，但是随着数量的不断增加，尤其是数据爆炸时代背景下的海量数据，以关系型数据为例，这里我们需要使用分库分表的方式来支持海量数据，这种方式由于数据库的各种限制，比如说事务一致性的控制，数据备份机制，全局索引等等数据库的实际的架构方面的原因，随着数据量的增加，写入和查询的性能会受到很大的挑战，尤其在实时性要求更高的场景，我们需要更优秀的架构。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkozw4iza2j215l0g6q3y.jpg" alt="微信截图_20201114205428.png"></p><p>这个是引入了Flink之后的架构，在一个完整的时间驱动型架构中往往会涉及到已有数据实体的存储，实体之间关系的维护，统计报表的持久化等需求，所以我们在这个架构中仍然需要用到传统关系型数据库，那么在这个架构中，触发计算的部分，我们交给Apache Flink处理，计算结果既可以存储到支持海量数据的Hadoop生态中的HDFS上，我们也可以将计算结果和统计信息存储在传统数据库中供实时查询。</p><p>那么这种解决方案有什么优势呢？</p><p><strong>实时性</strong>。为了数据价值最大化，从上面的场景中，我们可以很明显的体会到数据实时反馈的重要性，Flink为了实时计算处理，进行了针对实时流计算的定制特性，比如丰富的状态支持，多窗口语义支持，灵活的Timer和Trigger机制，强大的CEP机制等等等，同时进行了大量的性能优化，这里限于篇幅不能一一列举，后面有机会会再介绍。</p><h2 id="数据分析型应用"><a href="#数据分析型应用" class="headerlink" title="数据分析型应用"></a>数据分析型应用</h2><p>So，怎样的应用才是数据分析型应用呢？</p><p>数据分析型应用是一个非常宽泛的范围，凡是数据分析型应用都是<strong>从原始数据中提取有价值的信息和指标</strong>。</p><p>传统的数据分析方案是一次查询，获得一次查询 获得一次结果，为了实现始终得到最新的结果，需要自己定义触发器（到了某个设定的条件，自动执行查询）也就是我们说的Batch方式的查询方式。</p><p>而得益于Timer和State的支持，Flink能够持续查询，Flink的Timer能够持续触发计算，State能够保存上次结果增加计算，一次查询能够源源不断的获得最新的结果。</p><p>为了体现Flink的优秀性能，我举一些特定例子</p><p>比如说，几乎要求零延迟的天猫/京东双十一大屏</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkp3n2m556j20d805qgtj.jpg" alt="微信截图_20201114230411.png"></p><p>这个统计结果几乎是要求零延迟展示给大家的，现在几家巨头电商的双十一计算逻辑都是在Flink中实现的，侧面验证了Flink在快和处理数据量巨大这两点上的可靠性。</p><p>实际上更多的业务可能既既是事件驱动型应用又是数据分析型应用，如果一定要定义这两种区别的话，我们可以从处理目的上来定义，事件驱动型应用是数据最后会直接派发新动作，比如上面的ATM应用检测到不正常动作就触发报警。而数据分析我们只是产生数据，让决策者根据结果数据为现实事件做决定。</p><h2 id="数据管道型应用"><a href="#数据管道型应用" class="headerlink" title="数据管道型应用"></a>数据管道型应用</h2><p>我们在采集数据的时候往往会根据数据的特性（数据量的大小，数据的结构）采用不同的数据库来存储数据，但是我们在使用数据的时候如果需要进行流处理，那么我们要针对不用的数据库开发的数据库开发上面所述的不同的触发器，大大增加开发成本。</p><p>现在Flink已经集成了CDC功能，正在完善对各个流行的数据库的解析模块，随着时间的推移，最后会成为一个完美的数据管道。</p><h2 id="流处理的历史"><a href="#流处理的历史" class="headerlink" title="流处理的历史"></a>流处理的历史</h2><p>这里把流处理的历史放在了第二部分，上面花了相当的篇幅来描述了什么是Flink(流处理)，先弄懂了这个，然后再介绍历史，应该会好一些。</p><p>为了同时获得准确性和低延迟，为了让当时的数据处理系统，可以同时提供快速和准确的结果，人们设计了所谓的lambda架构。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl83jzfn69j20l507utah.jpg" alt="undefined"></p><p>lambda架构增强了传统的批处理架构，其“快速层”（speed layer）由低延迟的流处理器来支持。数据到达之后由流处理器提取出来，并写入批处理存储。流处理器近乎实时地计算近似结果并将它们写入“快速表”（speed table）。批处理器定期处理批量存储中的数据，将准确的结果写入批处理表，并从速度表中删除相应的不准确结果。应用程序会合并快速表中的近似结果和批处理表中的准确结果，然后消费最终的结果。</p><p>lambda架构现在已经不再是最先进的，但仍在许多地方使用。该体系结构的最初目标是改善原始批处理分析体系结构的高延迟。但是，它有一些明显的缺点。首先，它需要对一个应用程序，做出两个语义上等效的逻辑实现，用于两个独立的、具有不同API的处理系统。其次，流处理器计算的结果只是近似的。第三，lambda架构很难建立和维护。</p><p>通过在第一代基础上进行改进，下一代分布式开源流处理器（2013）提供了更好的故障保证，并确保在发生故障时，每个输入记录仅对结果产生一次影响（exactly -once）。此外，编程API从相当低级的操作符接口演变为高级API。但是，一些改进（例如更高的吞吐量和更好的故障保证）是以将处理延迟从毫秒增加到几秒为代价的。此外，结果仍然取决于到达事件的时间和顺序。</p><p>第三代分布式开源流处理器（2015）解决了结果对到达事件的时间和顺序的依赖性。结合精确一次（exactly-once）的故障语义，这一代系统是第一个具有计算一致性和准确结果的开源流处理器。通过基于实际数据来计算结果（“重演”数据），这些系统还能够以与“实时”数据相同的方式处理历史数据。另一个改进是解决了延迟/吞吐量无法同时保证的问题。先前的流处理器仅能提供高吞吐量或者低延迟（其中之一），而第三代系统能够同时提供这两个特性。这一代的流处理器使得lambda架构过时了。当然，这一代流处理以flink为代表。</p><p>除了目前讨论的特性，例如容错、性能和结果准确性之外，流处理器还不断添加新的操作功能，例如高可用性设置，与资源管理器（如YARN或Kubernetes）的紧密集成，以及能够动态扩展流应用程序。其他功能包括：支持升级应用程序代码，或将作业迁移到其他群集或新版本的流处理器，而不会丢失当前状态。</p><h1 id="Flink基础：流处理基础"><a href="#Flink基础：流处理基础" class="headerlink" title="Flink基础：流处理基础"></a>Flink基础：流处理基础</h1><h2 id="数据流编程简介"><a href="#数据流编程简介" class="headerlink" title="数据流编程简介"></a>数据流编程简介</h2><h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><p>之前做了一个纯Java分析项目，大大加深了我对流处理的认识，只要是流处理，总是会包含的一些特性 ==&gt; 我们把这些特性称之为流处理特性。</p><p>顾名思义，<strong>数据流程序</strong>描述了数据如何在算子之间流动。数据流程序通常表示为有向图，其中<strong>节点称为算子</strong>，<strong>用来表示计算，边表示数据之间的依赖性</strong>。算子是数据流程序的基本功能单元。他们从输入消耗数据，对它们执行计算，并生成数据输出用于进一步处理。一个数据流图必须至少有一个数据源和一个数据接收器。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl83x00h4bj20l904ign3.jpg" alt="undefined"></p><p>上面的图只能叫逻辑流图，没有考虑在实际执行过程中的物理机的问题，下面是物理数据流图</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl840jvc7zj20l6080di4.jpg" alt="undefined"></p><p>在物理数据流图中，节点是任务。“Extract hashtags”和“Count”算子有两个并行算子任务，每个算子任务对输入数据的子集执行计算。</p><h3 id="数据并行与任务并行"><a href="#数据并行与任务并行" class="headerlink" title="数据并行与任务并行"></a>数据并行与任务并行</h3><p>我们可以以不同方式利用数据流图中的并行性。第一，我们可以<strong>对输入数据进行分区，并在数据的子集上并行执行具有相同算子的任务并行</strong>。这种类型的并行性被称为<strong>数据并行性</strong>。数据并行是有用的，因为它允许处理大量数据，并将计算分散到不同的计算节点上。第二，<strong>我们可以将不同的算子在相同或不同的数据上并行执行</strong>。这种并行性称为任务并行性。使用<strong>任务并行性</strong>，我们可以更好地利用计算资源。</p><h3 id="数据交换策略"><a href="#数据交换策略" class="headerlink" title="数据交换策略"></a>数据交换策略</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl84e3gozaj20lg0dfwhb.jpg" alt="undefined"></p><ul><li><strong>前向策略</strong>将数据从一个任务发送到接收任务。如果两个任务都位于同一台物理计算机上（这通常由任务调度器确保），这种交换策略可以避免网络通信。</li><li><strong>广播策略</strong>将所有数据发送到算子的所有的并行任务上面去。因为这种策略会复制数据和涉及网络通信，所以代价相当昂贵。</li><li><strong>基于键控的策略</strong>通过Key值(键)对数据进行分区保证具有相同Key的数据将由同一任务处理。在图2-2中，输出“Extract hashtags”算子使用键来分区（hashtag），以便count算子的任务可以正确计算每个#标签的出现次数。</li><li><strong>随机策略</strong>统一将数据分配到算子的任务中去，以便均匀地将负载分配到不同的计算任务。</li></ul><h2 id="并行处理流数据"><a href="#并行处理流数据" class="headerlink" title="并行处理流数据"></a>并行处理流数据</h2><p>首先，让我们定义术语数据流：<strong>数据流是一个可能无限的事件序列。</strong></p><p>数据流中的事件可以表示监控数据，传感器测量数据，信用卡交易数据，气象站观测数据，在线用户交互数据，网络搜索数据等。在本节中，我们将学习如何并行处理无限流，使用数据流编程范式。</p><h3 id="延迟和吞吐量"><a href="#延迟和吞吐量" class="headerlink" title="延迟和吞吐量"></a>延迟和吞吐量</h3><p>流处理程序不同与批处理程序。在评估性能时，要求也有所不同。对于批处理程序，我们通常关心一个作业的总的执行时间，或我们的处理引擎读取输入所需的时间，执行计算，并回写结果。由于流处理程序是连续运行的，输入可能是无界的，所以数据流处理中没有总执行时间的概念。 相反，流处理程序必须尽可能快的提供输入ew数据的计算结果。我们使用延迟和吞吐量来表征流处理的性能要求。</p><h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><p><strong>延迟表示处理事件所需的时间</strong>。</p><p>在数据流中，延迟是以时间为单位测量的，例如毫秒。根据应用程序，我们可能会关心平均延迟，最大延迟或百分位延迟。例如，平均延迟值为10ms意味着处理事件的平均时间在10毫秒内。或者，延迟值为95%，10ms表示95%的事件在10ms内处理完毕。平均值隐藏了处理延迟的真实分布，可能会让人难以发现问题。</p><p>确保低延迟对于许多流应用程序来说至关重要，例如欺诈检测，系统警报，网络监控和提供具有严格服务水平协议的服务。低延迟是流处理的关键特性，它实现了我们所谓的实时应用程序。像Apache Flink这样的现代流处理器可以提供低至几毫秒的延迟。</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p><strong>吞吐量是衡量系统处理能力的指标，也就是处理速率。</strong></p><h2 id="数据流上的操作"><a href="#数据流上的操作" class="headerlink" title="数据流上的操作"></a>数据流上的操作</h2><p>流处理引擎通畅提供的一组内置操作：                                                                                                                                                                                                                                                           </p><p><strong>摄取(ingest)，转换(transform)和输出流(output)</strong></p><p>操作可以是无状态的或有状态的。无状态操作不保持任何内部状态。也就是说，事件的处理不依赖于过去看到的任何事件，也没有保留历史。 无状态操作很容易并行化，因为事件可以彼此独立地处理，也独立于事件到达的顺序(和事件到达顺序没有关系)。 而且，在失败的情况下，无状态操作可以是简单的重新启动并从中断处继续处理。相反， 有状态操作可能会维护之前收到的事件的信息。此状态可以通过传入事件更新，也可以用于未来事件的处理逻辑。有状态的流 处理应用程序更难以并行化和以容错的方式来运行，因为状态需要有效的进行分区和在发生故障的情况下可靠地恢复。</p><h3 id="数据摄入和数据吞吐量"><a href="#数据摄入和数据吞吐量" class="headerlink" title="数据摄入和数据吞吐量"></a>数据摄入和数据吞吐量</h3><p>数据摄取和数据出口操作允许流处理程序与外部系统通信。数据摄取是操作从外部源获取原始数据并将其转换为其他格式(ETL)。实现数据提取逻辑的运算符被称为数据源。数据源可以从TCP Socket，文件，Kafka Topic或传感器数据接口中提取数据。数据出口是以适合消费的形式产出到外部系统。执行数据出口的运算符称为数据接收器，包括文件，数据库，消息队列和监控接口。</p><h3 id="转换算子"><a href="#转换算子" class="headerlink" title="转换算子"></a>转换算子</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl84so9twij20sv05a74j.jpg" alt="undefined"></p><p>转换算子是单遍处理算子，碰到一个事件处理一个事件。这些操作在使用后会消费一个事件，然后对事件数据做一些转换，产生一个新的输出流。转换逻辑可以集成在 操作符中或由UDF函数提供。</p><p>操作符可以接受多个输入流并产生多个输出流。他们还可以通过修改数据流图的结构要么将流分成多个流，要么将流合并为一条流。</p><h3 id="滚动聚合"><a href="#滚动聚合" class="headerlink" title="滚动聚合"></a>滚动聚合</h3><p>滚动聚合是一种聚合，例如sum，minimum和maximum，为每个输入事件不断更新。 聚合操作是有状态的，并将当前状态与传入事件一起计算以产生更新的聚合值。请注意能够有效地将当前状态与事件相结合 产生单个值，聚合函数必须是关联的和可交换的。否则，操作符必须存储完整的流数据历史。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl84v84umrj20jt0cgq3o.jpg" alt="undefined"></p><h3 id="窗口操作符"><a href="#窗口操作符" class="headerlink" title="窗口操作符"></a>窗口操作符</h3><p>转换和滚动聚合一次处理一个事件产生输出事件并可能更新状态。但是，有些操作必须收集并缓冲数据以计算其结果。 例如，考虑不同流之间的连接或整体聚合这样的操作，例如中值函数。为了在无界流上高效运行这些操作符，我们需要限制 这些操作维护的数据量。在本节中，我们将讨论窗口操作，提供此服务。</p><p>窗口还可以在语义上实现关于流的比较复杂的查询。我们已经看到了滚动聚合的方式，以聚合值编码整个流的历史数据来为每个事件提供低延迟的结果。 但如果我们只对最近的数据感兴趣的话会怎样？考虑给司机提供实时交通信息的应用程序。这个程序可以使他们避免拥挤的路线。在这种场景下，你想知道某个位置在最近几分钟内是否有事故发生。 另一方面，了解所有发生过的事故在这个应用场景下并没有什么卵用。更重要的是，通过将流历史缩减为单一聚合值，我们将丢失这段时间内数据的变化。例如，我们可能想知道每5分钟有多少车辆穿过 某个路口。</p><p><strong>窗口操作不断从无限事件流中创建有限的事件集</strong>，好让我们执行有限集的计算。通常会基于数据属性或基于时间的窗口来分配事件。 要正确定义窗口运算符语义，我们需要确定如何给窗口分配事件以及对窗口中的元素进行求值的频率是什么样的。 窗口的行为由一组策略定义。窗口策略决定何时创建新的窗口以及要分配的事件属于哪个窗口，以及何时对窗口中的元素进行求值。 而窗口的求值基于触发条件。一旦触发条件得到满足，窗口的内容将会被发送到求值函数，求值函数会将计算逻辑应用于窗口中的元素。 求值函数可以是sum或minimal或自定义的聚合函数。 求值策略可以根据时间或者数据属性计算(例如，在过去五秒内收到的事件或者最近的一百个事件等等)。 接下来，我们描述常见窗口类型的语义。</p><ul><li>滚动窗口是将事件分配到固定大小的不重叠的窗口中。当通过窗口的结尾时，全部事件被发送到求值函数进行处理。基于计数的滚动窗口定义了在触发求值之前需要收集多少事件。下图显示了一个基于计数的翻滚窗口，每四个元素一个窗口。基于时间的滚动窗口定义一个时间间隔，包含在此时间间隔内的事件。下下图显示了基于时间的滚动窗口，将事件收集到窗口中每10分钟触发一次计算。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl853ixg14j20xl06v3yq.jpg" alt="undefined"></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl853p56uoj20z007yjrn.jpg" alt="undefined"></p><ul><li>滑动窗口将事件分配到固定大小的重叠的窗口中去。因此，事件可能属于多个桶。我们通过提供窗口的长度和滑动距离来定义滑动窗口。滑动距离定义了创建新窗口的间隔。基于滑动计数的窗口，下图长度为四个事件，三个为滑动距离。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl855xhdfdj20vz08h0st.jpg" alt="undefined"></p><ul><li>会话窗口在常见的真实场景中很有用，一些场景既不能使用滚动窗口也不能使用滑动窗口。考虑一个分析在线用户行为的应用程序。在应用程序里，我们想把源自同一时期的用户活动或会话事件分组在一起。会话由一系列相邻时间发生的事件组成，接下来有一段时间没有活动。例如，用户在App上浏览一系列的新闻，然后关掉App，那么浏览新闻这段时间的浏览事件就是一个会话。会话窗口事先没有定义窗口的长度，而是取决于数据的实际情况，滚动窗口和滑动窗口无法应用于这个场景。相反，我们需要将同一会话中的事件分配到同一个窗口中去，而不同的会话可能窗口长度不一样。会话窗口会定义一个间隙值来区分不同的会话。间隙值的意思是：用户一段时间内不活动，就认为用户的会话结束了。下图显示了一个会话窗口。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl856ykspxj20zb06zdg1.jpg" alt="undefined"></p><p>到目前为止，所有窗口类型都是在整条流上去做窗口操作。但实际上你可能想要将一条流分流成多个逻辑流并定义并行窗口。 例如，如果我们正在接收来自不同传感器的测量结果，那么可能想要在做窗口计算之前按传感器ID对流进行分流操作。 在并行窗口中，每条流都独立于其他流，然后应用了窗口逻辑。下图显示了一个基于计数的长度为2的并行滚动窗口，根据事件颜色分流。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl858l5xs9j20to0c80t6.jpg" alt="undefined"></p><p>在流处理中，窗口操作与两个主要概念密切相关：时间语义和状态管理。时间也许是流处理最重要的方面。即使低延迟是流处理的一个有吸引力的特性，它的真正价值不仅仅是快速分析。真实世界的系统，网络和通信渠道远非完美，流数据经常被推迟或无序(乱序)到达。理解如何在这种条件下提供准确和确定的结果是至关重要的。 更重要的是，流处理程序可以按原样处理事件制作的也应该能够处理相同的历史事件方式，从而实现离线分析甚至时间旅行分析。 当然，前提是我们的系统可以保存状态，因为可能有故障发生。到目前为止，我们看到的所有窗口类型在产生结果前都需要保存之前的数据。实际上，如果我们想计算任何指标，即使是简单的计数，我们也需要保存状态。考虑到流处理程序可能会运行几天，几个月甚至几年，我们需要确保状态可以在发生故障的情况下可靠地恢复。 并且即使程序崩溃，我们的系统也能保证计算出准确的结果。本章，我们将在流处理应用可能发生故障的语境下，深入探讨时间和状态的概念。</p><h2 id="时间语义"><a href="#时间语义" class="headerlink" title="时间语义"></a>时间语义</h2><h3 id="在流处理中一分钟代表什么？"><a href="#在流处理中一分钟代表什么？" class="headerlink" title="在流处理中一分钟代表什么？"></a>在流处理中一分钟代表什么？</h3><p>在处理可能是无限的事件流（包含了连续到达的事件），时间成为流处理程序的核心方面。假设我们想要连续的计算结果，可能每分钟就要计算一次。在我们的流处理程序上下文中，一分钟的意思是什么？</p><p>考虑一个程序需要分析一款移动端的在线游戏的用户所产生的事件流。游戏中的用户分了组，而应用程序将收集每个小组的活动数据，基于小组中的成员多快达到了游戏设定的目标，然后在游戏中提供奖励。例如额外的生命和用户升级。例如，如果一个小组中的所有用户在一分钟之内都弹出了500个泡泡，他们将升一级。Alice是一个勤奋的玩家，她在每天早晨的通勤时间玩游戏。问题在于Alice住在柏林，并且乘地铁去上班。而柏林的地铁手机信号很差。我们设想一个这样的场景，Alice当她的手机连上网时，开始弹泡泡，然后游戏会将数据发送到我们编写的应用程序中，这时地铁突然进入了隧道，她的手机也断网了。Alice还在玩这个游戏，而产生的事件将会缓存在手机中。当地铁离开隧道，Alice的手机又在线了，而手机中缓存的游戏事件将发送到应用程序。我们的应用程序应该如何处理这些数据？在这个场景中一分钟的意思是什么？这个一分钟应该包含Alice离线的那段时间吗？下图展示了这个问题。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl85ano45xj20pr0fbjsg.jpg" alt="undefined"></p><p>在线手游是一个简单的场景，展示了应用程序的运算应该取决于事件实际发生的时间，而不是应用程序收到事件的时间。如果我们按照应用程序收到事件的时间来进行处理的话，最糟糕的后果就是，Alice和她的朋友们再也不玩这个游戏了。但是还有很多时间语义非常关键的应用程序，我们需要保证时间语义的正确性。如果我们只考虑我们在一分钟之内收到了多少数据，我们的结果会变化，因为结果取决于网络连接的速度或处理的速度。相反，定义一分钟之内的事件数量，这个一分钟应该是数据本身的时间。</p><p>在Alice的这个例子中，流处理程序可能会碰到两个不同的时间概念：处理时间和事件时间。我们将在接下来的部分，讨论这两个概念。</p><h3 id="处理时间"><a href="#处理时间" class="headerlink" title="处理时间"></a>处理时间</h3><p>处理时间是处理流的应用程序的机器的本地时钟的时间（墙上时钟）。处理时间的窗口包含了一个时间段内来到机器的所有事件。这个时间段指的是机器的墙上时钟。如下图所示，在Alice的这个例子中，处理时间窗口在Alice的手机离线的情况下，时间将会继续行走。但这个处理时间窗口将不会收集Alice的手机离线时产生的事件。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl85e0dlv9j20pq0g8jsi.jpg" alt="undefined"></p><h3 id="事件时间"><a href="#事件时间" class="headerlink" title="事件时间"></a>事件时间</h3><p>　　事件时间是流中的事件实际发生的时间。事件时间基于流中的事件所包含的时间戳。通常情况下，在事件进入流处理程序前，事件数据就已经包含了时间戳。下图展示了事件时间窗口将会正确的将事件分发到窗口中去。可以如实反应事情是怎么发生的。即使事件可能存在延迟。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl85efcaw7j20pq0g80tu.jpg" alt="undefined"></p><p>​        事件时间使得计算结果的过程不需要依赖处理数据的速度。基于事件时间的操作是可以预测的，而计算结果也是确定的。无论流处理程序处理流数据的速度快或是慢，无论事件到达流处理程序的速度快或是慢，事件时间窗口的计算结果都是一样的。</p><p>　　可以处理迟到的事件只是我们使用事件时间所克服的一个挑战而已。普遍存在的事件乱序问题可以使用事件时间得到解决。考虑和Alice玩同样游戏的Bob，他恰好和Alice在同一趟地铁上。Alice和Bob虽然玩的游戏一样，但他们的手机信号是不同的运营商提供的。当Alice的手机没信号时，Bob的手机依然有信号，游戏数据可以正常发送出去。</p><p>　　如果使用事件时间，即使碰到了事件乱序到达的情况，我们也可以保证结果的正确性。还有，当我们在处理可以重播的流数据时，由于时间戳的确定性，我们可以快进过去。也就是说，我们可以重播一条流，然后分析历史数据，就好像流中的事件是实时发生一样。另外，我们可以快进历史数据来使我们的应用程序追上现在的事件，然后应用程序仍然是一个实时处理程序，而且业务逻辑不需要改变。</p><h3 id="水位线"><a href="#水位线" class="headerlink" title="水位线"></a>水位线</h3><p>　　在我们对事件时间窗口的讨论中，我们忽略了一个很重要的方面：<strong>我们应该怎样去决定何时触发事件时间窗口的计算</strong>？也就是说，在我们可以确定一个时间点之前的所有事件都已经到达之前，我们需要等待多久？我们如何知道事件是迟到的？在分布式系统无法准确预测行为的现实条件下，以及外部组件所引发的事件的延迟，以上问题并没有准确的答案。在本小节中，我们将会看到如何使用水位线来设置事件时间窗口的行为。</p><p>　　水位线是全局进度的度量标准。系统可以确信在一个时间点之后，不会有早于这个时间点发生的事件到来了。本质上，水位线提供了一个逻辑时钟，这个逻辑时钟告诉系统当前的事件时间。当一个运算符接收到含有时间T的水位线时，这个运算符会认为早于时间T的发生的事件已经全部都到达了。对于事件时间窗口和乱序事件的处理，水位线非常重要。运算符一旦接收到水位线，运算符会认为一段时间内发生的所有事件都已经观察到，可以触发针对这段时间内所有事件的计算了。</p><p>　　水位线提供了一种结果可信度和延时之间的妥协。激进的水位线设置可以保证低延迟，但结果的准确性不够。在这种情况下，迟到的事件有可能晚于水位线到达，我们需要编写一些代码来处理迟到事件。另一方面，如果水位线设置的过于宽松，计算的结果准确性会很高，但可能会增加流处理程序不必要的延时。</p><p>　　在很多真实世界的场景里面，系统无法获得足够的知识来完美的确定水位线。在手游这个场景中，我们无法得知一个用户离线时间会有多长，他们可能正在穿越一条隧道，可能正在乘飞机，可能永远不会再玩儿了。水位线无论是用户自定义的或者是自动生成的，在一个分布式系统中追踪全局的时间进度都不是很容易。所以仅仅依靠水位线可能并不是一个很好的主意。流处理系统还需要提供一些机制来处理迟到的元素（在水位线之后到达的事件）。根据应用场景，我们可能需要把迟到事件丢弃掉，或者写到日志里，或者使用迟到事件来更新之前已经计算好的结果。</p><h3 id="处理时间和事件时间"><a href="#处理时间和事件时间" class="headerlink" title="处理时间和事件时间"></a>处理时间和事件时间</h3><p>　　大家可能会有疑问，既然事件时间已经可以解决我们的所有问题，为什么我们还要对比这两个时间概念？真相是，处理时间在很多情况下依然很有用。处理时间窗口将会带来理论上最低的延迟。因为我们不需要考虑迟到事件以及乱序事件，所以一个窗口只需要简单的缓存窗口内的数据即可，一旦机器时间超过指定的处理时间窗口的结束时间，就会触发窗口的计算。所以对于一些处理速度比结果准确性更重要的流处理程序，处理时间就派上用场了。另一个应用场景是，当我们需要在真实的时间场景下，周期性的报告结果时，同时不考虑结果的准确性。一个例子就是一个实时监控的仪表盘，负责显示当事件到达时立即聚合的结果。最后，处理时间窗口可以提供流本身数据的忠实表达，对于一些案例可能是很必要的特性。例如我们可能对观察流和对每分钟事件的计数（检测可能存在的停电状况）很感兴趣。简单的说，处理时间提供了低延迟，同时结果也取决于处理速度，并且也不能保证确定性。另一方面，事件时间保证了结果的确定性，同时还可以使我们能够处理迟到的或者乱序的事件流。</p><h2 id="状态和持久化模型"><a href="#状态和持久化模型" class="headerlink" title="状态和持久化模型"></a>状态和持久化模型</h2><p>我们现在转向另一个对于流处理程序非常重要的话题：状态。在数据处理中，状态是普遍存在的。任何稍微复杂一点的计算，都涉及到状态。为了产生计算结果，一个函数在一段时间内的一定数量的事件上来累加状态（例如，聚合计算或者模式匹配）。有状态的运算符使用输入的事件以及内部保存的状态来计算得到输出。例如，一个滚动聚合运算符需要输出这个运算符所观察到的所有事件的累加和。这个运算符将会在内部保存当前观察到的所有事件的累加和，同时每输入一个事件就更新一次累加和的计算结果。相似的，当一个运算符检测到一个“高温”事件紧接着十分钟以内检测到一个“烟雾”事件时，将会报警。直到运算符观察到一个“烟雾”事件或者十分钟的时间段已经过去，这个运算符需要在内部状态中一直保存着“高温”事件。</p><p>当我们考虑一下使用批处理系统来分析一个无界数据集时，会发现状态的重要性显而易见。在现代流处理器兴起之前，处理无界数据集的一个通常做法是将输入的事件攒成微批，然后交由批处理器来处理。当一个任务结束时，计算结果将被持久化，而所有的运算符状态就丢失了。一旦一个任务在计算下一个微批次的数据时，这个任务是无法访问上一个任务的状态的（都丢掉了）。这个问题通常使用将状态代理到外部系统（例如数据库）的方法来解决。相反，在一个连续不间断运行的流处理任务中，事件的状态是一直存在的，我们可以将状态暴露出来作为编程模型中的一等公民。当然，我们的确可以使用外部系统来管理流的状态，即使这个解决方案会带来额外的延迟。</p><p>由于流处理运算符默认处理的是无界数据流。所以我们必须要注意不要让内部状态无限的增长。为了限制状态的大小，运算符通常情况下会保存一些之前所观察到的事件流的总结或者概要。这个总结可能是一个计数值，一个累加和，或者事件流的采样，窗口的缓存操作，或者是一个自定义的数据结构，这个数据结构用来保存数据流中感兴趣的一些特性。</p><p>我们可以想象的到，支持有状态的运算符可能会碰到一些实现上的挑战：</p><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>系统需要高效的管理状态，并保证针对状态的并发更新，不会产生竞争条件（race condition）。</p><h3 id="状态分区"><a href="#状态分区" class="headerlink" title="状态分区"></a>状态分区</h3><p>并行会带来复杂性。因为计算结果同时取决于已经保存的状态和输入的事件流。幸运的是，大多数情况下，我们可以使用Key来对状态进行分区，然后独立的管理每一个分区。例如，当我们处理一组传感器的测量事件流时，我们可以使用分区的运算符状态来针对不同的传感器独立的保存状态。</p><h3 id="状态恢复"><a href="#状态恢复" class="headerlink" title="状态恢复"></a>状态恢复</h3><p>第三个挑战是有状态的运算符如何保证状态可以恢复，即使出现任务失败的情况，计算也是正确的。</p><h3 id="任务失败"><a href="#任务失败" class="headerlink" title="任务失败"></a>任务失败</h3><p>流任务中的运算符状态是很宝贵的，也需要抵御任务失败带来的问题。如果在任务失败的情况下，状态丢失的话，在任务恢复以后计算的结果将是不正确的。流任务会连续不断的运行很长时间，而状态可能已经收集了几天甚至几个月。在失败的情况下，重新处理所有的输入并重新生成一个丢失的状态，将会很浪费时间，开销也很大。</p><h4 id="什么是任务失败？"><a href="#什么是任务失败？" class="headerlink" title="什么是任务失败？"></a>什么是任务失败？</h4><p>　　对于流中的每一个事件，一个处理任务分为以下步骤：</p><p>　　（1）接收事件，并将事件存储在本地的缓存中；</p><p>　　（2）可能会更新内部状态；</p><p>　　（3）产生输出记录。这些步骤都能失败，而系统必须对于在失败的场景下如何处理有清晰的定义。如果任务在第一步就失败了，事件会丢失吗？如果当更新内部状态的时候任务失败，那么内部状态会在任务恢复以后更新吗？在以上这些场景中，输出是确定性的吗？</p><p>　　在批处理场景下，所有的问题都不是问题。因为我们可以很方便的重新计算。所以不会有事件丢失，状态也可以得到完全恢复。在流的世界里，处理失败不是一个小问题。流系统在失败的情况下需要保证结果的准确性。接下来，我们需要看一下现代流处理系统所提供的一些保障，以及实现这些保障的机制。</p><h4 id="结果的保证"><a href="#结果的保证" class="headerlink" title="结果的保证"></a>结果的保证</h4><p>当我们讨论保证计算的结果时，我们的意思是流处理器的内部状态需要保证一致性。也就是说我们关心的是应用程序的代码在故障恢复以后看到的状态值是什么。要注意保证应用程序状态的一致性并不是保证应用程序的输出结果的一致性。一旦输出结果被持久化，结果的准确性就很难保证了。除非持久化系统支持事务。</p><p><strong>AT-MOST-ONCE</strong></p><p>　　当任务故障时，最简单的做法是什么都不干，既不恢复丢失的状态，也不重播丢失的事件。At-most-once语义的含义是最多处理一次事件。换句话说，事件可以被丢弃掉，也没有任何操作来保证结果的准确性。这种类型的保证也叫“没有保证”，因为一个丢弃掉所有事件的系统其实也提供了这样的保障。没有保障听起来是一个糟糕的主意，但如果我们能接受近似的结果，并且希望尽可能低的延迟，那么这样也挺好。</p><p><strong>AT-LEAST-ONCE</strong></p><p>　　在大多数的真实应用场景，我们希望不丢失事件。这种类型的保障成为at-least-once，意思是所有的事件都得到了处理，而且一些事件还可能被处理多次。如果结果的正确性仅仅依赖于数据的完整性，那么重复处理是可以接受的。例如，判断一个事件是否在流中出现过，at-least-once这样的保证完全可以正确的实现。在最坏的情况下，我们多次遇到了这个事件。而如果我们要对一个特定的事件进行计数，计算结果就可能是错误的了。</p><p>　　为了保证在at-least-once语义的保证下，计算结果也能正确。我们还需要另一套系统来从数据源或者缓存中重新播放数据。持久化的事件日志系统将会把所有的事件写入到持久化存储中。所以如果任务发生故障，这些数据可以重新播放。还有一种方法可以获得同等的效果，就是使用结果承认机制。这种方法将会把每一条数据都保存在缓存中，直到数据的处理等到所有的任务的承认。一旦得到所有任务的承认，数据将被丢弃。</p><p><strong>EXACTLY-ONCE</strong></p><p>　　恰好处理一次是最严格的保证，也是最难实现的。恰好处理一次语义不仅仅意味着没有事件丢失，还意味着针对每一个数据，内部状态仅仅更新一次。本质上，恰好处理一次语义意味着我们的应用程序可以提供准确的结果，就好像从未发生过故障。</p><p>　　提供恰好处理一次语义的保证必须有至少处理一次语义的保证才行，同时还需要数据重放机制。另外，流处理器还需要保证内部状态的一致性。也就是说，在故障恢复以后，流处理器应该知道一个事件有没有在状态中更新。事务更新是达到这个目标的一种方法，但可能引入很大的性能问题。Flink使用了一种轻量级快照机制来保证恰好处理一次语义。</p><p><strong>端到端恰好处理一次</strong></p><p>　　目前我们看到的一致性保证都是由流处理器实现的，也就是说都是在Flink流处理器内部保证的。而在真实世界中，流处理应用除了流处理器以外还包含了数据源（例如Kafka）和持久化系统。端到端的一致性保证意味着结果的正确性贯穿了整个流处理应用的始终。每一个组件都保证了它自己的一致性。而整个端到端的一致性级别取决于所有组件中一致性最弱的组件。要注意的是，我们可以通过弱一致性来实现更强的一致性语义。例如，当任务的操作具有幂等性时，比如流的最大值或者最小值的计算。在这种场景下，我们可以通过最少处理一次这样的一致性来实现恰好处理一次这样的最高级别的一致性。</p><h1 id="Flink基础：Flink运行架构"><a href="#Flink基础：Flink运行架构" class="headerlink" title="Flink基础：Flink运行架构"></a>Flink基础：Flink运行架构</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>　　Flink是一个用于有状态的并行数据流处理的分布式系统。它由多个进程构成，这些进程一般会分布运行在不同的机器上。对于分布式系统来说，面对的常见问题有：集群中资源的分配和管理、进程协调调度、持久化和高可用的数据存储，以及故障恢复。</p><p>　　对于这些分布式系统的经典问题，业内已有比较成熟的解决方案和服务。所以Flink并不会自己去处理所有的问题，而是利用了现有的集群架构和服务，这样它就可以把精力集中在核心工作——<font color="red"><strong>分布式数据流处理</strong></font>上了。Flink与一些集群资源管理工具有很好的集成，比如Apache Mesos、YARN和Kubernetes；同时，也可以配置为独立（stand-alone）集群运行。Flink自己并不提供持久化的分布式存储，而是直接利用了已有的分布式文件系统（比如HDFS）或者对象存储（比如S3）。对于高可用的配置，Flink需要依靠Apache ZooKeeper来完成。</p><p>　　在本节中，我们将介绍Flink的不同组件，以及在运行程序时它们如何相互作用。我们会讨论部署Flink应用程序的两种模式，并且了解每种模式下分发和执行任务的方式。最后，我们还会解释一下Flink的高可用性模式是如何工作的。</p><h3 id="Flink运行时组件"><a href="#Flink运行时组件" class="headerlink" title="Flink运行时组件"></a>Flink运行时组件</h3><p>　　Flink运行时架构主要包括四个不同的组件，它们会在运行流处理应用程序时协同工作：作业管理器（JobManager）、资源管理器（ResourceManager）、任务管理器（TaskManager），以及分发器（Dispatcher）。因为Flink是用Java和Scala实现的，所以所有组件都会运行在Java虚拟机（JVMs）上。每个组件的职责如下：</p><ul><li><strong>作业管理器（JobManager）</strong>是控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的作业管理器所控制执行。作业管理器会先接收到要执行的应用程序。这个应用程序会包括：作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库和其它资源的JAR包。作业管理器会把JobGraph转换成一个物理层面的数据流图，这个图被叫做“执行图”（ExecutionGraph），包含了所有可以并发执行的任务。作业管理器会向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（slot）。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的TaskManager上。而在运行过程中，作业管理器会负责所有需要中央协调的操作，比如说检查点（checkpoints）的协调。</li><li><strong>ResourceManager</strong>主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManger插槽是Flink中定义的处理资源单元。Flink为不同的环境和资源管理工具提供了不同资源管理器（ResourceManager），比如YARN、Mesos、K8s，以及standalone部署。当作业管理器申请插槽资源时，ResourceManager会将有空闲插槽的TaskManager分配给作业管理器。如果ResourceManager没有足够的插槽来满足作业管理器的请求，它还可以向资源提供平台发起会话，以提供启动TaskManager进程的容器。另外，ResourceManager还负责终止空闲的TaskManager，释放计算资源。</li><li><strong>任务管理器（TaskManager）</strong>是Flink中的工作进程。通常在Flink中会有多个TaskManager运行，每一个TaskManager都包含了一定数量的插槽（slots）。插槽的数量限制了TaskManager能够执行的任务数量。启动之后，TaskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给作业管理器调用。作业管理器就可以向插槽分配任务（tasks）来执行了。在执行过程中，一个TaskManager可以跟其它运行同一应用程序的TaskManager交换数据。任务的执行和插槽的概念会在“任务执行”一节做具体讨论。</li><li><strong>分发器（Dispatcher）</strong>可以跨作业运行，它为应用提交提供了REST接口。当一个应用被提交执行时，分发器就会启动并将应用移交给一个作业管理器。由于是REST接口，所以Dispatcher可以作为集群的一个HTTP接入点，这样就能够不受防火墙阻挡。Dispatcher也会启动一个Web UI，用来方便地展示和监控作业执行的信息。Dispatcher在架构中可能并不是必需的，这取决于应用提交运行的方式。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl87wvvwclj20zc0bpwfq.jpg" alt="undefined"></p><blockquote><p>上图是从一个较为高层级的视角，来看应用中各组件的交互协作。如果部署的集群环境不同（例如YARN，Mesos，Kubernetes，standalone等），其中一些步骤可以被省略，或是有些组件会运行在同一个JVM进程中。</p></blockquote><h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><p>Flink应用程序可以用以下两种不同的方式部署：</p><p><strong>框架（Framework）方式</strong></p><p>　　在这个模式下，Flink应用被打包成一个Jar文件，并由客户端提交给一个运行服务（running service）。这个服务可以是一个Flink的Dispatcher，也可以是一个Flink的作业管理器，或是Yarn的ResourceManager。如果application被提交给一个作业管理器，则它会立即开始执行这个application。如果application被提交给了一个Dispatcher，或是Yarn ResourceManager，则它会启动一个作业管理器，然后将application交给它，再由作业管理器开始执行此应用。</p><p>**库（Library）方式                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           **</p><p>在这个模式下，Flink Application 会被打包在一个容器（container） 镜像里，例如一个Docker 镜像。此镜像包含了运行作业管理器和ResourceManager的代码。当一个容器从镜像启动后，它会自动启动ResourceManager和作业管理器，并提交打包好的应用。另一种方法是：将应用打包到镜像后，只用于部署TaskManager容器。从镜像启动的容器会自动启动一个TaskManager，然后连接ResourceManager并注册它的slots。这些镜像的启动以及失败重启，通常都会由一个外部的资源管理器管理（比如Kubernetes）。</p><p>框架模式遵循了传统的任务提交方式，从客户端提交到Flink运行服务。而在库模式下，没有运行的Flink服务。它是将Flink作为一个库，与应用程序一同打包到了一个容器镜像。这种部署方式在微服务架构中较为常见。我们会在“运行管理流式应用程序”一节对这个话题做详细讨论。</p><h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><p>一个TaskManager可以同时执行多个<strong>任务（tasks）</strong>。这些任务可以是同一个<strong>算子（operator）</strong>的<strong>子任务</strong>（数据并行）<strong>，也可以是来自不同算子的</strong>（任务并行），甚至可以是另一个不同应用程序的（作业并行）。TaskManager提供了一定数量的处理插槽（processing slots），用于控制可以并行执行的任务数。一个slot可以执行应用的一个分片，也就是应用中每一个算子的一个并行任务。下图展示了TaskManagers，slots，tasks以及operators之间的关系：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl8i2lx179j21170g1mzk.jpg" alt="undefined"></p><p>最左边是一个“作业图”（JobGraph），包含了5个算子——它是应用程序的非并行表示。其中算子A和C是数据源（source），E是输出端（sink）。C和E并行度为2，而其他的算子并行度为4。因为最高的并行度是4，所以应用需要至少四个slot来执行任务。现在有两个TaskManager，每个又各有两个slot，所以我们的需求是满足的。作业管理器将JobGraph转化为“执行图”（ExecutionGraph），并将任务分配到四个可用的slot上。<strong>对于有4个并行任务的算子，它的task会分配到每个slot上</strong>。而对于并行度为2的operator C和E，它们的任务被分配到slot 1.1、2.1 以及 slot 1.2、2.2。将tasks调度到slots上，可以让多个tasks跑在同一个TaskManager内，也就可以是的tasks之间的数据交换更高效。然而将太多任务调度到同一个TaskManager上会导致TaskManager过载，继而影响效率。之后我们会在“控制任务调度”一节继续讨论如何控制任务的调度。</p><p>TaskManager在同一个JVM中以多线程的方式执行任务。线程较进程会更轻量级，但是线程之间并没有对任务进行严格隔离。所以，单个任务的异常行为有可能会导致整个TaskManager进程挂掉，当然也同时包括运行在此进程上的所有任务。通过为每个TaskManager配置单独的slot，就可以将应用在TaskManager上相互隔离开来。TaskManager内部有多线程并行的机制，而且在一台主机上可以部署多个TaskManager，所以Flink在资源配置上非常灵活，在部署应用时可以充分权衡性能和资源的隔离。我们将会在第九章对Flink集群的配置和搭建继续做详细讨论。</p><h3 id="高可用配置"><a href="#高可用配置" class="headerlink" title="高可用配置"></a>高可用配置</h3><p>流式应用程序一般被设计为7 x 24小时运行。所以很重要的一点是：即使出现了进程挂掉的情况，应用仍需要继续保持运行。为了从故障恢复，系统首先需要重启进程、然后重启应用并恢复它的状态。接下来，我们就来了解Flink如何重启失败的进程。</p><p><strong>TaskManager故障</strong></p><p>　　如前所述，Flink需要足够数目的slot，来执行一个应用的所有任务。假设一个Flink环境有4个TaskManager，每个提供2个插槽，那么流应用程序执行的最高并行度为8。如果其中一个TaskManager挂掉了，那么可用的slots会降到6。在这种情况下，作业管理器会请求ResourceManager提供更多的slots。如果此请求无法满足——例如应用跑在一个独立集群——那么作业管理器在有足够的slots之前，无法重启应用。应用的重启策略决定了作业管理器的重启频率，以及两次重启尝试之间的时间间隔。</p><p><strong>作业管理器故障</strong></p><p>　　比TaskManager故障更严重的问题是作业管理器故障。作业管理器控制整个流应用程序的执行，并维护执行中的元数据——例如指向已完成检查点的指针。若是对应的作业管理器挂掉，则流程序无法继续运行。所以这就导致在Flink应用中，作业管理器是单点故障。为了解决这个问题，Flink提供了高可用模式。在原先的作业管理器挂掉后，可以将一个作业的状态和元数据迁移到另一个作业管理器，并继续执行。</p><p>　　Flink的高可用模式基于Apache ZooKeeper，我们知道，ZooKeeper是用来管理需要协调和共识的分布式服务的系统。Flink主要利用ZooKeeper来进行领导者（leader）的选举，并把它作为一个高可用和持久化的数据存储。当在高可用模式下运行时，作业管理器会将JobGraph以及所有需要的元数据（例如应用程序的jar文件），写入到一个远程的持久化存储系统中。而且，作业管理器会将指向存储位置的指针，写入到ZooKeeper的数据存储中。在执行一个应用的过程中，作业管理器会接收每个独立任务检查点的状态句柄（也就是存储位置）。当一个检查点完成时（所有任务已经成功地将它们的状态写入到远程存储）， 作业管理器把状态句柄写入远程存储，并将指向这个远程存储的指针写入ZooKeeper。这样，一个作业管理器挂掉之后再恢复，所需要的所有数据信息已经都保存在了远程存储，而ZooKeeper里存有指向此存储位置的指针。下图描述了这个设计：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl98e1vx16j20t10gogna.jpg" alt="undefined"></p><p>当一个作业管理器失败，所有属于这个应用的任务都会自动取消。一个新的作业管理器接管工作，会执行以下操作：</p><ul><li>从ZooKeeper请求存储位置（storage location），从远端存储获取JobGraph，Jar文件，以及应用最近一次检查点（checkpoint）的状态句柄（state handles）</li><li>从ResourceManager请求slots，用来继续运行应用</li><li>重启应用，并将所有任务的状态，重设为最近一次已完成的检查点</li></ul><p>　　如果我们是在容器环境里运行应用（如Kubernetes），故障的作业管理器或TaskManager 容器通常会由容器服务自动重启。当运行在YARN或Mesos之上时，作业管理器或TaskManager进程会由Flink的保留进程自动触发重启。而在standalone模式下，Flink并未提供重启故障进程的工具。所以，此模式下我们可以增加备用（standby）的 作业管理器和TaskManager，用于接管故障的进程。我们将会在“高可用配置”一节中做进一步讨论。</p><h2 id="Flink中的数据传输"><a href="#Flink中的数据传输" class="headerlink" title="Flink中的数据传输"></a>Flink中的数据传输</h2><h3 id="基于信任度的流控制"><a href="#基于信任度的流控制" class="headerlink" title="基于信任度的流控制"></a>基于信任度的流控制</h3><p>通过网络连接来发送每条数据的效率很低，会导致很大的开销。为了充分利用网络连接的带宽，就需要进行缓冲了。在流处理的上下文中，缓冲的一个缺点是会增加延迟，因为数据需要在缓冲区中进行收集，而不是立即发送。</p><p>　　Flink实现了一个基于信任度的流量控制机制，其工作原理如下。接收任务授予发送任务一些“信任度”（credit），也就是为了接收其数据而保留的网络缓冲区数。当发送者收到一个信任度通知，它就会按照被授予的信任度，发送尽可能多的缓冲数据，并且同时发送目前积压数据的大小——也就是已填满并准备发送的网络缓冲的数量。接收者用保留的缓冲区处理发来的数据，并对发送者传来的积压量进行综合考量，为其所有连接的发送者确定下一个信用度授权的优先级。</p><p>　　基于信用度的流控制可以减少延迟，因为发送者可以在接收者有足够的资源接受数据时立即发送数据。此外，在数据倾斜的情况下，这样分配网络资源是一种很有效的机制，因为信用度是根据发送者积压数据量的规模授予的。因此，基于信用的流量控制是Flink实现高吞吐量和低延迟的重要组成部分。</p><h4 id="任务链"><a href="#任务链" class="headerlink" title="任务链"></a>任务链</h4><p>Flink采用了一种称为任务链的优化技术，可以在特定条件下减少本地通信的开销。为了满足任务链的要求，必须将两个或多个算子设为相同的并行度，并通过本地转发（local forward）的方式进行连接。下图所示的算子管道满足这些要求。它由三个算子组成，这些算子的任务并行度都被设为2，并且通过本地转发方式相连接。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9hf5p4qj20wh06yjrs.jpg" alt="undefined"></p><p>下图展示了管道以任务链方式运行的过程。算子的函数被融合成了一个单一的任务，由一个线程执行。由函数生成的数据通过一个简单的方法调用移交给下一个函数；这样在函数之间直接传递数据，基本上没有序列化和通信成本。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9i2ut13j20nk0cmdgi.jpg" alt="undefined"></p><p>任务链可以显著降低本地任务之间的通信成本，但也有一些场景，在没有链接的情况下运行管道操作是有意义的。例如，如果任务链中某个函数执行的开销巨大，那就可以将一条长的任务链管道断开，或者将一条链断开为两个任务，从而可以将这个开销大的函数调度到不同的槽（slots）中。下图显示了在没有任务链的情况下相同管道操作的执行情况。所有函数都由独立的单个任务来评估，每个任务都在专有的线程中运行。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9imstamj20wg0d1gmk.jpg" alt="undefined"></p><p><strong>任务链在Flink中默认会启用</strong>。在“控制任务链”一节中，我们展示了如何禁用应用程序的任务链，以及如何控制各个算子的链接行为。</p><h2 id="事件时间处理"><a href="#事件时间处理" class="headerlink" title="事件时间处理"></a>事件时间处理</h2><p>​        在“时间语义”一节，我们重点强调了时间语义在流处理应用中的重要性，并且解释了处理时间（processing time）和事件时间（event time）的不同。处理时间比较好理解，因为它是基于处理器本地时间的；但同时，它会带来比较混乱、不一致、并且不可重现的结果。相比之下，事件时间语义能够产生可重现且一致的结果，这也是许多流处理场景希望解决的一大难题。但是，与处理时间应用程序相比，事件时间应用程序会更复杂，需要额外的配置。另外，支持事件时间的流处理器，也比纯粹在处理时间中运行的系统内部更为复杂。</p><p>　　Flink为常见的事件时间处理操作提供了直观且易于使用的原语，同时暴露了表达性很强的API，用户可以使用自定义算子实现更高级的事件时间应用程序。很好地理解Flink的内部时间处理，对于实现这样的高级应用程序会有很大帮助，有时也是必需的。上一章介绍了Flink利用两个概念来支持事件时间语义：记录时间戳（timestamps）和水位线（watermarks）。接下来，我们将描述Flink如何在内部实现并处理时间戳和水位线，进而支持具有事件时间语义的流式应用程序。</p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>　　由Flink事件时间流应用程序处理的所有记录都必须伴有时间戳。时间戳将数据与特定时间点相关联，通常就是数据所表示的事件发生的时间点。而只要时间戳大致跟数据流保持一致，基本上随着数据流的前进而增大，应用程序就可以自由选择时间戳的含义。不过正如“时间语义”一节中所讨论的，在现实场景中，时间戳基本上都是乱序的，所以采用“事件时间”而非“处理事件”往往会显得更为重要。</p><p>　　当Flink以事件时间模式处理数据流时，它会根据数据记录的时间戳来处理基于时间的算子。例如，时间窗口算子根据相关时间戳将数据分配给不同的时间窗口。Flink将时间戳编码为16字节的长整型值，并将其作为元数据附加到数据记录中。它的内置运算符会将这个长整型值解释为一个具有毫秒精度的Unix时间戳，也就是1970-01-01-00:00:00.000以来的毫秒数。当然，如果用户进行了自定义，那么运算符可以有自己的解释，例如，可以将精度调整到微秒。</p><h3 id="水位线-1"><a href="#水位线-1" class="headerlink" title="水位线"></a>水位线</h3><p>　　除了时间戳，基于事件时间的Flink应用程序还必须支持水位线（watermark）。在基于事件时间的应用中，水位线用于生成每个任务的当前事件时间。基于时间的算子使用这个“当前事件时间”来触发计算和处理操作。例如，一个时间窗口任务（time-window task）会在任务的事件时间超出窗口的关闭边界时，完成窗口计算，并输出计算结果。</p><p>在Flink中，水位线被实现为一条特殊的数据记录，它里面以长整型值保存了一个时间戳。水位线在带有时间戳的数据流中，跟随着其它数据一起流动，如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9pspnzfj20ss07g753.jpg" alt="undefined"></p><p><strong>水位线有两个基本属性</strong>：</p><ul><li>必须单调递增，以确保任务的事件时间时钟在向前推进，而不是在后退。</li><li>它们与数据的时间戳相关。带有时间戳T的水位线表示，所有后续数据的时间戳都应该大于T。</li></ul><p>　　上面的第二个属性用于处理带有乱序时间戳的数据流，比如图中时间戳3和5的数据。基于时间的算子任务会收集和处理数据（这些数据可能具有乱序的时间戳），并在事件时间时钟到达某个时刻时完成计算。这个时刻就表示数据收集的截止，具有之前时间戳的数据应该都已经到达、不再需要了；而其中的事件时间时钟，正是由当前接收到的水位线来指示的。如果任务再接收到的数据违反了watermark的这一属性，也就是时间戳小于以前接收到的水位线时，它所属的那部分计算可能已经完成了。这种数据被称为延迟数据（late records）。Flink提供了处理延迟数据的不同方式，我们会在“处理延迟数据”一节中讨论。</p><p>　　水位线还有一个很有趣的特性，它允许应用程序自己来平衡结果的完整性和延迟。如果水位线与数据的时间戳非常接近，那么我们可以得到较低的处理延迟，因为任务在完成计算之前只会短暂地等待更多数据到达。而同时，结果的完整性可能会受到影响，因为相关数据可能因为迟到而被视为“延迟数据”，这样就不会包含在结果中。相反，非常保守的水位线提供了足够的时间去等待所有数据到达，这样会增加处理延迟，但提高了结果的完整性。</p><h3 id="watermark的传递和事件时间"><a href="#watermark的传递和事件时间" class="headerlink" title="watermark的传递和事件时间"></a>watermark的传递和事件时间</h3><p>在本节中，我们将讨论算子如何处理水位线。Flink把watermark作为一条特殊的数据来实现，它也会由算子任务接收和发送。任务会有一个内部的时间服务，它会维护定时器，并在收到watermark时触发。<strong>任务可以在计时器服务中注册定时器，以便在将来特定的时间点执行计算。例如，窗口算子为每个活动窗口注册一个定时器，当事件时间超过窗口的结束时间时，该计时器将清除窗口的状态。</strong></p><p>当任务收到watermark时，将执行以下操作：</p><ul><li>任务根据watermark的时间戳更新其内部事件时钟。</li><li>任务的时间服务会将所有过期的计时器标识出来，它们的时间小于当前的事件时间。对于每个过期的计时器，任务调用一个回调函数，该函数可以执行计算并发送结果。</li><li>任务会发出一个带有更新后的事件时间的watermark。</li></ul><blockquote><p>Flink限制通过DataStream API访问时间戳和watermark。函数不能读取或修改数据的时间戳和watermark，但底层的“处理函数”（process functions）除外，它们可以读取当前处理数据的时间戳、请求算子的当前事件时间，还可以注册定时器。通常的函数都不会暴露这些可以设置时间戳、操作任务事件时间时钟、或者发出水位线的API。而基于时间的数据流算子任务则会配置发送出的数据的时间戳，以确保它们能够与已到达的水位线平齐。例如，窗口计算完成后，时间窗口的算子任务会将窗口的结束时间作为时间戳附加到将要发送出的结果数据上，然后再使用触发窗口计算的时间戳发出watermark。</p></blockquote><p>　　现在，让我们更详细地解释一下任务在接收到新的watermark时，如何继续发送watermark并更新其事件时钟。正如我们在“数据并发和任务并发”中所了解的，Flink将数据流拆分为多个分区，并通过单独的算子任务并行地处理每个分区。每个分区都是一个流，里面包含了带着时间戳的数据和watermark。一个算子与它前置或后续算子的连接方式有多种情况，所以它对应的任务可以从一个或多个“输入分区”接收数据和watermark，同时也可以将数据和watermark发送到一个或多个“输出分区”。接下来，我们将详细描述一个任务如何向多个输出任务发送watermark，以及如何通过接收到的watermark来驱动事件时间时钟前进。</p><p>　　任务为每个输入分区维护一个分区水位线（watermark）。当从一个分区接收到watermark时，它会比较新接收到的值和当前水位值，然后将相应的分区watermark更新为两者的最大值。然后，任务会比较所有分区watermark的大小，将其事件时钟更新为所有分区watermark的最小值。如果事件时间时钟前进了，任务就将处理所有被触发的定时器操作，并向所有连接的输出分区发送出相应的watermark，最终将新的事件时间广播给所有下游任务。</p><p>下图显示了具有四个输入分区和三个输出分区的任务如何接收watermark、更新分区watermark和事件时间时钟，以及向下游发出watermark。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9rpx0enj213p0n641h.jpg" alt="undefined"></p><p>具有两个或多个输入流（如Union或CoFlatMap）的算子任务（参见“多流转换”一节）也会以所有分区watermark的最小值作为事件时间时钟。它们并不区分不同输入流的分区watermark，所以两个输入流的数据都是基于相同的事件时间时钟进行处理的。当然我们可以想到，如果应用程序的各个输入流的事件时间不一致，那么这种处理方式可能会导致问题。</p><p>　　Flink的水位处理和传递算法，确保了算子任务发出的时间戳和watermark是“对齐”的。不过它依赖一个条件，那就是所有分区都会提供不断增长的watermark。一旦一个分区不再推进水位线的上升，或者完全处于空闲状态、不再发送任何数据和watermark，任务的事件时间时钟就将停滞不前，任务的定时器也就无法触发了。对于基于时间的算子来说，它们需要依赖时钟的推进来执行计算和清除状态，这种情况显然就会有问题。如果任务没有定期从所有输入任务接收到新的watermark，那么基于时间的算子的处理延迟和状态空间的大小都会显著增加。</p><p>　　对于具有两个输入流而且watermark明显不同的算子，也会出现类似的情况。具有两个输入流的任务的事件时间时钟，将会同较慢的那条流的watermark保持一致，而通常较快流的数据或者中间结果会在state中缓冲，直到事件时间时钟达到这条流的watermark，才会允许处理它们。</p><h3 id="时间戳的分配和水位线的产生"><a href="#时间戳的分配和水位线的产生" class="headerlink" title="时间戳的分配和水位线的产生"></a>时间戳的分配和水位线的产生</h3><p>我们已经解释了什么是时间戳和水位线，以及它们是如何由Flink内部处理的；然而我们还没有讨论它们的产生。流应用程序接收到数据流时，通常就会先分配时间戳并生成水位线（watermark）。因为时间戳的选择是由不同的应用程序决定的，而且watermark取决于时间戳和流的特性，所以应用程序必须首先显式地分配时间戳并生成watermark。Flink流应用程序可以通过三种方式分配时间戳和生成watermark：</p><ul><li>在数据源（source）处分配：当数据流被摄入到应用程序中时，可以由“源函数”SourceFunction分配和生成时间戳和watermark。SourceFunction可以产生并发送一个数据流；数据会与相关的时间戳一起发送出去，而watermark可以作为一条特殊数据在任何时间点发出。如果SourceFunction（暂时）不再发出watermark，它可以声明自己处于“空闲”（idle）状态。Flink会在后续算子的水位计算中，把空闲的SourceFunction产生的流分区排除掉。source的这一空闲机制，可以用来解决前面提到的水位不再上升的问题。源函数（Source Function）在“实现自定义源函数”一节中进行了更详细的讨论。</li><li>定期分配：在Flink中，DataStream API提供一个名为AssignerWithPeriodicWatermarks的用户定义函数，它可以从每个数据中提取时间戳，并被定期调用以生成当前watermark。提取出的时间戳被分配给相应的数据，而生成的watermark也会添加到流中。这个函数将在“分配时间戳和生成水位线”一节中讨论。</li><li>间断分配：AssignerWithPunctuatedWatermarks是另一个用户定义的函数，它同样会从每个数据中提取一个时间戳。它可以用于生成特殊输入数据中的watermark。与AssignerWithPeriodicWatermarks相比，此函数可以（但不是必须）从每个记录中提取watermark。我们在“分配时间戳和生成水位线”一节中同样讨论了该函数。</li></ul><p>　　用户定义的时间戳分配函数并没有严格的限制，通常会放在尽可能靠近source算子的位置，因为当经过一些算子处理后，数据及其时间戳的顺序就更加难以解释了。所以尽管我们可以在流应用程序的中段覆盖已有的时间戳和watermark——Flink通过用户定义的函数提供了这种灵活性，但这显然并不是推荐的做法。</p><h2 id="状态管理-1"><a href="#状态管理-1" class="headerlink" title="状态管理"></a>状态管理</h2><p>​        我们已经知道大多数流应用程序都是有状态的。许多算子会不断地读取和更新状态，例如在窗口中收集的数据、读取输入源的位置，或者像机器学习模型那样的用户定制化的算子状态。 Flink用同样的方式处理所有的状态，无论是内置的还是用户自定义的算子。本节我们将会讨论Flink支持的不同类型的状态，并解释“状态后端”是如何存储和维护状态的。</p><p>​        一般来说，由一个任务维护，并且用来计算某个结果的所有数据，都属于这个任务的状态。你可以认为状态就是一个本地变量，可以被任务的业务逻辑访问。下图显示了任务与其状态之间的交互。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9ypa4y7j20hj09omxs.jpg" alt="undefined"></p><p>　　任务会接收一些输入数据。在处理数据时，任务可以读取和更新状态，并根据输入数据和状态计算结果。最简单的例子，就是统计接收到多少条数据的任务。当任务收到新数据时，它会访问状态以获取当前的计数，然后让计数递增，更新状态并发送出新的计数。</p><p>　　应用程序里，读取和写入状态的逻辑一般都很简单直接，而有效可靠的状态管理会复杂一些。这包括如何处理很大的状态——可能会超过内存，并且保证在发生故障时不会丢失任何状态。幸运的是，Flink会帮我们处理这相关的所有问题，包括状态一致性、故障处理以及高效存储和访问，以便开发人员可以专注于应用程序的逻辑。</p><p>　　在Flink中，状态始终与特定算子相关联。为了使运行时的Flink了解算子的状态，算子需要预先注册其状态。总的说来，有两种类型的状态：算子状态（operator state）和键控状态（keyed state），它们有着不同的范围访问，我们将在下面展开讨论。</p><h3 id="算子状态"><a href="#算子状态" class="headerlink" title="算子状态"></a>算子状态</h3><p>算子状态的作用范围限定为算子任务。这意味着由同一并行任务所处理的所有数据都可以访问到相同的状态，状态对于同一任务而言是共享的。算子状态不能由相同或不同算子的另一个任务访问。下图显示了任务如何访问算子状态。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfa2mwpxjj20gi0f1754.jpg" alt="undefined"></p><p>Flink为算子状态提供三种基本数据结构：</p><p><strong>列表状态</strong></p><p>将状态表示为一组数据的列表。</p><p><strong>联合列表状态</strong></p><p>也将状态表示为数据的列表。它与常规列表状态的区别在于，在发生故障时，或者从保存点（savepoint）启动应用程序时如何恢复。我们将在后面继续讨论。</p><p><strong>广播状态</strong></p><p>如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态。在保存检查点和重新调整算子并行度时，会用到这个特性。这两部分内容将在本章后面讨论。</p><h3 id="键控状态"><a href="#键控状态" class="headerlink" title="键控状态"></a>键控状态</h3><p>顾名思义，键控状态是根据输入数据流中定义的键（key）来维护和访问的。Flink为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个key对应的状态。当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的key。因此，具有相同key的所有数据都会访问相同的状态。下图显示了任务如何与键控状态进行交互。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfaifkmeij20kt0h9zlj.jpg" alt="undefined"></p><p>我们可以将键控状态看成是在算子所有并行任务上，对键进行分区（或分片）之后的一个键值映射（key-value map）。 Flink为键控状态提供不同的数据结构，用于确定map中每个key存储的值的类型。我们简单了解一下最常见的键控状态。</p><h4 id="值状态"><a href="#值状态" class="headerlink" title="值状态"></a>值状态</h4><p>为每个键存储一个任意类型的单个值。复杂数据结构也可以存储为值状态。</p><h4 id="列表状态"><a href="#列表状态" class="headerlink" title="列表状态"></a>列表状态</h4><p>为每个键存储一个值的列表。列表里的每个数据可以是任意类型。</p><h4 id="映射状态"><a href="#映射状态" class="headerlink" title="映射状态"></a>映射状态</h4><p>为每个键存储一个键值映射（map）。map的key和value可以是任意类型。</p><p>状态的数据结构可以让Flink实现更有效的状态访问。我们将在“在运行时上下文（RuntimeContext）中声明键控状态”中做进一步讨论。</p><h3 id="状态后端"><a href="#状态后端" class="headerlink" title="状态后端"></a>状态后端</h3><p>　　每传入一条数据，有状态的算子任务都会读取和更新状态。由于有效的状态访问对于处理数据的低延迟至关重要，因此每个并行任务都会在本地维护其状态，以确保快速的状态访问。状态到底是如何被存储、访问以及维护的？这件事由一个可插入的组件决定，这个组件就叫做状态后端（state backend）。状态后端主要负责两件事：本地的状态管理，以及将检查点（checkpoint）状态写入远程存储。</p><p>　　对于本地状态管理，状态后端会存储所有键控状态，并确保所有的访问都被正确地限定在当前键范围。 Flink提供了默认的状态后端，会将键控状态作为内存中的对象进行管理，将它们存储在JVM堆上。另一种状态后端则会把状态对象进行序列化，并将它们放入RocksDB中，然后写入本地硬盘。第一种方式可以提供非常快速的状态访问，但它受内存大小的限制；而访问RocksDB状态后端存储的状态速度会较慢，但其状态可以增长到非常大。</p><p>　　状态检查点的写入也非常重要，这是因为Flink是一个分布式系统，而状态只能在本地维护。 TaskManager进程（所有任务在其上运行）可能在任何时间点挂掉。因此，它的本地存储只能被认为是不稳定的。状态后端负责将任务的状态检查点写入远程的持久存储。写入检查点的远程存储可以是分布式文件系统，也可以是数据库。不同的状态后端在状态检查点的写入机制方面有所不同。例如，RocksDB状态后端支持增量的检查点，这对于非常大的状态来说，可以显著减少状态检查点写入的开销。</p><p>我们将在“选择状态后端”一节中更详细地讨论不同的状态后端及其优缺点。</p><h4 id="调整有状态算子的并行度"><a href="#调整有状态算子的并行度" class="headerlink" title="调整有状态算子的并行度"></a>调整有状态算子的并行度</h4><p>　　流应用程序的一个常见要求是，为了增大或较小输入数据的速率，需要灵活地调整算子的并行度。对于无状态算子而言，并行度的调整没有任何问题，但更改有状态算子的并行度显然就没那么简单了，因为它们的状态需要重新分区并分配给更多或更少的并行任务。 Flink支持四种模式来调整不同类型的状态。</p><p>　　具有键控状态的算子通过将键重新分区为更少或更多任务来缩放并行度。不过，并行度调整时任务之间会有一些必要的状态转移。为了提高效率，Flink并不会对单独的key做重新分配，而是用所谓的“键组”（key group）把键管理起来。键组是key的分区形式，同时也是Flink为任务分配key的方式。图3-13显示了如何在键组中重新分配键控状态。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfawq49exj20sv0jitc6.jpg" alt="undefined"></p><p>　　具有算子列表状态的算子，会通过重新分配列表中的数据项目来进行并行度缩放。从概念上讲，所有并行算子任务的列表项目会被收集起来，并将其均匀地重新分配给更少或更多的任务。如果列表条目少于算子的新并行度，则某些任务将以空状态开始。下图显示了算子列表状态的重新分配。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfax3sj46j20x80ceq4a.jpg" alt="undefined"></p><p>　　具有算子联合列表状态的算子，会通过向每个任务广播状态的完整列表，来进行并行度的缩放。然后，任务可以选择要使用的状态项和要丢弃的状态项。下图显示了如何重新分配算子联合列表状态。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfaxicg8hj20vw0f575r.jpg" alt="undefined"></p><p>　　具有算子广播状态的算子，通过将状态复制到新任务，来增大任务的并行度。这是没问题的，因为广播状态保证了所有任务都具有相同的状态。而对于缩小并行度的情况，我们可以直接取消剩余任务，因为状态是相同的，已经被复制并且不会丢失。下图显示了算子广播状态的重新分配。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfaxwogz6j20oo0bb74y.jpg" alt="undefined"></p><h2 id="检查点，保存点和状态恢复"><a href="#检查点，保存点和状态恢复" class="headerlink" title="检查点，保存点和状态恢复"></a>检查点，保存点和状态恢复</h2><p>　　Flink是一个分布式数据处理系统，因此必须有一套机制处理各种故障，比如被杀掉的进程，故障的机器和中断的网络连接。任务都是在本地维护状态的，所以Flink必须确保状态不会丢失，并且在发生故障时能够保持一致。</p><p>　　在本节中，我们将介绍Flink的检查点（checkpoint）和恢复机制，这保证了“精确一次”（exactly-once）的状态一致性。我们还会讨论Flink独特的保存点（savepoint）功能，这是一个“瑞士军刀”式的工具，可以解决许多操作数据流时面对的问题。</p><h3 id="一致的检查点"><a href="#一致的检查点" class="headerlink" title="一致的检查点"></a>一致的检查点</h3><p>　　Flink的恢复机制的核心，就是应用状态的一致检查点。有状态流应用的一致检查点，其实就是所有任务状态在某个时间点的一份拷贝，而这个时间点应该是所有任务都恰好处理完一个相同的输入数据的时候。这个过程可以通过一致检查点的一个简单算法步骤来解释。这个算法的步骤是：</p><ul><li>暂停所有输入流的摄取，也就是不再接收新数据的输入。</li><li>等待所有正在处理的数据计算完毕，这意味着结束时，所有任务都已经处理了所有输入数据。</li><li>通过将每个任务的状态复制到远程持久存储，来得到一个检查点。所有任务完成拷贝操作后，检查点就完成了。</li><li>恢复所有输入流的摄取。</li></ul><p>　　需要注意，Flink实现的并不是这种简单的机制。我们将在本节后面介绍Flink更精妙的检查点算法。</p><p>下图显示了一个简单应用中的一致检查点。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfayxbpf9j20nu0hrabk.jpg" alt="undefined"></p><p>　　上面的应用程序中具有单一的输入源（source）任务，输入数据就是一组不断增长的数字的流——1,2,3等。数字流被划分为偶数流和奇数流。求和算子（sum）的两个任务会分别实时计算当前所有偶数和奇数的总和。源任务会将其输入流的当前偏移量存储为状态，而求和任务则将当前的总和值存储为状态。在图3-17中，Flink在输入偏移量为5时，将检查点写入了远程存储，当前的总和为6和9</p><h3 id="从一致检查点中恢复状态"><a href="#从一致检查点中恢复状态" class="headerlink" title="从一致检查点中恢复状态"></a>从一致检查点中恢复状态</h3><p>在执行流应用程序期间，Flink会定期检查状态的一致检查点。如果发生故障，Flink将会使用最近的检查点来一致恢复应用程序的状态，并重新启动处理流程。下图显示了恢复过程。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfazjk3kjj20q318x42f.jpg" alt="undefined"></p><p>应用程序从检查点的恢复分为三步：</p><ul><li>重新启动整个应用程序。</li><li>将所有的有状态任务的状态重置为最近一次的检查点。</li><li>恢复所有任务的处理。</li></ul><p>　　这种检查点的保存和恢复机制可以为应用程序状态提供“精确一次”（exactly-once）的一致性，因为所有算子都会保存检查点并恢复其所有状态，这样一来所有的输入流就都会被重置到检查点完成时的位置。至于数据源是否可以重置它的输入流，这取决于其实现方式和消费流数据的外部接口。例如，像Apache Kafka这样的事件日志系统可以提供流上之前偏移位置的数据，所以我们可以将源重置到之前的偏移量，重新消费数据。而从套接字（socket）消费数据的流就不能被重置了，因为套接字的数据一旦被消费就会丢弃掉。因此，对于应用程序而言，只有当所有的输入流消费的都是可重置的数据源时，才能确保在“精确一次”的状态一致性下运行。</p><p>　　从检查点重新启动应用程序后，其内部状态与检查点完成时的状态完全相同。然后它就会开始消费并处理检查点和发生故障之间的所有数据。尽管这意味着Flink会对一些数据处理两次（在故障之前和之后），我们仍然可以说这个机制实现了精确一次的一致性语义，因为所有算子的状态都已被重置，而重置后的状态下还不曾看到这些数据。</p><p>　　我们必须指出，Flink的检查点保存和恢复机制仅仅可以重置流应用程序的内部状态。对于应用中的一些的输出（sink）算子，在恢复期间，某些结果数据可能会多次发送到下游系统，比如事件日志、文件系统或数据库。对于某些存储系统，Flink提供了具有精确一次输出功能的sink函数，比如，可以在检查点完成时提交发出的记录。另一种适用于许多存储系统的方法是幂等更新。在“应用程序一致性保证”一节中，我们还会详细讨论如何解决应用程序端到端的精确一次一致性问题。</p><h3 id="Flink的检查点算法"><a href="#Flink的检查点算法" class="headerlink" title="Flink的检查点算法"></a>Flink的检查点算法</h3><p>　　Flink的恢复机制，基于它的一致性检查点。前面我们已经了解了从流应用中创建检查点的简单方法——先暂停应用，保存检查点，然后再恢复应用程序，这种方法很好理解，但它的理念是“停止一切”，这对于即使是中等延迟要求的应用程序而言也是不实用的。所以Flink没有这么简单粗暴，而是基于Chandy-Lamport算法实现了分布式快照的检查点保存。该算法并不会暂停整个应用程序，而是将检查点的保存与数据处理分离，这样就可以实现在其它任务做检查点状态保存状态时，让某些任务继续进行而不受影响。接下来我们将解释此算法的工作原理。</p><p>　　Flink的检查点算法用到了一种称为“检查点分界线”（checkpoint barrier）的特殊数据形式。与水位线（watermark）类似，检查点分界线由source算子注入到常规的数据流中，它的位置是限定好的，不能超过其他数据，也不能被后面的数据超过。检查点分界线带有检查点ID，用来标识它所属的检查点；这样，这个分界线就将一条流逻辑上分成了两部分。分界线之前到来的数据导致的状态更改，都会被包含在当前分界线所属的检查点中；而基于分界线之后的数据导致的所有更改，就会被包含在之后的检查点中。</p><p>　　我们用一个简单的流应用程序作为示例，来一步一步解释这个算法。该应用程序有两个源（source）任务，每个任务都消费一个增长的数字流。源任务的输出被划分为两部分：偶数和奇数的流。每个分区由一个任务处理，该任务计算所有收到的数字的总和，并将更新的总和转发给输出（sink）任务。这个应用程序的结构如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb0fcof8j20uy0e8myi.jpg" alt="undefined"></p><p>作业管理器会向每个数据源（source）任务发送一条带有新检查点ID的消息，通过这种方式来启动检查点，如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb0s7gl2j20uy0e0jst.jpg" alt="undefined"></p><p>　　当source任务收到消息时，它会暂停发出新的数据，在状态后端触发本地状态的检查点保存，并向所有传出的流分区广播带着检查点ID的分界线（barriers）。状态后端在状态检查点完成后会通知任务，而任务会向作业管理器确认检查点完成。在发出所有分界线后，source任务就可以继续常规操作，发出新的数据了。通过将分界线注入到输出流中，源函数（source function）定义了检查点在流中所处的位置。下图显示了两个源任务将本地状态保存到检查点，并发出检查点分界线之后的流应用程序。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb16kvayj20y70jgwgk.jpg" alt="undefined"></p><p>　　源任务发出的检查点分界线（barrier），将被传递给所连接的任务。与水位线（watermark）类似，barrier会被广播到所有连接的并行任务，以确保每个任务从它的每个输入流中都能接收到。当任务收到一个新检查点的barrier时，它会等待这个检查点的所有输入分区的barrier到达。在等待的过程中，任务并不会闲着，而是会继续处理尚未提供barrier的流分区中的数据。对于那些barrier已经到达的分区，如果继续有新的数据到达，它们就不会被立即处理，而是先缓存起来。这个等待所有分界线到达的过程，称为“分界线对齐”（barrier alignment），如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb1j5vy1j20uy0hrmz1.jpg" alt="undefined"></p><p>当任务从所有输入分区都收到barrier时，它就会在状态后端启动一个检查点的保存，并继续向所有下游连接的任务广播检查点分界线，如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb1y7d78j20w40ed0un.jpg" alt="undefined"></p><p>所有的检查点barrier都发出后，任务就开始处理之前缓冲的数据。在处理并发出所有缓冲数据之后，任务就可以继续正常处理输入流了。下图显示了此时的应用程序。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb2aooe1j20yf0edtae.jpg" alt="undefined"></p><p>　　最终，检查点分界线会到达输出（sink）任务。当sink任务接收到barrier时，它也会先执行“分界线对齐”，然后将自己的状态保存到检查点，并向作业管理器确认已接收到barrier。一旦从应用程序的所有任务收到一个检查点的确认信息，作业管理器就会将这个检查点记录为已完成。下图显示了检查点算法的最后一步。这样，当发生故障时，我们就可以用已完成的检查点恢复应用程序了。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb2ul73nj20yf0frtao.jpg" alt="undefined"></p><h3 id="检查点的性能影响"><a href="#检查点的性能影响" class="headerlink" title="检查点的性能影响"></a>检查点的性能影响</h3><p>　　Flink的检查点算法可以在不停止整个应用程序的情况下，生成一致的分布式检查点。但是，它可能会增加应用程序的处理延迟。Flink对此有一些调整措施，可以在某些场景下显得对性能的影响没那么大。</p><p>　　当任务将其状态保存到检查点时，它其实处于一个阻塞状态，而此时新的输入会被缓存起来。由于状态可能变得非常大，而且检查点需要通过网络将数据写入远程存储系统，检查点的写入很容易就会花费几秒到几分钟的时间——这对于要求低延迟的应用程序而言，显然是不可接受的。在Flink的设计中，真正负责执行检查点写入的，其实是状态后端。具体怎样复制任务的状态，取决于状态后端的实现方式。例如，文件系统（FileSystem）状态后端和RocksDB状态后端都支持了异步（asynchronous）检查点。触发检查点操作时，状态后端会先创建状态的本地副本。本地拷贝完成后，任务就将继续常规的数据处理，这往往并不会花费太多时间。一个后台线程会将本地快照异步复制到远程存储，并在完成检查点后再回来通知任务。异步检查点的机制，显著减少了任务继续处理数据之前的等待时间。此外，RocksDB状态后端还实现了增量的检查点，这样可以大大减少要传输的数据量。</p><p>　　为了减少检查点算法对处理延迟的影响，另一种技术是调整分界线对齐的步骤。对于需要非常低的延迟、并且可以容忍“至少一次”（at-least-once）状态保证的应用程序，Flink可以将检查点算法配置为，在等待barrier对齐期间处理所有到达的数据，而不是把barrier已经到达的那些分区的数据缓存起来。当检查点的所有barrier到达，算子任务就会将状态写入检查点——当然，现在的状态中，就可能包括了一些“提前”的更改，这些更改由本该属于下一个检查点的数据到来时触发。如果发生故障，从检查点恢复时，就将再次处理这些数据：这意味着检查点现在提供的是“至少一次”（at-least-once）而不是“精确一次”（exactly-once）的一致性保证。</p><h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>　　Flink的恢复算法是基于状态检查点的。Flink根据可配置的策略，定期保存并自动丢弃检查点。检查点的目的是确保在发生故障时可以重新启动应用程序，所以当应用程序被显式地撤销（cancel）时，检查点会被删除掉。除此之外，应用程序状态的一致性快照还可用于除故障恢复之外的更多功能。</p><p>Flink中一个最有价值，也是最独特的功能是保存点（savepoints）。原则上，创建保存点使用的算法与检查点完全相同，因此保存点可以认为就是具有一些额外元数据的检查点。 Flink不会自动创建保存点，因此用户（或者外部调度程序）必须明确地触发创建操作。同样，Flink也不会自动清理保存点。第10章将会具体介绍如何触发和处理保存点。</p><h4 id="使用保存点"><a href="#使用保存点" class="headerlink" title="使用保存点"></a>使用保存点</h4><p>　　有了应用程序和与之兼容的保存点，我们就可以从保存点启动应用程序了。这会将应用程序的状态初始化为保存点的状态，并从保存点创建时的状态开始运行应用程序。虽然看起来这种行为似乎与用检查点从故障中恢复应用程序完全相同，但实际上故障恢复只是一种特殊情况，它只是在相同的集群上以相同的配置启动相同的应用程序。而从保存点启动应用程序会更加灵活，这就可以让我们做更多事情了。</p><ul><li>可以从保存点启动不同但兼容的应用程序。这样一来，我们就可以及时修复应用程序中的逻辑bug，并让流式应用的源尽可能多地提供之前发生的事件，然后重新处理，以便修复之前的计算结果。修改后的应用程序还可用于运行A / B测试，或者具有不同业务逻辑的假设场景。这里要注意，应用程序和保存点必须兼容才可以这么做——也就是说，应用程序必须能够加载保存点的状态。</li><li>可以使用不同的并行度来启动相同的应用程序，可以将应用程序的并行度增大或减小。</li><li>可以在不同的集群上启动同样的应用程序。这非常有意义，意味着我们可以将应用程序迁移到较新的Flink版本或不同的集群上去。</li><li>可以使用保存点暂停应用程序，稍后再恢复。这样做的意义在于，可以为更高优先级的应用程序释放集群资源，或者在输入数据不连续生成时释放集群资源。</li><li>还可以将保存点设置为某一版本，并归档（archive）存储应用程序的状态。</li></ul><p>保存点是非常强大的功能，所以许多用户会定期创建保存点以便能够及时退回之前的状态。我们见到的各种场景中，保存点一个最有趣的应用是不断将流应用程序迁移到更便宜的数据中心上去。</p><h4 id="从保存点启动应用程序"><a href="#从保存点启动应用程序" class="headerlink" title="从保存点启动应用程序"></a>从保存点启动应用程序</h4><p>　　前面提到的保存点的所有用例，都遵循相同的模式。那就是首先创建正在运行的应用程序的保存点，然后在一个新启动的应用程序中用它来恢复状态。之前我们已经知道，保存点的创建和检查点非常相似，而接下来我们就将介绍对于一个从保存点启动的应用程序，Flink如何初始化其状态。</p><p>　　应用程序由多个算子组成。每个算子可以定义一个或多个键控状态和算子状态。算子由一个或多个算子任务并行执行。因此，一个典型的应用程序会包含多个状态，这些状态分布在多个算子任务中，这些任务可以运行在不同的TaskManager进程上。</p><p>　　图3-26显示了一个具有三个算子的应用程序，每个算子执行两个算子任务。一个算子（OP-1）具有单一的算子状态（OS-1），而另一个算子（OP-2）具有两个键控状态（KS-1和KS-2）。当保存点创建时，会将所有任务的状态复制到持久化的存储位置。</p><p>　　保存点中的状态拷贝会以算子标识符（operator ID）和状态名称（state name）组织起来。算子ID和状态名称必须能够将保存点的状态数据，映射到一个正在启动的应用程序的算子状态。从保存点启动应用程序时，Flink会将保存点的数据重新分配给相应的算子任务。</p><blockquote><p>请注意，保存点不包含有关算子任务的信息。这是因为当应用程序以不同的并行度启动时，任务数量可能会更改。</p></blockquote><p>　　如果我们要从保存点启动一个修改过的应用程序，那么保存点中的状态只能映射到符合标准的应用程序——它里面的算子必须具有相应的ID和状态名称。默认情况下，Flink会自动分配唯一的算子ID。然而，一个算子的ID，是基于它之前算子的ID确定性地生成的。因此，算子的ID会在其前序算子改变时改变，比如，当我们添加了新的或移除掉一个算子时，前序算子ID改变，当前算子ID就会变化。所以对于具有默认算子ID的应用程序而言，如果想在不丢失状态的前提下升级，就会受到极大的限制。因此，我们强烈建议在程序中为算子手动分配唯一ID，而不是依靠Flink的默认分配。我们将在“指定唯一的算子标识符”一节中详细说明如何分配算子标识符。</p><h1 id="Flink维表关联方式"><a href="#Flink维表关联方式" class="headerlink" title="Flink维表关联方式"></a>Flink维表关联方式</h1><p>从维表加载方式可以分为：</p><ul><li>实时数据库查找关联</li><li>预加载维表关联</li><li>维表变更日志关联</li><li>灵活组合衍生其他关联方式</li></ul><p>从维表在Flink内部的使用方式可以分为：</p><ul><li>预加载维表</li><li>热存储维表</li><li>广播维表</li><li>Temporal Table Function Join (仅SQL可用)</li></ul><p>一般我们习惯性把这个操作叫做Data Enrichment(数据扩充)</p><p>从处理思路又可以分为四种：</p><ul><li>全量预加载+定时刷新</li><li>实时查询+缓存刷新</li><li>纯实时查询</li><li>流式化纬度</li></ul><p><strong>TODO</strong> 后面我会针对这些纬度表的处理方式进行进一步的整理和补充</p><p>整体维表关联设计的指标：</p><ol><li>实现简单性：设计是否足够简单，易于迭代和维护</li><li>吞吐量：性能是否足够好</li><li>维表数据的实时性：维度表的更新是否可以立即对作业可见</li><li>数据库的负载</li><li>内存资源占用</li><li>可拓展性</li><li>结果确定性</li></ol><h1 id="Flink-原理与实现：内存管理"><a href="#Flink-原理与实现：内存管理" class="headerlink" title="Flink 原理与实现：内存管理"></a>Flink 原理与实现：内存管理</h1><p>如今，大数据领域的开源框架（Hadoop，Spark，Storm）都使用的 JVM，当然也包括 Flink。基于 JVM 的数据分析引擎都需要面对将大量数据存到内存中，这就不得不面对 JVM 存在的几个问题：</p><ol><li>Java 对象存储密度低。一个只包含 boolean 属性的对象占用了16个字节内存：对象头占了8个，boolean 属性占了1个，对齐填充占了7个。而实际上只需要一个bit（1/8字节）就够了。</li><li>Full GC 会极大地影响性能，尤其是为了处理更大数据而开了很大内存空间的JVM来说，GC 会达到秒级甚至分钟级。</li><li>OOM 问题影响稳定性。OutOfMemoryError是分布式计算框架经常会遇到的问题，当JVM中所有对象大小超过分配给JVM的内存大小时，就会发生OutOfMemoryError错误，导致JVM崩溃，分布式框架的健壮性和性能都会受到影响。</li></ol><p>所以目前，越来越多的大数据项目开始自己管理JVM内存了，像 Spark、Flink、HBase，为的就是获得像 C 一样的性能以及避免 OOM 的发生。本文将会讨论 Flink 是如何解决上面的问题的，主要内容包括内存管理、定制的序列化工具、缓存友好的数据结构和算法、堆外内存、JIT编译优化（Just In Time Compiler 即时编译器）等。</p><h2 id="积极的内存管理"><a href="#积极的内存管理" class="headerlink" title="积极的内存管理"></a>积极的内存管理</h2><p>Flink 并不是将大量对象存在堆上，而是将对象都序列化到一个预分配的内存块上，这个内存块叫做 <code>MemorySegment</code>，它代表了一段固定长度的内存（默认大小为 32KB），也是 Flink 中最小的内存分配单元，并且提供了非常高效的读写方法。你可以把 MemorySegment 想象成是为 Flink 定制的 <code>java.nio.ByteBuffer</code>。它的底层可以是一个普通的 Java 字节数组（<code>byte[]</code>），也可以是一个申请在堆外的 <code>ByteBuffer</code>。每条记录都会以序列化的形式存储在一个或多个<code>MemorySegment</code>中。</p><p>Flink 中的 Worker 名叫 TaskManager，是用来运行用户代码的 JVM 进程。TaskManager 的堆内存主要被分成了三个部分：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjwqeh9dfkj20k40l9ab4.jpg" alt="undefined"></p><ul><li><strong>Network Buffers:</strong> 一定数量的32KB大小的 buffer，主要用于数据的网络传输。在 TaskManager 启动的时候就会分配。默认数量是 2048 个，可以通过 <code>taskmanager.network.numberOfBuffers</code> 来配置。（阅读<a href="http://wuchong.me/blog/2016/04/26/flink-internals-how-to-handle-backpressure/?spm=a2c6h.12873639.0.0.506a2e39Kl3K9L" target="_blank" rel="noopener">这篇文章</a>了解更多Network Buffer的管理）</li><li><strong>Memory Manager Pool:</strong> 这是一个由 <code>MemoryManager</code> 管理的，由众多<code>MemorySegment</code>组成的超大集合。Flink 中的算法（如 sort/shuffle/join）会向这个内存池申请 MemorySegment，将序列化后的数据存于其中，使用完后释放回内存池。默认情况下，池子占了堆内存的 70% 的大小。</li><li><strong>Remaining (Free) Heap:</strong> 这部分的内存是留给用户代码以及 TaskManager 的数据结构使用的。因为这些数据结构一般都很小，所以基本上这些内存都是给用户代码使用的。从GC的角度来看，可以把这里看成的新生代，也就是说这里主要都是由用户代码生成的短期对象。</li></ul><p><em>注意：Memory Manager Pool 主要在Batch模式下使用。在Steaming模式下，该池子不会预分配内存，也不会向该池子请求内存块。也就是说该部分的内存都是可以给用户代码使用的。不过社区是打算在 Streaming 模式下也能将该池子利用起来。</em></p><p>Flink 采用类似 DBMS 的 sort 和 join 算法，直接操作二进制数据，从而使序列化/反序列化带来的开销达到最小。所以 Flink 的内部实现更像 C/C++ 而非 Java。如果需要处理的数据超出了内存限制，则会将部分数据存储到硬盘上。如果要操作多块MemorySegment就像操作一块大的连续内存一样，Flink会使用逻辑视图（<code>AbstractPagedInputView</code>）来方便操作。下图描述了 Flink 如何存储序列化后的数据到内存块中，以及在需要的时候如何将数据存储到磁盘上。</p><p>从上面我们能够得出 Flink 积极的内存管理以及直接操作二进制数据有以下几点好处：</p><ol><li><strong>减少GC压力。</strong>显而易见，因为所有常驻型数据都以二进制的形式存在 Flink 的<code>MemoryManager</code>中，这些<code>MemorySegment</code>一直呆在老年代而不会被GC回收。其他的数据对象基本上是由用户代码生成的短生命周期对象，这部分对象可以被 Minor GC 快速回收。只要用户不去创建大量类似缓存的常驻型对象，那么老年代的大小是不会变的，Major GC也就永远不会发生。从而有效地降低了垃圾回收的压力。另外，这里的内存块还可以是堆外内存，这可以使得 JVM 内存更小，从而加速垃圾回收。</li><li><strong>避免了OOM。</strong>所有的运行时数据结构和算法只能通过内存池申请内存，保证了其使用的内存大小是固定的，不会因为运行时数据结构和算法而发生OOM。在内存吃紧的情况下，算法（sort/join等）会高效地将一大批内存块写到磁盘，之后再读回来。因此，<code>OutOfMemoryErrors</code>可以有效地被避免。</li><li><strong>节省内存空间。</strong>Java 对象在存储上有很多额外的消耗（如上一节所谈）。如果只存储实际数据的二进制内容，就可以避免这部分消耗。</li><li><strong>高效的二进制操作 &amp; 缓存友好的计算。</strong>二进制数据以定义好的格式存储，可以高效地比较与操作。另外，该二进制形式可以把相关的值，以及hash值，键值和指针等相邻地放进内存中。这使得数据结构可以对高速缓存更友好，可以从 L1/L2/L3 缓存获得性能的提升（下文会详细解释）。</li></ol><h2 id="为-Flink-量身定制的序列化框架"><a href="#为-Flink-量身定制的序列化框架" class="headerlink" title="为 Flink 量身定制的序列化框架"></a>为 Flink 量身定制的序列化框架</h2><p>目前 Java 生态圈提供了众多的序列化框架：Java serialization, Kryo, Apache Avro 等等。但是 Flink 实现了自己的序列化框架。因为在 Flink 中处理的数据流通常是同一类型，由于数据集对象的类型固定，对于数据集可以只保存一份对象Schema信息，节省大量的存储空间。同时，对于固定大小的类型，也可通过固定的偏移位置存取。当我们需要访问某个对象成员变量的时候，通过定制的序列化工具，并不需要反序列化整个Java对象，而是可以直接通过偏移量，只是反序列化特定的对象成员变量。如果对象的成员变量较多时，能够大大减少Java对象的创建开销，以及内存数据的拷贝大小。</p><p>Flink支持任意的Java或是Scala类型。Flink 在数据类型上有很大的进步，不需要实现一个特定的接口（像Hadoop中的<code>org.apache.hadoop.io.Writable</code>），Flink 能够自动识别数据类型。Flink 通过 Java Reflection 框架分析基于 Java 的 Flink 程序 UDF (User Define Function)的返回类型的类型信息，通过 Scala Compiler 分析基于 Scala 的 Flink 程序 UDF 的返回类型的类型信息。类型信息由 <code>TypeInformation</code> 类表示，TypeInformation 支持以下几种类型：</p><ul><li><code>BasicTypeInfo</code>: 任意Java 基本类型（装箱的）或 String 类型。</li><li><code>BasicArrayTypeInfo</code>: 任意Java基本类型数组（装箱的）或 String 数组。</li><li><code>WritableTypeInfo</code>: 任意 Hadoop Writable 接口的实现类。</li><li><code>TupleTypeInfo</code>: 任意的 Flink Tuple 类型(支持Tuple1 to Tuple25)。Flink tuples 是固定长度固定类型的Java Tuple实现。</li><li><code>CaseClassTypeInfo</code>: 任意的 Scala CaseClass(包括 Scala tuples)。</li><li><code>PojoTypeInfo</code>: 任意的 POJO (Java or Scala)，例如，Java对象的所有成员变量，要么是 public 修饰符定义，要么有 getter/setter 方法。</li><li><code>GenericTypeInfo</code>: 任意无法匹配之前几种类型的类。</li></ul><p>前六种数据类型基本上可以满足绝大部分的Flink程序，针对前六种类型数据集，Flink皆可以自动生成对应的TypeSerializer，能非常高效地对数据集进行序列化和反序列化。对于最后一种数据类型，Flink会使用Kryo进行序列化和反序列化。每个TypeInformation中，都包含了serializer，类型会自动通过serializer进行序列化，然后用Java Unsafe接口写入MemorySegments。对于可以用作key的数据类型，Flink还同时自动生成TypeComparator，用来辅助直接对序列化后的二进制数据进行compare、hash等操作。对于 Tuple、CaseClass、POJO 等组合类型，其TypeSerializer和TypeComparator也是组合的，序列化和比较时会委托给对应的serializers和comparators。如下图展示 一个内嵌型的Tuple3 对象的序列化过程。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjwrvcz2rjj20pf0d70tf.jpg" alt="undefined"></p><p>可以看出这种序列化方式存储密度是相当紧凑的。其中 int 占4字节，double 占8字节，POJO多个一个字节的header，PojoSerializer只负责将header序列化进去，并委托每个字段对应的serializer对字段进行序列化。</p><p>Flink 的类型系统可以很轻松地扩展出自定义的TypeInformation、Serializer以及Comparator，来提升数据类型在序列化和比较时的性能。</p><h2 id="Flink-如何直接操作二进制数据"><a href="#Flink-如何直接操作二进制数据" class="headerlink" title="Flink 如何直接操作二进制数据"></a>Flink 如何直接操作二进制数据</h2><p>Flink 提供了如 group、sort、join 等操作，这些操作都需要访问海量数据。这里，我们以sort为例，这是一个在 Flink 中使用非常频繁的操作。</p><p>首先，Flink 会从 MemoryManager 中申请一批 MemorySegment，我们把这批 MemorySegment 称作 sort buffer，用来存放排序的数据。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjws4z21vij20jv0b2wev.jpg" alt="undefined"></p><p>我们会把 sort buffer 分成两块区域。一个区域是用来存放所有对象完整的二进制数据。另一个区域用来存放指向完整二进制数据的指针以及定长的序列化后的key（key+pointer）。如果需要序列化的key是个变长类型，如String，则会取其前缀序列化。如上图所示，当一个对象要加到 sort buffer 中时，它的二进制数据会被加到第一个区域，指针（可能还有key）会被加到第二个区域。</p><p>将实际的数据和指针加定长key分开存放有两个目的。第一，交换定长块（key+pointer）更高效，不用交换真实的数据也不用移动其他key和pointer。第二，这样做是缓存友好的，因为key都是连续存储在内存中的，可以大大减少 cache miss（后面会详细解释）。</p><p>排序的关键是比大小和交换。Flink 中，会先用 key 比大小，这样就可以直接用二进制的key比较而不需要反序列化出整个对象。因为key是定长的，所以如果key相同（或者没有提供二进制key），那就必须将真实的二进制数据反序列化出来，然后再做比较。之后，只需要交换key+pointer就可以达到排序的效果，真实的数据不用移动。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjwsnd19ebj20li0bkaak.jpg" alt="undefined"></p><p>最后，访问排序后的数据，可以沿着排好序的key+pointer区域顺序访问，通过pointer找到对应的真实数据，并写到内存或外部（更多细节可以看这篇文章 <a href="http://flink.apache.org/news/2015/03/13/peeking-into-Apache-Flinks-Engine-Room.html" target="_blank" rel="noopener">Joins in Flink</a>）。</p><h2 id="缓存友好的数据结构和算法"><a href="#缓存友好的数据结构和算法" class="headerlink" title="缓存友好的数据结构和算法"></a>缓存友好的数据结构和算法</h2><p>随着磁盘IO和网络IO越来越快，CPU逐渐成为了大数据领域的瓶颈。从 L1/L2/L3 缓存读取数据的速度比从主内存读取数据的速度快好几个量级。通过性能分析可以发现，CPU时间中的很大一部分都是浪费在等待数据从主内存过来上。如果这些数据可以从 L1/L2/L3 缓存过来，那么这些等待时间可以极大地降低，并且所有的算法会因此而受益。</p><p>在上面讨论中我们谈到的，Flink 通过定制的序列化框架将算法中需要操作的数据（如sort中的key）连续存储，而完整数据存储在其他地方。因为对于完整的数据来说，key+pointer更容易装进缓存，这大大提高了缓存命中率，从而提高了基础算法的效率。这对于上层应用是完全透明的，可以充分享受缓存友好带来的性能提升。</p><h2 id="走向堆外内存"><a href="#走向堆外内存" class="headerlink" title="走向堆外内存"></a>走向堆外内存</h2><p>Flink 基于堆内存的内存管理机制已经可以解决很多JVM现存问题了，为什么还要引入堆外内存？</p><ol><li>启动超大内存（上百GB）的JVM需要很长时间，GC停留时间也会很长（分钟级）。使用堆外内存的话，可以极大地减小堆内存（只需要分配Remaining Heap那一块），使得 TaskManager 扩展到上百GB内存不是问题。</li><li>高效的 IO 操作。堆外内存在写磁盘或网络传输时是 <code>zero-copy</code>，而堆内存的话，至少需要 copy 一次。</li><li>堆外内存是进程间共享的。也就是说，即使JVM进程崩溃也不会丢失数据。这可以用来做故障恢复（Flink暂时没有利用起这个，不过未来很可能会去做）。</li></ol><p>但是强大的东西总是会有其负面的一面，不然为何大家不都用堆外内存呢。</p><ol><li>堆内存的使用、监控、调试都要简单很多。堆外内存意味着更复杂更麻烦。</li><li>Flink 有时需要分配短生命周期的 <code>MemorySegment</code>，这个申请在堆上会更廉价。</li><li>有些操作在堆内存上会快一点点。</li></ol><p>Flink用通过<code>ByteBuffer.allocateDirect(numBytes)</code>来申请堆外内存，用 <code>sun.misc.Unsafe</code> 来操作堆外内存。</p><p>基于 Flink 优秀的设计，实现堆外内存是很方便的。Flink 将原来的 <code>MemorySegment</code> 变成了抽象类，并生成了两个子类。<code>HeapMemorySegment</code> 和 <code>HybridMemorySegment</code>。从字面意思上也很容易理解，前者是用来分配堆内存的，后者是用来分配堆外内存<strong>和堆内存</strong>的。是的，你没有看错，后者既可以分配堆外内存又可以分配堆内存。为什么要这样设计呢？</p><p>首先假设<code>HybridMemorySegment</code>只提供分配堆外内存。在上述堆外内存的不足中的第二点谈到，Flink 有时需要分配短生命周期的 buffer，这些buffer用<code>HeapMemorySegment</code>会更高效。那么当使用堆外内存时，为了也满足堆内存的需求，我们需要同时加载两个子类。这就涉及到了 JIT 编译优化的问题。因为以前 <code>MemorySegment</code> 是一个单独的 final 类，没有子类。JIT 编译时，所有要调用的方法都是确定的，所有的方法调用都可以被去虚化（de-virtualized）和内联（inlined），这可以极大地提高性能（MemroySegment的使用相当频繁）。然而如果同时加载两个子类，那么 JIT 编译器就只能在真正运行到的时候才知道是哪个子类，这样就无法提前做优化。实际测试的性能差距在 2.7 倍左右。</p><p>Flink 使用了两种方案：</p><p><strong>方案1：只能有一种 MemorySegment 实现被加载</strong></p><p>代码中所有的短生命周期和长生命周期的MemorySegment都实例化其中一个子类，另一个子类根本没有实例化过（使用工厂模式来控制）。那么运行一段时间后，JIT 会意识到所有调用的方法都是确定的，然后会做优化。</p><p><strong>方案2：提供一种实现能同时处理堆内存和堆外内存</strong></p><p>这就是 <code>HybridMemorySegment</code> 了，能同时处理堆与堆外内存，这样就不需要子类了。这里 Flink 优雅地实现了一份代码能同时操作堆和堆外内存。这主要归功于 <code>sun.misc.Unsafe</code>提供的一系列方法，如getLong方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Unsafe.getLong(Object reference, long offset)</span><br></pre></td></tr></table></figure><ul><li>如果reference不为空，则会取该对象的地址，加上后面的offset，从相对地址处取出8字节并得到 long。这对应了堆内存的场景。</li><li>如果reference为空，则offset就是要操作的绝对地址，从该地址处取出数据。这对应了堆外内存的场景。</li></ul><p>这里我们看下 <code>MemorySegment</code> 及其子类的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MemorySegment</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 堆内存引用</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] heapMemory;</span><br><span class="line">  <span class="comment">// 堆外内存地址</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> address;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//堆内存的初始化</span></span><br><span class="line">  MemorySegment(<span class="keyword">byte</span>[] buffer, Object owner) &#123;</span><br><span class="line">    <span class="comment">//一些先验检查</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.heapMemory = buffer;</span><br><span class="line">    <span class="keyword">this</span>.address = BYTE_ARRAY_BASE_OFFSET;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//堆外内存的初始化</span></span><br><span class="line">  MemorySegment(<span class="keyword">long</span> offHeapAddress, <span class="keyword">int</span> size, Object owner) &#123;</span><br><span class="line">    <span class="comment">//一些先验检查</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.heapMemory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.address = offHeapAddress;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> pos = address + index;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; pos &lt;= addressLimit - <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="comment">// 这是我们关注的地方，使用 Unsafe 来操作 on-heap &amp; off-heap</span></span><br><span class="line">      <span class="keyword">return</span> UNSAFE.getLong(heapMemory, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (address &gt; addressLimit) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"segment has been freed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// index is in fact invalid</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapMemorySegment</span> <span class="keyword">extends</span> <span class="title">MemorySegment</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指向heapMemory的额外引用，用来如数组越界的检查</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] memory;</span><br><span class="line">  <span class="comment">// 只能初始化堆内存</span></span><br><span class="line">  HeapMemorySegment(<span class="keyword">byte</span>[] memory, Object owner) &#123;</span><br><span class="line">    <span class="keyword">super</span>(Objects.requireNonNull(memory), owner);</span><br><span class="line">    <span class="keyword">this</span>.memory = memory;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HybridMemorySegment</span> <span class="keyword">extends</span> <span class="title">MemorySegment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer offHeapBuffer;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 堆外内存初始化</span></span><br><span class="line">  HybridMemorySegment(ByteBuffer buffer, Object owner) &#123;</span><br><span class="line">    <span class="keyword">super</span>(checkBufferAndGetAddress(buffer), buffer.capacity(), owner);</span><br><span class="line">    <span class="keyword">this</span>.offHeapBuffer = buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 堆内存初始化</span></span><br><span class="line">  HybridMemorySegment(<span class="keyword">byte</span>[] buffer, Object owner) &#123;</span><br><span class="line">    <span class="keyword">super</span>(buffer, owner);</span><br><span class="line">    <span class="keyword">this</span>.offHeapBuffer = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，HybridMemorySegment 中的很多方法其实都下沉到了父类去实现。包括堆内堆外内存的初始化。<code>MemorySegment</code> 中的 <code>getXXX</code>/<code>putXXX</code> 方法都是调用了 unsafe 方法，可以说<code>MemorySegment</code>已经具有了些 Hybrid 的意思了。<code>HeapMemorySegment</code>只调用了父类的<code>MemorySegment(byte[] buffer, Object owner)</code>方法，也就只能申请堆内存。另外，阅读代码你会发现，许多方法（大量的 getXXX/putXXX）都被标记成了 final，两个子类也是 final 类型，为的也是优化 JIT 编译器，会提醒 JIT 这个方法是可以被去虚化和内联的。</p><p>对于堆外内存，使用 <code>HybridMemorySegment</code> 能同时用来代表堆和堆外内存。这样只需要一个类就能代表长生命周期的堆外内存和短生命周期的堆内存。既然<code>HybridMemorySegment</code>已经这么全能，为什么还要方案1呢？因为我们需要工厂模式来保证只有一个子类被加载（为了更高的性能），而且HeapMemorySegment比heap模式的HybridMemorySegment要快。</p><p>下方是一些性能测试数据，更详细的数据请参考<a href="http://flink.apache.org/news/2015/09/16/off-heap-memory.html#appendix-detailed-micro-benchmarks" target="_blank" rel="noopener">这篇文章</a>。</p><table><thead><tr><th align="left">Segment</th><th align="left">Time</th></tr></thead><tbody><tr><td align="left">HeapMemorySegment, exclusive</td><td align="left">1,441 msecs</td></tr><tr><td align="left">HeapMemorySegment, mixed</td><td align="left">3,841 msecs</td></tr><tr><td align="left">HybridMemorySegment, heap, exclusive</td><td align="left">1,626 msecs</td></tr><tr><td align="left">HybridMemorySegment, off-heap, exclusive</td><td align="left">1,628 msecs</td></tr><tr><td align="left">HybridMemorySegment, heap, mixed</td><td align="left">3,848 msecs</td></tr><tr><td align="left">HybridMemorySegment, off-heap, mixed</td><td align="left">3,847 msecs</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要总结了 Flink 面对 JVM 存在的问题，而在内存管理的道路上越走越深。从自己管理内存，到序列化框架，再到堆外内存。其实纵观大数据生态圈，其实会发现各个开源项目都有同样的趋势。比如最近炒的很火热的 Spark Tungsten 项目，与 Flink 在内存管理上的思想是及其相似的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://flink.apache.org/news/2015/09/16/off-heap-memory.html" target="_blank" rel="noopener">Off-heap Memory in Apache Flink and the curious JIT compiler</a></li><li><a href="https://flink.apache.org/news/2015/05/11/Juggling-with-Bits-and-Bytes.html" target="_blank" rel="noopener">Juggling with Bits and Bytes</a></li><li><a href="https://flink.apache.org/news/2015/03/13/peeking-into-Apache-Flinks-Engine-Room.html" target="_blank" rel="noopener">Peeking into Apache Flink’s Engine Room</a></li><li><a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=53741525" target="_blank" rel="noopener">Flink: Memory Management</a></li><li><a href="http://www.bigsynapse.com/addressing-big-data-performance" target="_blank" rel="noopener">Big Data Performance Engineering</a></li><li><a href="http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/" target="_blank" rel="noopener">sun.misc.misc.Unsafe usage for C style memory management</a></li><li><a href="http://howtodoinjava.com/core-java/related-concepts/usage-of-class-sun-misc-unsafe/" target="_blank" rel="noopener">sun.misc.misc.Unsafe usage for C style memory management - How to do it.</a></li><li><a href="http://www.javamex.com/tutorials/memory/object_memory_usage.shtml" target="_blank" rel="noopener">Memory usage of Java objects: general guide</a></li><li><a href="http://www.36dsj.com/archives/33650" target="_blank" rel="noopener">脱离JVM？ Hadoop生态圈的挣扎与演化</a></li></ul><h1 id="Flink-内存设置思路"><a href="#Flink-内存设置思路" class="headerlink" title="Flink 内存设置思路"></a>Flink 内存设置思路</h1><p>Flink内存设置思路分为两个版本</p><p>分别是1.9之前和之后的</p><h2 id="Flink-lt-1-9"><a href="#Flink-lt-1-9" class="headerlink" title="Flink &lt;= 1.9"></a>Flink &lt;= 1.9</h2><p>这里用Flink1.8为例，计算内存的代码位于<code>org.apache.flink.runtime.clusterframework.ContaineredTaskManagerParameters</code>类的<code>create</code>方法。</p><p>按照计算步骤，以<code>taskmanager.heap.size=6g</code>为例子，其他参数保持不动，最终得到的参数如下：</p><p>​                        -Xms4148m -Xmx4148m  -XX:MaxDirectMemorySize=1996m</p><p>两块内存加起来是6144m = 6g jvm的设置符合参数。</p><p>Flink Dashboard上面显示的是：</p><p>​        JVM Heap Size：3.95 GB  Flink Managed Memory：2.74 GB</p><p>​        JVM (Heap/Non-Heap) Commit： Heap：3.95 GB Non-Heap：141 MB Total：4.09 GB</p><p>​        Outside JVM：Capacity：457 MB</p><p>​        NetWork: count: xxxxx</p><h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p>设容器内存总大小是x</p><p>详细看create方法：</p><pre><code>1.  cutoff：容器超过3g, 简单可以记成 0.25x. flink为了防止内存溢出，计算的时候先切了一块内存下来不参与后续计算，这块就是cutoff</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cutoff = Math.max(containerized.heap-cutoff-min, taskmanager.heap.size * containerized.heap-cutoff-ratio)</span><br></pre></td></tr></table></figure><p>默认值是600和0.25，所以6g的时候=Math.max(600, 6144*0.25) = 1536m</p><p>剩余大小 0.75x6g = 4608m</p><ol start="2"><li>networkBufMB：简单记成 0.75*0.1x，最大1g</li></ol><p>网络buffer使用内存分成新旧版，这里只关注新版，涉及参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">taskmanager.memory.segment-size：32kb</span><br><span class="line">taskmanager.network.memory.fraction：0.1</span><br><span class="line">taskmanager.network.memory.min：64mb</span><br><span class="line">taskmanager.network.memory.max：1g</span><br></pre></td></tr></table></figure><p>计算参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.min(taskmanager.network.memory.max，Math.max(taskmanager.network.memory.min, taskmanager.network.memory.fraction * (x - cutoff))</span><br></pre></td></tr></table></figure><p>这里的结果就是：Math.min(1g, Math.max(64mb, 0.1 * 4608m) = 460.8m</p><ol start="3"><li>heapSizeMB：0.75 * 0.9x</li></ol><p>taskmanager.memory.off-heap默认为false，主要指的是Flink Managed Memory使用Heap还是Non-heap，默认使用Heap，如果开启使用Non-heap将再减少一部分资源。</p><p>计算公式：<code>x - cutoff - networkBufMB</code></p><p>这里就是：4147.2　　　　（注意：这个就是-xmx 4148m）</p><p>​    4. offHeapSizeMB： x - heapSizeMB</p><p>就是1996m　　　　　　　(注意：这个就是XX:MaxDirectMemorySize: 1996m)</p><p>后续：上面只是一个jvm的参数预估设置，实际设置还与运行中环境有关，TaskManagerServices.fromConfiguration</p><p>会计算一个 freeHeapMemoryWithDefrag，计算之前会手动触发gc，然后用Jvm最大内存 - 总内存 + 空闲内存。</p><p>这个值可以认为是一个空运行的flink任务剩余的堆内存了。</p><p>后面将计算Flink管理的内存，这个指的是Flink Managed Memory Segment: taskmanager.memory.fraction默认是0.7，</p><p>被Flink管理的内存就是：freeHeapMemoryWithDefrag * 0.7</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk54bjvcx9j20ee0nkjvz.jpg" alt="undefined"></p><p>所以虽然6g内存计算出来后，heap是4148，但是在dashbord中显示不足4148, 为3.95G=4044.8, Flink managed内存小于 0.75<em>0.9</em>0.7 = 2903.04 , dashboard上显示2.74g = 2805.76m</p><p>框架运行需要：4148 - 4044.8 = 103.2m，3.95 * 0.7 = 2.765 &gt; 2.74。没有相等，其他的内存使用暂时没有探究了。</p><p>Flink Managed内存一般用于批处理作业，流处理作业可以调整 taskmanager.memory.fraction，使得这部分内存用于用户代码。</p><p>Non - heap空间一般用于 JVM 的栈空间、方法区等堆外开销外，还包括网络 buffer、batch 缓存、RocksDB</p><h2 id="Flink-gt-1-10"><a href="#Flink-gt-1-10" class="headerlink" title="Flink &gt;= 1.10"></a>Flink &gt;= 1.10</h2><p>Flink后面内存进行了较大的变动，也就是说之前上面云邪写的内存管理已经过时了</p><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/zh/ops/memory/mem_migration.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.10/zh/ops/memory/mem_migration.html</a></p><p>这里设置单个taskmanager为14g，taskmanager.memory.managed.fraction为0.5，将会得到以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xmx5721030656  = 5456MB = 5.328g</span><br><span class="line">-=1207959552  = 1152MB = 1.125g</span><br><span class="line">-XX:MaxMetaspaceSize=100663296 = 96MB</span><br></pre></td></tr></table></figure><p>可以发现，上面的加起来等于6704MB，远远不足14g，和1.8版本有很大的不同。</p><p>再看dashboard：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JVM Heap Size：5.19 GB   Flink Managed Memory：6.45 GB</span><br><span class="line">JVM (Heap/Non-Heap) ： Heap：5.19 GB  Non-Heap：1.33 GB  Total：6.52 GB</span><br><span class="line">Outside JVM：Capacity：1.01GB</span><br><span class="line">NetWork: count:  xxxxx</span><br></pre></td></tr></table></figure><p>可以计算得到6.45+6.52+1.01 = 13.98 等于14</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">taskmanager.memory.process.size 设置的是容器的内存大小，等于之前的 taskmanager.heap.size</span><br><span class="line"></span><br><span class="line">计算过程在org.apache.flink.runtime.clusterframework.TaskExecutorProcessUtils中processSpecFromConfig方法，TaskExecutorProcessSpec类展示了1.10版本整个内存的组成。</span><br><span class="line"></span><br><span class="line">计算方法分成3种：</span><br><span class="line">1.指定了taskmanager.memory.task.heap.size和taskmanager.memory.managed.size   </span><br><span class="line">见方法：deriveProcessSpecWithExplicitTaskAndManagedMemory</span><br><span class="line">2.指定了taskmanager.memory.flink.size  </span><br><span class="line">见方法：deriveProcessSpecWithTotalFlinkMemory</span><br><span class="line">3.指定了taskmanager.memory.process.size（容器环境一般指定这个，决定全局容量）</span><br><span class="line">totalProcessMemorySize = 设置的值 14g,   jvmMetaspaceSize = taskmanager.memory.jvm-metaspace.size,默认96m,这个对应参数-XX:MaxMetaspaceSize=100663296。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jvmOverheadSize：</span><br><span class="line"></span><br><span class="line">taskmanager.memory.jvm-overhead.min  192m</span><br><span class="line">taskmanager.memory.jvm-overhead.max 1g</span><br><span class="line">taskmanager.memory.jvm-overhead.fraction 0.1</span><br></pre></td></tr></table></figure><p>公式 14g * 0.1 = 1.4g 必须在[192m, 1g]之间，所以jvmOverheadSize的大小是1g</p><p>totalFlinkMemorySize = 14g - 1g - 96m = 13216m</p><p>frameworkHeapMemorySize：taskmanager.memory.framework.heap.size 默认128m</p><p>frameworkOffHeapMemorySize：taskmanager.memory.framework.off-heap.size 默认128m</p><p>taskOffHeapMemorySize：taskmanager.memory.task.off-heap.size 默认0</p><p>确定好上面这些参数后，就是最重要的三个指标的计算了：</p><p>taskHeapMemorySize，networkMemorySize，managedMemorySize</p><p>计算分成确定了：taskmanager.memory.task.heap.size还是没确定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">确定了taskmanager.memory.task.heap.size</span><br><span class="line">taskHeapMemorySize = 设置值</span><br><span class="line">managedMemorySize = 设置了使用设置值，否则使用 0.4 * totalFlinkMemorySize</span><br><span class="line">如果 taskHeapMemorySize + taskOffHeapMemorySize + frameworkHeapMemorySize + frameworkOffHeapMemorySize + managedMemorySize &gt; totalFlinkMemorySize异常</span><br><span class="line">networkMemorySize 等于剩余的大小，之后还会check这块内存是否充足，可以自己查看对应代码</span><br><span class="line">未设置heap大小</span><br><span class="line">先确定 managedMemorySize = 设置了使用设置值，否则使用 0.4 * totalFlinkMemorySize，这里就是 0.5 * 13216m = 6608 = 6.45g (这里就是dashboard的显示内容)</span><br><span class="line">再确定network buffer大小，这个也是有两种情况，不细说。 [64mb, 1g] 0.1 * totalFlinkMemorySize = 1321.6, 所以是1g</span><br><span class="line">最后剩余的就是taskHeapMemorySize,不能为负数，这里等于  13216 - 6608 - 1024 - 128 - 128 = 5328 = 5.2g (这里约等于dashboard的显示heap大小)</span><br><span class="line">最后jvm的参数的计算过程：</span><br><span class="line">jvmHeapSize = frameworkHeapSize + taskHeapSize = 5328 + 128 = 5456</span><br><span class="line">jvmDirectSize = frameworkOffHeapMemorySize + taskOffHeapSize + networkMemSize = 128 + 1024 = 1152</span><br><span class="line">jvmMetaspaceSize = 96m</span><br></pre></td></tr></table></figure><h3 id="全新内存划分"><a href="#全新内存划分" class="headerlink" title="全新内存划分"></a>全新内存划分</h3><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/ops/memory/mem_detail.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.10/ops/memory/mem_detail.html</a></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk54yygegpj20iw0yota9.jpg" alt="undefined"></p><p>从计算过程，结合上图可以看出Flink 1.10中的一个内存划分了。</p><p>总内存 = Flink 内存 + JVM Metaspace （96m）+ JVM Overhead （计算为0.1 * 全局大小，结果必须在[192m, 1g]之间）</p><p>Flink内存被划分成6部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">框架运行需要的Heap和Non Heap，默认都是128m</span><br><span class="line">任务需要的Heap和Non Heap(默认0), Heap是通过计算其他5部分内存，Flink内存剩余得到</span><br><span class="line">网络缓冲 (0.1 * Flink内存，结果必须在[64mb, 1g]之间）</span><br><span class="line">Flink管理内存：0.4 * Flink内存</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Flink 1.10之前对内存的划分比较简单，主要就是Heap + Non-Heap，之后对内存做了更细致的切分。</p><p>Flink 1.8可以调整taskmanager.memory.fraction 减少Heap中的管理的内存，增大用户代码的内存使用，调整containerized.heap-cutoff-ratio，控制Non-heap空间，这个影响rocksdb。</p><p>Flink 1.10可以调整taskmanager.memory.managed.fraction 控制managed内存，这个影响rocksdb，也会影响taskHeap大小，需要衡量。</p><p>也可以看到Flink内存模型的变化managed内存位置也发生了变化，作用也有了些许变化。</p><p>JVM 主要划分 Heap 和 Non-Heap，Non-Heap又划分为Direct和Native等。</p><p>1.8的Non-Heap都是通过XX:MaxDirectMemorySize设置的</p><p>1.10的Network buffer在Direct里面，另一部分是Native(包括Managed Memory)，主要用于rocksdb，如果使用的是Heap状态后台，可以设置小点，也用于Batch。</p><h1 id="多流合并"><a href="#多流合并" class="headerlink" title="多流合并"></a>多流合并</h1><p>遇到了一个多流合并的问题，目前给出的方案是：</p><ol><li><p>分析业务数据源，很多需要多个流的join的场景 是伪命题，用union即可。</p></li><li><p>union + group by ，在基于key的流中可以取代join。优势： 在join 发生数据倾斜或者反压，很难 checkpoint时，用union可以回避这个问题。</p></li><li><p>例如三个流join，可以 tempstream = stream1.join(stream2)  ResultStream = tempstream.join(stream3)。语法支持，看了下生成的图，不确定是不是想要的效果。</p></li><li><p>将第三点的 join 换成 cogroup操作。这个是社区直播中，提问多流join后  得到的回复</p></li><li><p>基于blink引擎，多表join 直接用sql表达出来。select * from table1 a left join table2 b on a.id = b.id left join table3 c on b.id = c.id 这个方案也是在社区直播，提问多流join后 得到的回复。</p></li></ol><p>SQL暂时是不用的，那么只剩下了第一种。</p><p>我尝试拆分一下逻辑。</p><h1 id="Flink-的算子链机制"><a href="#Flink-的算子链机制" class="headerlink" title="Flink 的算子链机制"></a>Flink 的算子链机制</h1><p>“为什么我的 Flink 作业 Web UI 中只显示出了一个框，并且 Records Sent 和Records Received 指标都是 0 ？是我的程序写得有问题吗？”</p><p>在 Flink 社区群里经常能看到类似这样的疑问。这种情况几乎都不是程序有问题，而是因为 Flink 的 operator chain ——即算子链机制导致的，即提交的作业的执行计划中，所有算子的并发实例（即 sub-task ）都因为满足特定条件而串成了整体来执行，自然就观察不到算子之间的数据流量了。</p><p>当然上述是一种特殊情况。我们更常见到的是只有部分算子得到了算子链机制的优化，如官方文档中出现过多次的下图所示，注意 Source 和 map() 算子。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkmcz3c92rj20u00ki0z9.jpg" alt="undefined"></p><p>算子链机制的好处是显而易见的：<strong>所有 chain 在一起的 sub-task 都会在同一个线程（即 TaskManager 的 slot）中执行，能够减少不必要的数据交换、序列化和上下文切换，从而提高作业的执行效率。</strong></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkmd1v7t1nj20u009rjua.jpg" alt="undefined"></p><h2 id="逻辑计划中的算子链"><a href="#逻辑计划中的算子链" class="headerlink" title="逻辑计划中的算子链"></a>逻辑计划中的算子链</h2><p>对 Flink Runtime 稍有了解的看官应该知道，Flink 作业的执行计划会用三层图结构来表示，即：</p><ul><li>StreamGraph —— 原始逻辑执行计划</li><li>JobGraph —— 优化的逻辑执行计划（Web UI 中看到的就是这个）</li><li>ExecutionGraph —— 物理执行计划</li></ul><p>算子链是在优化逻辑计划时加入的，也就是由 StreamGraph 生成 JobGraph 的过程中。那么我们来到负责生成 JobGraph 的 o.a.f.streaming.api.graph.StreamingJobGraphGenerator 类，查看其核心方法 createJobGraph() 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> JobGraph <span class="title">createJobGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// make sure that all vertices start immediately</span></span><br><span class="line">    jobGraph.setScheduleMode(streamGraph.getScheduleMode());</span><br><span class="line">    <span class="comment">// Generate deterministic hashes for the nodes in order to identify them across</span></span><br><span class="line">    <span class="comment">// submission iff they didn't change.</span></span><br><span class="line">    Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes = defaultStreamGraphHasher.traverseStreamGraphAndGenerateHashes(streamGraph);</span><br><span class="line">    <span class="comment">// Generate legacy version hashes for backwards compatibility</span></span><br><span class="line">    List&lt;Map&lt;Integer, <span class="keyword">byte</span>[]&gt;&gt; legacyHashes = <span class="keyword">new</span> ArrayList&lt;&gt;(legacyStreamGraphHashers.size());</span><br><span class="line">    <span class="keyword">for</span> (StreamGraphHasher hasher : legacyStreamGraphHashers) &#123;</span><br><span class="line">        legacyHashes.add(hasher.traverseStreamGraphAndGenerateHashes(streamGraph));</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; chainedOperatorHashes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    setChaining(hashes, legacyHashes, chainedOperatorHashes);</span><br><span class="line"></span><br><span class="line">    setPhysicalEdges();</span><br><span class="line">    <span class="comment">// 略......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jobGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，该方法会先计算出 StreamGraph 中各个节点的哈希码作为唯一标识，并创建一个空的 Map 结构保存即将被链在一起的算子的哈希码，然后调用 setChaining() 方法，如下源码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChaining</span><span class="params">(Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes, List&lt;Map&lt;Integer, <span class="keyword">byte</span>[]&gt;&gt; legacyHashes, Map&lt;Integer, List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; chainedOperatorHashes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer sourceNodeId : streamGraph.getSourceIDs()) &#123;</span><br><span class="line">        createChain(sourceNodeId, sourceNodeId, hashes, legacyHashes, <span class="number">0</span>, chainedOperatorHashes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见是逐个遍历 StreamGraph 中的 Source 节点，并调用 createChain() 方法。createChain() 是逻辑计划层创建算子链的核心方法，完整源码如下，有点长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;StreamEdge&gt; <span class="title">createChain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Integer startNodeId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Integer currentNodeId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;Map&lt;Integer, <span class="keyword">byte</span>[]&gt;&gt; legacyHashes,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> chainIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;Integer, List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; chainedOperatorHashes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!builtVertices.contains(startNodeId)) &#123;</span><br><span class="line">        List&lt;StreamEdge&gt; transitiveOutEdges = <span class="keyword">new</span> ArrayList&lt;StreamEdge&gt;();</span><br><span class="line">        List&lt;StreamEdge&gt; chainableOutputs = <span class="keyword">new</span> ArrayList&lt;StreamEdge&gt;();</span><br><span class="line">        List&lt;StreamEdge&gt; nonChainableOutputs = <span class="keyword">new</span> ArrayList&lt;StreamEdge&gt;();</span><br><span class="line"></span><br><span class="line">        StreamNode currentNode = streamGraph.getStreamNode(currentNodeId);</span><br><span class="line">        <span class="keyword">for</span> (StreamEdge outEdge : currentNode.getOutEdges()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isChainable(outEdge, streamGraph)) &#123;</span><br><span class="line">                chainableOutputs.add(outEdge);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nonChainableOutputs.add(outEdge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (StreamEdge chainable : chainableOutputs) &#123;</span><br><span class="line">            transitiveOutEdges.addAll(</span><br><span class="line">                    createChain(startNodeId, chainable.getTargetId(), hashes, legacyHashes, chainIndex + <span class="number">1</span>, chainedOperatorHashes));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (StreamEdge nonChainable : nonChainableOutputs) &#123;</span><br><span class="line">            transitiveOutEdges.add(nonChainable);</span><br><span class="line">            createChain(nonChainable.getTargetId(), nonChainable.getTargetId(), hashes, legacyHashes, <span class="number">0</span>, chainedOperatorHashes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt; operatorHashes =</span><br><span class="line">            chainedOperatorHashes.computeIfAbsent(startNodeId, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] primaryHashBytes = hashes.get(currentNodeId);</span><br><span class="line">        OperatorID currentOperatorId = <span class="keyword">new</span> OperatorID(primaryHashBytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map&lt;Integer, <span class="keyword">byte</span>[]&gt; legacyHash : legacyHashes) &#123;</span><br><span class="line">            operatorHashes.add(<span class="keyword">new</span> Tuple2&lt;&gt;(primaryHashBytes, legacyHash.get(currentNodeId)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chainedNames.put(currentNodeId, createChainedName(currentNodeId, chainableOutputs));</span><br><span class="line">        chainedMinResources.put(currentNodeId, createChainedMinResources(currentNodeId, chainableOutputs));</span><br><span class="line">        chainedPreferredResources.put(currentNodeId, createChainedPreferredResources(currentNodeId, chainableOutputs));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode.getInputFormat() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getOrCreateFormatContainer(startNodeId).addInputFormat(currentOperatorId, currentNode.getInputFormat());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.getOutputFormat() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getOrCreateFormatContainer(startNodeId).addOutputFormat(currentOperatorId, currentNode.getOutputFormat());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StreamConfig config = currentNodeId.equals(startNodeId)</span><br><span class="line">                ? createJobVertex(startNodeId, hashes, legacyHashes, chainedOperatorHashes)</span><br><span class="line">                : <span class="keyword">new</span> StreamConfig(<span class="keyword">new</span> Configuration());</span><br><span class="line"></span><br><span class="line">        setVertexConfig(currentNodeId, config, chainableOutputs, nonChainableOutputs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNodeId.equals(startNodeId)) &#123;</span><br><span class="line">            config.setChainStart();</span><br><span class="line">            config.setChainIndex(<span class="number">0</span>);</span><br><span class="line">            config.setOperatorName(streamGraph.getStreamNode(currentNodeId).getOperatorName());</span><br><span class="line">            config.setOutEdgesInOrder(transitiveOutEdges);</span><br><span class="line">            config.setOutEdges(streamGraph.getStreamNode(currentNodeId).getOutEdges());</span><br><span class="line">            <span class="keyword">for</span> (StreamEdge edge : transitiveOutEdges) &#123;</span><br><span class="line">                connect(startNodeId, edge);</span><br><span class="line">            &#125;</span><br><span class="line">            config.setTransitiveChainedTaskConfigs(chainedConfigs.get(startNodeId));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chainedConfigs.computeIfAbsent(startNodeId, k -&gt; <span class="keyword">new</span> HashMap&lt;Integer, StreamConfig&gt;());</span><br><span class="line">            config.setChainIndex(chainIndex);</span><br><span class="line">            StreamNode node = streamGraph.getStreamNode(currentNodeId);</span><br><span class="line">            config.setOperatorName(node.getOperatorName());</span><br><span class="line">            chainedConfigs.get(startNodeId).put(currentNodeId, config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        config.setOperatorID(currentOperatorId);</span><br><span class="line">        <span class="keyword">if</span> (chainableOutputs.isEmpty()) &#123;</span><br><span class="line">            config.setChainEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transitiveOutEdges;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先解释一下方法开头创建的 3 个 List 结构：</p><ul><li>transitiveOutEdges：当前算子链在 JobGraph 中的出边列表，同时也是 createChain() 方法的最终返回值；</li><li>chainableOutputs：当前能够链在一起的 StreamGraph 边列表；</li><li>nonChainableOutputs：当前不能够链在一起的 StreamGraph 边列表。</li></ul><p>接下来，从 Source 开始遍历 StreamGraph 中当前节点的所有出边，调用 isChainable() 方法判断是否可以被链在一起（这个判断逻辑稍后会讲到）。可以链接的出边被放入 chainableOutputs 列表，否则放入 nonChainableOutputs 列表。</p><p>对于 chainableOutputs 中的边，就会以这些边的直接下游为起点，继续递归调用createChain() 方法延展算子链。对于 nonChainableOutputs 中的边，由于当前算子链的延展已经到头，就会以这些“断点”为起点，继续递归调用 createChain() 方法试图创建新的算子链。也就是说，逻辑计划中整个创建算子链的过程都是递归的，亦即实际返回时，是从 Sink 端开始返回的。</p><p>然后要判断当前节点是不是算子链的起始节点。如果是，则调用 createJobVertex()方法为算子链创建一个 JobVertex（ 即 JobGraph 中的节点），也就形成了我们在Web UI 中看到的 JobGraph 效果：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1gkmd8wroh7j20u00ezgp1.jpg" alt="undefined"></p><p>最后，还需要将各个节点的算子链数据写入各自的 StreamConfig 中，算子链的起始节点要额外保存下 transitiveOutEdges。StreamConfig 在后文的物理执行阶段会再次用到。</p><h2 id="形成算子链的条件"><a href="#形成算子链的条件" class="headerlink" title="形成算子链的条件"></a>形成算子链的条件</h2><p>来看看 isChainable() 方法的代码。 由此可得，上下游算子能够 chain 在一起的条件还是非常苛刻的（老生常谈了），列举如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChainable</span><span class="params">(StreamEdge edge, StreamGraph streamGraph)</span> </span>&#123;</span><br><span class="line">    StreamNode upStreamVertex = streamGraph.getSourceVertex(edge);</span><br><span class="line">    StreamNode downStreamVertex = streamGraph.getTargetVertex(edge);</span><br><span class="line"></span><br><span class="line">    StreamOperatorFactory&lt;?&gt; headOperator = upStreamVertex.getOperatorFactory();</span><br><span class="line">    StreamOperatorFactory&lt;?&gt; outOperator = downStreamVertex.getOperatorFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> downStreamVertex.getInEdges().size() == <span class="number">1</span></span><br><span class="line">            &amp;&amp; outOperator != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; headOperator != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; upStreamVertex.isSameSlotSharingGroup(downStreamVertex)</span><br><span class="line">            &amp;&amp; outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS</span><br><span class="line">            &amp;&amp; (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||</span><br><span class="line">                headOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)</span><br><span class="line">            &amp;&amp; (edge.getPartitioner() <span class="keyword">instanceof</span> ForwardPartitioner)</span><br><span class="line">            &amp;&amp; edge.getShuffleMode() != ShuffleMode.BATCH</span><br><span class="line">            &amp;&amp; upStreamVertex.getParallelism() == downStreamVertex.getParallelism()</span><br><span class="line">            &amp;&amp; streamGraph.isChainingEnabled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上下游算子实例处于同一个 SlotSharingGroup 中（之后再提）；</p></li><li><p>下游算子的链接策略（ChainingStrategy）为 ALWAYS ——既可以与上游链接，也可以与下游链接。我们常见的 map()、filter() 等都属此类；</p></li><li><p>上游算子的链接策略为 HEAD 或 ALWAYS。HEAD 策略表示只能与下游链接，这在正常情况下是 Source 算子的专属；</p></li><li><p>两个算子间的物理分区逻辑是 ForwardPartitioner ，可参见之前写过的《聊聊Flink DataStream 的八种物理分区逻辑》；</p></li><li><p>两个算子间的 shuffle 方式不是批处理模式；</p></li><li><p>上下游算子实例的并行度相同；</p></li><li><p>没有禁用算子链。</p></li></ul><h2 id="禁用算子链"><a href="#禁用算子链" class="headerlink" title="禁用算子链"></a>禁用算子链</h2><p>用户可以在一个算子上调用 startNewChain() 方法强制开始一个新的算子链，或者调用 disableOperatorChaining() 方法指定它不参与算子链。代码位于 SingleOutputStreamOperator 类中，都是通过改变算子的链接策略实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@PublicEvolving</span><br><span class="line">public SingleOutputStreamOperator&lt;T&gt; disableChaining() &#123;</span><br><span class="line">    return setChainingStrategy(ChainingStrategy.NEVER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@PublicEvolving</span><br><span class="line">public SingleOutputStreamOperator&lt;T&gt; startNewChain() &#123;</span><br><span class="line">    return setChainingStrategy(ChainingStrategy.HEAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要在整个运行时环境中禁用算子链，调用 StreamExecutionEnvironment.disableOperatorChaining() 方法即可。</p><h2 id="物理计划中的算子链"><a href="#物理计划中的算子链" class="headerlink" title="物理计划中的算子链"></a>物理计划中的算子链</h2><p>在 JobGraph 转换成 ExecutionGraph 并交由 TaskManager 执行之后，会生成调度执行的基本任务单元 ——StreamTask，负责执行具体的 StreamOperator 逻辑。在StreamTask.invoke() 方法中，初始化了状态后端、checkpoint 存储和定时器服务之后，可以发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">operatorChain = new OperatorChain&lt;&gt;(this, recordWriters);</span><br><span class="line">headOperator = operatorChain.getHeadOperator();</span><br></pre></td></tr></table></figure><p>构造出了一个 OperatorChain 实例，这就是算子链在实际执行时的形态。解释一下OperatorChain 中的几个主要属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final StreamOperator&lt;?&gt;[] allOperators;</span><br><span class="line">private final RecordWriterOutput&lt;?&gt;[] streamOutputs;</span><br><span class="line">private final WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; chainEntryPoint;</span><br><span class="line">private final OP headOperator;</span><br></pre></td></tr></table></figure><ul><li>headOperator：算子链的第一个算子，对应 JobGraph 中的算子链起始节点；</li><li>allOperators：算子链中的所有算子，倒序排列，即 headOperator 位于该数组的末尾；</li><li>streamOutputs：算子链的输出，可以有多个；</li><li>chainEntryPoint：算子链的“入口点”，它的含义将在后文说明。</li></ul><p>由上可知，所有 StreamTask 都会创建 OperatorChain。如果一个算子无法进入算子链，也会形成一个只有 headOperator 的单个算子的 OperatorChain。</p><p>OperatorChain 构造方法中的核心代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; outEdgesInOrder.size(); i++) &#123;</span><br><span class="line">    StreamEdge outEdge = outEdgesInOrder.get(i);</span><br><span class="line">    RecordWriterOutput&lt;?&gt; streamOutput = createStreamOutput(</span><br><span class="line">        recordWriters.get(i),</span><br><span class="line">        outEdge,</span><br><span class="line">        chainedConfigs.get(outEdge.getSourceId()),</span><br><span class="line">        containingTask.getEnvironment());</span><br><span class="line">    this.streamOutputs[i] = streamOutput;</span><br><span class="line">    streamOutputMap.put(outEdge, streamOutput);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// we create the chain of operators and grab the collector that leads into the chain</span><br><span class="line">List&lt;StreamOperator&lt;?&gt;&gt; allOps = new ArrayList&lt;&gt;(chainedConfigs.size());</span><br><span class="line">this.chainEntryPoint = createOutputCollector(</span><br><span class="line">    containingTask,</span><br><span class="line">    configuration,</span><br><span class="line">    chainedConfigs,</span><br><span class="line">    userCodeClassloader,</span><br><span class="line">    streamOutputMap,</span><br><span class="line">    allOps);</span><br><span class="line"></span><br><span class="line">if (operatorFactory != null) &#123;</span><br><span class="line">    WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; output = getChainEntryPoint();</span><br><span class="line">    headOperator = operatorFactory.createStreamOperator(containingTask, configuration, output);</span><br><span class="line">    headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_OUTPUT_WATERMARK, output.getWatermarkGauge());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    headOperator = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// add head operator to end of chain</span><br><span class="line">allOps.add(headOperator);</span><br><span class="line">this.allOperators = allOps.toArray(new StreamOperator&lt;?&gt;[allOps.size()]);</span><br></pre></td></tr></table></figure><p>首先会遍历算子链整体的所有出边，并调用 createStreamOutput() 方法创建对应的下游输出 RecordWriterOutput。然后就会调用 createOutputCollector() 方法创建物理的算子链，并返回 chainEntryPoint，这个方法比较重要，部分代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt; createOutputCollector(</span><br><span class="line">        StreamTask&lt;?, ?&gt; containingTask,</span><br><span class="line">        StreamConfig operatorConfig,</span><br><span class="line">        Map&lt;Integer, StreamConfig&gt; chainedConfigs,</span><br><span class="line">        ClassLoader userCodeClassloader,</span><br><span class="line">        Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputs,</span><br><span class="line">        List&lt;StreamOperator&lt;?&gt;&gt; allOperators) &#123;</span><br><span class="line">    List&lt;Tuple2&lt;WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt;, StreamEdge&gt;&gt; allOutputs = new ArrayList&lt;&gt;(4);</span><br><span class="line"></span><br><span class="line">    // create collectors for the network outputs</span><br><span class="line">    for (StreamEdge outputEdge : operatorConfig.getNonChainedOutputs(userCodeClassloader)) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        RecordWriterOutput&lt;T&gt; output = (RecordWriterOutput&lt;T&gt;) streamOutputs.get(outputEdge);</span><br><span class="line">        allOutputs.add(new Tuple2&lt;&gt;(output, outputEdge));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Create collectors for the chained outputs</span><br><span class="line">    for (StreamEdge outputEdge : operatorConfig.getChainedOutputs(userCodeClassloader)) &#123;</span><br><span class="line">        int outputId = outputEdge.getTargetId();</span><br><span class="line">        StreamConfig chainedOpConfig = chainedConfigs.get(outputId);</span><br><span class="line">        WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt; output = createChainedOperator(</span><br><span class="line">            containingTask,</span><br><span class="line">            chainedOpConfig,</span><br><span class="line">            chainedConfigs,</span><br><span class="line">            userCodeClassloader,</span><br><span class="line">            streamOutputs,</span><br><span class="line">            allOperators,</span><br><span class="line">            outputEdge.getOutputTag());</span><br><span class="line">        allOutputs.add(new Tuple2&lt;&gt;(output, outputEdge));</span><br><span class="line">    &#125;</span><br><span class="line">    // 以下略......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法从上一节提到的 StreamConfig 中分别取出出边和链接边的数据，并创建各自的 Output。出边的 Output 就是将数据发往算子链之外下游的 RecordWriterOutput，而链接边的输出要靠 createChainedOperator() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private &lt;IN, OUT&gt; WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; createChainedOperator(</span><br><span class="line">        StreamTask&lt;?, ?&gt; containingTask,</span><br><span class="line">        StreamConfig operatorConfig,</span><br><span class="line">        Map&lt;Integer, StreamConfig&gt; chainedConfigs,</span><br><span class="line">        ClassLoader userCodeClassloader,</span><br><span class="line">        Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputs,</span><br><span class="line">        List&lt;StreamOperator&lt;?&gt;&gt; allOperators,</span><br><span class="line">        OutputTag&lt;IN&gt; outputTag) &#123;</span><br><span class="line">    // create the output that the operator writes to first. this may recursively create more operators</span><br><span class="line">    WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; chainedOperatorOutput = createOutputCollector(</span><br><span class="line">        containingTask,</span><br><span class="line">        operatorConfig,</span><br><span class="line">        chainedConfigs,</span><br><span class="line">        userCodeClassloader,</span><br><span class="line">        streamOutputs,</span><br><span class="line">        allOperators);</span><br><span class="line"></span><br><span class="line">    // now create the operator and give it the output collector to write its output to</span><br><span class="line">    StreamOperatorFactory&lt;OUT&gt; chainedOperatorFactory = operatorConfig.getStreamOperatorFactory(userCodeClassloader);</span><br><span class="line">    OneInputStreamOperator&lt;IN, OUT&gt; chainedOperator = chainedOperatorFactory.createStreamOperator(</span><br><span class="line">            containingTask, operatorConfig, chainedOperatorOutput);</span><br><span class="line"></span><br><span class="line">    allOperators.add(chainedOperator);</span><br><span class="line"></span><br><span class="line">    WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; currentOperatorOutput;</span><br><span class="line">    if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">        currentOperatorOutput = new ChainingOutput&lt;&gt;(chainedOperator, this, outputTag);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        TypeSerializer&lt;IN&gt; inSerializer = operatorConfig.getTypeSerializerIn1(userCodeClassloader);</span><br><span class="line">        currentOperatorOutput = new CopyingChainingOutput&lt;&gt;(chainedOperator, inSerializer, outputTag, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // wrap watermark gauges since registered metrics must be unique</span><br><span class="line">    chainedOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, currentOperatorOutput.getWatermarkGauge()::getValue);</span><br><span class="line">    chainedOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_OUTPUT_WATERMARK, chainedOperatorOutput.getWatermarkGauge()::getValue);</span><br><span class="line">    return currentOperatorOutput;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一眼就可以看到，这个方法递归调用了上述 createOutputCollector() 方法，与逻辑计划阶段类似，通过不断延伸 Output 来产生 chainedOperator（即算子链中除了headOperator 之外的算子），并逆序返回，这也是 allOperators 数组中的算子顺序为倒序的原因。</p><p>chainedOperator 产生之后，将它们通过 ChainingOutput 连接起来，形成如下图所示的结构。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1gkmdb2gkhoj20u00fjwgy.jpg" alt="undefined"></p><p>最后来看看 ChainingOutput.collect() 方法是如何输出数据流的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void collect(StreamRecord&lt;T&gt; record) &#123;</span><br><span class="line">    if (this.outputTag != null) &#123;</span><br><span class="line">        // we are only responsible for emitting to the main input</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    pushToOperator(record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;X&gt; void collect(OutputTag&lt;X&gt; outputTag, StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">    if (this.outputTag == null || !this.outputTag.equals(outputTag)) &#123;</span><br><span class="line">        // we are only responsible for emitting to the side-output specified by our</span><br><span class="line">        // OutputTag.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    pushToOperator(record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // we know that the given outputTag matches our OutputTag so the record</span><br><span class="line">        // must be of the type that our operator expects.</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        StreamRecord&lt;T&gt; castRecord = (StreamRecord&lt;T&gt;) record;</span><br><span class="line">        numRecordsIn.inc();</span><br><span class="line">        operator.setKeyContextElement1(castRecord);</span><br><span class="line">        operator.processElement(castRecord);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e) &#123;</span><br><span class="line">        throw new ExceptionInChainedOperatorException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见是通过调用链接算子的 processElement() 方法，直接将数据推给下游处理了。也就是说，OperatorChain 完全可以看做一个由 headOperator 和 streamOutputs组成的单个算子，其内部的 chainedOperator 和 ChainingOutput 都像是被黑盒遮蔽，同时没有引入任何 overhead。</p><p>打通了算子链在执行层的逻辑，看官应该会明白 chainEntryPoint 的含义了。由于它位于递归返回的终点，所以它就是流入算子链的起始 Output，即上图中指向 headOperator 的 RecordWriterOutput。</p><h1 id="Flink-Stream-类型转换"><a href="#Flink-Stream-类型转换" class="headerlink" title="Flink Stream 类型转换"></a>Flink Stream 类型转换</h1><blockquote><p>1.Map[DataStream -&gt; DataStream]<br>调用用户定义的MapFunction对DataStream[T]数据进行处理，形成新的DataStream[T]，其中<strong>数据格式可能会发生变化</strong>,常用作对数据集内数据的清洗和转换。</p></blockquote><blockquote><p>2.FlatMap[DataStream -&gt; DataStream]<br>主要对输入的元素处理之后生成一个或者多个元素</p></blockquote><blockquote><p> 3.Filter[DataStream -&gt; DataStream]<br>该算子将按照条件对输入数据集进行筛选操作，将符合条件的数据集输出，将不符合条件的数据过滤掉</p></blockquote><blockquote><p>4.KeyBy[DataStream -&gt; KeyedStream]<br>该算子根据指定的key将输入的DataStream[T]数据格式转换为KeyedStream[T]，也就是在数据集中执行Partition操作，将相同的key值的数据放置在相同的分区中。简单来说，就是sql里面的group by</p></blockquote><blockquote><p>5.Reduce[KeyedStream -&gt; DataStream]<br>该算子和MapReduce的Reduce原理基本一致，主要目的是将输入的KeyedStream通过传入的用户自定义的ReduceFunction滚动的进行数据聚合处理，其中定义的ReduceFunction必须满足运算结合律和交换律</p></blockquote><blockquote><p>6.Union[DataStream -&gt; DataStream]<br>将两个或者多个输入的数据集合并成一个数据集，需要保证两个数据集的格式一致，输出的数据集的格式和输入的数据集格式保持一致</p></blockquote><blockquote><p>7.Connect, CoMap, CoFlatMap[DataStream -&gt; DataStream]<br>Connect算子主要是为了合并两种后者多种不同数据类型的数据集，合并后悔保留原来的数据集的数据类型。连接操作允许共享状态数据，也就是说在多个数据集之间可以操作和查看对方数据集的状态。</p></blockquote><blockquote><p>8.Split[DataStream -&gt; SplitStream]<br>Split是将一个DataStream数据集按照条件进行拆分，形成两个数据集的过程</p><p>split stream要打印，需要转换成DataStream，使用select方法</p></blockquote><h2 id="Flink-WindowStream-amp-AllWindowedStream"><a href="#Flink-WindowStream-amp-AllWindowedStream" class="headerlink" title="Flink WindowStream &amp; AllWindowedStream"></a>Flink WindowStream &amp; AllWindowedStream</h2><p><code>WindowedStream</code>代表了根据key分组，并且基于<code>WindowAssigner</code>切分窗口的数据流。所以<code>WindowedStream</code>都是从<code>KeyedStream</code>衍生而来的。</p><p>而在<u><code>WindowedStream</code>上进行任何transformation也都将转变回<code>DataStream</code>。</u></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataStream</span>[<span class="type">MyType</span>] stream = ...</span><br><span class="line"><span class="type">WindowedDataStream</span>[<span class="type">MyType</span>] windowed = stream</span><br><span class="line">        .keyBy(<span class="string">"userId"</span>)</span><br><span class="line">        .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">5</span>))) <span class="comment">// Last 5 seconds of data</span></span><br><span class="line"><span class="type">DataStream</span>[<span class="type">ResultType</span>] result = windowed.reduce(myReducer)</span><br></pre></td></tr></table></figure><p>在key分组的流上进行窗口切分是比较常用的场景，也能够很好地并行化（不同的key上的窗口聚合可以分配到不同的task去处理）。不过当我们需要在普通流上进行窗口操作时，就要用到 <code>AllWindowedStream</code>。<code>AllWindowedStream</code>是直接在<code>DataStream</code>上进行<code>windowAll(...)</code>操作。AllWindowedStream 的实现是基于 WindowedStream 的。Flink 不推荐使用<code>AllWindowedStream</code>，因为在普通流上进行窗口操作，就势必需要将所有分区的流都汇集到单个的Task中，而这个单个的Task很显然就会成为整个Job的瓶颈。</p><p>Flink windowStream 进行操作，要使用apply函数，传入windowFunction，不能在使用Process。</p><h2 id="join，coGroup，connect，union"><a href="#join，coGroup，connect，union" class="headerlink" title="join，coGroup，connect，union"></a>join，coGroup，connect，union</h2><p><strong>join</strong></p><p>1 可用于DataStream和DataSet。只能2个DataStream一起join，或者2个DataSet一起join</p><p>2 用于DataStream时返回是JoinedStreams ,用于DataSet时返回是JoinOperatorSets </p><p>3 用于DataStream时需要与窗口同时使用，语法是：join where equalTo window apply ，用于DataSet时的语法是：join where equalTo with （where是指定第一个输入的分区字段，equalTo是指定第二个输入的分区字段，这2个字段类型需要一致）</p><p>4 与SQL中的inner join同义，只输出2个实时窗口内或2个数据集合内能匹配上的笛卡尔积，不能匹配上的不输出。</p><p>5 apply方法中或with方法中均可以使用JoinFunction或 FlatJoinFunction处理匹配上的数据对（用于DataStream和DataSet时均可）</p><p>6 侧重对2个输入里的 数据对 进行处理，join方法的入参是单个数据</p><p>7 可以join2个类型不同的流或join2个类型不同的数据集（比如Tuple2&lt;String, Long&gt; join Tuple2&lt;Long,String&gt;）,但是匹配的key或field类型要一致，不然报错（比如where中的String与equalTo中的String匹配才行）</p><p><strong>coGroup</strong></p><p>1 可用于DataStream和DataSet。只能2个DataStream一起coGroup，或者2个DataSet一起coGroup</p><p>2 用于DataStream时返回是CoGroupedStreams，用于DataSet时返回是CoGroupOperatorSets</p><p>3 用于DataStream时需要与窗口同时使用，语法是：coGroup where equalTo window apply ，用于DataSet时的语法是：coGroup where equalTo with,</p><p>4 把2个实时窗口内或2个数据集合内key相同的数据分组同一个分区，key不能匹配上的数据（只在一个窗口或集合内存在的数据）也分组到另一个分区上。</p><p>5 apply方法中或with方法中均可以使用CoGroupFunction对数据分组（用于DataStream和DataSet时均可，无FlatCoGroupFunction）</p><p>6 侧重对2个输入的 集合 进行处理，coGroup方法的入参是Iterable类型</p><p>7 可以coGroup2个类型不同的流或coGroup2个类型不同的数据集（比如Tuple2&lt;String, Long&gt; join Tuple2&lt;Long,String&gt;）,但是匹配的key或field类型要一致，不然报错（比如where中的String与equalTo中的String匹配才行）</p><p><strong>connect</strong></p><p>1 只能用于DataStream,返回是ConnectedStreams。不能用于DataSet.</p><p>2 只能2个流一起connect（stream1.connect(stream2)）</p><p>3 connect后可以对2个流分别处理（使用CoMapFunction或CoFlatMapFunction）</p><p>4 可以connect2个类型不同的流（比如Tuple2&lt;String, Long&gt; connect Tuple2&lt;Long,String&gt;）</p><p><strong>union</strong></p><p>1 用于DataStream时,返回是Datastream;用于DataSet时,返回是DataSet;</p><p>2 可以多个流一起合并（stream1.union(stream2,stream3,stream4)），合并结果是一个新Datastream；只能2个DataSet一起合并，合并结果是一个新DataSet</p><p>3 无论是合并Datastream还是合并DataSet，都不去重，2个源的消息或记录都保存。</p><p>4 不可以union 2个类型不同的流或union 2个类型不同的数据集</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glyqex8e4cj20fe06g0sz.jpg" alt="undefined"></p><p><a href="https://blog.csdn.net/u010002184/article/details/106800819" target="_blank" rel="noopener">更多细节</a></p><h1 id="Flink-TimerService-Timers"><a href="#Flink-TimerService-Timers" class="headerlink" title="Flink TimerService Timers"></a>Flink TimerService Timers</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong><code>currentProcessingTime()</code></strong>: Long 返回当前处理时间<br><strong><code>currentWatermark()</code></strong>: Long 返回当前 watermark 的时间戳<br><strong><code>registerProcessingTimeTimer(timestamp: Long)</code></strong>: Unit 会注册当前 key 的processing time 的定时器。当 processing time 到达定时时间时，触发 timer。<br><strong><code>registerEventTimeTimer(timestamp: Long)</code></strong>: Unit 会注册当前 key 的 event time 定时器。当 水位线大于等于定时器注册的时间时，触发定时器执行回调函数。<br><strong><code>deleteProcessingTimeTimer(timestamp: Long)</code></strong>: Unit 删除之前注册处理时间定时器。如果没有这个时间戳的定时器，则不执行。<br><strong><code>deleteEventTimeTimer(timestamp: Long)</code></strong>: Unit 删除之前注册的事件时间定时器，如果没有此时间戳的定时器，则不执行。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Flink进阶的知识点和文章整理&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Apache Flink" scheme="http://yoursite.com/tags/Apache-Flink/"/>
    
  </entry>
  
  <entry>
    <title>Drools</title>
    <link href="http://yoursite.com/2020/10/13/Drools/"/>
    <id>http://yoursite.com/2020/10/13/Drools/</id>
    <published>2020-10-13T04:54:59.000Z</published>
    <updated>2025-07-30T06:45:05.810Z</updated>
    
    <content type="html"><![CDATA[<p>Drools的复杂度非常高，本文前面Base Component出处是网络上流传的黑马教学文档。</p><p>后面复杂的部分晚些我会补上。</p><p>笑，maybe</p><a id="more"></a> <h1 id="规则引擎Drools-base-component"><a href="#规则引擎Drools-base-component" class="headerlink" title="规则引擎Drools [base component]"></a>规则引擎Drools [base component]</h1><h2 id="1-什么是规则引擎"><a href="#1-什么是规则引擎" class="headerlink" title="1. 什么是规则引擎"></a>1. 什么是规则引擎</h2><p><strong>规则引擎</strong>，全称为<strong>业务规则管理系统</strong>，英文名为BRMS(即Business Rule Management System)。规则引擎的主要思想是将应用程序中的业务决策部分分离出来，并使用预定义的语义模块编写业务决策（业务规则），由用户或开发者在需要时进行配置、管理。</p><p>需要注意的是规则引擎并不是一个具体的技术框架，而是指的一类系统，即业务规则管理系统。目前市面上具体的规则引擎产品有：drools、VisualRules、iLog等。</p><p>规则引擎实现了将业务决策从应用程序代码中分离出来，接收数据输入，解释业务规则，并根据业务规则做出业务决策。规则引擎其实就是一个输入输出平台。</p><p>系统中引入规则引擎后，业务规则不再以程序代码的形式驻留在系统中，取而代之的是处理规则的规则引擎，业务规则存储在规则库中，完全独立于程序。业务人员可以像管理数据一样对业务规则进行管理，比如查询、添加、更新、统计、提交业务规则等。业务规则被加载到规则引擎中供应用系统调用。</p><h2 id="2-使用规则引擎的优势"><a href="#2-使用规则引擎的优势" class="headerlink" title="2. 使用规则引擎的优势"></a>2. 使用规则引擎的优势</h2><p>使用规则引擎的优势如下：</p><p>1、业务规则与系统代码分离，实现业务规则的集中管理</p><p>2、在不重启服务的情况下可随时对业务规则进行扩展和维护</p><p>3、可以动态修改业务规则，从而快速响应需求变更</p><p>4、规则引擎是相对独立的，只关心业务规则，使得业务分析人员也可以参与编辑、维护系统的业务规则</p><p>5、减少了硬编码业务规则的成本和风险</p><p>6、使用规则引擎提供的规则编辑工具，使复杂的业务规则实现变得的简单</p><h2 id="3-规则引擎应用场景"><a href="#3-规则引擎应用场景" class="headerlink" title="3. 规则引擎应用场景"></a>3. 规则引擎应用场景</h2><p>对于一些存在比较复杂的业务规则并且业务规则会频繁变动的系统比较适合使用规则引擎，如下：</p><p>1、风险控制系统—-风险贷款、风险评估</p><p>2、反欺诈项目—-银行贷款、征信验证</p><p>3、决策平台系统—-财务计算</p><p>4、促销平台系统—-满减、打折、加价购</p><h2 id="4-Drools介绍"><a href="#4-Drools介绍" class="headerlink" title="4. Drools介绍"></a>4. Drools介绍</h2><p>drools是一款由JBoss组织提供的基于Java语言开发的开源规则引擎，可以将复杂且多变的业务规则从硬编码中解放出来，以规则脚本的形式存放在文件或特定的存储介质中(例如存放在数据库中)，使得业务规则的变更不需要修改项目代码、重启服务器就可以在线上环境立即生效。</p><p>drools官网地址：<a href="https://drools.org/" target="_blank" rel="noopener">https://drools.org/</a></p><p>drools源码下载地址：<a href="https://github.com/kiegroup/drools" target="_blank" rel="noopener">https://github.com/kiegroup/drools</a></p><p>在项目中使用drools时，即可以单独使用也可以整合spring使用。如果单独使用只需要导入如下maven坐标即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>drools API开发步骤如下：<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmhstmhbj21fg0gw428.jpg" alt="5.png"></p><h2 id="5-Drools入门案例"><a href="#5-Drools入门案例" class="headerlink" title="5. Drools入门案例"></a>5. Drools入门案例</h2><p>本小节通过一个Drools入门案例来让大家初步了解Drools的使用方式、对Drools有一个整体概念。</p><h3 id="5-1-业务场景说明"><a href="#5-1-业务场景说明" class="headerlink" title="5.1 业务场景说明"></a>5.1 业务场景说明</h3><p>业务场景：消费者在图书商城购买图书，下单后需要在支付页面显示订单优惠后的价格。具体优惠规则如下：</p><table><thead><tr><th align="left">规则编号</th><th align="left">规则名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">规则一</td><td align="left">所购图书总价在100元以下的没有优惠</td></tr><tr><td align="left">2</td><td align="left">规则二</td><td align="left">所购图书总价在100到200元的优惠20元</td></tr><tr><td align="left">3</td><td align="left">规则三</td><td align="left">所购图书总价在200到300元的优惠50元</td></tr><tr><td align="left">4</td><td align="left">规则四</td><td align="left">所购图书总价在300元以上的优惠100元</td></tr></tbody></table><h3 id="5-2-开发实现"><a href="#5-2-开发实现" class="headerlink" title="5.2 开发实现"></a>5.2 开发实现</h3><p>第一步：创建maven工程drools_quickstart并导入drools相关maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：根据drools要求创建resources/META-INF/kmodule.xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kmodule</span> <span class="attr">xmlns</span>=<span class="string">"http://www.drools.org/xsd/kmodule"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        name:指定kbase的名称，可以任意，但是需要唯一</span></span><br><span class="line"><span class="comment">        packages:指定规则文件的目录，需要根据实际情况填写，否则无法加载到规则文件</span></span><br><span class="line"><span class="comment">        default:指定当前kbase是否为默认</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kbase</span> <span class="attr">name</span>=<span class="string">"myKbase1"</span> <span class="attr">packages</span>=<span class="string">"rules"</span> <span class="attr">default</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            name:指定ksession名称，可以任意，但是需要唯一</span></span><br><span class="line"><span class="comment">            default:指定当前session是否为默认</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ksession</span> <span class="attr">name</span>=<span class="string">"ksession-rule"</span> <span class="attr">default</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kbase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">kmodule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：上面配置文件的名称和位置都是固定写法，不能更改</p><p>第三步：创建实体类Order</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Double originalPrice;<span class="comment">//订单原始价格，即优惠前价格</span></span><br><span class="line">    <span class="keyword">private</span> Double realPrice;<span class="comment">//订单真实价格，即优惠后价格</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Order&#123;"</span> +</span><br><span class="line">                <span class="string">"originalPrice="</span> + originalPrice +</span><br><span class="line">                <span class="string">", realPrice="</span> + realPrice +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getOriginalPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOriginalPrice</span><span class="params">(Double originalPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.originalPrice = originalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getRealPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> realPrice;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRealPrice</span><span class="params">(Double realPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realPrice = realPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：创建规则文件resources/rules/bookDiscount.drl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图书优惠规则</span></span><br><span class="line"><span class="keyword">package</span> book.discount</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Order</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则一：所购图书总价在100元以下的没有优惠</span></span><br><span class="line">rule <span class="string">"book_discount_1"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(originalPrice &lt; <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice());</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则一：所购图书总价在100元以下的没有优惠"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则二：所购图书总价在100到200元的优惠20元</span></span><br><span class="line">rule <span class="string">"book_discount_2"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(originalPrice &lt; <span class="number">200</span> &amp;&amp; originalPrice &gt;= <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则二：所购图书总价在100到200元的优惠20元"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则三：所购图书总价在200到300元的优惠50元</span></span><br><span class="line">rule <span class="string">"book_discount_3"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(originalPrice &lt;= <span class="number">300</span> &amp;&amp; originalPrice &gt;= <span class="number">200</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则三：所购图书总价在200到300元的优惠50元"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则四：所购图书总价在300元以上的优惠100元</span></span><br><span class="line">rule <span class="string">"book_discount_4"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(originalPrice &gt;= <span class="number">300</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则四：所购图书总价在300元以上的优惠100元"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第五步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">    <span class="comment">//会话对象，用于和规则引擎交互</span></span><br><span class="line">    KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格</span></span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.setOriginalPrice(<span class="number">210</span>D);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配</span></span><br><span class="line">    kieSession.insert(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//激活规则引擎，如果规则匹配成功则执行规则</span></span><br><span class="line">    kieSession.fireAllRules();</span><br><span class="line">    <span class="comment">//关闭会话</span></span><br><span class="line">    kieSession.dispose();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"优惠前原始价格："</span> + order.getOriginalPrice() +</span><br><span class="line">                       <span class="string">"，优惠后价格："</span> + order.getRealPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的入门案例我们可以发现，使用drools规则引擎主要工作就是编写规则文件，在规则文件中定义跟业务相关的业务规则，例如本案例定义的就是图书优惠规则。规则定义好后就需要调用drools提供的API将数据提供给规则引擎进行规则模式匹配，规则引擎会执行匹配成功的规则并将计算的结果返回给我们。</p><p>可能大家会有疑问，就是我们虽然没有在代码中编写规则的判断逻辑，但是我们还是在规则文件中编写了业务规则，这跟在代码中编写规则有什么本质的区别呢？</p><p>我们前面其实已经提到，使用规则引擎时业务规则可以做到动态管理。业务人员可以像管理数据一样对业务规则进行管理，比如查询、添加、更新、统计、提交业务规则等。这样就可以做到在不重启服务的情况下调整业务规则。</p><h3 id="5-3-小结"><a href="#5-3-小结" class="headerlink" title="5.3 小结"></a>5.3 小结</h3><h4 id="5-3-1-规则引擎构成"><a href="#5-3-1-规则引擎构成" class="headerlink" title="5.3.1 规则引擎构成"></a>5.3.1 规则引擎构成</h4><p>drools规则引擎由以下三部分构成：</p><ul><li>Working Memory（工作内存）</li><li>Rule Base（规则库）</li><li>Inference Engine（推理引擎）</li></ul><p>其中Inference Engine（推理引擎）又包括：</p><ul><li>Pattern Matcher（匹配器）     具体匹配哪一个规则，由这个完成</li><li>Agenda(议程)</li><li>Execution Engine（执行引擎）</li></ul><p>如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmkpkhnuj20sj060gml.jpg" alt="8.png"></p><h4 id="5-3-2-相关概念说明"><a href="#5-3-2-相关概念说明" class="headerlink" title="5.3.2 相关概念说明"></a>5.3.2 相关概念说明</h4><p><strong>Working Memory</strong>：工作内存，drools规则引擎会从Working Memory中获取数据并和规则文件中定义的规则进行模式匹配，所以我们开发的应用程序只需要将我们的数据插入到Working Memory中即可，例如本案例中我们调用kieSession.insert(order)就是将order对象插入到了工作内存中。</p><p><strong>Fact</strong>：事实，是指在drools 规则应用当中，将一个<strong>普通的JavaBean插入到Working Memory后的对象</strong>就是Fact对象，例如本案例中的Order对象就属于Fact对象。Fact对象是我们的应用和规则引擎进行数据交互的桥梁或通道。</p><p><strong>Rule Base</strong>：规则库，我们在规则文件中定义的规则都会被加载到规则库中。</p><p><strong>Pattern Matcher</strong>：匹配器，将Rule Base中的所有规则与Working Memory中的Fact对象进行模式匹配，匹配成功的规则将被激活并放入Agenda中。</p><p><strong>Agenda</strong>：议程，用于存放通过匹配器进行模式匹配后被激活的规则。</p><p><strong>Execution Engine</strong>：执行引擎，执行Agenda中被激活的规则。</p><h4 id="5-3-3-规则引擎执行过程"><a href="#5-3-3-规则引擎执行过程" class="headerlink" title="5.3.3 规则引擎执行过程"></a>5.3.3 规则引擎执行过程</h4><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmlg1debj20sk097myn.jpg" alt="10.png"></p><h4 id="5-3-4-KIE介绍"><a href="#5-3-4-KIE介绍" class="headerlink" title="5.3.4 KIE介绍"></a>5.3.4 KIE介绍</h4><p>我们在操作Drools时经常使用的API以及它们之间的关系如下图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmlyh6xnj20o0065mxr.jpg" alt="9.png"></p><p>通过上面的核心API可以发现，大部分类名都是以Kie开头。<strong>Kie全称为Knowledge Is Everything</strong>，即”知识就是一切”的缩写，是Jboss一系列项目的总称。如下图所示，Kie的主要模块有OptaPlanner、Drools、UberFire、jBPM。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmm9g0pqj21f40ggmyt.jpg" alt="11.png"></p><p>通过上图可以看到，Drools是整个KIE项目中的一个组件，Drools中还包括一个Drools-WB的模块，它是一个可视化的规则编辑器。</p><h2 id="6-Drools基础语法"><a href="#6-Drools基础语法" class="headerlink" title="6. Drools基础语法"></a>6. Drools基础语法</h2><h3 id="6-1-规则文件构成"><a href="#6-1-规则文件构成" class="headerlink" title="6.1 规则文件构成"></a>6.1 规则文件构成</h3><p>在使用Drools时非常重要的一个工作就是编写规则文件，通常规则文件的后缀为.drl。</p><p><strong>drl是Drools Rule Language的缩写</strong>。在规则文件中编写具体的规则内容。</p><p>一套完整的规则文件内容构成如下：</p><table><thead><tr><th align="left">关键字</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">package</td><td align="left">包名，只限于逻辑上的管理，同一个包名下的查询或者函数可以直接调用</td></tr><tr><td align="left">import</td><td align="left">用于导入类或者静态方法</td></tr><tr><td align="left">global</td><td align="left">全局变量</td></tr><tr><td align="left">function</td><td align="left">自定义函数</td></tr><tr><td align="left">query</td><td align="left">查询</td></tr><tr><td align="left">rule end</td><td align="left">规则体</td></tr></tbody></table><p>Drools支持的规则文件，除了drl形式，还有Excel文件类型的。</p><h3 id="6-2-规则体语法结构"><a href="#6-2-规则体语法结构" class="headerlink" title="6.2 规则体语法结构"></a>6.2 规则体语法结构</h3><p>规则体是规则文件内容中的重要组成部分，是进行业务规则判断、处理业务结果的部分。</p><p>规则体语法结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">"ruleName"</span></span><br><span class="line">    attributes</span><br><span class="line">    when</span><br><span class="line">        LHS </span><br><span class="line">    then</span><br><span class="line">        RHS</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>rule</strong>：关键字，表示规则开始，参数为规则的唯一名称。</p><p><strong>attributes</strong>：规则属性，是rule与when之间的参数，为可选项。</p><p><strong>when</strong>：关键字，后面跟规则的条件部分。</p><p><strong>LHS</strong>(Left Hand Side)：是规则的条件部分的通用名称。它由零个或多个条件元素组成。<strong>如果LHS为空，则它将被视为始终为true的条件元素</strong>。  （左手边）</p><p><strong>then</strong>：关键字，后面跟规则的结果部分。</p><p><strong>RHS</strong>(Right Hand Side)：是规则的后果或行动部分的通用名称。 （右手边）</p><p><strong>end</strong>：关键字，表示一个规则结束。</p><h3 id="6-3-注释"><a href="#6-3-注释" class="headerlink" title="6.3 注释"></a>6.3 注释</h3><p>在drl形式的规则文件中使用注释和Java类中使用注释一致，分为单行注释和多行注释。</p><p>单行注释用”//“进行标记，多行注释以”/<em>“开始，以”</em>/“结束。如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//规则rule1的注释，这是一个单行注释</span><br><span class="line">rule &quot;rule1&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;rule1触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">规则rule2的注释，</span><br><span class="line">这是一个多行注释</span><br><span class="line">*/</span><br><span class="line">rule &quot;rule2&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;rule2触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="6-4-Pattern模式匹配"><a href="#6-4-Pattern模式匹配" class="headerlink" title="6.4 Pattern模式匹配"></a>6.4 Pattern模式匹配</h3><p>前面我们已经知道了Drools中的匹配器可以将Rule Base中的所有规则与Working Memory中的Fact对象进行模式匹配，那么我们就需要在规则体的LHS部分定义规则并进行模式匹配。LHS部分由一个或者多个条件组成，条件又称为pattern。</p><p><strong>pattern的语法结构为：绑定变量名:Object(Field约束)</strong></p><p>其中绑定变量名可以省略，通常绑定变量名的命名一般建议以$开始。如果定义了绑定变量名，就可以在规则体的RHS部分使用此绑定变量名来操作相应的Fact对象。Field约束部分是需要返回true或者false的0个或多个表达式。</p><p>例如我们的入门案例中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规则二：所购图书总价在100到200元的优惠20元</span></span><br><span class="line">rule <span class="string">"book_discount_2"</span></span><br><span class="line">    when</span><br><span class="line">        <span class="comment">//Order为类型约束，originalPrice为属性约束</span></span><br><span class="line">        $order:Order(originalPrice &lt; <span class="number">200</span> &amp;&amp; originalPrice &gt;= <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则二：所购图书总价在100到200元的优惠20元"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以知道，匹配的条件为：</p><p>1、工作内存中必须存在Order这种类型的Fact对象—–类型约束</p><p>2、Fact对象的originalPrice属性值必须小于200——属性约束</p><p>3、Fact对象的originalPrice属性值必须大于等于100——属性约束</p><p>以上条件必须同时满足当前规则才有可能被激活。</p><p><strong>绑定变量既可以用在对象上，也可以用在对象的属性上</strong>。例如上面的例子可以改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规则二：所购图书总价在100到200元的优惠20元</span></span><br><span class="line">rule <span class="string">"book_discount_2"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order($op:originalPrice &lt; <span class="number">200</span> &amp;&amp; originalPrice &gt;= <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"$op="</span> + $op);</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则二：所购图书总价在100到200元的优惠20元"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>LHS部分还可以定义多个pattern，多个pattern之间可以使用and或者or进行连接，也可以不写，默认连接为and。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规则二：所购图书总价在100到200元的优惠20元</span></span><br><span class="line">rule <span class="string">"book_discount_2"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order($op:originalPrice &lt; <span class="number">200</span> &amp;&amp; originalPrice &gt;= <span class="number">100</span>) and</span><br><span class="line">        $customer:Customer(age &gt; <span class="number">20</span> &amp;&amp; gender==<span class="string">'male'</span>)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"$op="</span> + $op);</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则二：所购图书总价在100到200元的优惠20元"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="6-5-比较操作符"><a href="#6-5-比较操作符" class="headerlink" title="6.5 比较操作符"></a>6.5 比较操作符</h3><p>Drools提供的比较操作符，如下表：</p><table><thead><tr><th align="left">符号</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于</td></tr><tr><td align="left">==</td><td align="left">等于</td></tr><tr><td align="left">!=</td><td align="left">不等于</td></tr><tr><td align="left">contains</td><td align="left">检查一个Fact对象的某个属性值是否包含一个指定的对象值</td></tr><tr><td align="left">not contains</td><td align="left">检查一个Fact对象的某个属性值是否不包含一个指定的对象值</td></tr><tr><td align="left">memberOf</td><td align="left">判断一个Fact对象的某个属性是否在一个或多个集合中</td></tr><tr><td align="left">not memberOf</td><td align="left">判断一个Fact对象的某个属性是否不在一个或多个集合中</td></tr><tr><td align="left">matches</td><td align="left">判断一个Fact对象的属性是否与提供的标准的Java正则表达式进行匹配</td></tr><tr><td align="left">not matches</td><td align="left">判断一个Fact对象的属性是否不与提供的标准的Java正则表达式进行匹配</td></tr></tbody></table><p>前6个比较操作符和Java中的完全相同，下面我们重点学习后6个比较操作符。</p><h4 id="6-5-1-语法"><a href="#6-5-1-语法" class="headerlink" title="6.5.1 语法"></a>6.5.1 语法</h4><ul><li><p><strong>contains | not contains语法结构</strong></p><p>Object(Field[Collection/Array] contains value)</p><p>Object(Field[Collection/Array] not contains value)</p></li><li><p><strong>memberOf | not memberOf语法结构</strong></p><p>Object(field memberOf value[Collection/Array])</p><p>Object(field not memberOf value[Collection/Array])</p></li><li><p><strong>matches | not matches语法结构</strong></p><p>Object(field matches “正则表达式”)</p><p>Object(field not matches “正则表达式”)</p></li></ul><p>contain是前面包含后面，memberOf是后面包含前面。</p><h4 id="6-5-2-操作步骤"><a href="#6-5-2-操作步骤" class="headerlink" title="6.5.2 操作步骤"></a>6.5.2 操作步骤</h4><p>第一步：创建实体类，用于测试比较操作符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实体类</span></span><br><span class="line"><span class="comment"> * 用于测试比较操作符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparisonOperatorEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String names;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNames</span><span class="params">(String names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：在/resources/rules下创建规则文件comparisonOperator.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package comparisonOperator</span><br><span class="line">import com.itheima.drools.entity.ComparisonOperatorEntity</span><br><span class="line">/*</span><br><span class="line"> 当前规则文件用于测试Drools提供的比较操作符</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//测试比较操作符contains</span><br><span class="line">rule &quot;rule_comparison_contains&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names contains &quot;张三&quot;)</span><br><span class="line">        ComparisonOperatorEntity(list contains names)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_contains触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//测试比较操作符not contains</span><br><span class="line">rule &quot;rule_comparison_notContains&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names not contains &quot;张三&quot;)</span><br><span class="line">        ComparisonOperatorEntity(list not contains names)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_notContains触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//测试比较操作符memberOf</span><br><span class="line">rule &quot;rule_comparison_memberOf&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names memberOf list)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_memberOf触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//测试比较操作符not memberOf</span><br><span class="line">rule &quot;rule_comparison_notMemberOf&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names not memberOf list)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_notMemberOf触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//测试比较操作符matches</span><br><span class="line">rule &quot;rule_comparison_matches&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names matches &quot;张.*&quot;)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_matches触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//测试比较操作符not matches</span><br><span class="line">rule &quot;rule_comparison_notMatches&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names not matches &quot;张.*&quot;)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_notMatches触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第三步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试比较操作符</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">    KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">    ComparisonOperatorEntity comparisonOperatorEntity = <span class="keyword">new</span> ComparisonOperatorEntity();</span><br><span class="line">    comparisonOperatorEntity.setNames(<span class="string">"张三"</span>);</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"张三"</span>);</span><br><span class="line">    list.add(<span class="string">"李四"</span>);</span><br><span class="line">    comparisonOperatorEntity.setList(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配，如果规则匹配成功则执行规则</span></span><br><span class="line">    kieSession.insert(comparisonOperatorEntity);</span><br><span class="line"></span><br><span class="line">    kieSession.fireAllRules();</span><br><span class="line">    kieSession.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-执行指定规则"><a href="#6-6-执行指定规则" class="headerlink" title="6.6 执行指定规则"></a>6.6 执行指定规则</h3><p>通过前面的案例可以看到，我们在调用规则代码时，满足条件的规则都会被执行。那么如果我们只想执行其中的某个规则如何实现呢？</p><p>Drools给我们提供的方式是通过规则过滤器来实现执行指定规则。对于规则文件不用做任何修改，只需要修改Java代码即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">ComparisonOperatorEntity comparisonOperatorEntity = <span class="keyword">new</span> ComparisonOperatorEntity();</span><br><span class="line">comparisonOperatorEntity.setNames(<span class="string">"张三"</span>);</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"张三"</span>);</span><br><span class="line">list.add(<span class="string">"李四"</span>);</span><br><span class="line">comparisonOperatorEntity.setList(list);</span><br><span class="line">kieSession.insert(comparisonOperatorEntity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过规则过滤器实现只执行指定规则</span></span><br><span class="line">kieSession.fireAllRules(<span class="keyword">new</span> RuleNameEqualsAgendaFilter(<span class="string">"rule_comparison_memberOf"</span>));</span><br><span class="line"></span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><h3 id="6-7-关键字"><a href="#6-7-关键字" class="headerlink" title="6.7 关键字"></a>6.7 关键字</h3><p>Drools的关键字分为：硬关键字(Hard keywords)和软关键字(Soft keywords)。</p><p><strong>硬关键字是我们在规则文件中定义包名或者规则名时明确不能使用的，否则程序会报错</strong>。软关键字虽然可以使用，但是不建议使用。</p><p>硬关键字包括：true false null</p><p>软关键字包括：lock-on-active date-effective date-expires no-loop auto-focus activation-group agenda-group ruleflow-group entry-point duration package import dialect salience enabled attributes rule extend when then template query declare function global eval not in or and exists forall accumulate collect from action reverse result end over init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">rule true  //不可以</span><br><span class="line">rule &quot;true&quot;  //可以</span><br></pre></td></tr></table></figure><h3 id="6-8-Drools内置方法"><a href="#6-8-Drools内置方法" class="headerlink" title="6.8 Drools内置方法"></a>6.8 Drools内置方法</h3><p>规则文件的<code>RHS</code>部分的主要作用是通过<strong>插入，删除或修改工作内存中的Fact数据</strong>，来达到控制规则引擎执行的目的。Drools提供了一些方法可以用来操作工作内存中的数据，<strong>操作完成后规则引擎会重新进行相关规则的匹配，</strong>原来没有匹配成功的规则在我们修改数据完成后有可能就会匹配成功了。</p><p>创建如下实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-8-1-update方法"><a href="#6-8-1-update方法" class="headerlink" title="6.8.1 update方法"></a>6.8.1 update方法</h4><p><strong>update方法的作用是更新工作内存中的数据，并让相关的规则重新匹配。</strong>   （要避免死循环）</p><p>第一步：编写规则文件/resources/rules/student.drl，文件内容如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> student</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Student</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 当前规则文件用于测试Drools提供的内置方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age小于10岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(<span class="number">15</span>);</span><br><span class="line">        update($s);<span class="comment">//更新数据，导致相关的规则会重新匹配</span></span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age小于10岁触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age小于20岁同时大于10岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; <span class="number">20</span> &amp;&amp; age &gt; <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(<span class="number">25</span>);</span><br><span class="line">        update($s);<span class="comment">//更新数据，导致相关的规则会重新匹配</span></span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age小于20岁同时大于10岁触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age大于20岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &gt; <span class="number">20</span>)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age大于20岁触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student = new Student();</span><br><span class="line">student.setAge(5);</span><br><span class="line"></span><br><span class="line">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配，如果规则匹配成功则执行规则</span><br><span class="line">kieSession.insert(student);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台的输出可以看到规则文件中定义的三个规则都触发了。</p><p>在更新数据时需要注意防止发生死循环。</p><h4 id="6-8-2-insert方法"><a href="#6-8-2-insert方法" class="headerlink" title="6.8.2 insert方法"></a>6.8.2 insert方法</h4><p>insert方法的作用是向工作内存中插入数据，并让相关的规则重新匹配。</p><p>第一步：修改student.drl文件内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package student</span><br><span class="line">import com.itheima.drools.entity.Student</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 当前规则文件用于测试Drools提供的内置方法</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">rule &quot;rule_student_age等于10岁&quot;</span><br><span class="line">    when</span><br><span class="line">        $s:Student(age == 10)</span><br><span class="line">    then</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student.setAge(5);</span><br><span class="line">        insert(student);//插入数据，导致相关的规则会重新匹配</span><br><span class="line">        System.out.println(&quot;规则rule_student_age等于10岁触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_student_age小于10岁&quot;</span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; 10)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(15);</span><br><span class="line">        update($s);</span><br><span class="line">        System.out.println(&quot;规则rule_student_age小于10岁触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_student_age小于20岁同时大于10岁&quot;</span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; 20 &amp;&amp; age &gt; 10)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(25);</span><br><span class="line">        update($s);</span><br><span class="line">        System.out.println(&quot;规则rule_student_age小于20岁同时大于10岁触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_student_age大于20岁&quot;</span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &gt; 20)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_student_age大于20岁触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setAge(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配，如果规则匹配成功则执行规则</span></span><br><span class="line">kieSession.insert(student);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台输出可以发现，四个规则都触发了，这是因为首先进行规则匹配时只有第一个规则可以匹配成功，但是在第一个规则中向工作内存中插入了一个数据导致重新进行规则匹配，此时第二个规则可以匹配成功。在第二个规则中进行了数据修改导致第三个规则也可以匹配成功，以此类推最终四个规则都匹配成功并执行了。</p><h4 id="6-8-3-retract方法"><a href="#6-8-3-retract方法" class="headerlink" title="6.8.3 retract方法"></a>6.8.3 retract方法</h4><p><strong>retract方法的作用是删除工作内存中的数据，并让相关的规则重新匹配。</strong></p><p>第一步：修改student.drl文件内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> student</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Student</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 当前规则文件用于测试Drools提供的内置方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age等于10岁时删除数据"</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    salience：设置当前规则的执行优先级，数值越大越优先执行，默认值为0.</span></span><br><span class="line"><span class="comment">    因为当前规则的匹配条件和下面规则的匹配条件相同，为了保证先执行当前规则，需要设置优先级</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    salience <span class="number">100</span> </span><br><span class="line">    when</span><br><span class="line">        $s:Student(age == <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        retract($s);<span class="comment">//retract方法的作用是删除工作内存中的数据，并让相关的规则重新匹配。</span></span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age等于10岁时删除数据触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age等于10岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age == <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setAge(<span class="number">5</span>);</span><br><span class="line">        insert(student);</span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age等于10岁触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age小于10岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(<span class="number">15</span>);</span><br><span class="line">        update($s);</span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age小于10岁触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age小于20岁同时大于10岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; <span class="number">20</span> &amp;&amp; age &gt; <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(<span class="number">25</span>);</span><br><span class="line">        update($s);</span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age小于20岁同时大于10岁触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age大于20岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &gt; <span class="number">20</span>)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age大于20岁触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setAge(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配，如果规则匹配成功则执行规则</span></span><br><span class="line">kieSession.insert(student);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台输出可以发现，只有第一个规则触发了，因为在第一个规则中将工作内存中的数据删除了导致第二个规则并没有匹配成功。</p><h2 id="7-规则属性-attributes"><a href="#7-规则属性-attributes" class="headerlink" title="7. 规则属性  attributes"></a>7. 规则属性  attributes</h2><p>前面我们已经知道了规则体的构成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">"ruleName"</span></span><br><span class="line">    attributes</span><br><span class="line">    when</span><br><span class="line">        LHS</span><br><span class="line">    then</span><br><span class="line">        RHS</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>本章节就是针对规则体的<strong>attributes</strong>属性部分进行讲解。Drools中提供的属性如下表(部分属性)：</p><table><thead><tr><th align="left">属性名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">salience</td><td align="left">指定规则执行优先级</td></tr><tr><td align="left">dialect</td><td align="left">指定规则使用的语言类型，取值为java和mvel</td></tr><tr><td align="left">enabled</td><td align="left">指定规则是否启用</td></tr><tr><td align="left">date-effective</td><td align="left">指定规则生效时间</td></tr><tr><td align="left">date-expires</td><td align="left">指定规则失效时间</td></tr><tr><td align="left">activation-group</td><td align="left">激活分组，具有相同分组名称的规则只能有一个规则触发</td></tr><tr><td align="left">agenda-group</td><td align="left">议程分组，只有获取焦点的组中的规则才有可能触发</td></tr><tr><td align="left">timer</td><td align="left">定时器，指定规则触发的时间</td></tr><tr><td align="left">auto-focus</td><td align="left">自动获取焦点，一般结合agenda-group一起使用</td></tr><tr><td align="left">no-loop</td><td align="left">防止死循环</td></tr></tbody></table><h3 id="7-1-enabled属性"><a href="#7-1-enabled属性" class="headerlink" title="7.1 enabled属性"></a>7.1 enabled属性</h3><p>enabled属性对应的取值为true和false，默认值为true。</p><p>用于指定当前规则是否启用，如果设置的值为false则当前规则无论是否匹配成功都不会触发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">"rule_comparison_notMemberOf"</span></span><br><span class="line">    <span class="comment">//指定当前规则不可用，当前规则无论是否匹配成功都不会执行</span></span><br><span class="line">    enabled <span class="keyword">false</span></span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names not memberOf list)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_comparison_notMemberOf触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="7-2-dialect属性"><a href="#7-2-dialect属性" class="headerlink" title="7.2 dialect属性"></a>7.2 dialect属性</h3><p>dialect属性用于指定当前规则使用的语言类型，取值为java和mvel，默认值为java。</p><p>注：mvel是一种基于java语法的表达式语言。</p><p>mvel像正则表达式一样，有直接支持集合、数组和字符串匹配的操作符。</p><p>mvel还提供了用来配置和构造字符串的模板语言。</p><p>mvel表达式内容包括属性表达式，布尔表达式，方法调用，变量赋值，函数定义等。</p><h3 id="7-3-salience属性"><a href="#7-3-salience属性" class="headerlink" title="7.3 salience属性"></a>7.3 salience属性</h3><p>salience属性用于指定规则的执行优先级，<strong>取值类型为Integer</strong>。<strong>数值越大越优先执行</strong>。每个规则都有一个默认的执行顺序，如果不设置salience属性，规则体的执行顺序为由上到下。</p><p>可以通过创建规则文件salience.drl来测试salience属性，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package test.salience</span><br><span class="line"></span><br><span class="line">rule &quot;rule_1&quot;</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_1触发&quot;);</span><br><span class="line">end</span><br><span class="line">    </span><br><span class="line">rule &quot;rule_2&quot;</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_2触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_3&quot;</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_3触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>通过控制台可以看到，由于以上三个规则没有设置salience属性，所以执行的顺序是按照规则文件中规则的顺序由上到下执行的。接下来我们修改一下文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package testsalience</span><br><span class="line"></span><br><span class="line">rule &quot;rule_1&quot;</span><br><span class="line">    salience 9</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_1触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_2&quot;</span><br><span class="line">    salience 10</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_2触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_3&quot;</span><br><span class="line">    salience 8</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_3触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>通过控制台可以看到，规则文件执行的顺序是按照我们设置的salience值由大到小顺序执行的。</p><p>建议在编写规则时使用salience属性明确指定执行优先级。</p><h3 id="7-4-no-loop属性"><a href="#7-4-no-loop属性" class="headerlink" title="7.4 no-loop属性"></a>7.4 no-loop属性</h3><p>no-loop属性用于防止死循环，当规则通过update之类的函数修改了Fact对象时，可能使当前规则再次被激活从而导致死循环。取值类型为Boolean，默认值为false。测试步骤如下：</p><p>第一步：编写规则文件/resource/rules/noloop.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package testnoloop</span><br><span class="line">import com.itheima.drools.entity.Student</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试no-loop属性</span><br><span class="line">*/</span><br><span class="line">rule &quot;rule_noloop&quot;</span><br><span class="line">    when</span><br><span class="line">        // no-loop true</span><br><span class="line">        $student:Student(age == 25)</span><br><span class="line">    then</span><br><span class="line">        update($student);//注意此处执行update会导致当前规则重新被激活</span><br><span class="line">        System.out.println(&quot;规则rule_noloop触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student = new Student();</span><br><span class="line">student.setAge(25);</span><br><span class="line"></span><br><span class="line">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配，如果规则匹配成功则执行规则</span><br><span class="line">kieSession.insert(student);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台可以看到，由于我们没有设置no-loop属性的值，所以发生了死循环。接下来设置no-loop的值为true再次测试则不会发生死循环。</p><h3 id="7-5-activation-group属性"><a href="#7-5-activation-group属性" class="headerlink" title="7.5 activation-group属性"></a>7.5 activation-group属性</h3><p>activation-group属性是指<strong>激活分组</strong>，取值为String类型。具有相同分组名称的规则只能有一个规则被触发。</p><p>第一步：编写规则文件/resources/rules/activationgroup.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package testactivationgroup</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试activation-group属性</span><br><span class="line">*/</span><br><span class="line">    </span><br><span class="line">rule &quot;rule_activationgroup_1&quot;</span><br><span class="line">    activation-group &quot;mygroup&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_activationgroup_1触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_activationgroup_2&quot;</span><br><span class="line">    activation-group &quot;mygroup&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_activationgroup_2触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台可以发现，上面的两个规则因为属于同一个分组，所以只有一个触发了。同一个分组中的多个规则如果都能够匹配成功，具体哪一个最终能够被触发可以通过salience属性确定。</p><h3 id="7-6-agenda-group属性"><a href="#7-6-agenda-group属性" class="headerlink" title="7.6 agenda-group属性"></a>7.6 agenda-group属性</h3><p>agenda-group属性为<strong>议程分组</strong>，属于另一种可控的规则执行方式。用户可以通过设置agenda-group来控制规则的执行，只有获取焦点的组中的规则才会被触发。</p><p>第一步：创建规则文件/resources/rules/agendagroup.drl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testagendagroup</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    此规则文件用于测试agenda-group属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">rule <span class="string">"rule_agendagroup_1"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_1"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_1触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_agendagroup_2"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_1"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_2触发"</span>);</span><br><span class="line">end</span><br><span class="line"><span class="comment">//========================================================</span></span><br><span class="line">rule <span class="string">"rule_agendagroup_3"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_2"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_3触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_agendagroup_4"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_2"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_4触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置焦点，对应agenda-group分组中的规则才可能被触发</span></span><br><span class="line">kieSession.getAgenda().getAgendaGroup(<span class="string">"myagendagroup_1"</span>).setFocus();</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台可以看到，只有获取焦点的分组中的规则才会触发。与activation-group不同的是，activation-group定义的分组中只能够有一个规则可以被触发，而agenda-group分组中的多个规则都可以被触发。</p><h3 id="7-7-auto-focus属性"><a href="#7-7-auto-focus属性" class="headerlink" title="7.7 auto-focus属性"></a>7.7 auto-focus属性</h3><p>auto-focus属性为<strong>自动获取焦点</strong>，取值类型为Boolean，默认值为false。一般结合agenda-group属性使用，当一个议程分组未获取焦点时，可以设置auto-focus属性来控制。</p><p>第一步：修改/resources/rules/agendagroup.drl文件内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testagendagroup</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_agendagroup_1"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_1"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_1触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_agendagroup_2"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_1"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_2触发"</span>);</span><br><span class="line">end</span><br><span class="line"><span class="comment">//========================================================</span></span><br><span class="line">rule <span class="string">"rule_agendagroup_3"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_2"</span></span><br><span class="line">    auto-focus <span class="keyword">true</span> <span class="comment">//自动获取焦点</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_3触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_agendagroup_4"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_2"</span></span><br><span class="line">    auto-focus <span class="keyword">true</span> <span class="comment">//自动获取焦点</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_4触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台可以看到，设置auto-focus属性为true的规则都触发了。</p><p>注意：同一个组，只要有个设置auto-focus true 其他的设置不设置都无所谓啦。都会起作用的。</p><h3 id="7-8-timer属性"><a href="#7-8-timer属性" class="headerlink" title="7.8 timer属性"></a>7.8 timer属性</h3><p>timer属性可以通过定时器的方式指定规则执行的时间，使用方式有两种：</p><p><strong>方式一</strong>：timer (int: <initial delay> <repeat interval>?)</repeat></initial></p><p>此种方式遵循java.util.Timer对象的使用方式，第一个参数表示几秒后执行，第二个参数表示每隔几秒执行一次，第二个参数为可选。</p><p><strong>方式二</strong>：timer(cron: <cron expression>) </cron></p><p>此种方式使用标准的unix cron表达式的使用方式来定义规则执行的时间。</p><p>第一步：创建规则文件/resources/rules/timer.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package testtimer</span><br><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.util.Date</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试timer属性</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">rule &quot;rule_timer_1&quot;</span><br><span class="line">    timer (5s 2s) //含义：5秒后触发，然后每隔2秒触发一次</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_timer_1触发，触发时间为：&quot; + </span><br><span class="line">                         new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_timer_2&quot;</span><br><span class="line">    timer (cron:0/1 * * * * ?) //含义：每隔1秒触发一次</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_timer_2触发，触发时间为：&quot; + </span><br><span class="line">                         new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line"><span class="keyword">final</span> KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动规则引擎进行规则匹配，直到调用halt方法才结束规则引擎</span></span><br><span class="line">        kieSession.fireUntilHalt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"><span class="comment">//结束规则引擎</span></span><br><span class="line">kieSession.halt();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>注意：单元测试的代码和以前的有所不同，因为我们规则文件中使用到了timer进行定时执行，需要程序能够持续一段时间才能够看到定时器触发的效果。</p><h3 id="7-9-date-effective属性"><a href="#7-9-date-effective属性" class="headerlink" title="7.9 date-effective属性"></a>7.9 date-effective属性</h3><p>date-effective属性<strong>用于指定规则的生效时间</strong>，即只有当前系统时间大于等于设置的时间或者日期规则才有可能触发。默认日期格式为：dd-MMM-yyyy。用户也可以自定义日期格式。</p><p>第一步：编写规则文件/resources/rules/dateeffective.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package testdateeffective</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试date-effective属性</span><br><span class="line">*/</span><br><span class="line">rule &quot;rule_dateeffective_1&quot;</span><br><span class="line">    date-effective &quot;2020-10-01 10:00&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_dateeffective_1触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置日期格式</span></span><br><span class="line">System.setProperty(<span class="string">"drools.dateformat"</span>,<span class="string">"yyyy-MM-dd HH:mm"</span>);</span><br><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>注意：上面的代码需要设置日期格式，否则我们在规则文件中写的日期格式和默认的日期格式不匹配程序会报错。</p><h3 id="7-10-date-expires属性"><a href="#7-10-date-expires属性" class="headerlink" title="7.10 date-expires属性"></a>7.10 date-expires属性</h3><p>date-expires属性用于指定规则的<strong>失效时间</strong>，即只有当前系统时间小于设置的时间或者日期规则才有可能触发。默认日期格式为：dd-MMM-yyyy。用户也可以自定义日期格式。</p><p>第一步：编写规则文件/resource/rules/dateexpires.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package testdateexpires</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试date-expires属性</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">rule &quot;rule_dateexpires_1&quot;</span><br><span class="line">    date-expires &quot;2019-10-01 10:00&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_dateexpires_1触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置日期格式</span></span><br><span class="line">System.setProperty(<span class="string">"drools.dateformat"</span>,<span class="string">"yyyy-MM-dd HH:mm"</span>);</span><br><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>注意：上面的代码需要设置日期格式，否则我们在规则文件中写的日期格式和默认的日期格式不匹配程序会报错。</p><h2 id="8-Drools高级语法"><a href="#8-Drools高级语法" class="headerlink" title="8. Drools高级语法"></a>8. Drools高级语法</h2><p>前面章节我们已经知道了一套完整的规则文件内容构成如下：</p><table><thead><tr><th align="left">关键字</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">package</td><td align="left">包名，只限于逻辑上的管理，同一个包名下的查询或者函数可以直接调用</td></tr><tr><td align="left">import</td><td align="left">用于导入类或者静态方法</td></tr><tr><td align="left">global</td><td align="left">全局变量</td></tr><tr><td align="left">function</td><td align="left">自定义函数</td></tr><tr><td align="left">query</td><td align="left">查询</td></tr><tr><td align="left">rule end</td><td align="left">规则体</td></tr></tbody></table><p>本章节我们就来学习其中的几个关键字。</p><h3 id="8-1-global全局变量"><a href="#8-1-global全局变量" class="headerlink" title="8.1 global全局变量"></a>8.1 global全局变量</h3><p>global关键字用于在规则文件中<strong>定义全局变量</strong>，它可以让应用程序的对象在规则文件中能够被访问。可以用来为规则文件提供数据或服务。</p><p>语法结构为：<strong>global 对象类型 对象名称</strong></p><p>在使用global定义的全局变量时有两点需要注意：</p><p>1、如果对象类型为<strong>包装类型</strong>时，在一个规则中改变了global的值，那么<strong>只针对当前规则有效</strong>，对其他规则中的global不会有影响。可以理解为它是当前规则代码中的global副本，规则内部修改不会影响全局的使用。</p><p>2、如果对象类型为<strong>集合类型或JavaBean</strong>时，在一个规则中改变了global的值，对java代码和所有规则都有效。</p><p>下面我们通过代码进行验证：</p><p>第一步：创建UserService类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools.service;</span><br><span class="line"></span><br><span class="line">public class UserService &#123;</span><br><span class="line">    public void save()&#123;</span><br><span class="line">        System.out.println(&quot;UserService.save()...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：编写规则文件/resources/rules/global.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package testglobal</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试global全局变量</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">global java.lang.Integer count //定义一个包装类型的全局变量</span><br><span class="line">global com.itheima.drools.service.UserService userService //定义一个JavaBean类型的全局变量</span><br><span class="line">global java.util.List gList //定义一个集合类型的全局变量</span><br><span class="line"></span><br><span class="line">rule &quot;rule_global_1&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        count += 10; //全局变量计算，只对当前规则有效，其他规则不受影响</span><br><span class="line">        userService.save();//调用全局变量的方法</span><br><span class="line">        gList.add(&quot;itcast&quot;);//向集合类型的全局变量中添加元素，Java代码和所有规则都受影响</span><br><span class="line">        gList.add(&quot;itheima&quot;);</span><br><span class="line">        System.out.println(&quot;count=&quot; + count);</span><br><span class="line">        System.out.println(&quot;gList.size=&quot; + gList.size());</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_global_2&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        userService.save();</span><br><span class="line">        System.out.println(&quot;count=&quot; + count);</span><br><span class="line">        System.out.println(&quot;gList.size=&quot; + gList.size());</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第三步：编写单元测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">//设置全局变量，名称和类型必须和规则文件中定义的全局变量名称对应</span><br><span class="line">kieSession.setGlobal(&quot;userService&quot;,new UserService());</span><br><span class="line">kieSession.setGlobal(&quot;count&quot;,5);</span><br><span class="line">List list = new ArrayList();//size为0</span><br><span class="line">kieSession.setGlobal(&quot;gList&quot;,list);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br><span class="line"></span><br><span class="line">//因为在规则中为全局变量添加了两个元素，所以现在的size为2</span><br><span class="line">System.out.println(list.size());</span><br></pre></td></tr></table></figure><p>注意：</p><p>后面的代码中定义了全局变量以后，前面的test都需要加，不然会出错。</p><h3 id="8-2-query查询"><a href="#8-2-query查询" class="headerlink" title="8.2 query查询"></a>8.2 query查询</h3><p>query查询提供了一种<strong>查询working memory中符合约束条件的Fact对象</strong>的简单方法。它仅包含规则文件中的LHS部分，不用指定“when”和“then”部分并且以end结束。具体语法结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query 查询的名称(可选参数)</span><br><span class="line">    LHS</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>具体操作步骤：</p><p>第一步：编写规则文件/resources/rules/query.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package testquery</span><br><span class="line">import com.itheima.drools.entity.Student</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试query查询</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//不带参数的查询</span><br><span class="line">//当前query用于查询Working Memory中age&gt;10的Student对象</span><br><span class="line">query &quot;query_1&quot;</span><br><span class="line">    $student:Student(age &gt; 10)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//带有参数的查询</span><br><span class="line">//当前query用于查询Working Memory中age&gt;10同时name需要和传递的参数name相同的Student对象</span><br><span class="line">query &quot;query_2&quot;(String sname)</span><br><span class="line">    $student:Student(age &gt; 20 &amp;&amp; name == sname)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student1 = new Student();</span><br><span class="line">student1.setName(&quot;张三&quot;);</span><br><span class="line">student1.setAge(12);</span><br><span class="line"></span><br><span class="line">Student student2 = new Student();</span><br><span class="line">student2.setName(&quot;李四&quot;);</span><br><span class="line">student2.setAge(8);</span><br><span class="line"></span><br><span class="line">Student student3 = new Student();</span><br><span class="line">student3.setName(&quot;王五&quot;);</span><br><span class="line">student3.setAge(22);</span><br><span class="line"></span><br><span class="line">//将对象插入Working Memory中</span><br><span class="line">kieSession.insert(student1);</span><br><span class="line">kieSession.insert(student2);</span><br><span class="line">kieSession.insert(student3);</span><br><span class="line"></span><br><span class="line">//调用规则文件中的查询</span><br><span class="line">QueryResults results1 = kieSession.getQueryResults(&quot;query_1&quot;);</span><br><span class="line">int size = results1.size();</span><br><span class="line">System.out.println(&quot;size=&quot; + size);</span><br><span class="line">for (QueryResultsRow row : results1) &#123;</span><br><span class="line">    Student student = (Student) row.get(&quot;$student&quot;);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用规则文件中的查询</span><br><span class="line">QueryResults results2 = kieSession.getQueryResults(&quot;query_2&quot;,&quot;王五&quot;);</span><br><span class="line">size = results2.size();</span><br><span class="line">System.out.println(&quot;size=&quot; + size);</span><br><span class="line">for (QueryResultsRow row : results2) &#123;</span><br><span class="line">    Student student = (Student) row.get(&quot;$student&quot;);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br><span class="line">//kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><h3 id="8-3-function函数"><a href="#8-3-function函数" class="headerlink" title="8.3 function函数"></a>8.3 function函数</h3><p>function关键字用于在规则文件中定义函数，就相当于java类中的方法一样。可以在规则体中调用定义的函数。使用函数的好处是可以将业务逻辑集中放置在一个地方，根据需要可以对函数进行修改。</p><p>函数定义的语法结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 返回值类型 函数名(可选参数)&#123;</span><br><span class="line">    <span class="comment">//逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体操作步骤：</p><p>第一步：编写规则文件/resources/rules/function.drl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testfunction</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Student</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    此规则文件用于测试function函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数</span></span><br><span class="line"><span class="function">function String <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_function_1"</span></span><br><span class="line">    when</span><br><span class="line">        $student:Student(name != <span class="keyword">null</span>)</span><br><span class="line">    then</span><br><span class="line">        <span class="comment">//调用上面定义的函数</span></span><br><span class="line">        String ret = sayHello($student.getName());</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setName(<span class="string">"小明"</span>);</span><br><span class="line"></span><br><span class="line">kieSession.insert(student);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><h3 id="8-4-LHS加强"><a href="#8-4-LHS加强" class="headerlink" title="8.4 LHS加强"></a>8.4 LHS加强</h3><p>前面我们已经知道了在规则体中的LHS部分是<strong>介于when和then之间的部分</strong>，主要用于模式匹配，只有匹配结果为true时，才会触发RHS部分的执行。本章节我们会针对LHS部分学习几个新的用法。</p><h4 id="8-4-1-复合值限制in-not-in"><a href="#8-4-1-复合值限制in-not-in" class="headerlink" title="8.4.1 复合值限制in/not in"></a>8.4.1 复合值限制in/not in</h4><p>复合值限制是指超过一种匹配值的限制条件，类似于SQL语句中的in关键字。Drools规则体中的LHS部分可以使用in或者not in进行复合值的匹配。具体语法结构如下：</p><p><strong>Object(field in (比较值1,比较值2…))</strong></p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$s:Student(name in (&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;))</span><br><span class="line">$s:Student(name not in (&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;))</span><br></pre></td></tr></table></figure><h4 id="8-4-2-条件元素eval"><a href="#8-4-2-条件元素eval" class="headerlink" title="8.4.2 条件元素eval"></a>8.4.2 条件元素eval</h4><p>eval用于规则体的LHS部分，并返回一个Boolean类型的值。语法结构如下：</p><p><strong>eval(表达式)</strong></p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval(true)</span><br><span class="line">eval(false)</span><br><span class="line">eval(1 == 1)</span><br></pre></td></tr></table></figure><h4 id="8-4-3-条件元素not"><a href="#8-4-3-条件元素not" class="headerlink" title="8.4.3 条件元素not"></a>8.4.3 条件元素not</h4><p>not用于判断Working Memory中是否存在某个Fact对象，如果不存在则返回true，如果存在则返回false。语法结构如下：</p><p><strong>not Object(可选属性约束)</strong></p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">not Student()</span><br><span class="line">not Student(age &lt; 10)</span><br></pre></td></tr></table></figure><h4 id="8-4-4-条件元素exists"><a href="#8-4-4-条件元素exists" class="headerlink" title="8.4.4 条件元素exists"></a>8.4.4 条件元素exists</h4><p>exists的作用与not相反，用于判断Working Memory中是否存在某个Fact对象，如果存在则返回true，不存在则返回false。语法结构如下：</p><p><strong>exists Object(可选属性约束)</strong></p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exists Student()</span><br><span class="line">exists Student(age &lt; 10 &amp;&amp; name != null)</span><br></pre></td></tr></table></figure><p>可能有人会有疑问，我们前面在LHS部分进行条件编写时并没有使用exists也可以达到判断Working Memory中是否存在某个符合条件的Fact元素的目的，那么我们使用exists还有什么意义？</p><p>两者的区别：当向Working Memory中加入多个满足条件的Fact对象时，使用了exists的规则执行一次，不使用exists的规则会执行多次。</p><p>例如：</p><p>规则文件(只有规则体)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rule &quot;使用exists的规则&quot;</span><br><span class="line">    when</span><br><span class="line">        exists Student()</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：使用exists的规则触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;没有使用exists的规则&quot;</span><br><span class="line">    when</span><br><span class="line">        Student()</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：没有使用exists的规则触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Java代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kieSession.insert(new Student());</span><br><span class="line">kieSession.insert(new Student());</span><br><span class="line">kieSession.fireAllRules();</span><br></pre></td></tr></table></figure><p>上面第一个规则只会执行一次，因为Working Memory中存在两个满足条件的Fact对象，第二个规则会执行两次。</p><h4 id="8-4-5-规则继承"><a href="#8-4-5-规则继承" class="headerlink" title="8.4.5 规则继承"></a>8.4.5 规则继承</h4><p>规则之间可以使用extends关键字进行规则条件部分的继承，类似于java类之间的继承。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rule &quot;rule_1&quot;</span><br><span class="line">    when</span><br><span class="line">        Student(age &gt; 10)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：rule_1触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_2&quot; extends &quot;rule_1&quot; //继承上面的规则</span><br><span class="line">    when</span><br><span class="line">        /*</span><br><span class="line">        此处的条件虽然只写了一个，但是从上面的规则继承了一个条件，</span><br><span class="line">        所以当前规则存在两个条件，即Student(age &lt; 20)和Student(age &gt; 10)</span><br><span class="line">        */</span><br><span class="line">        Student(age &lt; 20) </span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：rule_2触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="8-5-RHS加强"><a href="#8-5-RHS加强" class="headerlink" title="8.5 RHS加强"></a>8.5 RHS加强</h3><p>RHS部分是规则体的重要组成部分，当LHS部分的条件匹配成功后，对应的RHS部分就会触发执行。一般在RHS部分中需要进行业务处理。</p><p>在RHS部分Drools为我们提供了一个内置对象，名称就是drools。本小节我们来介绍几个drools对象提供的方法。</p><h4 id="8-5-1-halt"><a href="#8-5-1-halt" class="headerlink" title="8.5.1 halt"></a>8.5.1 halt</h4><p>halt方法的作用是<strong>立即终止后面所有规则的执行</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testhalt</span><br><span class="line">rule <span class="string">"rule_halt_1"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则：rule_halt_1触发"</span>);</span><br><span class="line">        drools.halt();<span class="comment">//立即终止后面所有规则执行</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前规则并不会触发，因为上面的规则调用了halt方法导致后面所有规则都不会执行</span></span><br><span class="line">rule <span class="string">"rule_halt_2"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则：rule_halt_2触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="8-5-2-getWorkingMemory"><a href="#8-5-2-getWorkingMemory" class="headerlink" title="8.5.2 getWorkingMemory"></a>8.5.2 getWorkingMemory</h4><p>getWorkingMemory方法的作用是返回工作内存对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testgetWorkingMemory</span><br><span class="line">rule <span class="string">"rule_getWorkingMemory"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(drools.getWorkingMemory());</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="8-5-3-getRule"><a href="#8-5-3-getRule" class="headerlink" title="8.5.3 getRule"></a>8.5.3 getRule</h4><p>getRule方法的作用是返回规则对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testgetRule</span><br><span class="line">rule <span class="string">"rule_getRule"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(drools.getRule());</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="8-6-规则文件编码规范（重要）"><a href="#8-6-规则文件编码规范（重要）" class="headerlink" title="8.6 规则文件编码规范（重要）"></a>8.6 规则文件编码规范（重要）</h3><p>我们在进行drl类型的规则文件编写时尽量遵循如下规范：</p><ul><li>所有的规则文件(.drl)应统一放在一个规定的文件夹中，如：/rules文件夹</li><li>书写的每个规则应尽量加上注释。注释要清晰明了，言简意赅</li><li>同一类型的对象尽量放在一个规则文件中，如所有Student类型的对象尽量放在一个规则文件中</li><li>规则结果部分(RHS)尽量不要有条件语句，如if(…)，尽量不要有复杂的逻辑和深层次的嵌套语句</li><li>每个规则最好都加上salience属性，明确执行顺序</li><li>Drools默认dialect为”Java”，尽量避免使用dialect “mvel”</li></ul><h2 id="9-Spring整合Drools"><a href="#9-Spring整合Drools" class="headerlink" title="9. Spring整合Drools"></a>9. Spring整合Drools</h2><h3 id="9-1-Spring简单整合Drools"><a href="#9-1-Spring简单整合Drools" class="headerlink" title="9.1 Spring简单整合Drools"></a>9.1 Spring简单整合Drools</h3><p>在项目中使用Drools时往往会跟Spring整合来使用。具体整合步骤如下：</p><p>第一步：创建maven工程drools_spring并配置pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools_spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">drools.version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">drools.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--注意：此处必须排除传递过来的依赖，否则会跟我们自己导入的Spring jar包产生冲突--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：创建规则目录/resources/rules，中rules目录中创建规则文件helloworld.drl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_helloworld"</span></span><br><span class="line">    when</span><br><span class="line">        eval(<span class="keyword">true</span>)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则：rule_helloworld触发..."</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第三步：创建Spring配置文件/resources/spring.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:kie</span>=<span class="string">"http://drools.org/schema/kie-spring"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://drools.org/schema/kie-spring</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://drools.org/schema/kie-spring.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kie:kmodule</span> <span class="attr">id</span>=<span class="string">"kmodule"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">kie:kbase</span> <span class="attr">name</span>=<span class="string">"kbase"</span> <span class="attr">packages</span>=<span class="string">"rules"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">kie:ksession</span> <span class="attr">name</span>=<span class="string">"ksession"</span>&gt;</span><span class="tag">&lt;/<span class="name">kie:ksession</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">kie:kbase</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kie:kmodule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.kie.spring.annotations.KModuleAnnotationPostProcessor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第四步：编写单元测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.test;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.kie.api.KieBase;</span><br><span class="line">import org.kie.api.cdi.KBase;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &quot;classpath:spring.xml&quot;)</span><br><span class="line">public class DroolsSpringTest &#123;</span><br><span class="line">    @KBase(&quot;kbase&quot;)</span><br><span class="line">    private KieBase kieBase;//注入KieBase对象</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        KieSession kieSession = kieBase.newKieSession();</span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        kieSession.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-Spring整合Drools-web"><a href="#9-2-Spring整合Drools-web" class="headerlink" title="9.2 Spring整合Drools+web"></a>9.2 Spring整合Drools+web</h3><p>本小节我们来进行Drools和Spring Web的整合。具体操作步骤如下：</p><p>第一步：创建maven的war工程drools_springweb并在pom.xml文件中导入相关maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools_springweb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">drools.version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">drools.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--注意：此处必须排除传递过来的依赖，否则会跟我们自己导入的Spring jar包产生冲突--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   自己加的版本号，不加的话，会报错</span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 指定端口 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 请求路径 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：配置web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三步：创建/resources/springmvc.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:kie</span>=<span class="string">"http://drools.org/schema/kie-spring"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://drools.org/schema/kie-spring</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://drools.org/schema/kie-spring.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">kie:kmodule</span> <span class="attr">id</span>=<span class="string">"kmodule"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">kie:kbase</span> <span class="attr">name</span>=<span class="string">"kbase"</span> <span class="attr">packages</span>=<span class="string">"rules"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">kie:ksession</span> <span class="attr">name</span>=<span class="string">"ksession"</span>&gt;</span><span class="tag">&lt;/<span class="name">kie:ksession</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">kie:kbase</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kie:kmodule</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.kie.spring.annotations.KModuleAnnotationPostProcessor"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring批量扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.itheima"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--springMVC注解驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第四步：创建规则文件/resources/rules/helloworld.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package helloworld</span><br><span class="line"></span><br><span class="line">rule &quot;rule_helloworld&quot;</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：rule_helloworld触发...&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第五步：创建RuleService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.cdi.KBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@KBase</span>(<span class="string">"kbase"</span>)</span><br><span class="line">    <span class="keyword">private</span> KieBase kieBase;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        KieSession kieSession = kieBase.newKieSession();</span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        kieSession.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步：创建HelloController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.service.RuleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RuleService ruleService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/rule"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ruleService.rule();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-Spring-Boot整合Drools"><a href="#9-3-Spring-Boot整合Drools" class="headerlink" title="9.3 Spring Boot整合Drools"></a>9.3 Spring Boot整合Drools</h3><p>目前在企业开发中Spring Boot已经成为主流，本小节我们来进行Spring Boot整合Drools。具体操作步骤：</p><p>第一步：创建maven工程drools_springboot并配置pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools_springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--drools规则引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-templates<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：创建/resources/application.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: drools_springboot</span><br></pre></td></tr></table></figure><p>第三步：创建规则文件/resources/rules/helloworld.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package helloworld</span><br><span class="line">rule &quot;rule_helloworld&quot;</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：rule_helloworld触发...&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第四步：编写配置类DroolsConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.config;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieServices;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieBuilder;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieFileSystem;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieRepository;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieContainer;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.kie.internal.io.ResourceFactory;</span><br><span class="line"><span class="keyword">import</span> org.kie.spring.KModuleBeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则引擎配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroolsConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定规则文件存放的目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RULES_PATH = <span class="string">"rules/"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieFileSystem <span class="title">kieFileSystem</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();</span><br><span class="line">        ResourcePatternResolver resourcePatternResolver = </span><br><span class="line">            <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">        Resource[] files = </span><br><span class="line">            resourcePatternResolver.getResources(<span class="string">"classpath*:"</span> + RULES_PATH + <span class="string">"*.*"</span>);</span><br><span class="line">        String path = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Resource file : files) &#123;</span><br><span class="line">            path = RULES_PATH + file.getFilename();</span><br><span class="line">            kieFileSystem.write(ResourceFactory.newClassPathResource(path, <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kieFileSystem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieContainer <span class="title">kieContainer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KieRepository kieRepository = kieServices.getRepository();</span><br><span class="line">        kieRepository.addKieModule(kieRepository::getDefaultReleaseId);</span><br><span class="line">        KieBuilder kieBuilder = kieServices.newKieBuilder(kieFileSystem());</span><br><span class="line">        kieBuilder.buildAll();</span><br><span class="line">        <span class="keyword">return</span> kieServices.newKieContainer(kieRepository.getDefaultReleaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieBase <span class="title">kieBase</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kieContainer().getKieBase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KModuleBeanFactoryPostProcessor <span class="title">kiePostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KModuleBeanFactoryPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步：创建RuleService类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools.service;</span><br><span class="line"></span><br><span class="line">import org.kie.api.KieBase;</span><br><span class="line">import org.kie.api.runtime.KieSession;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RuleService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private KieBase kieBase;</span><br><span class="line">    public void rule()&#123;</span><br><span class="line">        KieSession kieSession = kieBase.newKieSession();</span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        kieSession.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步：创建HelloController类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.drools.service.RuleService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RuleService ruleService;</span><br><span class="line">    @RequestMapping(&quot;/rule&quot;)</span><br><span class="line">    public String rule()&#123;</span><br><span class="line">        ruleService.rule();</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第七步：创建启动类DroolsApplication</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class DroolsApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DroolsApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第八步：启动服务，访问<a href="http://localhost:8080/hello/rule" target="_blank" rel="noopener">http://localhost:8080/hello/rule</a></p><h2 id="10-WorkBench"><a href="#10-WorkBench" class="headerlink" title="10. WorkBench"></a>10. WorkBench</h2><h3 id="10-1-WorkBench简介"><a href="#10-1-WorkBench简介" class="headerlink" title="10.1 WorkBench简介"></a>10.1 WorkBench简介</h3><p>WorkBench是KIE组件中的元素，也称为KIE-WB，是Drools-WB与JBPM-WB的结合体。它是一个<strong>可视化的规则编辑器</strong>。WorkBench其实就是一个war包，安装到tomcat中就可以运行。使用WorkBench可以在浏览器中创建数据对象、创建规则文件、创建测试场景并将规则部署到maven仓库供其他应用使用。</p><p>下载地址：<a href="https://download.jboss.org/drools/release/7.6.0.Final/kie-drools-wb-7.6.0.Final-tomcat8.war" target="_blank" rel="noopener">https://download.jboss.org/drools/release/7.6.0.Final/kie-drools-wb-7.6.0.Final-tomcat8.war</a></p><p>注意：下载的war包需要安装到tomcat8中。</p><h3 id="10-2-安装方式"><a href="#10-2-安装方式" class="headerlink" title="10.2 安装方式"></a>10.2 安装方式</h3><p>软件安装时经常会涉及到软件版本兼容性的问题，所以需要明确各个软件的使用版本。</p><p>本课程使用的软件环境如下：</p><ul><li>操作系统：Windows 10 64位</li><li>JDK版本：1.8</li><li>maven版本：3.5.4</li><li>Tomcat版本：8.5</li></ul><p>具体安装步骤：</p><p>第一步：配置Tomcat的环境变量CATALINA_HOME，对应的值为Tomcat安装目录</p><p>第二步：在Tomcat的bin目录下创建setenv.bat文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CATALINA_OPTS=&quot;-Xmx512M \</span><br><span class="line">    -Djava.security.auth.login.config=$CATALINA_HOME/webapps/kie-drools-wb/WEB-INF/classes/login.config \</span><br><span class="line">    -Dorg.jboss.logging.provider=jdk&quot;</span><br></pre></td></tr></table></figure><p>第三步：将下载的WorkBench的war包改名为kie-drools-wb.war并复制到Tomcat的webapps目录下</p><p>第四步：修改Tomcat下conf/tomcat-users.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tomcat-users</span> <span class="attr">xmlns</span>=<span class="string">"http://tomcat.apache.org/xml"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://tomcat.apache.org/xml tomcat-users.xsd"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--定义admin角色--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--定义一个用户，用户名为kie，密码为kie，对应的角色为admin角色--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"kie"</span> <span class="attr">password</span>=<span class="string">"kie"</span> <span class="attr">roles</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第五步：下载以下三个jar包并复制到Tomcat的lib目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kie-tomcat-integration-7.10.0.Final.jar</span><br><span class="line">javax.security.jacc-api-1.5.jar</span><br><span class="line">slf4j-api-1.7.25.jar</span><br></pre></td></tr></table></figure><p>第六步：修改Tomcat的conf/server.xml文件，添加Valve标签，内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.kie.integration.tomcat.JACCValve"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>第七步：启动Tomcat并访问<a href="http://localhost:8080/kie-drools-wb%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0WorkBench%E7%9A%84%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E3%80%82%E4%BD%BF%E7%94%A8%E5%89%8D%E9%9D%A2%E5%9C%A8tomcat-users.xml%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95%E5%8D%B3%E5%8F%AF" target="_blank" rel="noopener">http://localhost:8080/kie-drools-wb，可以看到WorkBench的登录页面。使用前面在tomcat-users.xml文件中定义的用户进行登录即可</a></p><p>注意：这里我自己的是80端口，<a href="http://localhost/kie-drools-wb" target="_blank" rel="noopener">http://localhost/kie-drools-wb</a></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmwxxjf3j20zs0hcgot.jpg" alt="12.png"></p><p>登录成功后进入系统首页：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmx7fhlej211x0gagsu.jpg" alt="13.png"></p><h3 id="10-3-使用方式"><a href="#10-3-使用方式" class="headerlink" title="10.3 使用方式"></a>10.3 使用方式</h3><h4 id="10-3-1-创建空间、项目"><a href="#10-3-1-创建空间、项目" class="headerlink" title="10.3.1 创建空间、项目"></a>10.3.1 创建空间、项目</h4><p>WorkBench中存在空间和项目的概念。我们在使用WorkBench时首先需要创建空间（Space），在空间中创建项目，在项目中创建数据对象、规则文件等。</p><ul><li><p>创建空间</p><p>第一步：登录WorkBench后进行系统首页，点击首页中的Design区域进入项目列表页面：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmxmiw8sj211o0dvwf8.jpg" alt="14.png"></p><p>如果是第一次登录还没有创建项目则无法看到项目</p><p>第二步：点击左上角Spaces导航链接进入空间列表页面</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmycnfllj211w0b40ta.jpg" alt="15.png"></p><p>第三步：点击右上角Add Space按钮弹出创建添加空间窗口</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmyor1bhj211x0d4js4.jpg" alt="16.png"></p><p>录入空间名称，点击Save按钮则完成空间的创建，如下图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmyzidd0j211y0arjrz.jpg" alt="17.png"></p><p>创建项目</p><p>前面已经提到，我们在WorkBench中需要先创建空间，在空间中才能创建项目。上面我们已经创建了一个空间itheima，现在需要住此空间中创建项目。</p><p>第一步：点击itheima空间，进入此空间</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn09r42gj211y0gkmy1.jpg" alt="18.png"></p><p>可以看到当前空间中还没有项目</p><p>第二步：点击Add Project按钮弹出添加项目窗口</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn0wnfabj211w0fuab3.jpg" alt="19.png"></p><p>第三步：在添加项目窗口中录入项目名称（例如项目名称为pro1），点击Add按钮完成操作</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn156plbj211x0g9wfi.jpg" alt="20.png"></p><p>可以看到在完成项目创建后，系统直接跳转到了项目页面。要查看当前itheima空间中的所有项目，可以点击左上角itheima链接：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn1mtjqij211w0chdge.jpg" alt="21.png"></p><h4 id="10-3-2-创建数据对象"><a href="#10-3-2-创建数据对象" class="headerlink" title="10.3.2 创建数据对象"></a>10.3.2 创建数据对象</h4><p>数据对象其实就是JavaBean，一般都是在drl规则文件中使用进行规则匹配。</p><p>第一步：在itheima空间中点击pro1项目，进入此项目页面</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn6bgiglj211v0i00tt.jpg" alt="22.png"></p><p>第二步：点击Create New Asset按钮选择“数据对象”</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn6p6cs3j211y0hv0u1.jpg" alt="23.png"></p><p>第三步：在弹出的创建数据对象窗口中输入数据对象的名称，点击确定按钮完成操作</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn73brn6j211y0ex0tn.jpg" alt="24.png"></p><p>操作完成后可以看到如下：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn7btncuj211y0f8ab8.jpg" alt="25.png"></p><p>第四步：点击“添加字段”按钮弹出新建字段窗口</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn7r6f6nj211y0dijsk.jpg" alt="26.png"></p><p>第五步：在新建字段窗口中录入字段Id（其实就是属性名），选择类型，点击创建按钮完成操作</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn83m32qj211y0f0gmp.jpg" alt="27.png"></p><p>完成操作后可以看到刚才创建的字段：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn8d62p5j211y0ex75c.jpg" alt="28.png"></p><p>可以点击添加字段按钮继续创建其他字段：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn8mu2z2j211y0ecq43.jpg" alt="29.png"></p><p>注意添加完字段后需要点击右上角保存按钮完成保存操作：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn9wzsg5j211y0fimyb.jpg" alt="32.png"></p><p>点击源代码按钮可以查看刚才创建的Person对象源码：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnabnhwaj211y0hd3zx.jpg" alt="30.png"></p><p>点击左上角pro1项目链接，可以看到当前pro1项目中已经创建的各种类型的对象：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnakrvfaj211w0ea754.jpg" alt="31.png"></p></li></ul><h4 id="10-3-3-创建DRL规则文件"><a href="#10-3-3-创建DRL规则文件" class="headerlink" title="10.3.3 创建DRL规则文件"></a>10.3.3 创建DRL规则文件</h4><p>  第一步：在pro1项目页面点击右上角Create New Asset按钮，选择“DRL文件”，弹出创建DRL文件窗口</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnauejywj211v0f1gms.jpg" alt="33.png"></p><p>  第二步：在添加DRL文件窗口录入DRL文件名称，点击确定按钮完成操作</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnb29fhgj211y0fowfh.jpg" alt="34.png"></p><p>  第三步：上面点击确定按钮完成创建DRL文件后，页面会跳转到编辑DRL文件页面</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnbba37dj211y0fmt9k.jpg" alt="35.png"></p><p>  可以看到DRL规则文件页面分为两个部分：左侧为项目浏览视图、右侧为编辑区域，需要注意的是左侧默认展示的不是项目浏览视图，需要点击上面设置按钮，选择“资料库视图”和“显示为文件夹”，如下图所示：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnbkqzyfj211y0gp75o.jpg" alt="36.png"></p><p>  第四步：在编辑DRL文件页面右侧区域进行DRL文件的编写，点击右上角保存按钮完成保存操作，点击检验按钮进行规则文件语法检查</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnby5iv8j211y0erjsq.jpg" alt="37.png"></p><p>  点击左上角pro1项目回到项目页面，可以看到此项目下已经存在两个对象，即person.drl规则文件和Person类：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnc8i1g9j211y0d60th.jpg" alt="38.png"></p><h4 id="10-3-4-创建测试场景"><a href="#10-3-4-创建测试场景" class="headerlink" title="10.3.4 创建测试场景"></a>10.3.4 创建测试场景</h4><p>  前面我们已经创建了Person数据对象和person规则文件，现在我们需要测试一下规则文件中的规则，可以通过创建测试场景来进行测试。</p><p>  第一步：在项目页面点击Create New Asset按钮选择“测试场景”，弹出创建测试场景窗口</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnncj3vq1j211y0eoab4.jpg" alt="39.png"></p><p>  第二步：在弹出的创建测试场景窗口中录入测试场景的名称，点击确定完成操作</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnncr39vzj211y0cedgt.jpg" alt="40.png"></p><p>  完成测试场景的创建后，页面会跳转到测试场景编辑页面，如下图：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnncy249rj211y0br75b.jpg" alt="41.png"></p><p>  第三步：因为我们编写的规则文件中需要从工作内存中获取Person对象进行规则匹配，所以在测试场景中需要准备Person对象给工作内存，点击“GIVEN”按钮弹出新建数据录入窗口，选择Person类，输入框中输入事实名称（名称任意），如下图</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnd648wpj211y0dawfr.jpg" alt="42.png"></p><p>  第四步：录入事实名称后点击后面的添加按钮，可以看到Person对象已经添加成功</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnndll1vtj211y0b8gmp.jpg" alt="43.png"></p><p>  第五步：我们给工作内存提供的Person对象还需要设置age属性的值，点击“添加字段”按钮弹出窗口，选择age属性</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnndutq8mj211y0dsjsp.jpg" alt="44.png"></p><p>  点击确定按钮后可以看到字段已经添加成功：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnne5h6csj211x0czgms.jpg" alt="45.png"></p><p>  第六步：点击age属性后面的编辑按钮，弹出字段值窗口</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnedo5kkj211y0dxabk.jpg" alt="image-20200113154817582.png"></p><p>  第七步：在弹出的窗口中点击字面值按钮，重新回到测试场景页面，可以看到age后面出现输入框，可以为age属性设置值</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnenrrcdj211y0cn0u4.jpg" alt="image-20200113155136957.png"></p><p>  设置好age属性的值后点击保存按钮保存测试场景</p><p>  第八步：点击右上角“运行测试场景”按钮进行测试</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnezucrjj211u0f2myp.jpg" alt="image-20200113155332666.png"></p><p>  测试成功后可以查看WorkBench部署的Tomcat控制台：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnfa8byuj20qn09ujrr.jpg" alt="image-20200113155819517.png"></p><h4 id="10-3-5-设置KieBase和KieSession"><a href="#10-3-5-设置KieBase和KieSession" class="headerlink" title="10.3.5 设置KieBase和KieSession"></a>10.3.5 设置KieBase和KieSession</h4><p>  第一步：在pro1项目页面点击右上角Settings按钮进入设置页面</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnfjo7ccj211y0ce756.jpg" alt="image-20200113162923877.png"></p><p>  第二步：在设置页面选择“知识库和会话”选项</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnfrfocjj211y0dx75c.jpg" alt="image-20200113163005061.png"></p><p>  第三步：在弹出的知识库和会话页面点击“添加”按钮进行设置</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnfzmshrj211t0gggmc.jpg" alt="image-20200113163313305.png"></p><p>  第四步：设置完成后点击右上角保存按钮完成设置操作，可以通过左侧浏览视图点击kmodule.xml，查看文件内容</p><p>  注意：出不来的话，要刷新一下。</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnngb49mgj211y0e275g.jpg" alt="image-20200113163539676.png"></p><h4 id="10-3-6-编译、构建、部署"><a href="#10-3-6-编译、构建、部署" class="headerlink" title="10.3.6 编译、构建、部署"></a>10.3.6 编译、构建、部署</h4><p>  前面我们已经在WorkBench中创建了一个空间itheima，并且在此空间中创建了一个项目pro1，在此项目中创建了数据文件、规则文件和测试场景，如下图：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnngljshdj211y0csmy2.jpg" alt="image-20200113160102668.png"></p><p>  点击右上角“Compile”按钮可以对项目进行编译，点击“Bulid&amp;Deploy”按钮进行构建和部署。</p><p>  部署成功后可以在本地maven仓库中看到当前项目已经被打成jar包：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnngtbntlj20dd04474b.jpg" alt="image-20200113160728259.png"></p><p>  将上面的jar包进行解压，可以看到我们创建的数据对象Person和规则文件person以及kmodule.xml都已经打到jar包中了。</p><h4 id="10-3-7-在项目中使用部署的规则"><a href="#10-3-7-在项目中使用部署的规则" class="headerlink" title="10.3.7 在项目中使用部署的规则"></a>10.3.7 在项目中使用部署的规则</h4><p>  前面我们已经在WorkBench中创建了pro1项目，并且在pro1项目中创建了数据文件、规则文件等。最后我们将此项目打成jar包部署到了maven仓库中。本小节就需要在外部项目中使用我们定义的规则。</p><p>  第一步：在IDEA中创建一个maven项目并在pom.xml文件中导入相关坐标</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.drools&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.10.0.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>  第二步：在项目中创建一个数据对象Person，需要和WorkBench中创建的Person包名、类名完全相同，属性也需要对应</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.pro1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> java.lang.String id;</span><br><span class="line">    <span class="keyword">private</span> java.lang.String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(java.lang.String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(java.lang.String id, java.lang.String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第三步：编写单元测试，远程加载maven仓库中的jar包最终完成规则调用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//通过此URL可以访问到maven仓库中的jar包</span></span><br><span class="line">    <span class="comment">//URL地址构成：http://ip地址:Tomcat端口号/WorkBench工程名/maven2/坐标/版本号/xxx.jar</span></span><br><span class="line">    String url = </span><br><span class="line">    <span class="string">"http://localhost:8080/kie-drools-wb/maven2/com/itheima/pro1/1.0.0/pro1-1.0.0.jar"</span>;</span><br><span class="line">    </span><br><span class="line">    KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过Resource资源对象加载jar包</span></span><br><span class="line">    UrlResource resource = (UrlResource) kieServices.getResources().newUrlResource(url);</span><br><span class="line">    <span class="comment">//通过Workbench提供的服务来访问maven仓库中的jar包资源，需要先进行Workbench的认证</span></span><br><span class="line">    resource.setUsername(<span class="string">"kie"</span>);</span><br><span class="line">    resource.setPassword(<span class="string">"kie"</span>);</span><br><span class="line">    resource.setBasicAuthentication(<span class="string">"enabled"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将资源转换为输入流，通过此输入流可以读取jar包数据</span></span><br><span class="line">    InputStream inputStream = resource.getInputStream();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建仓库对象，仓库对象中保存Drools的规则信息</span></span><br><span class="line">    KieRepository repository = kieServices.getRepository();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过输入流读取maven仓库中的jar包数据，包装成KieModule模块添加到仓库中</span></span><br><span class="line">    KieModule kieModule = </span><br><span class="line">    repository.</span><br><span class="line">        addKieModule(kieServices.getResources().newInputStreamResource(inputStream));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//基于KieModule模块创建容器对象，从容器中可以获取session会话</span></span><br><span class="line">    KieContainer kieContainer = kieServices.newKieContainer(kieModule.getReleaseId());</span><br><span class="line">    KieSession session = kieContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.setAge(<span class="number">10</span>);</span><br><span class="line">    session.insert(person);</span><br><span class="line"></span><br><span class="line">    session.fireAllRules();</span><br><span class="line">    session.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  执行单元测试可以发现控制台已经输出了相关内容。通过WorkBench修改规则输出内容并发布，再次执行单元测试可以发现控制台输出的内容也发生了变化。</p><p>  <strong>通过上面的案例可以发现，我们在IEDA中开发的项目中并没有编写规则文件，规则文件是我们通过WorkBench开发并安装部署到maven仓库中，我们自己开发的项目只需要远程加载maven仓库中的jar包就可以完成规则的调用。这种开发方式的好处是我们的应用可以和业务规则完全分离，同时通过WorkBench修改规则后我们的应用不需要任何修改就可以加载到最新的规则从而实现规则的动态变更。</strong></p><h2 id="11-Drools实战"><a href="#11-Drools实战" class="headerlink" title="11. Drools实战"></a>11. Drools实战</h2><h3 id="11-1-个人所得税计算器"><a href="#11-1-个人所得税计算器" class="headerlink" title="11.1 个人所得税计算器"></a>11.1 个人所得税计算器</h3><p>  本小节我们需要通过Drools规则引擎来根据规则计算个人所得税，最终页面效果如下：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnh76474j20c908et8v.jpg" alt="image-20200214132448956.png"></p><h4 id="11-1-1-名词解释"><a href="#11-1-1-名词解释" class="headerlink" title="11.1.1 名词解释"></a>11.1.1 名词解释</h4><p>  税前月收入：即税前工资，指交纳个人所得税之前的总工资</p><p>  应纳税所得额：指按照税法规定确定纳税人在一定期间所获得的所有应税收入减除在该纳税期间依法允许减除的各种支出后的余额</p><p>  税率：是对征税对象的征收比例或征收额度</p><p>  速算扣除数：指为解决超额累进税率分级计算税额的复杂技术问题，而预先计算出的一个数据，可以简化计算过程</p><p>  扣税额：是指实际缴纳的税额</p><p>  税后工资：是指扣完税后实际到手的工资收入</p><h4 id="11-1-2-计算规则"><a href="#11-1-2-计算规则" class="headerlink" title="11.1.2 计算规则"></a>11.1.2 计算规则</h4><p>  要实现个人所得税计算器，需要了解如下计算规则：（2011）</p><table><thead><tr><th align="left">规则编号</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">计算应纳税所得额</td><td align="left">应纳税所得额为税前工资减去3500</td></tr><tr><td align="left">2</td><td align="left">设置税率，应纳税所得额&lt;=1500</td><td align="left">税率为0.03，速算扣除数为0</td></tr><tr><td align="left">3</td><td align="left">设置税率，应纳税所得额在1500至4500之间</td><td align="left">税率为0.1，速算扣除数为105</td></tr><tr><td align="left">4</td><td align="left">设置税率，应纳税所得额在4500志9000之间</td><td align="left">税率为0.2，速算扣除数为555</td></tr><tr><td align="left">5</td><td align="left">设置税率，应纳税所得额在9000志35000之间</td><td align="left">税率为0.25，速算扣除数为1005</td></tr><tr><td align="left">6</td><td align="left">设置税率，应纳税所得额在35000至55000之间</td><td align="left">税率为0.3，速算扣除数为2755</td></tr><tr><td align="left">7</td><td align="left">设置税率，应纳税所得额在55000至80000之间</td><td align="left">税率为0.35，速算扣除数为5505</td></tr><tr><td align="left">8</td><td align="left">设置税率，应纳税所得额在80000以上</td><td align="left">税率为0.45，速算扣除数为13505</td></tr><tr><td align="left">9</td><td align="left">计算税后工资</td><td align="left">扣税额=应纳税所得额*税率-速算扣除数 税后工资=税前工资-扣税额</td></tr></tbody></table><p>  税前工资：10000</p><p>  应缴纳所得税：10000-3500 = 6500</p><p>  税率：0.2</p><p>  速算扣除数：555</p><p>  扣税额：6500 * 0.2 - 555 = 745</p><p>  税后工资：10000 - 745 = 9255</p><h4 id="11-1-3-实现步骤"><a href="#11-1-3-实现步骤" class="headerlink" title="11.1.3 实现步骤"></a>11.1.3 实现步骤</h4><p>  本实战案例我们基于Spring Boot整合Drools的方式来实现。</p><p>  第一步：创建maven工程calculation并配置pom.xml文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--drools规则引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-templates<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  第二步：创建/resources/application.yml文件</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">calculation</span></span><br></pre></td></tr></table></figure><p>  第三步：编写配置类DroolsConfig</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.config;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieServices;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieBuilder;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieFileSystem;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieRepository;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieContainer;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.kie.internal.io.ResourceFactory;</span><br><span class="line"><span class="keyword">import</span> org.kie.spring.KModuleBeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则引擎配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroolsConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定规则文件存放的目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RULES_PATH = <span class="string">"rules/"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieFileSystem <span class="title">kieFileSystem</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"drools.dateformat"</span>,<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();</span><br><span class="line">        ResourcePatternResolver resourcePatternResolver = </span><br><span class="line">            <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">        Resource[] files = </span><br><span class="line">            resourcePatternResolver.getResources(<span class="string">"classpath*:"</span> + RULES_PATH + <span class="string">"*.*"</span>);</span><br><span class="line">        String path = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Resource file : files) &#123;</span><br><span class="line">            path = RULES_PATH + file.getFilename();</span><br><span class="line">            kieFileSystem.write(ResourceFactory.newClassPathResource(path, <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kieFileSystem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieContainer <span class="title">kieContainer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KieRepository kieRepository = kieServices.getRepository();</span><br><span class="line">        kieRepository.addKieModule(kieRepository::getDefaultReleaseId);</span><br><span class="line">        KieBuilder kieBuilder = kieServices.newKieBuilder(kieFileSystem());</span><br><span class="line">        kieBuilder.buildAll();</span><br><span class="line">        <span class="keyword">return</span> kieServices.newKieContainer(kieRepository.getDefaultReleaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieBase <span class="title">kieBase</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kieContainer().getKieBase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KModuleBeanFactoryPostProcessor <span class="title">kiePostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KModuleBeanFactoryPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第四步：编写实体类Calculation</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> wage;<span class="comment">//税前工资</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> wagemore;<span class="comment">//应纳税所得额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> cess;<span class="comment">//税率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> preminus;<span class="comment">//速算扣除数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> wageminus;<span class="comment">//扣税额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> actualwage;<span class="comment">//税后工资</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWage</span><span class="params">(<span class="keyword">double</span> wage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wage = wage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getActualwage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> actualwage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActualwage</span><span class="params">(<span class="keyword">double</span> actualwage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actualwage = actualwage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWagemore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wagemore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWagemore</span><span class="params">(<span class="keyword">double</span> wagemore)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wagemore = wagemore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCess</span><span class="params">(<span class="keyword">double</span> cess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cess = cess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPreminus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preminus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPreminus</span><span class="params">(<span class="keyword">double</span> preminus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preminus = preminus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWageminus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wageminus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWageminus</span><span class="params">(<span class="keyword">double</span> wageminus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wageminus = wageminus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Calculation&#123;"</span> +</span><br><span class="line">                <span class="string">"wage="</span> + wage +</span><br><span class="line">                <span class="string">", actualwage="</span> + actualwage +</span><br><span class="line">                <span class="string">", wagemore="</span> + wagemore +</span><br><span class="line">                <span class="string">", cess="</span> + cess +</span><br><span class="line">                <span class="string">", preminus="</span> + preminus +</span><br><span class="line">                <span class="string">", wageminus="</span> + wageminus +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第五步：在resources/rules下创建规则文件calculation.drl文件</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calculation</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Calculation</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：计算应纳税所得额"</span></span><br><span class="line">    enabled <span class="keyword">true</span></span><br><span class="line">    salience <span class="number">3</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    date-effective <span class="string">"2011-09-01"</span> <span class="comment">//生效日期</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wage&gt;<span class="number">0</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setWagemore($cal.getWage()-<span class="number">3500</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额&lt;=1500"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &lt;= <span class="number">1500</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.03</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">0</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在1500至4500之间"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">1500</span> &amp;&amp; wagemore &lt;= <span class="number">4500</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.1</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">105</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在4500志9000之间"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">4500</span> &amp;&amp; wagemore &lt;= <span class="number">9000</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.2</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">555</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在9000志35000之间"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">9000</span> &amp;&amp; wagemore &lt;= <span class="number">35000</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.25</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">1005</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在35000至55000之间"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">35000</span> &amp;&amp; wagemore &lt;= <span class="number">55000</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.3</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">2755</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在55000至80000之间"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">55000</span> &amp;&amp; wagemore &lt;= <span class="number">80000</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.35</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">5505</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在80000以上"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">80000</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.45</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">13505</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：计算税后工资"</span></span><br><span class="line">    salience <span class="number">1</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wage &gt; <span class="number">0</span> &amp;&amp; wagemore &gt; <span class="number">0</span> &amp;&amp; wagemore &gt; <span class="number">0</span> &amp;&amp; cess &gt; <span class="number">0</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setWageminus($cal.getWagemore()*$cal.getCess()-$cal.getPreminus());</span><br><span class="line">        $cal.setActualwage($cal.getWage()-$cal.getWageminus());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----税前工资："</span>+$cal.getWage());</span><br><span class="line">        System.out.println(<span class="string">"-----应纳税所得额："</span>+$cal.getWagemore());</span><br><span class="line">        System.out.println(<span class="string">"-----税率："</span> + $cal.getCess());</span><br><span class="line">        System.out.println(<span class="string">"-----速算扣除数："</span> + $cal.getPreminus());</span><br><span class="line">        System.out.println(<span class="string">"-----扣税额："</span> + $cal.getWageminus());</span><br><span class="line">        System.out.println(<span class="string">"-----税后工资："</span> + $cal.getActualwage());</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>  第六步：创建RuleService</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Calculation;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用规则引擎，执行规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KieBase kieBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//个人所得税计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculation <span class="title">calculate</span><span class="params">(Calculation calculation)</span></span>&#123;</span><br><span class="line">        KieSession kieSession = kieBase.newKieSession();</span><br><span class="line">        kieSession.insert(calculation);</span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        kieSession.dispose();</span><br><span class="line">        <span class="keyword">return</span> calculation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第七步：创建RuleController</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Calculation;</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.service.RuleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rule"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RuleService ruleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/calculate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculation <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> wage)</span></span>&#123;</span><br><span class="line">        Calculation calculation = <span class="keyword">new</span> Calculation();</span><br><span class="line">        calculation.setWage(wage);</span><br><span class="line">        calculation = ruleService.calculate(calculation);</span><br><span class="line">        System.out.println(calculation);</span><br><span class="line">        <span class="keyword">return</span> calculation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第八步：创建启动类DroolsApplication</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroolsApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DroolsApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第九步：导入静态资源文件到resources/static目录下</p><h3 id="11-2-信用卡申请"><a href="#11-2-信用卡申请" class="headerlink" title="11.2 信用卡申请"></a>11.2 信用卡申请</h3><p>  本小节我们需要通过Drools规则引擎来根据规则进行申请人的合法性检查，检查通过后再根据规则确定信用卡额度，最终页面效果如下：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnid4a6xj20ki081mxb.jpg" alt="image-20200214202525859.png"></p><h4 id="9-2-1-计算规则"><a href="#9-2-1-计算规则" class="headerlink" title="9.2.1 计算规则"></a>9.2.1 计算规则</h4><p>  合法性检查规则如下：</p><table><thead><tr><th align="left">规则编号</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">检查学历与薪水1</td><td align="left">如果申请人既没房也没车，同时学历为大专以下，并且月薪少于5000，那么不通过</td></tr><tr><td align="left">2</td><td align="left">检查学历与薪水2</td><td align="left">如果申请人既没房也没车，同时学历为大专或本科，并且月薪少于3000，那么不通过</td></tr><tr><td align="left">3</td><td align="left">检查学历与薪水3</td><td align="left">如果申请人既没房也没车，同时学历为本科以上，并且月薪少于2000，同时之前没有信用卡的，那么不通过</td></tr><tr><td align="left">4</td><td align="left">检查申请人已有的信用卡数量</td><td align="left">如果申请人现有的信用卡数量大于10，那么不通过</td></tr></tbody></table><p>  信用卡额度确定规则：</p><table><thead><tr><th align="left">规则编号</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">规则1</td><td align="left">如果申请人有房有车，或者月收入在20000以上，那么发放的信用卡额度为15000</td></tr><tr><td align="left">2</td><td align="left">规则2</td><td align="left">如果申请人没房没车，但月收入在10000~20000之间，那么发放的信用卡额度为6000</td></tr><tr><td align="left">3</td><td align="left">规则3</td><td align="left">如果申请人没房没车，月收入在10000以下，那么发放的信用卡额度为3000</td></tr><tr><td align="left">4</td><td align="left">规则4</td><td align="left">如果申请人有房没车或者没房但有车，月收入在10000以下，那么发放的信用卡额度为5000</td></tr><tr><td align="left">5</td><td align="left">规则5</td><td align="left">如果申请人有房没车或者是没房但有车，月收入在10000~20000之间，那么发放的信用卡额度为8000</td></tr></tbody></table><h4 id="11-2-2-实现步骤"><a href="#11-2-2-实现步骤" class="headerlink" title="11.2.2 实现步骤"></a>11.2.2 实现步骤</h4><p>  第一步：创建maven工程creditCardApply并配置pom.xml文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>creditCardApply<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--drools规则引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-templates<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  第二步：创建/resources/application.yml文件</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">creditCardApply</span></span><br></pre></td></tr></table></figure><p>  第三步：编写配置类DroolsConfig</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.config;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieServices;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieBuilder;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieFileSystem;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieRepository;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieContainer;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.kie.internal.io.ResourceFactory;</span><br><span class="line"><span class="keyword">import</span> org.kie.spring.KModuleBeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则引擎配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroolsConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定规则文件存放的目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RULES_PATH = <span class="string">"rules/"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieFileSystem <span class="title">kieFileSystem</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();</span><br><span class="line">        ResourcePatternResolver resourcePatternResolver =</span><br><span class="line">                <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">        Resource[] files =</span><br><span class="line">                resourcePatternResolver.getResources(<span class="string">"classpath*:"</span> + RULES_PATH + <span class="string">"*.*"</span>);</span><br><span class="line">        String path = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Resource file : files) &#123;</span><br><span class="line">            path = RULES_PATH + file.getFilename();</span><br><span class="line">            kieFileSystem.write(ResourceFactory.newClassPathResource(path, <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kieFileSystem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieContainer <span class="title">kieContainer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KieRepository kieRepository = kieServices.getRepository();</span><br><span class="line">        kieRepository.addKieModule(kieRepository::getDefaultReleaseId);</span><br><span class="line">        KieBuilder kieBuilder = kieServices.newKieBuilder(kieFileSystem());</span><br><span class="line">        kieBuilder.buildAll();</span><br><span class="line">        <span class="keyword">return</span> kieServices.newKieContainer(kieRepository.getDefaultReleaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieBase <span class="title">kieBase</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kieContainer().getKieBase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KModuleBeanFactoryPostProcessor <span class="title">kiePostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KModuleBeanFactoryPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第四步：编写实体类CreditCardApplyInfo</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信用卡申请信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreditCardApplyInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EDUCATION_1 = <span class="string">"专科以下"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EDUCATION_2 = <span class="string">"专科"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EDUCATION_3 = <span class="string">"本科"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EDUCATION_4 = <span class="string">"本科以上"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String education;</span><br><span class="line">    <span class="keyword">private</span> String telephone;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> monthlyIncome = <span class="number">0</span>;<span class="comment">//月收入</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasHouse = <span class="keyword">false</span>;<span class="comment">//是否有房</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasCar = <span class="keyword">false</span>;<span class="comment">//是否有车</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hasCreditCardCount = <span class="number">0</span>;<span class="comment">//现持有信用卡数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> checkResult = <span class="keyword">true</span>;<span class="comment">//审核是否通过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> quota = <span class="number">0</span>;<span class="comment">//额度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEducation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> education;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEducation</span><span class="params">(String education)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.education = education;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTelephone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> telephone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTelephone</span><span class="params">(String telephone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.telephone = telephone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMonthlyIncome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> monthlyIncome;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMonthlyIncome</span><span class="params">(<span class="keyword">double</span> monthlyIncome)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.monthlyIncome = monthlyIncome;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasHouse</span><span class="params">(<span class="keyword">boolean</span> hasHouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasHouse = hasHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasCar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasCar</span><span class="params">(<span class="keyword">boolean</span> hasCar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasCar = hasCar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHasCreditCardCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasCreditCardCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasCreditCardCount</span><span class="params">(<span class="keyword">int</span> hasCreditCardCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasCreditCardCount = hasCreditCardCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCheckResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCheckResult</span><span class="params">(<span class="keyword">boolean</span> checkResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.checkResult = checkResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getQuota</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quota;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuota</span><span class="params">(<span class="keyword">double</span> quota)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quota = quota;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(checkResult)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"审核通过，信用卡额度为："</span> + quota;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"审核不通过"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第五步：在resources/rules下创建规则文件creditCardApply.drl文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.creditCardApply</span><br><span class="line">import com.itheima.drools.entity.CreditCardApplyInfo</span><br><span class="line"></span><br><span class="line">//合法性检查</span><br><span class="line">rule &quot;如果申请人既没房也没车，同时学历为大专以下，并且月薪少于5000，那么不通过&quot;</span><br><span class="line">    salience 10</span><br><span class="line">    no-loop true</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(hasCar == false &amp;&amp;</span><br><span class="line">                                hasHouse == false &amp;&amp;</span><br><span class="line">                                education == CreditCardApplyInfo.EDUCATION_1 &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt; 5000)</span><br><span class="line">    then</span><br><span class="line">        $c.setCheckResult(false);</span><br><span class="line">        drools.halt();</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人既没房也没车，同时学历为大专或本科，并且月薪少于3000，那么不通过&quot;</span><br><span class="line">    salience 10</span><br><span class="line">    no-loop true</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(hasCar == false &amp;&amp;</span><br><span class="line">                                hasHouse == false &amp;&amp;</span><br><span class="line">                                (education == CreditCardApplyInfo.EDUCATION_2  ||</span><br><span class="line">                                education == CreditCardApplyInfo.EDUCATION_3) &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt; 3000)</span><br><span class="line">    then</span><br><span class="line">        $c.setCheckResult(false);</span><br><span class="line">        drools.halt();</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人既没房也没车，同时学历为本科以上，并且月薪少于2000，同时之前没有信用卡的，那么不通过&quot;</span><br><span class="line">    salience 10</span><br><span class="line">    no-loop true</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(hasCar == false &amp;&amp;</span><br><span class="line">                                hasHouse == false &amp;&amp;</span><br><span class="line">                                education == CreditCardApplyInfo.EDUCATION_4 &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt; 2000 &amp;&amp;</span><br><span class="line">                                hasCreditCardCount == 0)</span><br><span class="line">    then</span><br><span class="line">        $c.setCheckResult(false);</span><br><span class="line">        drools.halt();</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人现有的信用卡数量大于10，那么不通过&quot;</span><br><span class="line">    salience 10</span><br><span class="line">    no-loop true</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(hasCreditCardCount &gt; 10)</span><br><span class="line">    then</span><br><span class="line">        $c.setCheckResult(false);</span><br><span class="line">        drools.halt();</span><br><span class="line">end</span><br><span class="line">//--------------------------------------------------------------------------</span><br><span class="line">//确定额度</span><br><span class="line">rule &quot;如果申请人有房有车，或者月收入在20000以上，那么发放的信用卡额度为15000&quot;</span><br><span class="line">    salience 1</span><br><span class="line">    no-loop true</span><br><span class="line">    activation-group &quot;quota_group&quot;</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(checkResult == true &amp;&amp;</span><br><span class="line">                                ((hasHouse == true &amp;&amp; hasCar == true) ||</span><br><span class="line">                                (monthlyIncome &gt; 20000)))</span><br><span class="line">    then</span><br><span class="line">        $c.setQuota(15000);</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人没房没车，但月收入在10000~20000之间，那么发放的信用卡额度为6000&quot;</span><br><span class="line">    salience 1</span><br><span class="line">    no-loop true</span><br><span class="line">    activation-group &quot;quota_group&quot;</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(checkResult == true &amp;&amp;</span><br><span class="line">                                hasHouse == false &amp;&amp;</span><br><span class="line">                                hasCar == false &amp;&amp;</span><br><span class="line">                                monthlyIncome &gt;= 10000 &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt;= 20000)</span><br><span class="line">    then</span><br><span class="line">        $c.setQuota(6000);</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人没房没车，月收入在10000以下，那么发放的信用卡额度为3000&quot;</span><br><span class="line">    salience 1</span><br><span class="line">    no-loop true</span><br><span class="line">    activation-group &quot;quota_group&quot;</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(checkResult == true &amp;&amp;</span><br><span class="line">                                        hasHouse == false &amp;&amp;</span><br><span class="line">                                        hasCar == false &amp;&amp;</span><br><span class="line">                                        monthlyIncome &lt; 10000)</span><br><span class="line">    then</span><br><span class="line">        $c.setQuota(3000);</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人有房没车或者没房但有车，月收入在10000以下，那么发放的信用卡额度为5000&quot;</span><br><span class="line">    salience 1</span><br><span class="line">    no-loop true</span><br><span class="line">    activation-group &quot;quota_group&quot;</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(checkResult == true &amp;&amp;</span><br><span class="line">                                ((hasHouse == true &amp;&amp; hasCar == false) ||</span><br><span class="line">                                (hasHouse == false &amp;&amp; hasCar == true)) &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt; 10000)</span><br><span class="line">    then</span><br><span class="line">        $c.setQuota(5000);</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人有房没车或者是没房但有车，月收入在10000~20000之间，那么发放的信用卡额度为8000&quot;</span><br><span class="line">    salience 1</span><br><span class="line">    no-loop true</span><br><span class="line">    activation-group &quot;quota_group&quot;</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(checkResult == true &amp;&amp;</span><br><span class="line">                                ((hasHouse == true &amp;&amp; hasCar == false) ||</span><br><span class="line">                                (hasHouse == false &amp;&amp; hasCar == true)) &amp;&amp;</span><br><span class="line">                                monthlyIncome &gt;= 10000 &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt;= 20000)</span><br><span class="line">    then</span><br><span class="line">        $c.setQuota(8000);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>  第六步：创建RuleService</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools.service;</span><br><span class="line"></span><br><span class="line">import com.itheima.drools.entity.CreditCardApplyInfo;</span><br><span class="line">import org.kie.api.KieBase;</span><br><span class="line">import org.kie.api.runtime.KieSession;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RuleService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private KieBase kieBase;</span><br><span class="line"></span><br><span class="line">    //调用Drools规则引擎实现信用卡申请</span><br><span class="line">    public CreditCardApplyInfo creditCardApply(CreditCardApplyInfo creditCardApplyInfo)&#123;</span><br><span class="line">        KieSession session = kieBase.newKieSession();</span><br><span class="line">        session.insert(creditCardApplyInfo);</span><br><span class="line">        session.fireAllRules();</span><br><span class="line">        session.dispose();</span><br><span class="line">        return creditCardApplyInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第七步：创建RuleController</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.drools.entity.CreditCardApplyInfo;</span><br><span class="line">import com.itheima.drools.service.RuleService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/rule&quot;)</span><br><span class="line">public class RuleController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RuleService ruleService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/creditCardApply&quot;)</span><br><span class="line">    public CreditCardApplyInfo creditCardApply(@RequestBody </span><br><span class="line">        CreditCardApplyInfo creditCardApplyInfo)&#123;</span><br><span class="line">        creditCardApplyInfo = ruleService.creditCardApply(creditCardApplyInfo);</span><br><span class="line">        return creditCardApplyInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第八步：创建启动类DroolsApplication</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class DroolsApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DroolsApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第九步：导入静态资源文件到resources/static目录下</p><h3 id="11-3-保险产品准入规则-学到决策表这里-高级部分跳过"><a href="#11-3-保险产品准入规则-学到决策表这里-高级部分跳过" class="headerlink" title="11.3 保险产品准入规则  (学到决策表这里 高级部分跳过)"></a>11.3 保险产品准入规则  (学到决策表这里 高级部分跳过)</h3><h4 id="11-3-1-决策表"><a href="#11-3-1-决策表" class="headerlink" title="11.3.1 决策表"></a>11.3.1 决策表</h4><p>  前面的课程中我们编写的规则文件都是drl形式的文件，Drools除了支持drl形式的文件外还支持xls格式的文件（即Excel文件）。这种xls格式的文件通常称为决策表（decision table）。</p><p>  决策表（decision table）是一个“精确而紧凑的”表示条件逻辑的方式，非常适合商业级别的规则。决策表与现有的drl文件可以无缝替换。Drools提供了相应的API可以将xls文件编译为drl格式的字符串。</p><p>  一个决策表的例子如下：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnj1ywwmj20zf0bumxh.jpg" alt="image-20200217160930138.png"></p><p>  决策表语法：</p><table><thead><tr><th align="left">关键字</th><th align="left">说明</th><th align="left">是否必须</th></tr></thead><tbody><tr><td align="left">RuleSet</td><td align="left">相当于drl文件中的package</td><td align="left">必须，只能有一个。如果没有设置RuleSet对应的值则使用默认值rule_table</td></tr><tr><td align="left">Sequential</td><td align="left">取值为Boolean类型。true表示规则按照表格自上到下的顺序执行，false表示乱序</td><td align="left">可选</td></tr><tr><td align="left">Import</td><td align="left">相当于drl文件中的import，如果引入多个类则类之间用逗号分隔</td><td align="left">可选</td></tr><tr><td align="left">Variables</td><td align="left">相当于drl文件中的global，用于定义全局变量，如果有多个全局变量则中间用逗号分隔</td><td align="left">可选</td></tr><tr><td align="left">RuleTable</td><td align="left">它指示了后面将会有一批rule，RuleTable的名称将会作为以后生成rule的前缀</td><td align="left">必须</td></tr><tr><td align="left">CONDITION</td><td align="left">规则条件关键字，相当于drl文件中的when。下面两行则表示 LHS 部分，第三行则为注释行，不计为规则部分，从第四行开始，每一行表示一条规则</td><td align="left">每个规则表至少有一个</td></tr><tr><td align="left">ACTION</td><td align="left">规则结果关键字，相当于drl文件中的then</td><td align="left">每个规则表至少有一个</td></tr><tr><td align="left">NO-LOOP</td><td align="left">相当于drl文件中的no-loop</td><td align="left">可选</td></tr><tr><td align="left">AGENDA-GROUP</td><td align="left">相当于drl文件中的agenda-group</td><td align="left">可选</td></tr></tbody></table><p>  在决策表中还经常使用到占位符，语法为$后面加数字，用于替换每条规则中设置的具体值。</p><p>  上面的决策表例子转换为drl格式的规则文件内容如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.PersonInfoEntity;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">global java.util.List listRules;</span><br><span class="line"></span><br><span class="line">rule <span class="string">"personCheck_10"</span></span><br><span class="line">    salience <span class="number">65535</span></span><br><span class="line">    agenda-group <span class="string">"sign"</span></span><br><span class="line">    when</span><br><span class="line">        $person : PersonInfoEntity(sex != <span class="string">"男"</span>)</span><br><span class="line">    then</span><br><span class="line">        listRules.add(<span class="string">"性别不对"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"personCheck_11"</span></span><br><span class="line">    salience <span class="number">65534</span></span><br><span class="line">    agenda-group <span class="string">"sign"</span></span><br><span class="line">    when</span><br><span class="line">        $person : PersonInfoEntity(age &lt; <span class="number">22</span> || age &gt; <span class="number">25</span>)</span><br><span class="line">    then</span><br><span class="line">        listRules.add(<span class="string">"年龄不合适"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"personCheck_12"</span></span><br><span class="line">    salience <span class="number">65533</span></span><br><span class="line">    agenda-group <span class="string">"sign"</span></span><br><span class="line">    when</span><br><span class="line">        $person : PersonInfoEntity(salary &lt; <span class="number">10000</span>)</span><br><span class="line">    then</span><br><span class="line">        listRules.add(<span class="string">"工资太低了"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>  要进行决策表相关操作，需要导入如下maven坐标：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-decisiontables<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  通过下图可以发现，由于maven的依赖传递特性在导入drools-decisiontables坐标后，drools-core和drools-compiler等坐标也被传递了过来</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnjdtdguj20m904yt8x.jpg" alt="image-20200218105819932.png"></p><p>  Drools提供的将xls文件编译为drl格式字符串的API如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String realPath = <span class="string">"C:\\testRule.xls"</span>;<span class="comment">//指定决策表xls文件的磁盘路径</span></span><br><span class="line">File file = <span class="keyword">new</span> File(realPath);</span><br><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">SpreadsheetCompiler compiler = <span class="keyword">new</span> SpreadsheetCompiler();</span><br><span class="line">String drl = compiler.compile(is, InputType.XLS);</span><br></pre></td></tr></table></figure><p>  Drools还提供了基于drl格式字符串创建KieSession的API：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KieHelper kieHelper = <span class="keyword">new</span> KieHelper();</span><br><span class="line">kieHelper.addContent(drl, ResourceType.DRL);</span><br><span class="line">KieSession session = kieHelper.build().newKieSession();</span><br></pre></td></tr></table></figure><p>  基于决策表的入门案例：</p><p>  第一步：创建maven工程drools_decisiontable_demo并配置pom.xml文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-decisiontables<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  第二步：创建实体类PersonInfoEntity</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInfoEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第三步：创建xls规则文件（可以直接使用资料中提供的testRule.xls文件）</p><p>  第四步：创建单元测试</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String realPath = <span class="string">"d:\\testRule.xls"</span>;<span class="comment">//指定决策表xls文件的磁盘路径</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(realPath);</span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    SpreadsheetCompiler compiler = <span class="keyword">new</span> SpreadsheetCompiler();</span><br><span class="line">    String drl = compiler.compile(is, InputType.XLS);</span><br><span class="line"></span><br><span class="line">    System.out.println(drl);</span><br><span class="line">    KieHelper kieHelper = <span class="keyword">new</span> KieHelper();</span><br><span class="line">    kieHelper.addContent(drl, ResourceType.DRL);</span><br><span class="line">    KieSession session = kieHelper.build().newKieSession();</span><br><span class="line"></span><br><span class="line">    PersonInfoEntity personInfoEntity = <span class="keyword">new</span> PersonInfoEntity();</span><br><span class="line">    personInfoEntity.setSex(<span class="string">"男"</span>);</span><br><span class="line">    personInfoEntity.setAge(<span class="number">35</span>);</span><br><span class="line">    personInfoEntity.setSalary(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    session.setGlobal(<span class="string">"listRules"</span>,list);</span><br><span class="line"></span><br><span class="line">    session.insert(personInfoEntity);</span><br><span class="line">    </span><br><span class="line">    session.getAgenda().getAgendaGroup(<span class="string">"sign"</span>).setFocus();</span><br><span class="line">    </span><br><span class="line">    session.fireAllRules();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    session.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-2-规则介绍"><a href="#11-3-2-规则介绍" class="headerlink" title="11.3.2 规则介绍"></a>11.3.2 规则介绍</h4><p>  各保险公司针对人身、财产推出了不同的保险产品，作为商业保险公司，筛选出符合公司利益最大化的客户是非常重要的，即各保险产品的准入人群是不同的，也就是说保险公司会针对不同的人群特征，制定不同的产品缴费和赔付规则。</p><p>  我们来看一下某保险产品准入规则的简化版，当不满足以下规则时，系统模块需要返回准入失败标识和失败原因</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">规则1：  保险公司是：PICC</span><br><span class="line">规则2：  销售区域是：北京、天津</span><br><span class="line">规则3：  投保人年龄：0 ~ 17岁</span><br><span class="line">规则4：  保险期间是：20年、25年、30年</span><br><span class="line">规则5：  缴费方式是：趸交（一次性交清）或年交</span><br><span class="line">规则6：  保险期与交费期规则一：保险期间为20年期交费期间最长10年交且不能选择[趸交]</span><br><span class="line">规则7：  保险期与交费期规则二：保险期间为25年期交费期间最长15年交且不能选择[趸交]</span><br><span class="line">规则8：  保险期与交费期规则三：保险期间为30年期交费期间最长20年交且不能选择[趸交]</span><br><span class="line">规则9：  被保人要求：（投保年龄+保险期间）不得大于40周岁</span><br><span class="line">规则10： 保险金额规则：投保时约定，最低为5万元，超过部分必须为1000元的整数倍</span><br><span class="line">规则11： 出单基本保额限额规则：线上出单基本保额限额62.5万元，超62.5万元需配合契调转线下出单</span><br></pre></td></tr></table></figure><p>  在本案例中规则文件是一个Excel文件，业务人员可以直接更改这个文件中指标的值，系统不需要做任何变更。</p><h4 id="11-3-3-实现步骤"><a href="#11-3-3-实现步骤" class="headerlink" title="11.3.3 实现步骤"></a>11.3.3 实现步骤</h4><p>  本案例还是基于Spring Boot整合Drools的架构来实现。</p><p>  第一步：创建maven工程insuranceInfoCheck并配置pom.xml文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="tag"><span class="string">                             http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>insuranceInfoCheck<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--drools规则引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-templates<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  第二步：创建/resources/application.yml文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: insuranceInfoCheck</span><br></pre></td></tr></table></figure><p>  第三步：创建实体类InsuranceInfo</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保险信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsuranceInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String param1;<span class="comment">//保险公司</span></span><br><span class="line">    <span class="keyword">private</span> String param2;<span class="comment">//方案代码</span></span><br><span class="line">    <span class="keyword">private</span> String param3;<span class="comment">//渠道号</span></span><br><span class="line">    <span class="keyword">private</span> String param4;<span class="comment">//销售区域</span></span><br><span class="line">    <span class="keyword">private</span> String param5;<span class="comment">//投保年龄</span></span><br><span class="line">    <span class="keyword">private</span> String param6;<span class="comment">//保险期间</span></span><br><span class="line">    <span class="keyword">private</span> String param7;<span class="comment">//缴费期间</span></span><br><span class="line">    <span class="keyword">private</span> String param8;<span class="comment">//缴费方式</span></span><br><span class="line">    <span class="keyword">private</span> String param9;<span class="comment">//保障类型</span></span><br><span class="line">    <span class="keyword">private</span> String param10;<span class="comment">//等待期</span></span><br><span class="line">    <span class="keyword">private</span> String param11;<span class="comment">//犹豫期</span></span><br><span class="line">    <span class="keyword">private</span> String param12;<span class="comment">//职业类型</span></span><br><span class="line">    <span class="keyword">private</span> String param13;<span class="comment">//保额限制</span></span><br><span class="line">    <span class="keyword">private</span> String param14;<span class="comment">//免赔额</span></span><br><span class="line">    <span class="keyword">private</span> String param15;<span class="comment">//主险保额</span></span><br><span class="line">    <span class="keyword">private</span> String param16;<span class="comment">//主险保费</span></span><br><span class="line">    <span class="keyword">private</span> String param17;<span class="comment">//附加险保额</span></span><br><span class="line">    <span class="keyword">private</span> String param18;<span class="comment">//附加险保费</span></span><br><span class="line">    <span class="keyword">private</span> String param19;<span class="comment">//与投保人关系</span></span><br><span class="line">    <span class="keyword">private</span> String param20;<span class="comment">//与被保人关系</span></span><br><span class="line">    <span class="keyword">private</span> String param21;<span class="comment">//性别</span></span><br><span class="line">    <span class="keyword">private</span> String param22;<span class="comment">//证件</span></span><br><span class="line">    <span class="keyword">private</span> String param23;<span class="comment">//保费</span></span><br><span class="line">    <span class="keyword">private</span> String param24;<span class="comment">//保额</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第四步：创建决策表文件（也可以直接使用实战资料中提供的insuranceInfoCheck.xls文件）</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnjpsulfj20yu0d7aa8.jpg" alt="image-20200218120618384.png"></p><p>  第五步：封装工具类KieSessionUtils</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.InsuranceInfo;</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.PersonInfoEntity;</span><br><span class="line"><span class="keyword">import</span> org.drools.decisiontable.InputType;</span><br><span class="line"><span class="keyword">import</span> org.drools.decisiontable.SpreadsheetCompiler;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.Message;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.Results;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.io.ResourceType;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.kie.internal.utils.KieHelper;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KieSessionUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">KieSessionUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把xls文件解析为String</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDRL</span> <span class="params">(String realPath)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(realPath); <span class="comment">// 例如：C:\\abc.xls</span></span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        SpreadsheetCompiler compiler = <span class="keyword">new</span> SpreadsheetCompiler();</span><br><span class="line">        String drl = compiler.compile(is, InputType.XLS);</span><br><span class="line">        System.out.println(drl);</span><br><span class="line">        <span class="keyword">return</span> drl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// drl为含有内容的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KieSession <span class="title">createKieSessionFromDRL</span><span class="params">(String drl)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        KieHelper kieHelper = <span class="keyword">new</span> KieHelper();</span><br><span class="line">        kieHelper.addContent(drl, ResourceType.DRL);</span><br><span class="line">        Results results = kieHelper.verify();</span><br><span class="line">        <span class="keyword">if</span> (results.hasMessages(Message.Level.WARNING, Message.Level.ERROR)) &#123;</span><br><span class="line">            List&lt;Message&gt; messages = results.getMessages(Message.Level.WARNING, Message.Level.ERROR);</span><br><span class="line">            <span class="keyword">for</span> (Message message : messages) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Error: "</span>+message.getText());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// throw new IllegalStateException("Compilation errors were found. Check the logs.");</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kieHelper.build().newKieSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// realPath为Excel文件绝对路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KieSession <span class="title">getKieSessionFromXLS</span><span class="params">(String realPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createKieSessionFromDRL(getDRL(realPath));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第六步：创建RuleService类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.InsuranceInfo;</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.utils.KieSessionUtils;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">insuranceInfoCheck</span><span class="params">(InsuranceInfo insuranceInfo)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        KieSession session = KieSessionUtils.getKieSessionFromXLS(<span class="string">"D:\\rules.xls"</span>);</span><br><span class="line">        session.getAgenda().getAgendaGroup(<span class="string">"sign"</span>).setFocus();</span><br><span class="line"></span><br><span class="line">        session.insert(insuranceInfo);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; listRules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        session.setGlobal(<span class="string">"listRules"</span>, listRules);</span><br><span class="line"></span><br><span class="line">        session.fireAllRules();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> listRules;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第七步：创建RuleController类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.InsuranceInfo;</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.service.RuleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rule"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RuleService ruleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/insuranceInfoCheck"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">insuranceInfoCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模拟数据，实际应为页面传递过来</span></span><br><span class="line">        InsuranceInfo insuranceInfo = <span class="keyword">new</span> InsuranceInfo();</span><br><span class="line">        insuranceInfo.setParam1(<span class="string">"picc"</span>);</span><br><span class="line">        insuranceInfo.setParam4(<span class="string">"上海"</span>);</span><br><span class="line">        insuranceInfo.setParam5(<span class="string">"101"</span>);</span><br><span class="line">        insuranceInfo.setParam6(<span class="string">"12"</span>);</span><br><span class="line">        insuranceInfo.setParam7(<span class="string">"222"</span>);</span><br><span class="line">        insuranceInfo.setParam8(<span class="string">"1"</span>);</span><br><span class="line">        insuranceInfo.setParam13(<span class="string">"3"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = ruleService.insuranceInfoCheck(insuranceInfo);</span><br><span class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                map.put(<span class="string">"checkResult"</span>,<span class="keyword">false</span>);</span><br><span class="line">                map.put(<span class="string">"msg"</span>,<span class="string">"准入失败"</span>);</span><br><span class="line">                map.put(<span class="string">"detail"</span>,list);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(<span class="string">"checkResult"</span>,<span class="keyword">true</span>);</span><br><span class="line">                map.put(<span class="string">"msg"</span>,<span class="string">"准入成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            map.put(<span class="string">"checkResult"</span>,<span class="keyword">false</span>);</span><br><span class="line">            map.put(<span class="string">"msg"</span>,<span class="string">"未知错误"</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第八步：创建启动类DroolsApplication</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroolsApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DroolsApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-Supplement"><a href="#12-Supplement" class="headerlink" title="12. Supplement"></a>12. Supplement</h2><h3 id="12-1-Kiehelper"><a href="#12-1-Kiehelper" class="headerlink" title="12.1 Kiehelper"></a>12.1 Kiehelper</h3><p>KieHelper是高版本的drools官方提供的工具操作类，可以更加方便的操作KIE中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KieHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">KieHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Constructing instances is not allowed for this class</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KieContainer <span class="title">getKieContainer</span><span class="params">(ReleaseId releaseId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               Resource... resources)</span> </span>&#123;</span><br><span class="line">        KieServices ks = KieServices.Factory.get();</span><br><span class="line">        createJar(ks, releaseId, resources);</span><br><span class="line">        <span class="keyword">return</span> ks.newKieContainer(releaseId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KieModule <span class="title">createAndDeployJar</span><span class="params">(KieServices ks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               ReleaseId releaseId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               Resource... resources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] jar = createJar(ks, releaseId, resources);</span><br><span class="line"></span><br><span class="line">        KieModule km = deployJarIntoRepository(ks, jar);</span><br><span class="line">        <span class="keyword">return</span> km;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] createJar(KieServices ks, ReleaseId releaseId, Resource... resources) &#123;</span><br><span class="line">        KieFileSystem kfs = ks.newKieFileSystem().generateAndWritePomXML(releaseId);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resources.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resources[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                kfs.write(resources[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        KieBuilder kieBuilder = ks.newKieBuilder(kfs);</span><br><span class="line">        ((InternalKieBuilder) kieBuilder).buildAll(o -&gt; <span class="keyword">true</span>);</span><br><span class="line">        Results results = kieBuilder.getResults();</span><br><span class="line">        <span class="keyword">if</span> (results.hasMessages(Message.Level.ERROR)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(results.getMessages(Message.Level.ERROR).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        InternalKieModule kieModule = (InternalKieModule) ks.getRepository()</span><br><span class="line">                .getKieModule(releaseId);</span><br><span class="line">        <span class="keyword">byte</span>[] jar = kieModule.getBytes();</span><br><span class="line">        <span class="keyword">return</span> jar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KieModule <span class="title">deployJarIntoRepository</span><span class="params">(KieServices ks, <span class="keyword">byte</span>[] jar)</span> </span>&#123;</span><br><span class="line">        Resource jarRes = ks.getResources().newByteArrayResource(jar);</span><br><span class="line">        KieModule km = ks.getRepository().addKieModule(jarRes);</span><br><span class="line">        <span class="keyword">return</span> km;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-KieSession-和StatelessSession"><a href="#12-2-KieSession-和StatelessSession" class="headerlink" title="12.2 KieSession 和StatelessSession"></a>12.2 KieSession 和StatelessSession</h3><p><strong>KieSession</strong></p><p>通过KieContainer可以获取KieSession，在kmodule.xml配置文件中如果不指定ksession的type默认也是有状态的session。有状态session的特性是，我们可以通过建立一次session完成多次与规则引擎之间的交互，在没有调用dispose方法时，会维持会话状态。使用KieSession的一般步骤为，获取session，insert Fact对象，然后调用fireAllRules进行规则匹配，随后调用dispose方法关闭session。</p><p><strong>StatelessSession</strong></p><p>StatelessKieSession提供了一个更加便利的API，是对KisSession的封装，不再调用dispose方法进行session的关闭。它隔离了每次与规则引擎的交互，不会再去维护会话的状态。同时也不再提供fireAllRules方法。<br>使用场景：<br>（1）数据校验<br>（2）运算<br>（3）数据过滤<br>（4）消息路由<br>（5）任何能被描述成函数或公式的规则</p><h2 id="13-Tips"><a href="#13-Tips" class="headerlink" title="13. Tips"></a>13. Tips</h2><p>DSL文件汇中写的判断条件，并不是直接使用的POJO类里面的属性，目前我的理解比较粗浅，应该是自动补全了get这个方法来获得的属性值，因为原来POJO里面的类属性是Private的。（也存在使用映射获得这个属性值的可能性）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Drools的复杂度非常高，本文前面Base Component出处是网络上流传的黑马教学文档。&lt;/p&gt;
&lt;p&gt;后面复杂的部分晚些我会补上。&lt;/p&gt;
&lt;p&gt;笑，maybe&lt;/p&gt;</summary>
    
    
    
    
    <category term="Drools" scheme="http://yoursite.com/tags/Drools/"/>
    
  </entry>
  
  <entry>
    <title>Jackson初体验</title>
    <link href="http://yoursite.com/2020/09/25/Jackson%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2020/09/25/Jackson%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2020-09-25T10:49:45.000Z</published>
    <updated>2025-07-30T07:24:16.711Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Jackson</p></blockquote><a id="more"></a> <h1 id="Jsckson"><a href="#Jsckson" class="headerlink" title="Jsckson"></a>Jsckson</h1><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><p><strong>Streaming</strong> : jackson-core jar，定义了底层的streaming API和实现了Json特性。<br><strong>Annotations</strong>: jackson-annotations jar，包含了标准的Jackson注解。<br><strong>Databind</strong> : jackson-databind jar，实现了数据绑定和对象序列化，它依赖于streaming和annotations的包。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="Object-gt-Json"><a href="#Object-gt-Json" class="headerlink" title="Object -&gt; Json"></a>Object -&gt; Json</h3><p><strong>writevalue(….)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">Staff obj = <span class="keyword">new</span> Staff();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object to JSON in file</span></span><br><span class="line">mapper.writeValue(<span class="keyword">new</span> File(<span class="string">"c:\\file.json"</span>), obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object to JSON in String</span></span><br><span class="line">String jsonInString = mapper.writeValueAsString(obj);</span><br></pre></td></tr></table></figure><h3 id="Json-gt-object"><a href="#Json-gt-object" class="headerlink" title="Json -&gt; object"></a>Json -&gt; object</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String jsonInString = <span class="string">"&#123;'name' : 'mjw'&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON from file to Object</span></span><br><span class="line">Staff obj = mapper.readValue(<span class="keyword">new</span> File(<span class="string">"c:\\file.json"</span>), Staff<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON from URL to Object</span></span><br><span class="line">Staff obj = mapper.readValue(<span class="keyword">new</span> URL(<span class="string">"http://www.jianshu.com/u/c38e94dcec65"</span>), Staff<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON from String to Object</span></span><br><span class="line">Staff obj = mapper.readValue(jsonInString, Staff<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="Pojo"><a href="#Pojo" class="headerlink" title="Pojo"></a>Pojo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-和-JSON-的相互转换"><a href="#Java-和-JSON-的相互转换" class="headerlink" title="Java 和 JSON 的相互转换"></a>Java 和 JSON 的相互转换</h3><p>下面通过一个实例，说明如何使用 Jackson 实现JSON和Java对象相互转换。<br> Album 类，包含一个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Album</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Album</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-ObjectMapper-进行转换"><a href="#使用-ObjectMapper-进行转换" class="headerlink" title="使用 ObjectMapper 进行转换"></a>使用 ObjectMapper 进行转换</h4><p>Jackson 默认使用 BeanSerializer 序列化POJO，要求对应的字段为 public，或者有对应的 getter 方法。</p><p>输出：</p><blockquote><p>{“title”:”Kind Of Blue”}</p></blockquote><h4 id="数组序列化"><a href="#数组序列化" class="headerlink" title="数组序列化"></a>数组序列化</h4><p>现在继续向 Album 添加一个数组字段及对应的 getter 和 setter 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] links;</span><br><span class="line"><span class="keyword">public</span> String[] getLinks()&#123;</span><br><span class="line">    <span class="keyword">return</span> links;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLinks</span><span class="params">(String[] links)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.links = links;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Album album = <span class="keyword">new</span> Album(<span class="string">"Kind Of Blue"</span>);</span><br><span class="line">album.setLinks(<span class="keyword">new</span> String[]&#123;<span class="string">"link1"</span>, <span class="string">"link2"</span>&#125;);</span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">mapper.writeValue(System.out, album);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>{“title”:”Kind Of Blue”,”links”:[“link1”,”link2”]}</p></blockquote><h4 id="List-序列化"><a href="#List-序列化" class="headerlink" title="List 序列化"></a>List 序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; songs;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getSongs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> songs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSongs</span><span class="params">(List&lt;String&gt; songs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.songs = songs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Album album = <span class="keyword">new</span> Album(<span class="string">"Kind Of Blue"</span>);</span><br><span class="line">album.setLinks(<span class="keyword">new</span> String[]&#123;<span class="string">"link1"</span>, <span class="string">"link2"</span>&#125;);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; songs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">songs.add(<span class="string">"So what"</span>);</span><br><span class="line">songs.add(<span class="string">"Flamenco Sketches"</span>);</span><br><span class="line">songs.add(<span class="string">"Freddie Freeloader"</span>);</span><br><span class="line"></span><br><span class="line">album.setSongs(songs);</span><br><span class="line"></span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">mapper.writeValue(System.out, album);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>{“title”:”Kind Of Blue”,”links”:[“link1”,”link2”],”songs”:[“So what”,”Flamenco Sketches”,”Freddie Freeloader”]}</p></blockquote><p>从输出结构可以看到，List和数组的输出格式是一样的。</p><h4 id="Java-对象序列化"><a href="#Java-对象序列化" class="headerlink" title="Java 对象序列化"></a>Java 对象序列化</h4><p>Java 对象，序列化后在JSON中被 {} 括起来。<br> 定义Artist 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Artist</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Date birthDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Album 中添加对应的字段，并在 main 中设置其值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Artist artist = <span class="keyword">new</span> Artist();</span><br><span class="line">artist.name = <span class="string">"Miles Davis"</span>;</span><br><span class="line">SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd-MM-yyyy"</span>);</span><br><span class="line">artist.birthDate = format.parse(<span class="string">"26-05-1926"</span>);</span><br><span class="line">album.setArtist(artist);</span><br></pre></td></tr></table></figure><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>配置 ObjectMapper ，可以让输出更好看一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapper.configure(SerializationFeature.INDENT_OUTPUT, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>此时的JSON输出如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span> : <span class="string">"Kind Of Blue"</span>,</span><br><span class="line">  <span class="attr">"links"</span> : [ <span class="string">"link1"</span>, <span class="string">"link2"</span> ],</span><br><span class="line">  <span class="attr">"songs"</span> : [ <span class="string">"So what"</span>, <span class="string">"Flamenco Sketches"</span>, <span class="string">"Freddie Freeloader"</span> ],</span><br><span class="line">  <span class="attr">"artist"</span> : &#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Miles Davis"</span>,</span><br><span class="line">    <span class="attr">"birthDate"</span> : <span class="number">-1376035200000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Map-序列化"><a href="#Map-序列化" class="headerlink" title="Map 序列化"></a>Map 序列化</h4><p>向 Album 中添加如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; musicians = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getMusicians</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableMap(musicians);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMusician</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">    musicians.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main 中添加如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">album.addMusician(<span class="string">"Miles Davis"</span>, <span class="string">"Trumpet, Band leader"</span>);</span><br><span class="line">album.addMusician(<span class="string">"Julian Adderley"</span>, <span class="string">"Alto Saxophone"</span>);</span><br><span class="line">album.addMusician(<span class="string">"Paul Chambers"</span>, <span class="string">"double bass"</span>);</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span> : <span class="string">"Kind Of Blue"</span>,</span><br><span class="line">  <span class="attr">"links"</span> : [ <span class="string">"link1"</span>, <span class="string">"link2"</span> ],</span><br><span class="line">  <span class="attr">"songs"</span> : [ <span class="string">"So what"</span>, <span class="string">"Flamenco Sketches"</span>, <span class="string">"Freddie Freeloader"</span> ],</span><br><span class="line">  <span class="attr">"artist"</span> : &#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Miles Davis"</span>,</span><br><span class="line">    <span class="attr">"birthDate"</span> : <span class="number">-1376035200000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"musicians"</span> : &#123;</span><br><span class="line">    <span class="attr">"Miles Davis"</span> : <span class="string">"Trumpet, Band leader"</span>,</span><br><span class="line">    <span class="attr">"Paul Chambers"</span> : <span class="string">"double bass"</span>,</span><br><span class="line">    <span class="attr">"Julian Adderley"</span> : <span class="string">"Alto Saxophone"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>设置输出时间格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat outputFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd MMM yyyy"</span>);</span><br><span class="line">mapper.setDateFormat(outputFormat);</span><br></pre></td></tr></table></figure><p>让Map按序输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>此时输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span> : <span class="string">"Kind Of Blue"</span>,</span><br><span class="line">  <span class="attr">"links"</span> : [ <span class="string">"link1"</span>, <span class="string">"link2"</span> ],</span><br><span class="line">  <span class="attr">"songs"</span> : [ <span class="string">"So what"</span>, <span class="string">"Flamenco Sketches"</span>, <span class="string">"Freddie Freeloader"</span> ],</span><br><span class="line">  <span class="attr">"artist"</span> : &#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Miles Davis"</span>,</span><br><span class="line">    <span class="attr">"birthDate"</span> : <span class="string">"26 May 1926"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"musicians"</span> : &#123;</span><br><span class="line">    <span class="attr">"Julian Adderley"</span> : <span class="string">"Alto Saxophone"</span>,</span><br><span class="line">    <span class="attr">"Miles Davis"</span> : <span class="string">"Trumpet, Band leader"</span>,</span><br><span class="line">    <span class="attr">"Paul Chambers"</span> : <span class="string">"double bass"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Tree-Model-进行转换"><a href="#使用-Tree-Model-进行转换" class="headerlink" title="使用 Tree Model 进行转换"></a>使用 Tree Model 进行转换</h3><p>我们继续使用上面的例子，来演示 Tree Model 的使用。使用 Tree 进行输出包含如下几个步骤：</p><ul><li>创建 JsonNodeFactory，用于创建 node。</li><li>使用JsonFactory创建 JsonGenerator，并指定输出方法。</li><li>创建ObjectMapper，它使用 JsonGenerator 和树的根节点输出到JSON。</li></ul><p>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationExampleTreeModel</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        JsonNodeFactory factory = <span class="keyword">new</span> JsonNodeFactory(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        JsonFactory jsonFactory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">        JsonGenerator generator = jsonFactory.createGenerator(System.out);</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        ObjectNode album = factory.objectNode();</span><br><span class="line">        mapper.writeTree(generator, album);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有添加任何实质性内容，所以输出为：</p><blockquote><p>{}</p></blockquote><p>开始添加内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">album.put(<span class="string">"Album-Title"</span>, <span class="string">"Kind Of Blue"</span>);</span><br></pre></td></tr></table></figure><p>JSON:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"Album-Title"</span>:<span class="string">"Kind Of Blue"</span>&#125;</span><br></pre></td></tr></table></figure><p>添加数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayNode links = factory.arrayNode();</span><br><span class="line">links.add(<span class="string">"link1"</span>).add(<span class="string">"link2"</span>);</span><br><span class="line">album.set(<span class="string">"links"</span>, links);</span><br></pre></td></tr></table></figure><p>JSON:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"Album-Title"</span>:<span class="string">"Kind Of Blue"</span>,<span class="attr">"links"</span>:[<span class="string">"link1"</span>,<span class="string">"link2"</span>]&#125;</span><br></pre></td></tr></table></figure><p>添加对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectNode artist = factory.objectNode();</span><br><span class="line">artist.put(<span class="string">"Artist-Name"</span>, <span class="string">"Miles Davis"</span>);</span><br><span class="line">artist.put(<span class="string">"birthDate"</span>, <span class="string">"26 May 1926"</span>);</span><br><span class="line">album.set(<span class="string">"artist"</span>, artist);</span><br></pre></td></tr></table></figure><p>JSON:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"Album-Title"</span>:<span class="string">"Kind Of Blue"</span>,<span class="attr">"links"</span>:[<span class="string">"link1"</span>,<span class="string">"link2"</span>],<span class="attr">"artist"</span>:&#123;<span class="attr">"Artist-Name"</span>:<span class="string">"Miles Davis"</span>,<span class="attr">"birthDate"</span>:<span class="string">"26 May 1926"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>添加 musicians:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectNode musicians = factory.objectNode();</span><br><span class="line">musicians.put(<span class="string">"Julian Adderley"</span>, <span class="string">"Alto Saxophone"</span>);</span><br><span class="line">musicians.put(<span class="string">"Miles Davis"</span>, <span class="string">"Trumpet, Band leader"</span>);</span><br><span class="line">album.set(<span class="string">"musicians"</span>, musicians);</span><br></pre></td></tr></table></figure><p>JSON:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"Album-Title"</span>:<span class="string">"Kind Of Blue"</span>,<span class="attr">"links"</span>:[<span class="string">"link1"</span>,<span class="string">"link2"</span>],<span class="attr">"artist"</span>:&#123;<span class="attr">"Artist-Name"</span>:<span class="string">"Miles Davis"</span>,<span class="attr">"birthDate"</span>:<span class="string">"26 May 1926"</span>&#125;,<span class="attr">"musicians"</span>:&#123;<span class="attr">"Julian Adderley"</span>:<span class="string">"Alto Saxophone"</span>,<span class="attr">"Miles Davis"</span>:<span class="string">"Trumpet, Band leader"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="注解包"><a href="#注解包" class="headerlink" title="注解包"></a>注解包</h2><h3 id="JsonIgnoreProperties"><a href="#JsonIgnoreProperties" class="headerlink" title="@JsonIgnoreProperties"></a>@JsonIgnoreProperties</h3><p><strong>类注解</strong>, 作用是json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。用法很简单@JsonIgnoreProperties({“property1”,”property2”})，Hibernate延时加载</p><p>因为jsonplugin用的是java的内审机制.hibernate会给被管理的pojo加入一个 hibernateLazyInitializer属性,jsonplugin会把hibernateLazyInitializer也拿出来操作,并读取里面一个不能被反射操作的属性就产生了这个异常，可以用annotation来排除hibernateLazyInitializer这个属性。</p><h3 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a>@JsonIgnore</h3><p><strong>作用于属性或字段上</strong>，用来表明，当生成json的时候忽略有该annotation的方法或字段</p><h3 id="JsonProperty-“firstName”"><a href="#JsonProperty-“firstName”" class="headerlink" title="@JsonProperty(“firstName”)"></a>@JsonProperty(“firstName”)</h3><p>作用于属性或字段上，重命名</p><h3 id="JsonFormat"><a href="#JsonFormat" class="headerlink" title="@JsonFormat"></a>@JsonFormat</h3><p>作用于属性或者字段上，方便的把Date类型直接转化为我们想要的模式，如@JsonFormat(pattern =”yyyy-MM-dd HH-mm-ss”)</p><h3 id="JsonSerialize"><a href="#JsonSerialize" class="headerlink" title="@JsonSerialize"></a>@JsonSerialize</h3><p>作用于属性或者字段上，指定序列化方式 @JsonSerialize(as=BasicType.class) 将类型序列化成指定类型 @JsonSerialize(using=CustomDoubleSerialize.class) 作用于属性或者字段上，用于在序列化时嵌入我们自定义的代码，比如序列化一个double<strong>时在其后面限制两位小数点。</strong></p><p>@JsonSerialize(using= CustomDoubleSerialize.class) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publicclass CustomDateDeserialize extends JsonDeserializer&lt;Date&gt; &#123;</span><br><span class="line">         <span class="keyword">private</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Date <span class="title">deserialize</span><span class="params">(JsonParser jp,DeserializationContext ctxt)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> IOException,JsonProcessingException </span>&#123;</span><br><span class="line">                   Date date = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                            date =sdf.parse(jp.getText());</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> date;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JsonDeserialize"><a href="#JsonDeserialize" class="headerlink" title="@JsonDeserialize"></a>@JsonDeserialize</h3><p>作用于属性或者字段上，指定反序列化方式 @JsonDeserialize(as=ValueImpl.class) 将类型反序列化成指定类型 @JsonDeserialize(using= CustomDateDeserialize.class) 用于在反序列化时嵌入我们自定义的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">publicclass CustomDateDeserialize extends JsonDeserializer&lt;Date&gt; &#123;</span><br><span class="line">         <span class="keyword">private</span> SimpleDateFormat sdf = newSimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Date <span class="title">deserialize</span><span class="params">(JsonParser jp,DeserializationContext ctxt)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> IOException,JsonProcessingException </span>&#123;</span><br><span class="line">                   Date date = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                            date =sdf.parse(jp.getText());</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> date;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JsonCreator"><a href="#JsonCreator" class="headerlink" title="@JsonCreator"></a>@JsonCreator</h3><p>作用于使用构造器方法或工厂方法 ，指定反序列化时创建实例方式(默认使用无参数构造器)</p><p>采用构造器方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publicclass MyBean &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@JsonCreator</span></span><br><span class="line"></span><br><span class="line">  publicMyBean(<span class="meta">@JsonProperty</span>(<span class="string">"value"</span>) <span class="keyword">int</span> v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = v;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用相同的方式，可以将@JsonCreator用在静态工厂方法上</p><p>不过，还有一个可选的替代方案，被称作“授权式”构建器（“delegating” creator）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingPOJO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> _x, _y;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JsonCreator</span></span><br><span class="line">   publicDelegatingPOJO(Map&lt;String,Object&gt; delegate) &#123;</span><br><span class="line">      _x = (Integer)delegate.get(<span class="string">"x"</span>);</span><br><span class="line">      _y = (Integer)delegate.get(<span class="string">"y"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JsonTypeInfo"><a href="#JsonTypeInfo" class="headerlink" title="@JsonTypeInfo"></a>@JsonTypeInfo</h3><p>类注解，当输出操作的对象拥有多个子类型且在反序列化时需要添加子类对象的类型信息，使用此注解可以正确地设置子类对象的类型</p><p>@JsonTypeInfo(use=Id.CLASS,include=As.PROPERTY,property=”class”)</p><p>子类类型作为属性,属性名为class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"animals"</span>: [ &#123;</span><br><span class="line">    <span class="string">"class"</span> :<span class="string">"jackson.Lion"</span>,</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"Simba"</span>,</span><br><span class="line">    <span class="string">"sound"</span> : <span class="string">"Roar"</span>,</span><br><span class="line">    <span class="string">"type"</span> : <span class="string">"carnivorous"</span>,</span><br><span class="line">    <span class="string">"endangered"</span> : <span class="keyword">true</span></span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use=Id.CLASS,include= As.WRAPPER_OBJECT)</span><br><span class="line"><span class="string">"animals"</span>: [ &#123;</span><br><span class="line">    <span class="string">"jackson.Lion"</span> : &#123;</span><br><span class="line">      <span class="string">"name"</span> : <span class="string">"Simba"</span>,</span><br><span class="line">      <span class="string">"sound"</span> : <span class="string">"Roar"</span>,</span><br><span class="line">      <span class="string">"type"</span> :<span class="string">"carnivorous"</span>,</span><br><span class="line">      <span class="string">"endangered"</span> : <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;]</span><br></pre></td></tr></table></figure><h3 id="JsonAutoDetect"><a href="#JsonAutoDetect" class="headerlink" title="@JsonAutoDetect"></a>@JsonAutoDetect</h3><p>类注解，指定属性发现规则</p><p>Jackson默认的属性发现规则将会查找到如下所述的属性：</p><p>•所有被public修饰的字段（成员变量）；</p><p>•所有被public修饰的getter（即形如“getXxx()”的方法）；</p><p>•所有被public修饰的setter（即形如“setXxx(value)”的方法）</p><p>@JsonAutoDetect(fieldVisibility=JsonAutoDetect.Visibility.ANY)</p><p>@JsonAutoDetect(fieldVisibility=JsonAutoDetect.Visibility.NONE)</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Jackson&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Jackson" scheme="http://yoursite.com/tags/Jackson/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2020/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-09-21T15:19:21.000Z</published>
    <updated>2025-07-30T06:32:16.665Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设计模式</p></blockquote><p>设计模式也是一个重要环节，值得花时间在上面。</p><a id="more"></a> <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="Adapter模式"><a href="#Adapter模式" class="headerlink" title="Adapter模式"></a>Adapter模式</h2><p>Adapter模式即适配器模式，对于适配器的理解参考现实生活中把交流电转换成直流电的电源适配器，用于填补<strong>现有的程序</strong>和<strong>所需的程序</strong>之间差异的设计模式就是Adapter模式，有以下两种实现方式：</p><p> 1. 类适配器模式（使用继承的适配器）<br> 2. 对象适配器模式（使用委托的适配器）<br>所谓继承和委托的区别在哪呢？<strong>委托是指将某个方法中的实际处理交给其他实例的方法</strong>，继承则是自己进行处理，下面分别看下两种实现方式：</p><p>这里有一个需要被适配的Banner类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被适配角色：交流100福特电源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guozhenZhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年6月21日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.string = string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"("</span>+ string +<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*"</span>+ string +<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;设计模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设计模式也是一个重要环节，值得花时间在上面。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2020/09/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/09/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-09-19T02:10:25.000Z</published>
    <updated>2025-07-30T06:35:01.758Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 正则表达式，学一次忘一次，记录之。</p></blockquote><a id="more"></a> <h1 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h1><blockquote><p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1givrsiqe4xj20hl0bsq37.jpg" alt="undefined"></p><p>以上的正则表达式可以接受 <code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。 但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p><h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1.基本匹配"></a>1.基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。 例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;the&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2.元字符"></a>2.元字符</h2><p>元字符不代表他们本身的字面意思，他们都有特殊的含义。</p><p>一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>句号匹配任意单个字符除了换行符。</td></tr><tr><td>[ ]</td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr><td>[^ ]</td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td>*</td><td>匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr><td>+</td><td>匹配&gt;=1个重复的+号前的字符。</td></tr><tr><td>?</td><td>标记?之前的字符为可选.</td></tr><tr><td>{n,m}</td><td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td></tr><tr><td>(xyz)</td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td>|</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td>\</td><td>转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td></tr><tr><td>^</td><td>从开始行开始匹配.</td></tr><tr><td>$</td><td>从末端开始匹配.</td></tr></tbody></table><h3 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a>2.1 点运算符 <code>.</code></h3><p><code>.</code>是元字符中最简单的例子。 <code>.</code>匹配任意单个字符，但不匹配换行符。 例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;.ar&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure><h3 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h3><p>字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[Tt]he&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure><p>方括号的句号就表示句号。 表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ar[.]&quot; =&gt; A garage is a good place to park a car.</span><br></pre></td></tr></table></figure><h4 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h4><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[^c]ar&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure><h3 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a>2.3 重复次数</h3><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。</p><h4 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a>2.3.1 <code>*</code> 号</h4><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。 例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[a-z]*&quot; =&gt; The car parked in the garage #21.</span><br></pre></td></tr></table></figure><p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。 <code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\s*cat\s*&quot; =&gt; The fat cat sat on the concatenation.</span><br></pre></td></tr></table></figure><h4 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a>2.3.2 <code>+</code> 号</h4><p><strong><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。</strong> 例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;c.+t&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h4 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a>2.3.3 <code>?</code> 号</h4><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[T]he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[T]?he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h3 id="2-4-号"><a href="#2-4-号" class="headerlink" title="2.4 {} 号"></a>2.4 <code>{}</code> 号</h3><p>在正则表达式中 <code>{}</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,3&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure><p>我们可以省略第二个参数。 例如，<code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,&#125;&quot; =&gt; The number was 9.9997 but we rounded it of</span><br></pre></td></tr></table></figure><p>如果逗号也省略掉则表示重复固定的次数。 例如，<code>[0-9]{3}</code> 匹配3位数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;3&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure><h3 id="2-5-特征标群"><a href="#2-5-特征标群" class="headerlink" title="2.5 (...) 特征标群"></a>2.5 <code>(...)</code> 特征标群</h3><p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, <strong>表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。</strong>再比如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>{}</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p><p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(c|g|p)ar&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h3 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a>2.6 <code>|</code> 或运算符</h3><p>或运算符就表示或，用作判断条件。</p><p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he|car&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h3 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a>2.7 转码特殊字符</h3><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p><p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(f|c|m)at\.?&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h3 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a>2.8 锚点</h3><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p><h4 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a>2.8.1 <code>^</code> 号</h4><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p><p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;^(T|t)he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h4 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a>2.8.2 <code>$</code> 号</h4><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p><p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(at\.)&quot; =&gt; The fat cat. sat. on the mat.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(at\.)$&quot; =&gt; The fat cat. sat. on the mat.</span><br></pre></td></tr></table></figure><h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式提供一些常用的字符集简写。如下:</p><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>除换行符外的所有字符</td></tr><tr><td>\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td>\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td>\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td>\s</td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p{Z}]</code></td></tr><tr><td>\S</td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符</td></tr><tr><td>\p</td><td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><hr><blockquote><p>进阶内容：</p></blockquote><h2 id="4-零宽断言"><a href="#4-零宽断言" class="headerlink" title="4.零宽断言"></a>4.零宽断言</h2><blockquote><p>无论是零宽还是断言，听起来都古古怪怪的，<br>那先解释一下这两个词。</p></blockquote><ol><li><p>断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，<br>意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”,正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.</p></li><li><p>零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</p></li></ol><p>假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1   &quot;&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;&quot;</span><br></pre></td></tr></table></figure><p>其中也就‘641’这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果正则应该怎么匹配呢？</p><p>下面先来讲几种类型的断言：</p><ol><li>正向先行断言（正前瞻）：</li></ol><ul><li>语法：（?=pattern）<br>作用：匹配pattern表达式的前面内容，不返回本身。</li></ul><p>这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到<code>&lt;/span&gt;</code>前面的数字内容</p><p>按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=) 就可以匹配到前面的内容了。</p><p>匹配什么内容呢？如果要所有内容那就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">".+(?=&lt;/span&gt;)"</span>;</span><br><span class="line"></span><br><span class="line">String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=  pattern.matcher(test);</span><br><span class="line"><span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">System.out.println(<span class="string">"匹配结果："</span>);</span><br><span class="line">System.out.println(mc.group());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配结果：</span></span><br><span class="line"><span class="comment">//&lt;span class="read-count"&gt;阅读数：641</span></span><br></pre></td></tr></table></figure><p>可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"\\d+(?=&lt;/span&gt;)"</span>;</span><br><span class="line"></span><br><span class="line">String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=  pattern.matcher(test);</span><br><span class="line"><span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">  System.out.println(mc.group());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配结果：</span></span><br><span class="line"><span class="comment">//641</span></span><br></pre></td></tr></table></figure><ol start="2"><li>正向后行断言（正后顾）:</li></ol><ul><li><p>语法：（?&lt;=pattern）</p><p>作用：匹配pattern表达式的后面的内容，不返回本身。</p></li></ul><p>有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。<br>上面的栗子，我们也可以用后行断言来处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(?&lt;=&lt;span class="read-count"&gt;阅读数：)\d+</span></span><br><span class="line">String reg=<span class="string">"(?&lt;=&lt;span class=\"read-count\"&gt;阅读数：)\\d+"</span>;</span><br><span class="line"></span><br><span class="line">String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=    pattern.matcher(test);</span><br><span class="line">     <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">       System.out.println(mc.group());</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//匹配结果：</span></span><br><span class="line"><span class="comment">//641</span></span><br></pre></td></tr></table></figure><p>就这么简单。</p><ol start="3"><li>负向先行断言（负前瞻）</li></ol><ul><li>语法：(?!pattern)</li><li>作用：匹配非pattern表达式的前面内容，不返回本身。</li></ul><p>有正向也有负向，负向在这里其实就是非的意思。<br>举个栗子：<strong>比如有一句 “我爱祖国，我是祖国的花朵”</strong><br><strong>现在要找到不是’的花朵’前面的祖国</strong><br>用正则就可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">祖国(?!的花朵)</span><br></pre></td></tr></table></figure><ol start="4"><li>负向后行断言（负后顾）</li></ol><ul><li>语法：(?&lt;!pattern)</li><li>作用：匹配非pattern表达式的后面内容，不返回本身。</li></ul><h2 id="5-捕获和非捕获"><a href="#5-捕获和非捕获" class="headerlink" title="5. 捕获和非捕获"></a>5. 捕获和非捕获</h2><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”</p><blockquote><p>捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。</p></blockquote><p>而根据命名方式的不同，又可以分为两种组：</p><ol><li>数字编号捕获组：<br>语法：(exp)<br>解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。<br>比如固定电话的：020-85653333<br>他的正则表达式为：(0\d{2})-(\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</li></ol><table><thead><tr><th>序号</th><th>编号</th><th>分组</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>(0\d{2})-(\d{8})</td><td>020-85653333</td></tr><tr><td>1</td><td>1</td><td>(0\d{2})</td><td>020</td></tr><tr><td>2</td><td>2</td><td>(\d{8})</td><td>85653333</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"020-85653333"</span>;</span><br><span class="line">     String reg=<span class="string">"(0\\d&#123;2&#125;)-(\\d&#123;8&#125;)"</span>;</span><br><span class="line">     Pattern pattern = Pattern.compile(reg);</span><br><span class="line">     Matcher mc= pattern.matcher(test);</span><br><span class="line">     <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line">       System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mc.groupCount();i++)&#123;</span><br><span class="line">             System.out.println(<span class="string">"第"</span>+i+<span class="string">"个分组为："</span>+mc.group(i));</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">第0个分组为：020-85653333</span><br><span class="line">第1个分组为：020</span><br><span class="line">第2个分组为：85653333</span><br></pre></td></tr></table></figure><p>可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。</p><ol start="2"><li>命名编号捕获组：<br>语法：(?<name>exp)<br>解释：分组的命名由表达式中的name指定<br>比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</haoma></quhao></name></li></ol><table><thead><tr><th>序号</th><th>编号</th><th>分组</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>(0\d{2})-(\d{8})</td><td>020-85653333</td></tr><tr><td>1</td><td>quhao</td><td>(0\d{2})</td><td>020</td></tr><tr><td>2</td><td>haoma</td><td>(\d{8})</td><td>85653333</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"020-85653333"</span>;</span><br><span class="line">     String reg=<span class="string">"(?&lt;quhao&gt;0\\d&#123;2&#125;)-(?&lt;haoma&gt;\\d&#123;8&#125;)"</span>;</span><br><span class="line">     Pattern pattern = Pattern.compile(reg);</span><br><span class="line">     Matcher mc= pattern.matcher(test);</span><br><span class="line">     <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line">         System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line">         System.out.println(mc.group(<span class="string">"quhao"</span>));</span><br><span class="line">         System.out.println(mc.group(<span class="string">"haoma"</span>));</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">分组名称为:quhao,匹配内容为：020</span><br><span class="line">分组名称为:haoma,匹配内容为：85653333</span><br></pre></td></tr></table></figure><ol start="3"><li>非捕获组：<br>语法：(?:exp)<br>解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。</li></ol><p>比如上面的正则表达式，程序<strong>不需要用到第一个分组</strong>，那就可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?:\0\d&#123;2&#125;)-(\d&#123;8&#125;)</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>编号</th><th>分组</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>(0\d{2})-(\d{8})</td><td>020-85653333</td></tr><tr><td>1</td><td>1</td><td>(\d{8})</td><td>85653333</td></tr></tbody></table><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：1</span><br><span class="line">第0个分组为：020-85653333</span><br><span class="line">第1个分组为：85653333</span><br></pre></td></tr></table></figure><h2 id="6-反向引用"><a href="#6-反向引用" class="headerlink" title="6.反向引用"></a>6.反向引用</h2><p>上面讲到捕获，我们知道：**<em>捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用**</em>。</p><p>根据捕获组的命名规则，反向引用可分为：</p><ol><li>数字编号组反向引用：\k<br>或\number</li><li>命名编号组反向引用：\k<br>或者&#39;name’</li></ol><p>上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用<br>注意两个字眼：“内容” 和 “使用”<br>这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住<br>那这里所说的“使用”是怎样使用呢？</p><ul><li>1）匹配到一个字母</li><li>2）匹配第下一个字母，检查是否和上一个字母是否一样</li><li>3）如果一样，则匹配成功，否则失败</li></ul><p>首先匹配一个字母：\w<br>我们需要做成分组才能捕获，因此写成这样：(\w)</p><p>那这个表达式就有一个捕获组：（\w）<br>然后我们要用这个捕获组作为条件，那就可以：(\w)\1<br>这样就大功告成了<br>可能有人不明白了，\1是什么意思呢？<br>还记得捕获组有两种命名方式吗，<strong>一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名</strong><br>在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的</p><p>因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k&lt;1&gt;或者\1<br>当然，通常都是是后者。<br>我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"aabbbbgbddesddfiid"</span>;</span><br><span class="line">     Pattern pattern = Pattern.compile(<span class="string">"(\\w)\\1"</span>);</span><br><span class="line">     Matcher mc= pattern.matcher(test);</span><br><span class="line">     <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">         System.out.println(mc.group());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">bb</span><br><span class="line">dd</span><br><span class="line">dd</span><br><span class="line">ii</span><br></pre></td></tr></table></figure><p>嗯，这就是我们想要的了。</p><p>在举个替换的例子，假如想要把字符串中abc换成a</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"abcbbabcbcgbddesddfiid"</span>;</span><br><span class="line">String reg=<span class="string">"(a)(b)c"</span>;</span><br><span class="line">System.out.println(test.replaceAll(reg, <span class="string">"$1"</span>));</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abbabcgbddesddfiid</span><br></pre></td></tr></table></figure><h2 id="7-贪婪和非贪婪"><a href="#7-贪婪和非贪婪" class="headerlink" title="7.贪婪和非贪婪"></a>7.贪婪和非贪婪</h2><p>我们都知道，贪婪就是不满足，尽可能多的要。<br>在正则中，贪婪也是差不多的意思:</p><blockquote><p>贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。<br>特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。</p></blockquote><p>前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;3,6&#125;</span><br></pre></td></tr></table></figure><p>用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"\\d&#123;3,6&#125;"</span>;        </span><br><span class="line">String test=<span class="string">"61762828 176 2991 871"</span>;</span><br><span class="line">System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line">System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line">Pattern p1 =Pattern.compile(reg);</span><br><span class="line">Matcher m1 = p1.matcher(test);</span><br><span class="line"> <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line">   System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文本：61762828 176 2991 44 871</span><br><span class="line">贪婪模式：\d&#123;3,6&#125;</span><br><span class="line">匹配结果：617628</span><br><span class="line">匹配结果：176</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：871</span><br></pre></td></tr></table></figure><p>由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。<br>一个量词就如此贪婪了，<br>那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？</p><blockquote><p>是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"(\\d&#123;1,2&#125;)(\\d&#123;3,4&#125;)"</span>;        </span><br><span class="line">String test=<span class="string">"61762828 176 2991 87321"</span>;</span><br><span class="line">System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line">System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line">Pattern p1 =Pattern.compile(reg);</span><br><span class="line">Matcher m1 = p1.matcher(test);</span><br><span class="line"> <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line">   System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>“617628” 是前面的\d{1,2}匹配出了61，后面的匹配出了7628</li><li>“2991” 是前面的\d{1,2}匹配出了29 ，后面的匹配出了91</li><li>“87321”是前面的\d{1,2}匹配出了87，后面的匹配出了321</li></ol><p><strong>2. 懒惰（非贪婪）</strong></p><blockquote><p>懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。<br>特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。</p></blockquote><p>懒惰量词是在贪婪量词后面加个“？”</p><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+?</td><td>重复1次或者更多次，但尽可能减少重复</td></tr><tr><td>??</td><td>重复0次或者1次，但尽可能减少重复</td></tr><tr><td>(n,m)?</td><td>重复n到m次，尽可能减少重复</td></tr><tr><td>(n,)?</td><td>重复n次以上，但尽可能减少重复</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"(\\d&#123;1,2&#125;?)(\\d&#123;3,4&#125;)"</span>;        </span><br><span class="line">     String test=<span class="string">"61762828 176 2991 87321"</span>;</span><br><span class="line">     System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line">     System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line">     Pattern p1 =Pattern.compile(reg);</span><br><span class="line">     Matcher m1 = p1.matcher(test);</span><br><span class="line">     <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line">         System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文本：61762828 176 2991 87321</span><br><span class="line">贪婪模式：(\d&#123;1,2&#125;?)(\d&#123;3,4&#125;)</span><br><span class="line">匹配结果：61762</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：87321</span><br></pre></td></tr></table></figure><blockquote><p>“61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762<br>“2991” 是左边的懒惰匹配出2，右边的贪婪匹配出991<br>“87321” 左边的懒惰匹配出8，右边的贪婪匹配出7321</p></blockquote><h2 id="8-反义"><a href="#8-反义" class="headerlink" title="8.反义"></a>8.反义</h2><p>前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：</p><table><thead><tr><th>字符</th><th>解释</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了x以外的任意字符</td></tr><tr><td>[^aeiou]</td><td>匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Linux中的通配符"><a href="#Linux中的通配符" class="headerlink" title="Linux中的通配符"></a>Linux中的通配符</h3><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任意个数个字符</td></tr><tr><td>?</td><td>代表任意一个字符，至少一个</td></tr><tr><td>[]</td><td>表示可以匹配字符组中的任意一个</td></tr><tr><td>[abc]</td><td>匹配 a b c中的任意一个</td></tr><tr><td>[a-f]</td><td>匹配范围中任意一个</td></tr></tbody></table><p>以上通配符都可以跟在ls命令后面，在现实的结果里面进行进一层的筛选。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">验证数字：^[0-9]*$</span><br><span class="line"></span><br><span class="line">验证n位的数字：^\d&#123;n&#125;$</span><br><span class="line"></span><br><span class="line">验证至少n位数字：^\d&#123;n,&#125;$</span><br><span class="line"></span><br><span class="line">验证m-n位的数字：^\d&#123;m,n&#125;$</span><br><span class="line"></span><br><span class="line">验证零和非零开头的数字：^(0|[1-9][0-9]*)$</span><br><span class="line"></span><br><span class="line">验证有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br><span class="line"></span><br><span class="line">验证有1-3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$</span><br><span class="line"></span><br><span class="line">验证非零的正整数：^\+?[1-9][0-9]*$</span><br><span class="line"></span><br><span class="line">验证非零的负整数：^\-[1-9][0-9]*$</span><br><span class="line"></span><br><span class="line">验证非负整数（正整数 + 0） ^\d+$</span><br><span class="line"></span><br><span class="line">验证非正整数（负整数 + 0） ^((-\d+)|(0+))$</span><br><span class="line"></span><br><span class="line">验证长度为3的字符：^.&#123;3&#125;$</span><br><span class="line"></span><br><span class="line">验证由26个英文字母组成的字符串：^[A-Za-z]+$</span><br><span class="line"></span><br><span class="line">验证由26个大写英文字母组成的字符串：^[A-Z]+$</span><br><span class="line"></span><br><span class="line">验证由26个小写英文字母组成的字符串：^[a-z]+$</span><br><span class="line"></span><br><span class="line">验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</span><br><span class="line"></span><br><span class="line">验证由数字、26个英文字母或者下划线组成的字符串：^\w+$</span><br><span class="line"></span><br><span class="line">验证用户密码:^[a-zA-Z]\w&#123;5,17&#125;$ 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。</span><br><span class="line"></span><br><span class="line">验证是否含有 ^%&amp;&apos;,;=?$\&quot; 等字符：[^%&amp;&apos;,;=?$\x22]+</span><br><span class="line"></span><br><span class="line">验证汉字：/^[\u4e00-\u9fa5]*$/     </span><br><span class="line"></span><br><span class="line">验证Email地址：^\w+[-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line"></span><br><span class="line">验证InternetURL：^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ ；^[a-zA-z]+://(w+(-w+)*)(.(w+(-w+)*))*(?S*)?$</span><br><span class="line"></span><br><span class="line">验证电话号码：^(\(\d&#123;3,4&#125;\)|\d&#123;3,4&#125;-)?\d&#123;7,8&#125;$：--正确格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX。</span><br><span class="line"></span><br><span class="line">验证身份证号（15位或18位数字）：^\d&#123;15&#125;|\d&#123;&#125;18$</span><br><span class="line"></span><br><span class="line">验证一年的12个月：^(0?[1-9]|1[0-2])$ 正确格式为：“01”-“09”和“1”“12”</span><br><span class="line"></span><br><span class="line">验证一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$ 正确格式为：01、09和1、31。</span><br><span class="line"></span><br><span class="line">整数：^-?\d+$</span><br><span class="line"></span><br><span class="line">非负浮点数（正浮点数 + 0）：^\d+(\.\d+)?$</span><br><span class="line"></span><br><span class="line">正浮点数 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span><br><span class="line"></span><br><span class="line">非正浮点数（负浮点数 + 0） ^((-\d+(\.\d+)?)|(0+(\.0+)?))$</span><br><span class="line"></span><br><span class="line">负浮点数 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span><br><span class="line"></span><br><span class="line">浮点数 ^(-?\d+)(\.\d+)?$</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 正则表达式，学一次忘一次，记录之。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Regex" scheme="http://yoursite.com/tags/Regex/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2020/09/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/09/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-09-05T15:30:58.000Z</published>
    <updated>2025-07-30T06:30:28.192Z</updated>
    
    <content type="html"><![CDATA[<p>终于到经典的动态规划问题，希望能顺利拿下。</p><a id="more"></a> <h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><strong>首先，动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离等等。</p><p>既然是要求最值，求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p><p>动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p><p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p><p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p><p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因。</p><p>提供一个思维框架，辅助思考状态转移方程：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] = base</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] = 求最值(选择1，选择2...)</span><br></pre></td></tr></table></figure><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gikkkp114ij20g60dcjsi.jpg" alt="{B0242798-1A3E-4D63-B93D-D09AB2CBEFC4}_20200909182025.jpg"></p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p><p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p>递归算法的时间复杂度怎么计算？就是用<strong>子问题个数乘以解决一个子问题需要的时间</strong>。</p><p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><p><strong>带备忘录的递归</strong></p><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><h3 id="DP-数组的迭代解法"><a href="#DP-数组的迭代解法" class="headerlink" title="DP 数组的迭代解法"></a>DP 数组的迭代解法</h3><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gilbzj0oe5j20zk0k0whe.jpg" alt="undefined"></p><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gilc0f38y1j20cw02p3yb.jpg" alt="undefined"></p><p>为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p><h3 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h3><p>上面的斐波那契数列很好理解，这个凑零钱问题，理解难度也并不是很高，但是这个凑零钱问题的代码如果直接接触的话会有点难度。</p><p>先看下题目：给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。</p><p>那么那么首先理一下思路，递归的思路如下，我们在这使用递归先解一遍。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gimhknub0vj20j009caba.jpg" alt="undefined"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coin2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> amount = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="keyword">new</span> Coin2().coinChange(coins, amount);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coins.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(coins, amount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (res == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            res = Math.min(res, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">            helper(coins, amount - coins[i], count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样解有个很大的问题，很明显的，这里的时间复杂度已经到了令人无法接受的程度，用时非常非常久。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> amount = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>如果用100来试最小硬币的耗时已经到了使用小时为单位的程度。</p><p>为了优化，接下来使用记忆化递归。</p><p>我们对其进行优化，进行记忆化递归，记忆化递归就是将已运算的结果进行存储，如上图我们对剩9元进行存储，在下次遍历到剩9元硬币时就可以直接返回结果，不必再次遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/11 11:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coin3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> amount = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="keyword">new</span> Coin3().coinChange(coins, amount);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(coins, amount, <span class="keyword">new</span> <span class="keyword">int</span>[amount]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span>[] res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res[amount - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res[amount - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ress = helper(coins, amount - coins[i], res);</span><br><span class="line">            <span class="keyword">if</span> (ress &gt;= <span class="number">0</span> &amp;&amp; ress &lt; min) &#123;</span><br><span class="line">                min = ress + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[amount - <span class="number">1</span>] = min == Integer.MAX_VALUE ? -<span class="number">1</span> : min;</span><br><span class="line">        System.out.println(<span class="string">"index = "</span> + (amount-<span class="number">1</span>) + <span class="string">"的时候，值是"</span>+ res[amount - <span class="number">1</span>] );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[amount - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面最重要的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> ress = helper(coins, amount - coins[i], res);</span><br><span class="line">    <span class="keyword">if</span> (ress &gt;= <span class="number">0</span> &amp;&amp; ress &lt; min) &#123;</span><br><span class="line">        min = ress + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是状态转移方程</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gimp0dfjubj20iy03jdfp.jpg" alt="undefined"></p><p>只要用这个方程的角度来理解这个代码就很好理解，</p><p>外面一层For是用来遍历coins的，然后里面就是递归到最后求值，整个程序的执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C:\Env\jdk1.8.0_144\bin\java.exe &quot;-javaagent:C:\App\IntelliJ IDEA </span><br><span class="line">index = 0的时候，值是1</span><br><span class="line">index = 1的时候，值是1</span><br><span class="line">index = 2的时候，值是2</span><br><span class="line">index = 3的时候，值是2</span><br><span class="line">index = 4的时候，值是1</span><br><span class="line">index = 5的时候，值是2</span><br><span class="line">index = 6的时候，值是2</span><br><span class="line">index = 7的时候，值是3</span><br><span class="line">index = 8的时候，值是3</span><br><span class="line">index = 9的时候，值是2</span><br><span class="line">index = 10的时候，值是3</span><br><span class="line">1599804625398</span><br><span class="line">200</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>整个程序从最里面，amount最小的值开始往字典上面记录，然后到最后结束。</p><p>下面第三种解法，动态规划解法。</p><p>动态规划解法也就是自底向上，动态规划就是将前面计算的结果拿来给后面用，因此如何定义就是一个问题，在这个问题中，我们定义数组res【amount+1】，数组代表数组下标对应的硬币元数所需的最小个数的合集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/11 14:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coin4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> amount = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="keyword">new</span> Coin4().coinChange(coins, amount);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  对于题意，对于任意给出的数来说，需要的硬币数量 &gt; 这个数本身必定是最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  dp的函含义是     对于每个index为amount的钱，value总是其需要的最小硬币数量、</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//  对dp的每个值进行填充</span></span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        <span class="comment">//  0元需要0个硬币来兑换</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//  外层是 amount的遍历，从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="comment">// 内层遍历的是 硬币的种类</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="comment">/** 这个判断要思考一下，比如说  i = 1的时候，</span></span><br><span class="line"><span class="comment">                 *  coins[j] 前后分别是 1，2，5</span></span><br><span class="line"><span class="comment">                 *  如果coins &lt;= j 的时候也就是说，当硬币面额小于余额的时候才会判断。</span></span><br><span class="line"><span class="comment">                 *  这个时候读取了 dp[0]的值，dp[1] = dp[0] + 1</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 *  当数组比较大(大于最大值的硬币)的时候，这个判断有点类似于没用了，</span></span><br><span class="line"><span class="comment">                 *  后面进行的的判断，会把dp[i]中每个硬币的组合都判断一遍。同时更新到了数组里面，取最小值</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  最后返回了数组。</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这个时候本文仅仅引入了状态转移方程这一个概念，下面从动态规划的角度讲一下这题。</p><p>这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。啥叫相互独立？用一个直观的例子来讲解。</p><p>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p><p>PS：关于最优子结构的问题，后文还会再举例探讨。</p><p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p><p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p><p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p><p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p><p>4、<strong>明确</strong> <strong><code>dp</code></strong> <strong>函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 <code>dp</code> 函数：</p><p><code>dp(n)</code> 的定义：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</p><p>搞清楚上面这几个关键点，解法的伪码就可以写出来了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪码框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义：要凑出金额 n，至少要 dp(n) 个硬币</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 做选择，选择需要硬币最少的那个结果</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            res = min(res, <span class="number">1</span> + dp(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 题目要求的最终结果是 dp(amount)</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gimp833eibj20iy03jdfp.jpg" alt="undefined"></p><p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p><p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p><p><strong>2、带备忘录的递归</strong></p><p>类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line">    <span class="comment"># 备忘录</span></span><br><span class="line">    memo = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 查备忘录，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记入备忘录</span></span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><p><strong>3、dp 数组的迭代解法</strong></p><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p><p><strong><code>dp</code></strong> <strong>数组的定义：当目标金额为</strong> <strong><code>i</code></strong> <strong>时，至少需要</strong> <strong><code>dp[i]</code></strong> <strong>枚硬币凑出</strong>。</p><p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p><p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p><p>之后我们会有一章专门讲解动态规划问题，如果有任何问题都可以随时回来重读本文，希望读者在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>下面主要讲两个常见问题：</p><p>1、到底什么才叫「最优子结构」，和动态规划什么关系。</p><p>2、为什么动态规划遍历<code>dp</code>数组的方式五花八门，有的正着遍历，有的倒着遍历，有的斜着遍历，有的无论咋遍历都是对的。</p><h4 id="一、最优子结构详解"><a href="#一、最优子结构详解" class="headerlink" title="一、最优子结构详解"></a>一、最优子结构详解</h4><p>「最优子结构」是某些问题的一种特定性质，并不是动态规划问题专有的。也就是说，很多问题其实都具有最优子结构，只是其中大部分不具有<strong>重叠子</strong>问题，所以我们不把它们归为动态规划系列问题而已。</p><p>我先举个很容易理解的例子：假设你们学校有 10 个班，你已经计算出了每个班的最高考试成绩。那么现在我要求你计算全校最高的成绩，你会不会算？当然会，而且你不用重新遍历全校学生的分数进行比较，而是只要在这 10 个最高成绩中取最大的就是全校的最高成绩。</p><p>这个问题就<strong>符合最优子结构</strong>：可以从子问题的最优结果推出更大规模问题的最优结果。让你算<strong>每个班</strong>的最优成绩就是子问题，你知道所有子问题的答案后，就可以借此推出<strong>全校</strong>学生的最优成绩这个规模更大的问题的答案。</p><p>你看，这么简单的问题都有最优子结构性质，只是因为显然没有重叠子问题，所以我们简单地求最值肯定用不出动态规划。</p><p>再举个例子：假设你们学校有 10 个班，你已知每个班的最大分数差（最高分和最低分的差值）。那么现在我让你计算全校学生中的最大分数差，你会不会算？可以想办法算，但是肯定不能通过已知的这 10 个班的最大分数差推到出来。因为这 10 个班的最大分数差不一定就包含全校学生的最大分数差，比如全校的最大分数差可能是 3 班的最高分和 6 班的最低分之差。</p><p>这次我给你提出的问题就<strong>不符合最优子结构</strong>，因为你没办通过每个班的最优值推出全校的最优值，没办法通过子问题的最优值推出规模更大的问题的最优值。</p><p>想满足最优子结，子问题之间必须互相独立。全校的最大分数差可能出现在两个班之间，显然子问题不独立，所以这个问题本身不符合最优子结构。</p><p><strong>那么遇到这种最优子结构失效情况，怎么办？策略是：改造问题</strong>。对于最大分数差这个问题，我们不是没办法利用已知的每个班的分数差吗，那我只能这样写一段暴力代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Student a : school) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Student b : school) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a is b) <span class="keyword">continue</span>;</span><br><span class="line">        result = max(result, |a.score - b.score|);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>改造问题，也就是把问题等价转化：最大分数差，不就等价于最高分数和最低分数的差么，那不就是要求最高和最低分数么，不就是我们讨论的第一个问题么，不就具有最优子结构了么？那现在改变思路，借助最优子结构解决最值问题，再回过头解决最大分数差问题，是不是就高效多了？</p><p>当然，上面这个例子太简单了，不过请读者回顾一下，我们做动态规划问题，是不是一直在求各种最值，本质跟我们举的例子没啥区别，无非需要处理一下重叠子问题。</p><p>再举个常见但也十分简单的例子，求一棵二叉树的最大值，不难吧（简单起见，假设节点中的值都是非负数）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxVal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = maxVal(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = maxVal(root.right);</span><br><span class="line">    <span class="keyword">return</span> max(root.val, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看这个问题也符合最优子结构，以<code>root</code>为根的树的最大值，可以通过两边子树（子问题）的最大值推导出来，结合刚才学校和班级的例子，很容易理解吧。</p><p>当然这也不是动态规划问题，旨在说明，最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；</p><p><strong>但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的</strong>，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路。</p><p>动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，不断以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。</p><p>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路。</p><h4 id="二、dp-数组的遍历方向"><a href="#二、dp-数组的遍历方向" class="headerlink" title="二、dp 数组的遍历方向"></a>二、dp 数组的遍历方向</h4><p>做动态规划问题时，肯定会对<code>dp</code>数组的遍历顺序有些头疼。我们拿二维<code>dp</code>数组来举例，有时候我们是正向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[][] dp = new int[m][n];</span><br><span class="line">for (int i = 0; i &lt; m; i++)</span><br><span class="line">    for (int j = 0; j &lt; n; j++)</span><br><span class="line">        // 计算 dp[i][j]</span><br></pre></td></tr></table></figure><p>有时候我们反向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = m - 1; i &gt;= 0; i--)</span><br><span class="line">    for (int j = n - 1; j &gt;= 0; j--)</span><br><span class="line">        // 计算 dp[i][j]</span><br></pre></td></tr></table></figure><p>有时候可能会斜向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 斜着遍历数组</span><br><span class="line">for (int l = 2; l &lt;= n; l++) &#123;</span><br><span class="line">    for (int i = 0; i &lt;= n - l; i++) &#123;</span><br><span class="line">        int j = l + i - 1;</span><br><span class="line">        // 计算 dp[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至更让人迷惑的是，有时候发现正向反向遍历都可以得到正确答案，比如我们在 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect" target="_blank" rel="noopener">团灭 LeetCode 股票买卖问题</a> 中有的地方就正反皆可。</p><p>如果仔细观察的话可以发现其中的原因的:</p><p><strong>1、遍历的过程中，所需的状态必须是已经计算出来的</strong>。</p><p><strong>2、遍历的终点必须是存储结果的那个位置</strong>。</p><p>下面来具体解释上面两个原则是什么意思。</p><p>比如编辑距离这个经典的问题，详解见前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484484&idx=1&sn=74594297022c84952162a68b7f739133&chksm=9bd7fa4caca0735a1364dd13901311ecd6ec4913c8db05a1ff6cae8f069627eebe8d651bbeb1&scene=21#wechat_redirect" target="_blank" rel="noopener">经典动态规划：编辑距离</a>，我们通过对<code>dp</code>数组的定义，确定了 base case 是<code>dp[..][0]</code>和<code>dp[0][..]</code>，最终答案是<code>dp[m][n]</code>；而且我们通过状态转移方程知道<code>dp[i][j]</code>需要从<code>dp[i-1][j]</code>,<code>dp[i][j-1]</code>,<code>dp[i-1][j-1]</code>转移而来，如下图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ginx8ihf5uj20u00gw0sz.jpg" alt="undefined"></p><p>那么，参考刚才说的两条原则，你该怎么遍历<code>dp</code>数组？肯定是正向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; m; i++)</span><br><span class="line">    for (int j = 1; j &lt; n; j++)</span><br><span class="line">        // 通过 dp[i-1][j], dp[i][j - 1], dp[i-1][j-1]</span><br><span class="line">        // 计算 dp[i][j]</span><br></pre></td></tr></table></figure><p><strong>因为，这样每一步迭代的左边、上边、左上边的位置都是 base case 或者之前计算过的，而且最终结束在我们想要的答案<code>dp[m][n]</code>。</strong></p><p>再举一例，回文子序列问题，详见前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484666&idx=1&sn=e3305be9513eaa16f7f1568c0892a468&chksm=9bd7faf2aca073e4f08332a706b7c10af877fee3993aac4dae86d05783d3d0df31844287104e&scene=21#wechat_redirect" target="_blank" rel="noopener">子序列解题模板：最长回文子序列</a>，我们通过过对<code>dp</code>数组的定义，确定了 base case 处在中间的对角线，<code>dp[i][j]</code>需要从<code>dp[i+1][j]</code>,<code>dp[i][j-1]</code>,<code>dp[i+1][j-1]</code>转移而来，想要求的最终答案是<code>dp[0][n-1]</code>，如下图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ginxawe8scj20u00gwweq.jpg" alt="undefined"></p><p>这种情况根据刚才的两个原则，就可以有两种正确的遍历方式：</p><p><strong>要么从左至右斜着遍历，要么从下向上从左到右遍历，这样才能保证每次<code>dp[i][j]</code>的左边、下边、左下边已经计算完毕，最终得到正确结果。</strong></p><p>现在，你应该理解了这两个原则，主要就是看 base case 和最终结果的存储位置，保证遍历过程中使用的数据都是计算完毕的就行，有时候确实存在多种方法可以得到正确答案，可根据个人口味自行选择。</p><h2 id="动态规划设计：正则表达式"><a href="#动态规划设计：正则表达式" class="headerlink" title="动态规划设计：正则表达式"></a>动态规划设计：正则表达式</h2><blockquote><p>需求：给定一个字符串 (s) 和一个字符模式 ( p)。实现支持 <code>.</code> 和 <code>*</code> 的正则表达式匹配。</p><ul><li><code>.</code> 匹配任意单个字符。</li><li><code>*</code> 匹配零个或多个前面的元素。</li></ul><p>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。</p><ul><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li></ul></blockquote><p>示例：</p><blockquote><p>输入:<br><code>s = &quot;aa&quot;</code><br><code>p = &quot;a&quot;</code><br>输出: <code>false</code><br>解释: <code>&quot;a&quot;</code> 无法匹配 <code>&quot;aa&quot;</code> 整个字符串。</p></blockquote><blockquote><p>输入:<br><code>s = &quot;aa&quot;</code><br><code>p = &quot;a*&quot;</code><br>输出: <code>true</code><br>解释: <code>&#39;*&#39;</code> 代表可匹配零个或多个前面的元素, 即可以匹配 <code>&#39;a&#39;</code> 。因此, 重复 <code>&#39;a&#39;</code> 一次, 字符串可变为 <code>&quot;aa&quot;</code>。</p></blockquote><blockquote><p>输入:<br><code>s = &quot;ab&quot;</code><br><code>p = &quot;.*&quot;</code><br>输出: <code>true</code><br>解释: <code>&quot;.*&quot;</code> 表示可匹配零个或多个(<code>&#39;*&#39;</code>)任意字符(<code>&#39;.&#39;</code>)。</p></blockquote><blockquote><p>输入:<br><code>s = &quot;aab&quot;</code><br><code>p = &quot;c*a*b&quot;</code><br>输出: <code>true</code><br>解释: <code>&#39;c&#39;</code> 可以不被重复, <code>&#39;a&#39;</code> 可以被重复一次。因此可以匹配字符串 <code>&quot;aab&quot;</code>。</p></blockquote><blockquote><p>输入:<br><code>s = &quot;mississippi&quot;</code><br><code>p = &quot;mis*is*p*.&quot;</code><br>输出: <code>false</code></p></blockquote><p>来自<code>LeetCode</code>第10题</p><p>题意：</p><blockquote><ul><li>这道题中的<code>*</code>表示之前那个字符可以有0个，1个或是多个，就是说，字符串<code>&quot;a*b&quot;</code>，可以表示<code>&quot;b&quot;</code>或是<code>&quot;aaab&quot;</code>，即<code>a</code>的个数任意（可以是0个，可以是3个），可以从示例4看出。</li><li>还有一个需要注意的点就是 <code>&quot;.*&quot;</code> 表示可匹配零个或多个(<code>&#39;*&#39;</code>)任意字符(<code>&#39;.&#39;</code>)，示例3</li></ul></blockquote><p><code>&#39;*&#39;</code>这个字符，它能表示前一个字符的 <code>0~n</code> 个副本。说到这里，我们就要将一个编程中经常提到的概念，<strong>自动机</strong>。</p><blockquote><p>状态机由状态寄存器和组合逻辑电路构成，能够根据控制信号按照预先设定的状态进行状态转移，是协调相关信号动作、完成特定操作的控制中心。有限状态机简写为FSM(Finite State Machine)</p></blockquote><p>有些地方也把状态机称为<strong>有限自动机</strong></p><p>解决正则表达问题的关键，在于我们如何构建一个合适的<strong>自动机</strong></p><p>然后此题又是一个非确定状态有限自动机，要自己手动构建一个，这种接法姑且搁置，后面阅读FlinkCEP源码的时候我再来分析。</p><hr><p>所以这里：</p><p>从头处理<em>s</em>和<em>p</em>两个字符串：</p><ul><li><p>首先，如果<em>p</em>为空了，此时若<em>s</em>不为空，则说明匹配失败，直接返回false，如果都为空，说明匹配结束，返回true。</p></li><li><p>其次，如果<em>p</em>不为空，存在两种情况，一种是单一匹配，一种是<code>&#39;*&#39;</code>的任意匹配。</p><ul><li><p>我们先假设单一匹配，创建一个<code>boolean</code>类型的<code>match</code>变量，计算一下单一匹配是否成功：</p><ul><li>在单一匹配的情况下，s*不能为空。</li><li><em>s</em>和<em>p</em>的当前第一个字符需要相等，或者p的第一个字符为<code>&#39;.&#39;</code>。</li></ul><p>如果成功就可以将两个字符串的第一位去掉，继续匹配后续的字符。</p></li><li><p>还有可能是要进行任意匹配，任意匹配的条件是当前<code>p</code>的长度要大于2，并且<code>p[1]</code>要为<code>&#39;*&#39;</code>，这个时候，可以匹配<code>s</code>中任意数量的字符<code>p[0]</code>。那么又是两种情况：</p><ul><li><p>看：如果看（匹配）一次，就相当于去掉s的第一个字符，继续向后匹配。</p></li><li><p>不看：如果不看（就是不进行匹配=匹配0次），就相当于s不变，p向后去掉两位（字符<code>p[0]</code>和<code>p[1]</code>的’<code>*</code>‘）。</p></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.isEmpty()) <span class="keyword">return</span> s.isEmpty();</span><br><span class="line">        <span class="comment">// *不代表0的匹配条件</span></span><br><span class="line">        <span class="keyword">boolean</span> match = !s.isEmpty() &amp;&amp; ((s.charAt(<span class="number">0</span>) == p.charAt(<span class="number">0</span>)) || p.charAt(<span class="number">0</span>) == <span class="string">'.'</span>);</span><br><span class="line">        <span class="comment">// 任意匹配</span></span><br><span class="line">        <span class="keyword">if</span>(p.length() &gt;= <span class="number">2</span> &amp;&amp; p.charAt(<span class="number">1</span>) == <span class="string">'*'</span>) <span class="keyword">return</span> isMatch(s, p.substring(<span class="number">2</span>)) || (match &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p));</span><br><span class="line">        <span class="comment">// 单一匹配</span></span><br><span class="line">        <span class="keyword">return</span> match &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tips: 这里有个点要注意，通过<code>charAt</code>的方式访问要比char[]的方式慢很多，作为对比，这里附上通过<code>toCharArray</code>转换的版本，前者用时109ms，后者17ms，可见差距之大。这里主要应该是因为<code>charAt</code>方法多了一层栈的深度（需要进出对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatchChar</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> s1, <span class="keyword">char</span>[] p, <span class="keyword">int</span> p1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 &gt;= p.length) <span class="keyword">return</span> s1 &gt;= s.length;</span><br><span class="line">        <span class="keyword">boolean</span> match = s1 &lt; s.length &amp;&amp; ((s[s1] == p[p1]) || p[p1] == <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span>(p.length - p1 &gt;= <span class="number">2</span> &amp;&amp; p[p1 + <span class="number">1</span>] == <span class="string">'*'</span>) <span class="keyword">return</span> isMatchChar(s, s1, p, p1 + <span class="number">2</span>) || (match &amp;&amp; isMatchChar(s, s1 + <span class="number">1</span>, p, p1));</span><br><span class="line">        <span class="keyword">return</span> match &amp;&amp; isMatchChar(s, s1 + <span class="number">1</span>, p, p1 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray(), pp = p.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> isMatchChar(ss, <span class="number">0</span>, pp, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj12glvvzzj20kk07vgly.jpg" alt="微信截图_20200924004758.png"></p><p>记忆化递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] mem;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatchChar</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> s1, <span class="keyword">char</span>[] p, <span class="keyword">int</span> p1)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p1 &gt;= p.length) <span class="keyword">return</span> s1 &gt;= s.length;</span><br><span class="line">    <span class="keyword">if</span>(mem[s1][p1] != <span class="number">0</span>) <span class="keyword">return</span> mem[s1][p1] &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> match = s1 &lt; s.length &amp;&amp; ((s[s1] == p[p1]) || p[p1] == <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.length - p1 &gt;= <span class="number">2</span> &amp;&amp; p[p1 + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> t = isMatchChar(s, s1, p, p1 + <span class="number">2</span>) || (match &amp;&amp; isMatchChar(s, s1 + <span class="number">1</span>, p, p1));</span><br><span class="line">        <span class="keyword">if</span>(t) mem[s1][p1] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> mem[s1][p1] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> t = match &amp;&amp; isMatchChar(s, s1 + <span class="number">1</span>, p, p1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(t) mem[s1][p1] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> mem[s1][p1] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mem = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span>[] ss = s.toCharArray(), pp = p.toCharArray();</span><br><span class="line">    <span class="keyword">return</span> isMatchChar(ss, <span class="number">0</span>, pp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段就是记忆化递归的套路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">this</span>.mem = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mem[s1][p1] != <span class="number">0</span>) <span class="keyword">return</span> mem[s1][p1] &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t) mem[s1][p1] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> mem[s1][p1] = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>动态规划</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s和p倒着看，dp[i][j]的取值分为以下几种情况：</span><br><span class="line">1.p[j - 1]p[j−1]为普通字符,若s[i - 1] == p[j - 1]，则dp[i][j] = dp[i - 1][j - 1]，否则匹配失败</span><br><span class="line">两个Char数组相同那么dp表中</span><br><span class="line">2.p[j−1]为&apos;.&apos;，则dp[i][j] = dp[i - 1][j - 1]</span><br><span class="line"></span><br><span class="line">3.p[j - 1]p[j−1]为&apos;*&apos;：</span><br><span class="line">(1)不看，则dp[i][j] = dp[i][j - 2]</span><br><span class="line">(2)看，则dp[i][j] = dp[i - 1][j]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch_DP</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray(), ptr = p.toCharArray();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[str.length + <span class="number">1</span>][ptr.length + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ptr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ptr[j - <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (str[i - <span class="number">1</span>] == ptr[j - <span class="number">1</span>] || ptr[j - <span class="number">1</span>] == <span class="string">'.'</span>)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//ptr[j - 1] == '*'</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">1</span>) dp[i][j] |= dp[i][j - <span class="number">2</span>];   <span class="comment">//不看</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">1</span> &amp;&amp; (str[i - <span class="number">1</span>] == ptr[j - <span class="number">2</span>] || ptr[j - <span class="number">2</span>] == <span class="string">'.'</span>))dp[i][j] |= dp[i - <span class="number">1</span>][j];    <span class="comment">//看</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[str.length][ptr.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于到经典的动态规划问题，希望能顺利拿下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>IDEA编译Flink1.11.1</title>
    <link href="http://yoursite.com/2020/08/29/IDEA%E7%BC%96%E8%AF%91Flink1-11-1/"/>
    <id>http://yoursite.com/2020/08/29/IDEA%E7%BC%96%E8%AF%91Flink1-11-1/</id>
    <published>2020-08-29T01:13:03.000Z</published>
    <updated>2020-08-31T16:10:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尝试熟悉一下IDEA直接编译Flink，顺手记录一下全过程。</p></blockquote><a id="more"></a> <h1 id="IDEA编译Flink1-11-1"><a href="#IDEA编译Flink1-11-1" class="headerlink" title="IDEA编译Flink1.11.1"></a>IDEA编译Flink1.11.1</h1><p>下载源码确保网路通畅不再赘述</p><h2 id="编译说明"><a href="#编译说明" class="headerlink" title="编译说明"></a>编译说明</h2><p>要想把技术沉淀下来，阅读源码是必不可少的，既然要阅读源码怎么能不会编译呢？</p><p>根据我的总结，编译中遇到的问题可以归纳为几种</p><p>网络问题和组件环境版本不兼容</p><p>网络问题在编译的过程中是始终困扰我的，后面详细讲讲。</p><p>组件环境版本我一直没怎么注意，觉得是想当然向下兼容。</p><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p><strong>编译平台 mac &amp; win10</strong></p><p><strong>编译java版本 8u202</strong></p><p><strong>编译maven版本 3.2.5</strong></p><p><strong>win10推荐使用Administrator账户（非必须）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user administrator /active:yes</span><br></pre></td></tr></table></figure><p><strong>mac对于账户没有特别的要求</strong></p><p><strong>Git设置proxy（详细可以见<a href="%5Bhttps://flymetothemars.github.io/2020/04/09/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/%5D(https://flymetothemars.github.io/2020/04/09/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/)">设置</a> 27条）</strong></p><p><strong>Maven设置proxy（详细可以见<a href="%5Bhttps://flymetothemars.github.io/2020/04/09/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/%5D(https://flymetothemars.github.io/2020/04/09/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/)">设置</a> 29条）</strong></p><h2 id="Nodejs版本管理"><a href="#Nodejs版本管理" class="headerlink" title="Nodejs版本管理"></a>Nodejs版本管理</h2><p>mac下的nodejs版本管理工具，就是n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n list</span><br><span class="line"></span><br><span class="line">n 直接选择版本</span><br></pre></td></tr></table></figure><p>window下要安装一个<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">nvm</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">先给nvm设置镜像</span><br><span class="line">root: C:\APP\tools\nvm</span><br><span class="line">path: C:\APP\tools\nodejs</span><br><span class="line"></span><br><span class="line">node_mirror: https://npm.taobao.org/mirrors/node/ </span><br><span class="line">npm_mirror: https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure><p>nvm设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nvm lsit</span><br><span class="line"></span><br><span class="line">nvm install</span><br><span class="line"></span><br><span class="line">nvm use</span><br></pre></td></tr></table></figure><p>Flink 1.11.1的版本是 <code>v10.9.0</code></p><h2 id="编译flink-runtime-web包"><a href="#编译flink-runtime-web包" class="headerlink" title="编译flink-runtime-web包"></a>编译flink-runtime-web包</h2><p>根据经验，凡是要用到WebUI，涉及到nodejs编译是最麻烦的，先把这个包单独拿出来编译试一下。</p><p>首先确保网络通畅，我们在国内所谓网络通畅，少不了一个好用的VPN，有了VPN再谈别的，不然啥都白扯。</p><p>SSR或者别的VPN在我们喜欢的端口设置了全局代理之后，Git和Maven才能顺利的下载依赖。</p><p>但是在这个<code>flink-runtime-web</code>包里遇到一个双重代理的问题，我在Maven的<code>setting.xml</code>文件里面设置了proxy，所以在这里对于nodejs的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Found proxies: [ss&#123;protocol='socks5', host='127.0.0.1', port=1080&#125;]</span><br><span class="line">[INFO] Running 'npm ci --cache-max=0 --no-save --https-proxy=http://127.0.0.1:1080 --proxy=http://127.0.0.1:1080' in /Users/flyhugh/Documents/Compile/flink-1.11.1/flink-runtime-web/web-dashboard</span><br></pre></td></tr></table></figure><p>这样代理是无法正常下载的，我在setting.xml里面关掉了这个代理，运行的时候就变成了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Running 'npm ci --cache-max=0 --no-save' in /Users/flyhugh/Documents/Compile/flink-1.11.1/flink-runtime-web/web-dashboard</span><br></pre></td></tr></table></figure><p>这样的代码是可以通过的</p><h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><p>我宿舍的网是50M的，VPN的速度也很不错，但是使用maven代理的时候，速度却总是跟不上？不知道为什么</p><p>还好现在流量不贵了，使用流量代理速度总还凑合，以后有了5G速度就更行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前写过一篇杂七杂八的编译，成功的也莫名其妙，这次特地用了两个平台对比编译，其实只要调试好网络，设置好组件的proxy，Java和Maven的版本选择正确，编译并不是特别麻烦的事情。</p><p>不过那个pom确实是很复杂，如果自己修改源码的话，感觉还是挺麻烦的。</p><p>不过总算是解决了心头的一个结。</p><p>后续根据使用情况不定期更新。</p><p>内存设置得大一点（idea64.vmoptions &lt;&lt; -Xmx8192m），编译速度会快不少。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gi9z89rfj3j22gw19snka.jpg" alt="WX20200831-142614@2x.png"></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1giag2k12elj22kp1m14cx.jpg" alt="QzpcVXNlcnNcZmx5aG9cQXBwRGF0YVxSb2FtaW5nXERpbmdUYWxrXDExMzI4MDM2MF92MlxJbWFnZUZpbGVzXDIxODg5NzUyOFwxNTk4ODgyNzcxODMwXzZGQjI5NjM4LTdGRDYtNDNjNC1CNTlBLUJGQ0FFMDA3RDEyRS5wbmc=.png"></p><p>win10下通过普通用户也编译成功，内存多给，编译速度加快。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;尝试熟悉一下IDEA直接编译Flink，顺手记录一下全过程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Apache Flink" scheme="http://yoursite.com/tags/Apache-Flink/"/>
    
  </entry>
  
</feed>
