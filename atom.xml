<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mars</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-28T17:08:39.263Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Fly Hugh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>朝花夕拾</title>
    <link href="http://yoursite.com/2050/10/14/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    <id>http://yoursite.com/2050/10/14/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/</id>
    <published>2050-10-13T22:31:42.000Z</published>
    <updated>2021-01-28T17:08:39.263Z</updated>
    
    <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq5gjm1gmj22541j9kjm.jpg" alt="IMG_20201015_173131.jpg" style="zoom: 25%;"><blockquote><p>笨猫不如烂笔头</p></blockquote><a id="more"></a> <h3 id="更友好的创建对象方式"><a href="#更友好的创建对象方式" class="headerlink" title="更友好的创建对象方式"></a>更友好的创建对象方式</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gdnjra9kkrj20sk0c6myf.jpg" alt="3d5024b55687373af54fcb9ef4e0eb4.png"></p><p>上面的方式，对JVM来说是更友好的，因为堆内存的调用无法避免，所以从栈内存这边入手解决内存问题是一个不错的解决的方式</p><hr><h3 id="下面代码是否线程安全"><a href="#下面代码是否线程安全" class="headerlink" title="下面代码是否线程安全"></a>下面代码是否线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看类似饿汉式的单例，线程安全，其实是有问题的</p><p>虽然只有一个线程能够获得锁，并且这个锁还是类锁，所有对象共享的</p><p>关键在于 jvm 对 new 的优化，这个变量没有声明 volatile，new 不是一个线程安全的操作，</p><p>对于 new 这个指令，一般的顺序是申请内存空间，初始化内存空间，然后把内存地址赋给 instance 对象，但是 jvm 会对这段指令进行优化，优化之后变成 申请内存空间，内存地址赋给 instance 对象，初始化内存空间，这就导致 第二层检查可能会出错，标准写法只需要在变量前声明 volatile 即可。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gdnkbsp9sij20pp0gy75i.jpg" alt="677701574e4f69f35e226ed6bc9a380.png"></p><hr><h3 id="volatile利用了什么协议来实现可见性"><a href="#volatile利用了什么协议来实现可见性" class="headerlink" title="volatile利用了什么协议来实现可见性"></a>volatile利用了什么协议来实现可见性</h3><p>volatile 是通过内存屏障实现的，MESI协议，缓存一致性协议</p><p>JVM推荐书《The Java Language Specification》<br>volatile 修饰的变量如果值发生变化 发现线程的高速缓存与主存数据不一致时候 由于缓存一致性协议 则总线将高速缓存中的值清空 其他线程只能通过访问主存来获取最新的值 并缓存到告诉缓存上。</p><hr><h3 id="Java-Trainsient-关键字"><a href="#Java-Trainsient-关键字" class="headerlink" title="Java Trainsient 关键字"></a>Java Trainsient 关键字</h3><p>1.一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 </p><p>2.transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 </p><p>3.一个静态变量不管是否被transient修饰，均不能被序列化。 </p><p>使用总结和场景：某个类的有些属性需要序列化，其他属性不需要被序列化，比如：敏感信息（如密码，银行卡号等），java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><h3 id="多线程中Random的使用"><a href="#多线程中Random的使用" class="headerlink" title="多线程中Random的使用"></a>多线程中Random的使用</h3><p>1.不要在多个线程间共享一个java.util.Random实例，而该把它放入ThreadLocal之中。</p><p>2.Java7以上我们更推荐使用java.util.concurrent.ThreadLocalRandom。</p><p>下面两条建议是 IDEA给的:</p><p>1.不要将将随机数放大10的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法</p><p>2.Math.random()应避免在多线程环境下使用</p><h3 id="为什么阿里禁止使用Executor创建线程池"><a href="#为什么阿里禁止使用Executor创建线程池" class="headerlink" title="为什么阿里禁止使用Executor创建线程池"></a>为什么阿里禁止使用Executor创建线程池</h3><p>阿里规约之所以强制要求手动创建线程池，也是和这些参数有关。具体为什么不允许，规约是这么说的：</p><p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>Executor提供的四个静态方法创建线程池，但是阿里规约却并不建议使用它。</p><p>Executors各个方法的弊端：<br>1）newFixedThreadPool和newSingleThreadExecutor:<br>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。<br>2）newCachedThreadPool和newScheduledThreadPool:<br>  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p><p>看一下这两种弊端怎么导致的。</p><p>第一种，newFixedThreadPool和newSingleThreadExecutor分别获得 FixedThreadPool 类型的线程池 和  SingleThreadExecutor 类型的线程池。　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">       return new FinalizableDelegatedExecutorService</span><br><span class="line">           (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                   0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为，创建了一个无界队列LinkedBlockingQueuesize，是一个最大值为Integer.MAX_VALUE的线程阻塞队列，当添加任务的速度大于线程池处理任务的速度，可能会在队列堆积大量的请求，消耗很大的内存，甚至导致OOM。</p><h3 id="阿里开发手册上不推荐（禁止）使用Double的根本原因"><a href="#阿里开发手册上不推荐（禁止）使用Double的根本原因" class="headerlink" title="阿里开发手册上不推荐（禁止）使用Double的根本原因"></a>阿里开发手册上不推荐（禁止）使用Double的根本原因</h3><p>精度丢失就不谈了，稍微深入一下为什么精度会丢失，分为一些不同情况</p><p><strong>典型现象（一）：条件判断超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.9999999f</span> );   <span class="comment">// 打印：false</span></span><br><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.99999999f</span> );  <span class="comment">// 打印：true    纳尼？</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.0</span>（十进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">00111111</span> <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span>（二进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">0x3F800000</span>（十六进制）</span><br><span class="line">    </span><br><span class="line"><span class="number">0.99999999</span>（十进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">00111111</span> <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span>（二进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">0x3F800000</span>（十六进制）</span><br><span class="line">    </span><br><span class="line">果不其然，这两个十进制浮点数的底层二进制表示是一毛一样的，怪不得==的判断结果返回<span class="keyword">true</span>！</span><br><span class="line"></span><br><span class="line">浮点数的精度问题。</span><br><span class="line">    </span><br><span class="line">浮点数在计算机中的存储方式遵循IEEE <span class="number">754</span> 浮点数计数标准，可以用科学计数法表示为：</span><br><span class="line">    <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、符号部分（S）</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>-正  <span class="number">1</span>-负</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、阶码部分（E）（指数部分）：</span><br><span class="line"></span><br><span class="line">对于<span class="keyword">float</span>型浮点数，指数部分<span class="number">8</span>位，考虑可正可负，因此可以表示的指数范围为-<span class="number">127</span> ~ <span class="number">128</span></span><br><span class="line">对于<span class="keyword">double</span>型浮点数，指数部分<span class="number">11</span>位，考虑可正可负，因此可以表示的指数范围为-<span class="number">1023</span> ~ <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、尾数部分（M）：</span><br><span class="line"></span><br><span class="line">浮点数的精度是由尾数的位数来决定的：</span><br><span class="line"></span><br><span class="line">对于<span class="keyword">float</span>型浮点数，尾数部分<span class="number">23</span>位，换算成十进制就是 <span class="number">2</span>^<span class="number">23</span>=<span class="number">8388608</span>，所以十进制精度只有<span class="number">6</span> ~ <span class="number">7</span>位；</span><br><span class="line">对于<span class="keyword">double</span>型浮点数，尾数部分<span class="number">52</span>位，换算成十进制就是 <span class="number">2</span>^<span class="number">52</span> = <span class="number">4503599627370496</span>，所以十进制精度只有<span class="number">15</span> ~ <span class="number">16</span>位</span><br><span class="line"></span><br><span class="line">所以对于上面的数值<span class="number">0.99999999f</span>，很明显已经超过了<span class="keyword">float</span>型浮点数据的精度范围，出问题也是在所难免的。</span><br></pre></td></tr></table></figure><p><strong>典型现象（二）：数据转换超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span>;</span><br><span class="line"><span class="keyword">double</span> d = (<span class="keyword">double</span>) f;</span><br><span class="line">System.out.println(f);  <span class="comment">// 打印：1.1</span></span><br><span class="line">System.out.println(d);  <span class="comment">// 打印：1.100000023841858  纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>典型现象（三）：基本运算超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">0.2</span> + <span class="number">0.7</span> );  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：0.8999999999999999   纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>典型现象（四）：数据自增超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = <span class="number">8455263f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(f1);</span><br><span class="line">    f1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印：8455263.0</span></span><br><span class="line"><span class="comment">// 打印：8455264.0</span></span><br><span class="line"><span class="comment">// 打印：8455265.0</span></span><br><span class="line"><span class="comment">// 打印：8455266.0</span></span><br><span class="line"><span class="comment">// 打印：8455267.0</span></span><br><span class="line"><span class="comment">// 打印：8455268.0</span></span><br><span class="line"><span class="comment">// 打印：8455269.0</span></span><br><span class="line"><span class="comment">// 打印：8455270.0</span></span><br><span class="line"><span class="comment">// 打印：8455271.0</span></span><br><span class="line"><span class="comment">// 打印：8455272.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">84552631f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(f2);</span><br><span class="line">    f2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br></pre></td></tr></table></figure><p>解决办法：</p><p>1.我们我们可以用字符串或者数组来表示这种大数，然后按照四则运算的规则来手动模拟出具体计算过程，中间还需要考虑各种诸如：<strong>进位、借位、符号</strong>等等问题的处理，有点复杂。</p><ol start="2"><li>JDK早已为我们考虑到了浮点数的计算精度问题，因此提供了专用于高精度数值计算的<strong>大数类</strong>来方便我们使用。</li></ol><h3 id="mac-清理maven仓库的脚本"><a href="#mac-清理maven仓库的脚本" class="headerlink" title="mac 清理maven仓库的脚本"></a>mac 清理maven仓库的脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这里写你的仓库路径</span><br><span class="line">REPOSITORY_PATH=~/Documents/tools/apache-maven-3.0.3/repository</span><br><span class="line">echo 正在搜索...</span><br><span class="line">find $REPOSITORY_PATH -name &quot;*lastUpdated*&quot; | xargs rm -fr</span><br><span class="line">echo 删除完毕</span><br><span class="line"></span><br><span class="line">mac（linux）系统-创建.sh文件脚本执行（mac用.command终端也可以）</span><br></pre></td></tr></table></figure><h3 id="idea目录较多，文件名较长产生的错误"><a href="#idea目录较多，文件名较长产生的错误" class="headerlink" title="idea目录较多，文件名较长产生的错误"></a>idea目录较多，文件名较长产生的错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error running &apos;ServiceStarter&apos;: Command line is too long. Shorten command line for ServiceStarter or also for Application default configuration.</span><br><span class="line"></span><br><span class="line">修改项目下 .idea\workspace.xml，找到标签 &lt;component name=&quot;PropertiesComponent&quot;&gt; ， 在标签里加一行 &lt;property name=&quot;dynamic.classpath&quot; value=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="Log4J-指定屏蔽某些特定报警信息"><a href="#Log4J-指定屏蔽某些特定报警信息" class="headerlink" title="Log4J 指定屏蔽某些特定报警信息"></a>Log4J 指定屏蔽某些特定报警信息</h3><p>Logger.getLogger(“org.apache.library”).setLevel(Level.OFF)</p><h3 id="Flink-Source并行度为1的意义"><a href="#Flink-Source并行度为1的意义" class="headerlink" title="Flink Source并行度为1的意义"></a>Flink Source并行度为1的意义</h3><p>对于需要设置EventTime的流来说，我们的TimestampAssigner应该在Source之后立即调用，原因是时间戳分配器看到的元素的顺序应该和source操作符产生数据的顺序是一样的，否则就乱了，也就是说，任何分区操作都会将元素的顺序打乱，例如：改变并行度 keyBy操作等等。，所以最佳实践是：</p><p>在尽量接近数据源source操作符的地方分配时间戳和产生水位线，甚至最好在SourceFunction中分配时间戳和产生水位线。当然在分配时间戳和产生水位线之前可以对流进行map和filter操作是没问题的，也就是说必须是窄依赖。</p><h3 id="JB套件的一个实用功能"><a href="#JB套件的一个实用功能" class="headerlink" title="JB套件的一个实用功能"></a>JB套件的一个实用功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前没注意，更改变量名字的时候直接使用refactor就可以了，真的实用</span><br></pre></td></tr></table></figure><h3 id="zk使用的分布式协议并不是paxos"><a href="#zk使用的分布式协议并不是paxos" class="headerlink" title="zk使用的分布式协议并不是paxos"></a>zk使用的分布式协议并不是paxos</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而是zab协议</span><br></pre></td></tr></table></figure><h3 id="为什么说NULL是计算机科学中最大的错误，至少值十亿美金"><a href="#为什么说NULL是计算机科学中最大的错误，至少值十亿美金" class="headerlink" title="为什么说NULL是计算机科学中最大的错误，至少值十亿美金"></a>为什么说NULL是计算机科学中最大的错误，至少值十亿美金</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.覆类型</span><br><span class="line">2.是凌乱的</span><br><span class="line">3.是一个特例</span><br><span class="line">4.使 API 变得糟糕</span><br><span class="line">5.使错误的语言决策更加恶化</span><br><span class="line">6.难以调试</span><br><span class="line">7.是不可组合的</span><br></pre></td></tr></table></figure><h4 id="1-NULL-颠覆类型"><a href="#1-NULL-颠覆类型" class="headerlink" title="1. NULL 颠覆类型"></a>1. NULL 颠覆类型</h4><p>静态类型语言不需要实际去执行程序，就可以检查程序中类型的使用，并且提供一定的程序行为保证。</p><p>例如，在 Java 中，如果我编写 <code>x.toUppercase()</code>，编译器会检查 <code>x</code> 的类型。如果 <code>x</code> 是一个 <code>String</code>，那么类型检查成功；如果 <code>x</code> 是一个 <code>Socket</code>，那么类型检查失败。</p><p>在编写庞大的、复杂的软件时，静态类型检查是一个强大的工具。但是对于 Java，这些很棒的编译时检查存在一个致命缺陷：任何引用都可以是 null，而调用一个 null 对象的方法会产生一个 <code>NullPointerException</code>。所以，</p><ul><li><code>toUppercase()</code> 可以被任意 <code>String</code> 对象调用。除非 <code>String</code> 是 null。</li><li><code>read()</code> 可以被任意 <code>InputStream</code> 对象调用。除非 <code>InputStream</code> 是 null。</li><li><code>toString()</code> 可以被任意 <code>Object</code> 对象调用。除非 <code>Object</code> 是 null。</li></ul><p>Java 不是唯一引起这个问题的语言；很多其它的类型系统也有同样的缺点，当然包括 AGOL W 语言。</p><p>在这些语言中，NULL 超出了类型检查的范围。它悄悄地越过类型检查，等待运行时，最后一下子释放出一大批错误。NULL 什么也不是，同时又什么都是。</p><h4 id="2-NULL-是凌乱的"><a href="#2-NULL-是凌乱的" class="headerlink" title="2. NULL 是凌乱的"></a>2. NULL 是凌乱的</h4><p>在很多情况下 null 是没有意义的。不幸的是，如果一种语言允许任何东西为 null，好吧，那么任何东西都可以是 null。</p><p>Java 程序员冒着患腕管综合症的风险写下</p><p>Java</p><p> <code>if (str == null 丨丨 str.equals(&quot;&quot;)) {}</code> </p><p>而在 C# 中添加 <code>String.IsNullOrEmpty</code> 是一个常见的语法</p><p>C#</p><p> <code>if (string.IsNullOrEmpty(str)) {}</code> </p><p>真可恶！</p><p>每次你写代码，将 null 字符串和空字符串混为一谈时，Guava 团队都要哭了。– <a href="https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="noopener">Google Guava</a></p><p>说得好。但是当你的类型系统（例如，Java 或者 C#）到处都允许 NULL 时，你就不能可靠地排除 NULL 的可能性，并且不可避免的会在某个地方混淆。</p><p>null 无处不在的可能性造成了这样一个问题，Java 8 添加了 <code>@NonNull</code> 标注，尝试着在它的类型系统中以追溯方式解决这个缺陷。</p><h4 id="3-NULL-是一个特例"><a href="#3-NULL-是一个特例" class="headerlink" title="3. NULL 是一个特例"></a>3. NULL 是一个特例</h4><p>考虑到 NULL 不是一个值却又起到一个值的作用，NULL 自然地成为各种特别处理方法的课题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char c = &apos;A&apos;;</span><br><span class="line">char *myChar = &amp;c;</span><br><span class="line">std::cout &lt;&lt; *myChar &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>单个 NUL 字符的例外已经导致无数的错误：API 的怪异行为、安全漏洞和缓冲区溢出。</p><p>NULL 是 C 字符串中最糟糕的错误；更确切地说，以 NUL 结尾的字符串是<a href="http://queue.acm.org/detail.cfm?id=2010365" target="_blank" rel="noopener">最昂贵的<strong>一字节</strong>错误</a>。</p><h4 id="4-NULL-使-API-变得糟糕"><a href="#4-NULL-使-API-变得糟糕" class="headerlink" title="4.NULL 使 API 变得糟糕"></a>4.NULL 使 API 变得糟糕</h4><p>我们可以想象在很多语言中类似的类（Python、JavaScript、Java、C# 等）。</p><p>现在假设我们的程序有一个慢的或者占用大量资源的方法，来找到某个人的电话号码——可能通过连通一个网络服务。</p><p>为了提高性能，我们将会使用本地存储作为缓存，将一个人名映射到他的电话号码上。</p><p>然而，一些人没有电话号码（即他们的电话号码是 nil）。我们仍然会缓存那些信息，所以我们不需要在后面重新填充那些信息。</p><p>但是现在意味着我们的结果模棱两可！它可能表示：</p><ol><li>这个人不存在于缓存中（Alice）</li><li>这个人存在于缓存中，但是没有电话号码（Tom）</li></ol><p>一种情形要求昂贵的重新计算，另一种需要即时的答复。但是我们的代码不够精密来区分这两种情况。</p><p>在实际的代码中，像这样的情况经常会以复杂且不易察觉的方式出现。因此，简单通用的 API 可以马上变成特例，迷惑了 null 凌乱行为的来源。</p><p>用一个 <code>contains()</code> 方法来修补 <code>Store</code> 类可能会有帮助。但是这引入重复的查找，导致降低性能和竞争条件。</p><h4 id="5-NULL-使错误的语言决策更加恶化"><a href="#5-NULL-使错误的语言决策更加恶化" class="headerlink" title="5.NULL 使错误的语言决策更加恶化"></a>5.NULL 使错误的语言决策更加恶化</h4><h4 id="6-NULL-难以调试"><a href="#6-NULL-难以调试" class="headerlink" title="6.NULL 难以调试"></a>6.NULL 难以调试</h4><p>来解释 NULL 是多么的麻烦，C++ 是一个很好的例子。调用成员函数指向一个 NULL 指针不一定会导致程序崩溃。更糟糕的是：它可能会导致程序崩溃。</p><h4 id="7-NULL不可组合"><a href="#7-NULL不可组合" class="headerlink" title="7.NULL不可组合"></a>7.NULL不可组合</h4><h3 id="IDEA-maven修改pom文件，导致jdk版本重置问题"><a href="#IDEA-maven修改pom文件，导致jdk版本重置问题" class="headerlink" title="IDEA maven修改pom文件，导致jdk版本重置问题"></a>IDEA maven修改pom文件，导致jdk版本重置问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><h3 id="MAVEN的scope"><a href="#MAVEN的scope" class="headerlink" title="MAVEN的scope"></a>MAVEN的scope</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">compile</span><br><span class="line">默认就是compile，什么都不配置也就是意味着compile。compile表示被依赖项目需要参与当前项目的编译，当然后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去。</span><br><span class="line"></span><br><span class="line">test</span><br><span class="line">scope为test表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的如junit。</span><br><span class="line"></span><br><span class="line">runntime</span><br><span class="line">runntime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过编译而已，说实话在终端的项目（非开源，企业内部系统）中，和compile区别不是很大。比较常见的如JSR×××的实现，对应的API jar是compile的，具体实现是runtime的，compile只需要知道接口就足够了。oracle jdbc驱动架包就是一个很好的例子，一般scope为runntime。另外runntime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。</span><br><span class="line"></span><br><span class="line">provided</span><br><span class="line">provided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。</span><br><span class="line"></span><br><span class="line">system</span><br><span class="line">从参与度来说，也provided相同，不过被依赖项不会从maven仓库抓，而是从本地文件系统拿，一定需要配合systemPath属性使用。</span><br><span class="line"></span><br><span class="line">scope的依赖传递</span><br><span class="line">A–&gt;B–&gt;C。当前项目为A，A依赖于B，B依赖于C。知道B在A项目中的scope，那么怎么知道C在A中的scope呢？</span><br><span class="line">答案是：</span><br><span class="line">当C是test或者provided时，C直接被丢弃，A不依赖C；</span><br><span class="line">否则A依赖C，C的scope继承于B的scope。</span><br></pre></td></tr></table></figure><h3 id="EXCEL一点小技巧"><a href="#EXCEL一点小技巧" class="headerlink" title="EXCEL一点小技巧"></a>EXCEL一点小技巧</h3><p>正好最近用来有点小用处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.从固定的单元格里随机取一个值</span><br><span class="line">=INDEX($G$2:$M$2, RANDBETWEEN(1,7))</span><br><span class="line">$G$2：下拉的时候不会自动延伸</span><br><span class="line"></span><br><span class="line">2.从固定列取值用在本单元格里</span><br><span class="line">=&quot;INSERT INTO `event_mapping` VALUES (&apos;&quot;&amp;B2&amp;&quot;&apos;,&quot;&amp;C2&amp;&quot;,&quot;&amp;D2&amp;&quot;);&quot;</span><br><span class="line"></span><br><span class="line">3.下拉到某行</span><br><span class="line">在有第一行的情况下，直接双击右下角小箭头即可</span><br></pre></td></tr></table></figure><h3 id="Flink-On-Zeppelin上传Jar包的位置"><a href="#Flink-On-Zeppelin上传Jar包的位置" class="headerlink" title="Flink On Zeppelin上传Jar包的位置"></a>Flink On Zeppelin上传Jar包的位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/opt/flink-1.10/flink-1.10.0/lib</span><br><span class="line"></span><br><span class="line">目前看来应该是放在flink包里面的，会稳定上传，已经确定</span><br><span class="line"></span><br><span class="line">在interpreter 依赖里面设置了路劲</span><br><span class="line">/opt/flink-1.10/flink-1.10.0/lib/jimipojo-1.0.jar</span><br></pre></td></tr></table></figure><h3 id="Flink系列深度好文，等待细读"><a href="#Flink系列深度好文，等待细读" class="headerlink" title="Flink系列深度好文，等待细读"></a>Flink系列深度好文，等待细读</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.jianshu.com/c/b6089c70072f</span><br><span class="line">flink的apply和process方法有什么区别呢</span><br></pre></td></tr></table></figure><h3 id="FastJson直接解析"><a href="#FastJson直接解析" class="headerlink" title="FastJson直接解析"></a>FastJson直接解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.map(</span><br><span class="line">a -&gt; JSON</span><br><span class="line">.parseObject(</span><br><span class="line">a,</span><br><span class="line">Pojo.class)</span><br><span class="line">).returns(</span><br><span class="line">Pojo.class</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>具体的还要试一下，我故意写的很难看来督促自己。。。</p><h3 id="FastJson很多坑-准备放弃"><a href="#FastJson很多坑-准备放弃" class="headerlink" title="FastJson很多坑 准备放弃"></a>FastJson很多坑 准备放弃</h3><h3 id="配置框架无法访问的问题"><a href="#配置框架无法访问的问题" class="headerlink" title="配置框架无法访问的问题"></a>配置框架无法访问的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有点脑残了，今天在mac上配置了zeppelin win无法访问，其原因是配置文件中的网络地址写死了 172.0.0.1, 如果想要别尔德位置能够访问的话，必须改变配置为其局域网id</span><br><span class="line"></span><br><span class="line">更好的选择是更改为0.0.0.0</span><br></pre></td></tr></table></figure><h3 id="解决GitHub提交历史头像不显示问题-以及首页没有绿色方块的问题"><a href="#解决GitHub提交历史头像不显示问题-以及首页没有绿色方块的问题" class="headerlink" title="解决GitHub提交历史头像不显示问题,以及首页没有绿色方块的问题"></a>解决GitHub提交历史头像不显示问题,以及首页没有绿色方块的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">最近把本地的一个项目提交推送到GitHub的时候发现有两个问题, </span><br><span class="line">1.在commit提交历史里面</span><br><span class="line"></span><br><span class="line">提交内容的旁边,显示的不是原本github主页的头像,而是默认的灰色章鱼头像</span><br><span class="line"></span><br><span class="line">2.我的contributions里面提交的历史(绿色方块)也没有了</span><br><span class="line"></span><br><span class="line">怎么解决呢？</span><br><span class="line"></span><br><span class="line">1.首先在终端里切到项目所在目录</span><br><span class="line"></span><br><span class="line">2.输入git show命令,你会发现 有一行写着Author: Apple &lt;邮箱&gt;,这个邮箱肯定不是你绑定到github的邮箱</span><br><span class="line"></span><br><span class="line">3.输入git config user.email &quot;你的邮箱地址&quot;,修改邮箱</span><br><span class="line"></span><br><span class="line">4.修改完以后输入git config user.email 检查是否修改成了你的邮箱</span><br><span class="line"></span><br><span class="line">5.到目前为止现在只是修改这个项目的邮箱,重新推送一个新的改动,在查看该项目的提交历史和contributions里面提交的历史(绿色方块),问题已经解决了(之前的依旧不显示)</span><br><span class="line"></span><br><span class="line">6.如果你想其他项目提交时,也避免此类情况,把上面的两条命令改成 （1） git config --global user.email &quot;your_email@example.com&quot;</span><br><span class="line"></span><br><span class="line">（2）git config --global user.email 就可以了</span><br></pre></td></tr></table></figure><h3 id="解决anaconda无法连接的问题"><a href="#解决anaconda无法连接的问题" class="headerlink" title="解决anaconda无法连接的问题"></a>解决anaconda无法连接的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win10下更换清华镜像后无法连接 是因为win10里面无法解析https协议，修改‪~\.condarc文件，把https换成http</span><br></pre></td></tr></table></figure><h3 id="排查挖矿程序中会用到的一些追踪某个进程的命令"><a href="#排查挖矿程序中会用到的一些追踪某个进程的命令" class="headerlink" title="排查挖矿程序中会用到的一些追踪某个进程的命令"></a>排查挖矿程序中会用到的一些追踪某个进程的命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>查看PID启动文件的路径</span><br><span class="line">ls -l /proc/$PID/exe</span><br><span class="line"><span class="meta">#</span>查看PID执行目录的路径</span><br><span class="line">ls -l /proc/$PID/cwd</span><br><span class="line"><span class="meta">#</span>在定时器配置目录查看是否存在异常定时器配置</span><br><span class="line">/var/spool/cron/root 和/etc/crontab 和/etc/rc.lcoal</span><br><span class="line"><span class="meta">#</span>查看定时器启动日志,跟踪自启动程序</span><br><span class="line">tail -f /var/log/cron</span><br><span class="line"><span class="meta">#</span>查看各个进程的cpu使用情况，默认按cpu使用率排序</span><br><span class="line">top</span><br><span class="line"><span class="meta">#</span>显示所有运行中的进程，q退出</span><br><span class="line">ps aux | less</span><br><span class="line"><span class="meta">#</span>查看test.jar进程号</span><br><span class="line">ps -aux|grep test.jar | grep -v grep</span><br><span class="line"><span class="meta">#</span>查看test.jar进程号</span><br><span class="line">ps -ef|grep test.jar | grep -v grep</span><br><span class="line"><span class="meta">#</span>查看该进程下各个线程的cpu使用情况</span><br><span class="line">top -Hp pid</span><br><span class="line"><span class="meta">#</span>将线程pid转换为十六进制 8f7</span><br><span class="line">printf "%x\n" pid</span><br><span class="line"><span class="meta">#</span>查看pid进程里面的线程信息,线程Id为十六进制</span><br><span class="line">jstack pid | grep 8f7</span><br><span class="line"><span class="meta">#</span>查看该进程打开的文件</span><br><span class="line">lsof -p pid</span><br><span class="line"><span class="meta">#</span>查看pid线程内存分配</span><br><span class="line">cat /proc/pid/maps </span><br><span class="line"><span class="meta">#</span>查看PID启动文件的路径</span><br><span class="line">ls -l /proc/$PID/exe </span><br><span class="line"><span class="meta">#</span>查看PID执行目录的路径</span><br><span class="line">ls -l /proc/$PID/cwd </span><br><span class="line"><span class="meta">#</span>查看PID详细的内存占比</span><br><span class="line">cat /proc/$PID/status</span><br></pre></td></tr></table></figure><h3 id="Kerberos缺点"><a href="#Kerberos缺点" class="headerlink" title="Kerberos缺点"></a>Kerberos缺点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、KDC 有单点风险，除非设置HA系统(Aictive Directory 可以做到这一点，目前apache directoryserver 也可以做到这一点)；</span><br><span class="line"></span><br><span class="line">2、访问压力可能使KDC过载；分布式服务使用Kerberos 必须做到这一点，KDC无法承受高负载请求；为什么Hadoop 要使用代理tokens的原因也是如此；</span><br><span class="line"></span><br><span class="line">3、服务之间的通信通道也需要安全认证，kerberos不保证数据加密；如果通信通道不安全，tickets 可能会被拦截或者通信伪造；</span><br><span class="line"></span><br><span class="line">4、机器之前需要保证时间的精确一致性，不然具备时限的tockens不会正常工作；这个在分布式领域是一个典型的问题，Paxos &amp;Raft协议也必须保证时间的一致性；</span><br><span class="line"></span><br><span class="line">5、如果机器间的时间没有被安全管理，理论上可能延长被盗token的使用时间；</span><br><span class="line"></span><br><span class="line">6、被盗用的token可以拿来直接访问服务，在KDC是没有访问日志的。每一个application需要拥有自己的以用户为单位的审计日志，这样才能保证被盗的ticket可被追踪，比如在Hadoop里面HDFS审计日志；</span><br><span class="line"></span><br><span class="line">7、这是一个仅仅认证服务：验证caller的合法性并准许给caller传递认证信息，他不处理任何授权信息；</span><br></pre></td></tr></table></figure><h3 id="mac无法运行-sh文件的解决办法"><a href="#mac无法运行-sh文件的解决办法" class="headerlink" title="mac无法运行.sh文件的解决办法"></a>mac无法运行.sh文件的解决办法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">今天解决了一下内网穿透的问题，</span><br><span class="line">轻量级的选择有frp，</span><br><span class="line">重量级的有goproxy</span><br><span class="line"></span><br><span class="line">几个问题记录一下，第一点：</span><br><span class="line">zsh无法运行.sh文件，要进行切换</span><br><span class="line">chsh -s /bin/bash</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h3 id="解决git下载速度慢的终极方法"><a href="#解决git下载速度慢的终极方法" class="headerlink" title="解决git下载速度慢的终极方法"></a>解决git下载速度慢的终极方法</h3><p>因为本地的网络始终有一些问题，再忍受了很久很久的龟速下载之后，终于找了个一个非常顶的方法</p><p>前提是现有一个vpn，但是vpn不会自动代理git的流量，不管是在windows下面还是在mac下面都不会自动代理git，这点一直让我十分苦恼，现在终于找到了一劳永逸的办法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos; </span><br><span class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br></pre></td></tr></table></figure><p>简单说明：vpn一般都是走的1080端口，通过这个端口转发git的流量，跳过本地运营商。</p><p>取消代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 取消代理</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line"></span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h3 id="Maven代理配置"><a href="#Maven代理配置" class="headerlink" title="Maven代理配置"></a>Maven代理配置</h3><p>不需要配置什么https或者http模式，在有代理的前提下，只要配置一个代理即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>ss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>socks5<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">host</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span>&gt;</span>1080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要注意的是监控一下端口，如果代理没开的话那肯定是无法连接上的，mirror就不用设置了，直接从中央仓库拉去数据。</p><h3 id="npm更换源"><a href="#npm更换源" class="headerlink" title="npm更换源"></a>npm更换源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//设置淘宝源</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">//设置公司的源</span><br><span class="line">npm config set registry http://127.0.0.1:4873</span><br><span class="line"></span><br><span class="line">//查看源，可以看到设置过的所有的源</span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>其实感觉应该把Mac管理node的brew n弄一下</p><h3 id="HDFS的某个错误"><a href="#HDFS的某个错误" class="headerlink" title="HDFS的某个错误"></a>HDFS的某个错误</h3><p>HBase和Flink在运行的时候报错</p><p>hbase启动后region自动挂了，Flink任务失败，文件丢失，然后查看hdfs日志</p><p>错误原因 dfs.datanode.max.transfer.threads 的参数4096，已经不足以支持现在的Thread，修改为2倍或者4倍或者更多</p><h3 id="IDEA-MAVEN停止加载"><a href="#IDEA-MAVEN停止加载" class="headerlink" title="IDEA MAVEN停止加载"></a>IDEA MAVEN停止加载</h3><p>经常遇到大型项目idea 停止加载mvn，然后就没办法了。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maven -&gt; maven goal idea的maven第六个按钮</span><br><span class="line">点击 然后</span><br><span class="line">mvn -U idea:idea</span><br><span class="line">即可</span><br></pre></td></tr></table></figure><h3 id="窗口触发的一些问题"><a href="#窗口触发的一些问题" class="headerlink" title="窗口触发的一些问题"></a>窗口触发的一些问题</h3><p>窗口是按 watermark 触发的，watermark 如果没有前进到 window end ， window 是不会触发的。</p><p>Flink的窗口触发具体机制需要去源码里面探寻</p><h3 id="Flink-SQL中的爆炸函数"><a href="#Flink-SQL中的爆炸函数" class="headerlink" title="Flink SQL中的爆炸函数"></a>Flink SQL中的爆炸函数</h3><p>Lateral View() 在Flink SQL中是unnest</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">users</span>, tag <span class="keyword">FROM</span> Orders <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> <span class="keyword">UNNEST</span>(tags) <span class="keyword">AS</span> t (tag)</span><br></pre></td></tr></table></figure><h3 id="Flink-UI在Yarn下"><a href="#Flink-UI在Yarn下" class="headerlink" title="Flink UI在Yarn下"></a>Flink UI在Yarn下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flink UI 在 Yarn下很多选线卡看不到详细信息，很正常，因为Yarn这个运行模式有的消息只能在Yarn上管理控制</span><br></pre></td></tr></table></figure><h3 id="Flink的时区问题"><a href="#Flink的时区问题" class="headerlink" title="Flink的时区问题"></a>Flink的时区问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flink的时间戳差了8个小时，可以用时间减去八个小时时差，生成一个减去8小时的列，作为watermark的时间戳。</span><br></pre></td></tr></table></figure><h3 id="Flink的心跳需求问题"><a href="#Flink的心跳需求问题" class="headerlink" title="Flink的心跳需求问题"></a>Flink的心跳需求问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用flink sql在实时计算当天凌晨截止到现在的累计数据的时候，计算步长是10分钟，如果这10分钟内没有新数据达到的话，现在的情况是这10分钟没有写记录，这就会造成业务查这个数据的时候需要找last value这种情形，设计一条方案让没有数据到达的时候也生成一条记录，这条记录的值就是last value。</span><br><span class="line"></span><br><span class="line">方案：</span><br><span class="line">往数据源发心跳数据。</span><br><span class="line">发送的数据格式和普通数据一样，只是这些数据不影响你的 agg 计算，比如 null 值。发送频率就根据需求去确定。</span><br></pre></td></tr></table></figure><h3 id="Flink避免重复劳动的一些方法"><a href="#Flink避免重复劳动的一些方法" class="headerlink" title="Flink避免重复劳动的一些方法"></a>Flink避免重复劳动的一些方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.写DDL+DML分别声明数据源和进行数据处理。</span><br><span class="line">2.groovy+ 规则引擎</span><br></pre></td></tr></table></figure><p>oppo：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gg3fk4uvm2j20j50b1wgo.jpg" alt="微信截图_20200624155221.png"></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gg3floj82tj20go0bw0v5.jpg" alt="FF36AEE6-1E6D-44da-80BB-9BD2FE8142D6.png"></p><h3 id="Flink配置参数"><a href="#Flink配置参数" class="headerlink" title="Flink配置参数"></a>Flink配置参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 开启 distinct agg 切分 </span><br><span class="line">table.optimizer.distinct-agg.split.enabled=true</span><br><span class="line"># 开启两阶段 即local-global 􏰝优化</span><br><span class="line">table.optimizer.agg-phase-strategy=TWO_PHASE</span><br><span class="line"># mini-batch 开启微批操作 </span><br><span class="line">table.exec.mini-batch.enabled=true</span><br><span class="line"># mini-batch的时间间隔，即作业需要额外忍受的延迟</span><br><span class="line">table.exec.mini-batch.allow-latency=5s</span><br><span class="line"># 一个节点中允许最多缓存的数据</span><br><span class="line">table.exec.mini-batch.size=5000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TableEnvironment tEnv = ...</span><br><span class="line"></span><br><span class="line">// access flink configuration</span><br><span class="line">Configuration configuration = tEnv.getConfig().getConfiguration();</span><br><span class="line">// set low-level key-value options</span><br><span class="line">configuration.setString(&quot;table.exec.mini-batch.enabled&quot;, &quot;true&quot;);</span><br><span class="line">configuration.setString(&quot;table.exec.mini-batch.allow-latency&quot;, &quot;5 s&quot;);</span><br><span class="line">configuration.setString(&quot;table.exec.mini-batch.size&quot;, &quot;5000&quot;);</span><br></pre></td></tr></table></figure><h3 id="Flink-GlobalWindow"><a href="#Flink-GlobalWindow" class="headerlink" title="Flink GlobalWindow"></a>Flink GlobalWindow</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function">def <span class="title">testJoin</span><span class="params">()</span>: Unit </span>=&#123;</span><br><span class="line">   val env = StreamExecutionEnvironment.getExecutionEnvironment</span><br><span class="line">   env.setParallelism(<span class="number">3</span>)</span><br><span class="line">   val person = env.fromElements((<span class="string">"1"</span>,<span class="string">"小张"</span>),(<span class="string">"2"</span>,<span class="string">"小刘"</span>),(<span class="string">"3"</span>,<span class="string">"小力"</span>),(<span class="string">"4"</span>,<span class="string">"小心"</span>))</span><br><span class="line">   val money = env.fromElements((<span class="string">"1"</span>,<span class="number">100</span>),(<span class="string">"2"</span>,<span class="number">200</span>),(<span class="string">"3"</span>,<span class="number">300</span>))</span><br><span class="line">   person.join(money)</span><br><span class="line">     .where(_._1)</span><br><span class="line">     .equalTo(_._1)</span><br><span class="line">     .window(GlobalWindows.create())</span><br><span class="line">     .apply((x,y) =&gt;&#123;</span><br><span class="line">       println( x+<span class="string">"==="</span>+y)</span><br><span class="line">       <span class="string">"xxx"</span></span><br><span class="line">      &#125;).print()</span><br><span class="line">   env.execute()</span><br><span class="line">   println(<span class="string">"end"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>无法运行，加个triggle(xxx)解决，默认是NeverTrigger</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">.window....</span><br><span class="line">.trigger(CountTrigger.of(1))</span><br><span class="line">.apply...</span><br></pre></td></tr></table></figure><h3 id="如何排查Kafka消息的异常"><a href="#如何排查Kafka消息的异常" class="headerlink" title="如何排查Kafka消息的异常"></a>如何排查Kafka消息的异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录住报错时的kafka offset，然后分阶段打印到控制台，再对比一下，把输出的格式分别调为Row.class 以前pojo类，或注释下一阶段代码，回放kafka 故障的offset数据，各个stream排查</span><br></pre></td></tr></table></figure><h3 id="MySQL的迁移"><a href="#MySQL的迁移" class="headerlink" title="MySQL的迁移"></a>MySQL的迁移</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--涉及到MySQL的迁移，我这边推荐少量数据的话使用MySQLDump.</span><br><span class="line">--还涉及到mysql安装在docker里的情况</span><br><span class="line">--mysqldump的用法</span><br><span class="line">    --备份所有数据库：</span><br><span class="line"></span><br><span class="line">    mysqldump -uroot -p --all-databases &gt; /backup/mysqldump/all.db</span><br><span class="line">    --备份指定数据库：</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p test &gt; /backup/mysqldump/test.db</span><br><span class="line">    --备份指定数据库指定表(多个表以空格间隔)</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p  mysql db event &gt; /backup/mysqldump/2table.db</span><br><span class="line">    --备份指定数据库排除某些表</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p test --ignore-table=test.t1 --ignore-table=test.t2 &gt; /backup/mysqldump/test2.db</span><br><span class="line">    --Docker进入mysql容器</span><br><span class="line">docker exec -it mysql1 bash //mysql1是我启动的mysql服务的name</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">--带docker的命令</span><br><span class="line">1.查看当前启动的mysql运行容器</span><br><span class="line"></span><br><span class="line">docker ps </span><br><span class="line"></span><br><span class="line">2.使用以下命令备份导出数据库中的所有表结构和数据</span><br><span class="line"></span><br><span class="line">docker exec -it  mysql mysqldump -uroot -p123456 paas_portal &gt; /cloud/sql/paas_portal.sql</span><br><span class="line">3.只导数据不导结构</span><br><span class="line"></span><br><span class="line">    mysqldump　-t　数据库名　-uroot　-p　&gt;　xxx.sql　</span><br><span class="line"></span><br><span class="line">docker exec -it mysql mysqldump -t -uroot -p123456 paas_portal &gt;/cloud/sql/paas_portal_dml.sql</span><br><span class="line">4.只导结构不导数据</span><br><span class="line"></span><br><span class="line">mysqldump　--opt　-d　数据库名　-u　root　-p　&gt;　xxx.sql　</span><br><span class="line"></span><br><span class="line">docker exec -it mysql mysqldump  --opt -d   -uroot -p123456 paas_portal &gt;/cloud/sql/paas_portal_ddl.sql</span><br><span class="line"></span><br><span class="line">5.导出特定表的结构</span><br><span class="line"></span><br><span class="line">mysqldump　-uroot　-p　-B　数据库名　--table　表名　&gt;　xxx.sql</span><br><span class="line"></span><br><span class="line">docker exec -it mysql mysqldump -uroot -p -B paas_portal --table user &gt; user.sql</span><br></pre></td></tr></table></figure><h3 id="远程调试Flink"><a href="#远程调试Flink" class="headerlink" title="远程调试Flink"></a>远程调试Flink</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gghbc3d8shj20le0jvtab.jpg" alt="TIM截图20200706160357.png"></p><p><a href="https://stackoverflow.com/questions/34816847/debugging-on-the-remote-cluster" target="_blank" rel="noopener">https://stackoverflow.com/questions/34816847/debugging-on-the-remote-cluster</a></p><h3 id="Log4J-和-slf4j联合使用"><a href="#Log4J-和-slf4j联合使用" class="headerlink" title="Log4J 和 slf4j联合使用"></a>Log4J 和 slf4j联合使用</h3><p>slf4j是什么？slf4j只是定义了一组日志接口，但并未提供任何实现，既然这样，为什么要用slf4j呢？log4j不是已经满足要求了吗？</p><p>是的，log4j满足了要求，但是，日志框架并不只有log4j一个，你喜欢用log4j，有的人可能更喜欢logback，有的人甚至用jdk自带的日志框架，这种情况下，如果你要依赖别人的jar，整个系统就用了两个日志框架，如果你依赖10个jar，每个jar用的日志框架都不同，岂不是一个工程用了10个日志框架，那就乱了！</p><p>如果你的代码使用slf4j的接口，具体日志实现框架你喜欢用log4j，其他人的代码也用slf4j的接口，具体实现未知，那你依赖其他人jar包时，整个工程就只会用到log4j日志框架，这是一种典型的门面模式应用，与jvm思想相同，我们面向slf4j写日志代码，slf4j处理具体日志实现框架之间的差异，正如我们面向jvm写java代码，jvm处理操作系统之间的差异，结果就是，一处编写，到处运行。况且，现在越来越多的开源工具都在用slf4j了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后，弄到slf4j与log4j的关联jar包，通过这个东西，将对slf4j接口的调用转换为对log4j的调用，不同的日志实现框架，这个转换工具不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>以及原来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="Log4J2的使用"><a href="#Log4J2的使用" class="headerlink" title="Log4J2的使用"></a>Log4J2的使用</h3><h4 id="Log4J2和Log4J1的比较"><a href="#Log4J2和Log4J1的比较" class="headerlink" title="Log4J2和Log4J1的比较"></a>Log4J2和Log4J1的比较</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>log4j是通过一个**.properties<strong>的文件作为主配置文件的，而现在的log4j 2则已经弃用了这种方式，采用的是</strong>.xml，.json或者.jsn**这种方式。</p><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>log4j只需要引入一个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>log4j 2则是需要2个核心</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><p>log4J.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#此句为定义名为stdout的输出端是哪种类型，可以是</span><br><span class="line">#org.apache.log4j.ConsoleAppender（控制台），</span><br><span class="line">#org.apache.log4j.FileAppender（文件），</span><br><span class="line">#org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span><br><span class="line">#org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</span><br><span class="line">#org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line"></span><br><span class="line">#此句为定义名为stdout的输出端的layout是哪种类型，可以是</span><br><span class="line">#org.apache.log4j.HTMLLayout（以HTML表格形式布局），</span><br><span class="line">#org.apache.log4j.PatternLayout（可以灵活地指定布局模式），</span><br><span class="line">#org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），</span><br><span class="line">#org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line"></span><br><span class="line">#如果使用pattern布局就要指定的打印信息的具体格式ConversionPattern，打印参数如下：</span><br><span class="line">#%m 输出代码中指定的消息</span><br><span class="line">#%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</span><br><span class="line">#%r 输出自应用启动到输出该log信息耗费的毫秒数</span><br><span class="line">#%c 输出所属的类目，通常就是所在类的全名</span><br><span class="line">#%t 输出产生该日志事件的线程名</span><br><span class="line">#%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”</span><br><span class="line">#%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式</span><br><span class="line">#比如：%d&#123;yyyy MMM dd HH:mm:ss,SSS&#125; 输出类似：2002年10月18日 22：10：28，921</span><br><span class="line">#%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。</span><br><span class="line">#[Log4JDemo]是log信息的开头，可以为任意字符，一般为项目简称。</span><br><span class="line">#log4j.appender.stdout.layout.ConversionPattern=[Log4JDemo] %p [%t] %C.%M(%L) | %m%n</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=[Log4JDemo] %p [%t] %C.%M(%L) | %m%n</span><br><span class="line"></span><br><span class="line">#设置日志文件</span><br><span class="line">log4j.appender.LogFile=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.LogFile.File=log4j.log</span><br><span class="line">log4j.appender.LogFile.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.LogFile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l  %m%n</span><br><span class="line"></span><br><span class="line">#此句为将等级为ALL的日志信息输出到stdout和LogFile这两个目的地</span><br><span class="line">#stdout和R的定义在下面的代码，可以任意起名</span><br><span class="line">#等级可分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</span><br><span class="line">#如果配置OFF则不打出任何信息</span><br><span class="line">#如果配置为INFO这样只显示INFO, WARN, ERROR的log信息，而DEBUG信息不会被显示，</span><br><span class="line">#log4j.rootCategory=ERROR,stdout,LogFile</span><br><span class="line">#log4j.rootCategory=ERROR,LogFile</span><br><span class="line">log4j.rootCategory=ERROR,stdout</span><br></pre></td></tr></table></figure><p>log4j2.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--先定义所有的appender--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--这个输出控制台的配置--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--输出日志的格式--&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"log"</span> <span class="attr">fileName</span>=<span class="string">"log/test.log"</span> <span class="attr">append</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileInfo"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/info.log"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">filePattern</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log"</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>        </span><br><span class="line">             <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100 MB"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileWarn"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/warn.log"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">filePattern</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"warn"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100 MB"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileError"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/error.log"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">filePattern</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"error"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100 MB"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.springframework"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.mybatis"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"all"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileInfo"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileWarn"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileError"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>log4j</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger LOGGER = Logger.getLogger(Test.class.getName());</span><br></pre></td></tr></table></figure><p>log4j2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Level;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger(Test.class.getName());</span><br></pre></td></tr></table></figure><h3 id="Spark-On-Yarn-结束任务的方式"><a href="#Spark-On-Yarn-结束任务的方式" class="headerlink" title="Spark On Yarn 结束任务的方式"></a>Spark On Yarn 结束任务的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、yarn app -kill  appid 丢数据或者多数据</span><br><span class="line">2、kill -15  pid        丢数据或者多数据</span><br><span class="line">3、监听http或hdfs目录方式     ok</span><br><span class="line">建议大家用第三种方式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们用的第一种 针对丢数据或者多数据 我们代码里把实时过来的数据checkpoint 下一次再跑的时候会去mysql里修改offset Kafka再读进来的数据和上次checkpoint的数据对比一下 去重</span><br></pre></td></tr></table></figure><h3 id="CharSequence"><a href="#CharSequence" class="headerlink" title="CharSequence"></a>CharSequence</h3><p>第一次见到这个CharSequence的时候感觉挺疑惑的，不知道为什么要有这个东西。这个CharSequence是String和Stringbuilder共同实现的接口类，在下面这种应用场景中，只有CharSequence是适用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">StringBuilder strbu = <span class="keyword">new</span> StringBuilder(<span class="string">"def"</span>);</span><br><span class="line"><span class="keyword">boolean</span> boo = <span class="keyword">true</span>;</span><br><span class="line">CharSequence cs = boo?str:strbu;</span><br></pre></td></tr></table></figure><h3 id="并发编程，创建多少个线程合适"><a href="#并发编程，创建多少个线程合适" class="headerlink" title="并发编程，创建多少个线程合适"></a>并发编程，创建多少个线程合适</h3><p>分为两种情况讨论，CPU密集型和 I/O密集型</p><p>在CPU密集型的程序中，理论上 线程数量 = CPU 核数（逻辑）就可以了，但是实际上，数量一般会设置为 CPU 核数（逻辑）+ 1，</p><blockquote><p>计算(CPU)密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。</p></blockquote><p>在I/O密集型程序的程序中，单核心线程数一般来说是这么设置的：</p><blockquote><p>最佳线程数 = (1/CPU利用率) = 1 + (I/O耗时/CPU耗时)</p></blockquote><p>多核心的线程数为：</p><blockquote><p>最佳线程数 = CPU核心数 * (1/CPU利用率) = CPU核心数 * (1 + (I/O耗时/CPU耗时))</p></blockquote><p>如果都是IO耗时的话，可以从纯理论上直接回答是2N或者2N+1</p><p>还有很多APM（Application Performance Manager）工具可以帮我们得到具体的数据比如 SkyWalking、CAT、zipkin</p><blockquote><p>假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s</p></blockquote><p>如何设计线程个数，使得可以在1s内处理完20个Transaction？</p><p>但是，但是，这是因为没有考虑到CPU数目。家里又没矿，一般服务器的CPU核数为16或者32，如果有80个线程，那么肯定会带来太多不必要的线程上下文切换开销（希望这句话你可以主动说出来），这就需要调优了，来做到最佳 balance</p><blockquote><p>计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？</p></blockquote><p>线程数 = 8 * (1 + 100/5) = 168 (个)</p><h3 id="Google-AutoValue"><a href="#Google-AutoValue" class="headerlink" title="Google AutoValue"></a>Google AutoValue</h3><p>Google的 AutoValue 用起来说实话不是特别方便，对于一些需要用到映射的支持也不是十分友好，总之一句话，在国内的生态下是不太适合使用的，虽然<code>EffectiveJava</code>的作者嗯吹这个组件。</p><p><a href="https://www.jianshu.com/p/e778e96fb751" target="_blank" rel="noopener">https://www.jianshu.com/p/e778e96fb751</a></p><p>这篇博客和AutoValue在Github上面自己的文档算是讲的比较好一点的文档。</p><h3 id="Idea-注释模板设置"><a href="#Idea-注释模板设置" class="headerlink" title="Idea 注释模板设置"></a>Idea 注释模板设置</h3><p><a href="https://blog.csdn.net/shadow_zed/article/details/80551460#commentBox" target="_blank" rel="noopener">https://blog.csdn.net/shadow_zed/article/details/80551460#commentBox</a></p><h3 id="Python中使用-join-替代-处理字符串"><a href="#Python中使用-join-替代-处理字符串" class="headerlink" title="Python中使用.join()替代+处理字符串"></a>Python中使用<code>.join()</code>替代<code>+</code>处理字符串</h3><p><a href="https://towardsdatascience.com/do-not-use-to-join-strings-in-python-f89908307273" target="_blank" rel="noopener">https://towardsdatascience.com/do-not-use-to-join-strings-in-python-f89908307273</a></p><h3 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h3><p>1.使用<code>CDN </code>等技术替代数据库存储。</p><p>2.存储选择特殊文件系统，比如S3、淘宝的TFS等等</p><p>数据库里面尽量只要写路径</p><h3 id="java的一些包的解释"><a href="#java的一些包的解释" class="headerlink" title="java的一些包的解释"></a>java的一些包的解释</h3><p><strong>PO(persistant object) 持久对象</strong><br>在o/r映射的时候出现的概念，如果没有o/r映射，没有这个概念存在了。通常对应数据模型(数据库),本身还有部分业务逻辑的处理。可以看成是与数据库 中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。</p><p><strong>VO(value object) 值对象</strong><br>通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递。</p><p><strong>TO(Transfer Object)，数据传输对象</strong><br>在应用程序不同tie(关系)之间传输的对象</p><p><strong>BO(business object) 业务对象</strong><br>从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</p><p><strong>POJO(plain ordinary java object)</strong> </p><p>简单无规则java对象<br>纯的传统意义的java对象。就是说在一些Object/Relation Mapping工具中，能够做到维护数据库表记录的persisent object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java Bean，只有属性字段及setter和getter方法。</p><p><strong>DAO(data access object) 数据访问对象</strong><br>是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使 用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO, 提供数据库的CRUD操作…</p><h3 id="IDEA2020-显示内存大小"><a href="#IDEA2020-显示内存大小" class="headerlink" title="IDEA2020 显示内存大小"></a>IDEA2020 显示内存大小</h3><p>双击shift 填入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show memory indicator</span><br></pre></td></tr></table></figure><p>在里面打开<code>ON</code></p><h3 id="Java程序结束前运行的代码"><a href="#Java程序结束前运行的代码" class="headerlink" title="Java程序结束前运行的代码"></a>Java程序结束前运行的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"repeat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当使用 kill pid 或者 kill -15 pid的时候这个部分是会执行后才关闭程序的</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关闭"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java8-try-…catch"><a href="#Java8-try-…catch" class="headerlink" title="Java8 try()…catch()"></a>Java8 try()…catch()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个FileWriter会自己关掉</span></span><br><span class="line"><span class="keyword">try</span>(FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>)) &#123;</span><br><span class="line">    fw.write(<span class="string">"test"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们使用try…catch()捕获异常的，如果遇到类似IO流的处理，要在finally部分关闭IO流，当然这个是JDK1.7之前的写法了；在JDK7优化后的<code>try-with-resource</code>语句，该语句确保了每个资源,在语句结束时关闭。所谓的资源是指在程序完成后，必须关闭的流对象。写在()里面的流对象对应的类都实现了自动关闭接口AutoCloseable。</p><h3 id="idea中设置maven的jvm参数"><a href="#idea中设置maven的jvm参数" class="headerlink" title="idea中设置maven的jvm参数"></a>idea中设置maven的jvm参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file-&gt;setting-&gt;Build,Execution,Deployment-&gt;Maven-&gt;Runner</span><br><span class="line">VM option栏设置jvm参数，-Xmx1g -XX:MaxMetaspaceSize=128m</span><br></pre></td></tr></table></figure><h3 id="命令行中设置maven的jvm参数"><a href="#命令行中设置maven的jvm参数" class="headerlink" title="命令行中设置maven的jvm参数"></a>命令行中设置maven的jvm参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 可以在mvn.cmd（linux中是mvn.sh或mvn）添加set MAVEN_OPTS=-Xmx1g -XX:MaxMetaspaceSize=128m</span><br><span class="line">2. 也可以添加MAVEN_OPTS环境变量</span><br></pre></td></tr></table></figure><h3 id="String-SubString"><a href="#String-SubString" class="headerlink" title="String SubString"></a>String SubString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">String Str = <span class="keyword">new</span> String(<span class="string">"www.runoob.com"</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"返回值 :"</span> );</span><br><span class="line">System.out.println(Str.substring(<span class="number">4</span>) );</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"返回值 :"</span> );</span><br><span class="line">System.out.println(Str.substring(<span class="number">4</span>, <span class="number">10</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回值 :runoob.com</span><br><span class="line">返回值 :runoob</span><br></pre></td></tr></table></figure><h3 id="通用的空间-地理空间ASL许可的开源Java库"><a href="#通用的空间-地理空间ASL许可的开源Java库" class="headerlink" title="通用的空间/地理空间ASL许可的开源Java库"></a>通用的空间/地理空间ASL许可的开源Java库</h3><p><em>Spatial4j</em></p><h3 id="IntegerCache"><a href="#IntegerCache" class="headerlink" title="IntegerCache"></a>IntegerCache</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gidwsbcl2aj20jn0k1ab1.jpg" alt="QzpcVXNlcnNcZmx5aG9cQXBwRGF0YVxSb2FtaW5nXERpbmdUYWxrXDExMzI4MDM2MF92MlxJbWFnZUZpbGVzXDIxODg5NzUyOFwxNTk5MTQ4OTI2NTQ3XzAwNjc2REI3LTEwMUYtNDFmNi04RDg1LTQxRDUxNEJENTZGMS5wbmc=.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1000</span>, b = <span class="number">1000</span>;</span><br><span class="line">    System.out.println(a == b);<span class="comment">//1</span></span><br><span class="line">    Integer c = <span class="number">100</span>, d = <span class="number">100</span>;</span><br><span class="line">    System.out.println(c == d);<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>false<br>true</p><p>因为存在这个IntegerCache，-128-127范围内是有Cache对象的，不会新生成。</p><h3 id="书单推荐"><a href="#书单推荐" class="headerlink" title="书单推荐"></a>书单推荐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">《Effective Java中文版》</span><br><span class="line">《实战Java虚拟机：JVM故障诊断与性能优化》</span><br><span class="line">《HotSpot实战》</span><br><span class="line">《实战Java高并发程序设计》</span><br><span class="line">《深入分析Java Web技术内幕》</span><br><span class="line">《大型网站技术架构 核心原理与案例分析》</span><br><span class="line">《大型网站系统与Java中间件实践》</span><br><span class="line">《从Paxos到ZooKeeper 分布式一致性原理与实践》</span><br><span class="line">《代码大全（第2版） 》</span><br><span class="line">《算法导论》</span><br><span class="line">《计算机程序设计艺术》</span><br><span class="line">《重构》</span><br><span class="line">《设计模式》</span><br><span class="line">《人月神话》</span><br><span class="line">《程序员修炼之道》</span><br></pre></td></tr></table></figure><h3 id="反射API"><a href="#反射API" class="headerlink" title="反射API"></a>反射API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.draft.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 反射</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-09-04 14:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefleactionAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"https://www.baidu.com"</span>);</span><br><span class="line">        String urlString = url.toExternalForm();</span><br><span class="line">        System.out.println(urlString);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"==============等价==============&gt;"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; type = Class.forName(<span class="string">"java.net.URL"</span>);</span><br><span class="line">        Constructor&lt;?&gt; constructor = type.getConstructor(String.class);</span><br><span class="line">        Object instance = constructor.newInstance(<span class="string">"https://www.baidu.com"</span>);</span><br><span class="line">        Method method = type.getMethod(<span class="string">"toExternalForm"</span>);</span><br><span class="line">        Object methodCallResult = method.invoke(instance);</span><br><span class="line"></span><br><span class="line">        System.out.println(methodCallResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的Java 反射API，还需要更深入的了解</p><h3 id="最详细的Anaconda安装步骤和注意点"><a href="#最详细的Anaconda安装步骤和注意点" class="headerlink" title="最详细的Anaconda安装步骤和注意点"></a>最详细的Anaconda安装步骤和注意点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/32925500</span><br></pre></td></tr></table></figure><h3 id="CUDA-Driver版本选型"><a href="#CUDA-Driver版本选型" class="headerlink" title="CUDA Driver版本选型"></a>CUDA Driver版本选型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#cuda-major-component-versions</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gihww4dllgj20zl0kldkg.jpg" alt="{291168FC-C79D-4F29-AE0B-DA3E3184D006}_20200907110920.jpg"></p><h3 id="CuDNN版本"><a href="#CuDNN版本" class="headerlink" title="CuDNN版本"></a>CuDNN版本</h3><p>CuDNN的版本是和CUDA版本对应，下载页面就能看到，安装十分简单，三个文件夹的文件和外面的一个文件，单独复制到已经安装好的CUDA文件夹中即可。</p><h3 id="Maven-阿里云插件仓库配置"><a href="#Maven-阿里云插件仓库配置" class="headerlink" title="Maven 阿里云插件仓库配置"></a>Maven 阿里云插件仓库配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-plugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="IDEA配置仓库最好用HTTPS"><a href="#IDEA配置仓库最好用HTTPS" class="headerlink" title="IDEA配置仓库最好用HTTPS"></a>IDEA配置仓库最好用HTTPS</h3><p>Win上有可能出现如下错误，mac上却没问题，佛了</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gilaolon3sj20n603n0wj.jpg" alt="QzpcVXNlcnNcQWRtaW5pc3RyYXRvclxBcHBEYXRhXFJvYW1pbmdcRGluZ1RhbGtcMzU1NTg3MDEyX3YyXEltYWdlRmlsZXNcMjE4ODk3NTI4XDE1OTk3MDA4MzA4MTBfNkQxRUYzMkItMURFMy00MjE1LThEODMtQ0M5ODMzOTdFMDY2LnBuZw==.png"></p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p><strong>五个常用框架</strong></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1giynphltjjj20jx0acdfu.jpg" alt="undefined"></p><p>1.spring framework<br>也就是我们经常说的spring框架，包括了ioc依赖注入，Context上下文、bean管理、springmvc等众多功能模块，其它spring项目比如spring boot也会依赖spring框架。</p><p>2.spring boot<br>它的目标是简化Spring应用和服务的创建、开发与部署，简化了配置文件，使用嵌入式web服务器，含有诸多开箱即用的微服务功能，可以和spring cloud联合部署。</p><p>Spring Boot的核心思想是约定大于配置，应用只需要很少的配置即可，简化了应用开发模式。</p><p>3.Spring Data<br>是一个数据访问及操作的工具集，封装了多种数据源的操作能力，包括：jdbc、Redis、MongoDB等。</p><p>4.Spring Cloud<br>是一套完整的微服务解决方案，是一系列不同功能的微服务框架的集合。Spring Cloud基于Spring Boot，简化了分布式系统的开发，集成了服务发现、配置管理、消息总线、负载均衡、断路器、数据监控等各种服务治理能力。比如sleuth提供了全链路追踪能力，Netflix套件提供了hystrix熔断器、zuul网关等众多的治理组件。config组件提供了动态配置能力，bus组件支持使用RabbitMQ、kafka、Activemq等消息队列，实现分布式服务之间的事件通信。</p><p>5.Spring Security<br>主要用于快速构建安全的应用程序和服务，在Spring Boot和Spring Security OAuth2的基础上，可以快速实现常见安全模型，如单点登录，令牌中继和令牌交换。你可以了解一下oauth2授权机制和jwt认证方式。oauth2是一种授权机制，规定了完备的授权、认证流程。JWT全称是JSON Web Token，是一种把认证信息包含在token中的认证实现，oauth2授权机制中就可以应用jwt来作为认证的具体实现方法。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1giynqh3y5rj20st0btmxe.jpg" alt="undefined"></p><p>本文涉及的流程与实现默认都是基于最新的5.x版本。</p><p>spring中的几个重要概念如下：</p><h4 id="1-IOC"><a href="#1-IOC" class="headerlink" title="1.IOC"></a>1.IOC</h4><p>IOC，就是控制反转，如最左边，拿公司招聘岗位来举例：</p><p>假设一个公司有产品、研发、测试等岗位。如果是公司根据岗位要求，逐个安排人选，如图中向下的箭头，这是正向流程。如果反过来，不用公司来安排候选人，而是由第三方猎头来匹配岗位和候选人，然后进行推荐，如图中向上的箭头，这就是控制反转。</p><p>在spring中，对象的属性是由对象自己创建的，就是正向流程；如果属性不是对象创建，而是由spring来自动进行装配，就是控制反转。这里的DI也就是依赖注入，就是实现控制反转的方式。正向流程导致了对象于对象之间的高耦合，IOC可以解决对象耦合的问题，有利于功能的复用，能够使程序的结构变得非常灵活。</p><h4 id="2-context上下文和bean"><a href="#2-context上下文和bean" class="headerlink" title="2.context上下文和bean"></a>2.context上下文和bean</h4><p>spring进行IOC实现时使用的有两个概念：context上下文和bean。</p><p>如中间图所示，所有被spring管理的、由spring创建的、用于依赖注入的对象，就叫做一个bean。Spring创建并完成依赖注入后，所有bean统一放在一个叫做context的上下文中进行管理。</p><h4 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3.AOP"></a>3.AOP</h4><p>AOP就是面向切面编程。如右面的图，一般程序执行流程是从controller层调用service层、然后service层调用DAO层访问数据，最后在逐层返回结果。</p><p>这个是图中向下箭头所示的按程序执行顺序的纵向处理。但是，一个系统中会有多个不同的服务，例如用户服务、商品信息服务等等，每个服务的controller层都需要验证参数，都需要处理异常，如果按照图中红色的部分，对不同服务的纵向处理流程进行横切，在每个切面上完成通用的功能，例如身份认证、验证参数、处理异常等等、这样就不用在每个服务中都写相同的逻辑了，这就是AOP思想解决的问题。</p><p>AOP以功能进行划分，对服务顺序执行流程中的不同位置进行横切，完成各服务共同需要实现的功能。</p><h3 id="Java加载properties的六种方式"><a href="#Java加载properties的六种方式" class="headerlink" title="Java加载properties的六种方式"></a>Java加载properties的六种方式</h3><p>Java加载properties文件的方式主要分为两大类：</p><p>一种是通过<code>import java.util.Properties</code>类中的<code>load(InputStream in)</code>方法加载；</p><p>另一种是通过<code>import java.util.ResourceBundle</code>类的<code>getBundle(String baseName)</code>方法加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.PropertyResourceBundle;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesUtil</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String basePath = <span class="string">"src/prop.properties"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String nickname = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">""</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 一、 使用java.util.Properties类的load(InputStream in)方法加载properties文件</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">      InputStream is = <span class="keyword">new</span> FileInputStream(basePath);</span><br><span class="line">      prop.load(is);</span><br><span class="line">      name = prop.getProperty(<span class="string">"username"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 二、 使用class变量的getResourceAsStream()方法</span></span><br><span class="line"><span class="comment">   * 注意：getResourceAsStream()读取路径是与本类的同一包下</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    InputStream is = PropertiesUtil.class</span><br><span class="line">        .getResourceAsStream(<span class="string">"/com/util/prop.properties"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      prop.load(is);</span><br><span class="line">      name = prop.getProperty(<span class="string">"username"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 三、</span></span><br><span class="line"><span class="comment">   * 使用class.getClassLoader()所得到的java.lang.ClassLoader的getResourceAsStream()方法</span></span><br><span class="line"><span class="comment">   * getResourceAsStream(name)方法的参数必须是包路径+文件名+.后缀 否则会报空指针异常</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    InputStream is = PropertiesUtil.class.getClassLoader()</span><br><span class="line">        .getResourceAsStream(<span class="string">"com/util/prop.properties"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      prop.load(is);</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 四、 使用java.lang.ClassLoader类的getSystemResourceAsStream()静态方法</span></span><br><span class="line"><span class="comment">   * getSystemResourceAsStream()方法的参数格式也是有固定要求的</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    InputStream is = ClassLoader</span><br><span class="line">        .getSystemResourceAsStream(<span class="string">"com/util/prop.properties"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      prop.load(is);</span><br><span class="line">      name = prop.getProperty(<span class="string">"username"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 五、 使用java.util.ResourceBundle类的getBundle()方法</span></span><br><span class="line"><span class="comment">   * 注意：这个getBundle()方法的参数只能写成包路径+properties文件名，否则将抛异常</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceBundle rb = ResourceBundle.getBundle(<span class="string">"com/util/prop"</span>);</span><br><span class="line">    password = rb.getString(<span class="string">"password"</span>);</span><br><span class="line">    <span class="keyword">return</span> password;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 六、 使用java.util.PropertyResourceBundle类的构造函数</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      InputStream is = <span class="keyword">new</span> FileInputStream(basePath);</span><br><span class="line">      ResourceBundle rb = <span class="keyword">new</span> PropertyResourceBundle(is);</span><br><span class="line">      nickname = rb.getString(<span class="string">"nickname"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> nickname;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"name1:"</span> + PropertiesUtil.getName1());</span><br><span class="line">    System.out.println(<span class="string">"name2:"</span> + PropertiesUtil.getName2());</span><br><span class="line">    System.out.println(<span class="string">"name3:"</span> + PropertiesUtil.getName3());</span><br><span class="line">    System.out.println(<span class="string">"name4:"</span> + PropertiesUtil.getName4());</span><br><span class="line">    System.out.println(<span class="string">"password:"</span> + PropertiesUtil.getName5());</span><br><span class="line">    System.out.println(<span class="string">"nickname:"</span> + PropertiesUtil.getName6());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPS第三方工具"><a href="#GPS第三方工具" class="headerlink" title="GPS第三方工具"></a>GPS第三方工具</h3><h4 id="GIS基本概念"><a href="#GIS基本概念" class="headerlink" title="GIS基本概念"></a>GIS基本概念</h4><ol><li>WKT(Well-known text)是开放地理空间联盟OGC（Open GIS Consortium ）制定的一种文本标记语言，用于表示矢量几何对象、空间参照系统及空间参照系统之间的转换。</li><li>WKB(well-known binary) 是WKT的二进制表示形式，解决了WKT表达方式冗余的问题，便于传输和在数据库中存储相同的信息</li><li>GeoJSON 一种JSON格式的Feature信息输出格式，它便于被JavaScript等脚本语言处理，OpenLayers等地理库便是采用GeoJSON格式。此外，TopoJSON等更精简的扩展格式</li></ol><h5 id="几何对象"><a href="#几何对象" class="headerlink" title="几何对象"></a>几何对象</h5><p>WKT可以表示的对象包括以下几种：</p><ul><li>Point, MultiPoint</li><li>LineString, MultiLineString</li><li>Polygon, MultiPolygon</li><li>GeometryCollection<ul><li>可以由多种Geometry组成，如：GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10)</li></ul></li></ul><table><thead><tr><th>Type</th><th>Shape</th><th>WKT</th><th>GeoJSON</th></tr></thead><tbody><tr><td>Point</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mlhtnkhj201f01f08k.jpg" alt="undefined"></td><td>POINT (30 10)</td><td>{ “type”: “Point”, “coordinates”: [30, 10] }</td></tr><tr><td>LineString</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mm3cj3lj201f01f0fv.jpg" alt="undefined"></td><td>LINESTRING (30 10, 10 30, 40 40)</td><td>{ “type”: “LineString”, “coordinates”: [ [30, 10], [10, 30], [40, 40] ] }</td></tr><tr><td>Polygon</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mn9522pj201f01f0n7.jpg" alt="undefined"></td><td>POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))</td><td>{ “type”: “Polygon”, “coordinates”: [ [[30, 10], [40, 40], [20, 40], [10, 20], [30, 10]] ] }</td></tr><tr><td>Polygon</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mntnasfj201f01fa9t.jpg" alt="undefined"></td><td>POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10),(20 30, 35 35, 30 20, 20 30))</td><td>{ “type”: “Polygon”, “coordinates”: [ [[35, 10], [45, 45], [15, 40], [10, 20], [35, 10]], [[20, 30], [35, 35], [30, 20], [20, 30]] ] }</td></tr><tr><td>MultiPoint</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mo9flxyj201f01f0b1.jpg" alt="undefined"></td><td>MULTIPOINT ((10 40), (40 30), (20 20), (30 10))</td><td>{ “type”: “MultiPoint”, “coordinates”: [ [10, 40], [40, 30], [20, 20], [30, 10] ] }</td></tr><tr><td>MultiPoint</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mo9flxyj201f01f0b1.jpg" alt="undefined"></td><td>MULTIPOINT (10 40, 40 30, 20 20, 30 10)</td><td>{ “type”: “MultiPoint”, “coordinates”: [ [10, 40], [40, 30], [20, 20], [30, 10] ] }</td></tr><tr><td>MultiLineString</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mqer9ahj201f01f0ge.jpg" alt="undefined"></td><td>MULTILINESTRING ((10 10, 20 20, 10 40),(40 40, 30 30, 40 20, 30 10))</td><td>{ “type”: “MultiLineString”, “coordinates”: [ [[10, 10], [20, 20], [10, 40]], [[40, 40], [30, 30], [40, 20], [30, 10]] ] }</td></tr><tr><td>MultiPolygon</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mqyv5g1j201f01f0sh.jpg" alt="undefined"></td><td>MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)),((15 5, 40 10, 10 20, 5 10, 15 5)))</td><td>{ “type”: “MultiPolygon”, “coordinates”: [ [ [[30, 20], [45, 40], [10, 40], [30, 20]] ], [ [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]] ] ] }</td></tr><tr><td>MultiPolygon</td><td><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mr4qybmj201f01fa9t.jpg" alt="undefined"></td><td>MULTIPOLYGON (((40 40, 20 45, 45 30, 40 40)),((20 35, 10 30, 10 10, 30 5, 45 20, 20 35),(30 20, 20 15, 20 25, 30 20)))</td><td>{ “type”: “MultiPolygon”, “coordinates”: [ [ [[40, 40], [20, 45], [45, 30], [40, 40]] ], [ [[20, 35], [10, 30], [10, 10], [30, 5], [45, 20], [20, 35]], [[30, 20], [20, 15], [20, 25], [30, 20]] ] ] }</td></tr></tbody></table><h4 id="WKB格式"><a href="#WKB格式" class="headerlink" title="WKB格式"></a>WKB格式</h4><p>WKB采用二进制进行存储，更方便于计算机处理，因此广泛运用于数据的传输与存储，以二位点Point(1 1)为例，</p><p>其WKB表达如下：</p><p>01 0100 0020 E6100000 000000000000F03F 000000000000F03F</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj2mtf7wtcj20i502sjrb.jpg" alt="undefined"></p><ol><li>byteOrder</li></ol><ul><li><p>表示编码方式，00为使用big-endian编码(XDR)，01为使用little-endian编码(NDR)。他们的不同仅限于在内存中放置字节的顺序，比如我们将0x1234abcd写入到以0×0000开始的内存中，则结果如下表：</p></li><li><table><thead><tr><th>Address</th><th>big-endian</th><th>little-endian</th></tr></thead><tbody><tr><td>0×0000</td><td>0x12</td><td>0xcd</td></tr><tr><td>0×0001</td><td>0x34</td><td>0xab</td></tr><tr><td>0×0002</td><td>0xab</td><td>0x34</td></tr><tr><td>0×0003</td><td>0xcd</td><td>0x12</td></tr></tbody></table></li></ul><ol start="2"><li>webTypd</li></ol><p>第二到第九字节对矢量数据基本信息进行了定义</p><ul><li>第二与第三个字节规定了矢量数据的类型，如例子中的0100代表Point；</li><li>第三与第四个字节规定了矢量数据的维数，如例子中的0020代表该点是二位的；</li><li>第五到第九个字节规定了矢量数据的空间参考SRID，如例子中的E6100000是4326的整数十六位进制表达</li></ul><ol start="3"><li>srid</li></ol><ul><li><em>第五到第九个字节规定了矢量数据的空间参考SRID，如例子中的E6100000是4326的整数十六位进制表达</em></li></ul><ol start="4"><li>structPoint</li></ol><ul><li><em>第十个字节开始，每16个字节就代表一个坐标对，如例子中的000000000000F03F是浮点型1的十六进制表达</em></li></ul><h4 id="JTS"><a href="#JTS" class="headerlink" title="JTS"></a>JTS</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ol><li><strong>JTS</strong>是加拿大的 Vivid Solutions公司做的一套开放源码的 Java API。它提供了一套空间数据操作的核心算法。为在兼容OGC标准的空间对象模型中进行基础的几何操作提供2D空间谓词API。</li></ol><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>表示Geometry对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.autonavi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.Coordinate;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.Geometry;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.GeometryCollection;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.GeometryFactory;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.LineString;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.LinearRing;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.Point;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.Polygon;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.MultiPolygon;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.MultiLineString;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.MultiPoint;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.io.ParseException;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.io.WKTReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeometryDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GeometryFactory geometryFactory = <span class="keyword">new</span> GeometryFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create a point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">createPoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Coordinate coord = <span class="keyword">new</span> Coordinate(<span class="number">109.013388</span>, <span class="number">32.715519</span>);</span><br><span class="line">        Point point = geometryFactory.createPoint( coord );</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create a point by WKT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">createPointByWKT</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        Point point = (Point) reader.read(<span class="string">"POINT (109.013388 32.715519)"</span>);</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create multiPoint by wkt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultiPoint <span class="title">createMulPointByWKT</span><span class="params">()</span><span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        MultiPoint mpoint = (MultiPoint) reader.read(<span class="string">"MULTIPOINT(109.013388 32.715519,119.32488 31.435678)"</span>);</span><br><span class="line">        <span class="keyword">return</span> mpoint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * create a line</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LineString <span class="title">createLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Coordinate[] coords  = <span class="keyword">new</span> Coordinate[] &#123;<span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>), <span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>)&#125;;</span><br><span class="line">        LineString line = geometryFactory.createLineString(coords);</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create a line by WKT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LineString <span class="title">createLineByWKT</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        LineString line = (LineString) reader.read(<span class="string">"LINESTRING(0 0, 2 0)"</span>);</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create multiLine </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultiLineString <span class="title">createMLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Coordinate[] coords1  = <span class="keyword">new</span> Coordinate[] &#123;<span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>), <span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>)&#125;;</span><br><span class="line">        LineString line1 = geometryFactory.createLineString(coords1);</span><br><span class="line">        Coordinate[] coords2  = <span class="keyword">new</span> Coordinate[] &#123;<span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>), <span class="keyword">new</span> Coordinate(<span class="number">2</span>, <span class="number">2</span>)&#125;;</span><br><span class="line">        LineString line2 = geometryFactory.createLineString(coords2);</span><br><span class="line">        LineString[] lineStrings = <span class="keyword">new</span> LineString[<span class="number">2</span>];</span><br><span class="line">        lineStrings[<span class="number">0</span>]= line1;</span><br><span class="line">        lineStrings[<span class="number">1</span>] = line2;</span><br><span class="line">        MultiLineString ms = geometryFactory.createMultiLineString(lineStrings);</span><br><span class="line">        <span class="keyword">return</span> ms;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create multiLine by WKT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultiLineString <span class="title">createMLineByWKT</span><span class="params">()</span><span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        MultiLineString line = (MultiLineString) reader.read(<span class="string">"MULTILINESTRING((0 0, 2 0),(1 1,2 2))"</span>);</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create a polygon(多边形) by WKT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Polygon <span class="title">createPolygonByWKT</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        Polygon polygon = (Polygon) reader.read(<span class="string">"POLYGON((20 10, 30 0, 40 10, 30 20, 20 10))"</span>);</span><br><span class="line">        <span class="keyword">return</span> polygon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create multi polygon by wkt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultiPolygon <span class="title">createMulPolygonByWKT</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        WKTReader reader = <span class="keyword">new</span> WKTReader( geometryFactory );</span><br><span class="line">        MultiPolygon mpolygon = (MultiPolygon) reader.read(<span class="string">"MULTIPOLYGON(((40 10, 30 0, 40 10, 30 20, 40 10),(30 10, 30 0, 40 10, 30 20, 30 10)))"</span>);</span><br><span class="line">        <span class="keyword">return</span> mpolygon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create GeometryCollection  contain point or multiPoint or line or multiLine or polygon or multiPolygon</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GeometryCollection <span class="title">createGeoCollect</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        LineString line = createLine();</span><br><span class="line">        Polygon poly =  createPolygonByWKT();</span><br><span class="line">        Geometry g1 = geometryFactory.createGeometry(line);</span><br><span class="line">        Geometry g2 = geometryFactory.createGeometry(poly);</span><br><span class="line">        Geometry[] garray = <span class="keyword">new</span> Geometry[]&#123;g1,g2&#125;;</span><br><span class="line">        GeometryCollection gc = geometryFactory.createGeometryCollection(garray);</span><br><span class="line">        <span class="keyword">return</span> gc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create a Circle  创建一个圆，圆心(x,y) 半径RADIUS</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> RADIUS</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Polygon <span class="title">createCircle</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">final</span> <span class="keyword">double</span> RADIUS)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> SIDES = <span class="number">32</span>;<span class="comment">//圆上面的点个数</span></span><br><span class="line">        Coordinate coords[] = <span class="keyword">new</span> Coordinate[SIDES+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIDES; i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> angle = ((<span class="keyword">double</span>) i / (<span class="keyword">double</span>) SIDES) * Math.PI * <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">double</span> dx = Math.cos( angle ) * RADIUS;</span><br><span class="line">            <span class="keyword">double</span> dy = Math.sin( angle ) * RADIUS;</span><br><span class="line">            coords[i] = <span class="keyword">new</span> Coordinate( (<span class="keyword">double</span>) x + dx, (<span class="keyword">double</span>) y + dy );</span><br><span class="line">        &#125;</span><br><span class="line">        coords[SIDES] = coords[<span class="number">0</span>];</span><br><span class="line">        LinearRing ring = geometryFactory.createLinearRing( coords );</span><br><span class="line">        Polygon polygon = geometryFactory.createPolygon( ring, <span class="keyword">null</span> );</span><br><span class="line">        <span class="keyword">return</span> polygon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        GeometryDemo gt = <span class="keyword">new</span> GeometryDemo();</span><br><span class="line">        Polygon p = gt.createCircle(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//圆上所有的坐标(32个)</span></span><br><span class="line">        Coordinate coords[] = p.getCoordinates();</span><br><span class="line">        <span class="keyword">for</span>(Coordinate coord:coords)&#123;</span><br><span class="line">            System.out.println(coord.x+<span class="string">","</span>+coord.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="火星坐标系"><a href="#火星坐标系" class="headerlink" title="火星坐标系"></a>火星坐标系</h4><p>在谷歌还没有发布谷歌地图时，在GIS领域常见的坐标系主要有WGS84经纬度坐标、北京54坐标或西安80坐标等；但自从谷歌地图发布之后，其海量的高清卫星免费影像是让整个GIS领域为之震惊的，但同时也为安全问题带来了一定的隐患。为了对实际坐标进行加密，于是国测局研究了一套算法，凡是公开发布的商业互联网地图，一定要在此加密算法的基础上进行发布，这样一来地图的坐标就与实地的坐标不相符了，于是大家把这种坐标戏称为“火星坐标”，这里我们就针对这一坐标作一些更为详细的说明。</p><p>所有的电子地图、导航设备，都需要加入该保密插件。第一步，地图公司测绘地图，测绘完成后，送到国家测绘局，将真实坐标的电子地图，加密成“火星坐标”，这样的地图才是可以出版和发布的，然后才可以让GPS公司处理。第二步，所有的GPS公司，只要需要汽车导航的，需要用到导航电子地图的，都需要在软件中加入该保密算法，将COM口读出来的真实的坐标信号，加密转换成ZF要求的保密的坐标。这样，GPS导航仪和导航电子地图就可以完全匹配，GPS也就可以正常工作了。</p><p>GCJ02</p><p>GCJ-02是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统。</p><p>中文名:国家测量局02号标准</p><p>外文名:GCJ-02</p><p>它是一种对经纬度数据的加密算法，即加入随机的偏差。</p><p>国内出版的各种地图系统（包括电子形式），必须至少采用GCJ-02对地理位置进行首次加密。</p><p>综上所述，其实火星坐标系和GCJ-02是同一种事物，它是国家测量(绘)局制定的02号标准，是一种对经纬度坐标进行非线性的随机加偏算法。</p><p>为了响应国家制定的标准，国内所有在线地图服务商（如百度地图、高德地图、搜狗地图和SOSO地图等）和国外部分在线地图服务商(如谷歌地图、必应地图和雅虎地图等)都必须进行GCJ-02加密才对公众进行开放，这就是为什么大家在用地图时总是发现有偏移的原因。</p><p>GCJ-02只是一种坐标偏移标准（算法），对投影没有任何限制，如果再以投影为基础作细分</p><h3 id="PrototBuf"><a href="#PrototBuf" class="headerlink" title="PrototBuf"></a>PrototBuf</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj76dp6ma8j21jb0r2ab4.jpg" alt="undefined"></p><h3 id="IDEA莫名其妙每次自动生成变量都有final修饰符"><a href="#IDEA莫名其妙每次自动生成变量都有final修饰符" class="headerlink" title="IDEA莫名其妙每次自动生成变量都有final修饰符"></a>IDEA莫名其妙每次自动生成变量都有final修饰符</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj79tlhudbg20yc0eeqsg.gif" alt="undefined"></p><h3 id="FlinkKafka兼容性"><a href="#FlinkKafka兼容性" class="headerlink" title="FlinkKafka兼容性"></a>FlinkKafka兼容性</h3><table><thead><tr><th>Maven Dependency</th><th>Supported since</th><th>Consumer and  Producer Class name</th><th>Kafka version</th><th>Notes</th></tr></thead><tbody><tr><td>flink-connector-kafka-0.8_2.11</td><td>1.0.0</td><td>FlinkKafkaConsumer08 FlinkKafkaProducer08</td><td>0.8.x</td><td>Uses the <a href="https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+SimpleConsumer+Example" target="_blank" rel="noopener">SimpleConsumer</a> API of Kafka internally. Offsets are committed to ZK by Flink.</td></tr><tr><td>flink-connector-kafka-0.9_2.11</td><td>1.0.0</td><td>FlinkKafkaConsumer09 FlinkKafkaProducer09</td><td>0.9.x</td><td>Uses the new <a href="http://kafka.apache.org/documentation.html#newconsumerapi" target="_blank" rel="noopener">Consumer API</a> Kafka.</td></tr><tr><td>flink-connector-kafka-0.10_2.11</td><td>1.2.0</td><td>FlinkKafkaConsumer010 FlinkKafkaProducer010</td><td>0.10.x</td><td>This connector supports <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-32+-+Add+timestamps+to+Kafka+message" target="_blank" rel="noopener">Kafka messages with timestamps</a> both for producing and consuming.</td></tr><tr><td>flink-connector-kafka-0.11_2.11</td><td>1.4.0</td><td>FlinkKafkaConsumer011 FlinkKafkaProducer011</td><td>0.11.x</td><td>Since 0.11.x Kafka does not support scala 2.10. This connectorsupports <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-98+-+Exactly+Once+Delivery+and+Transactional+Messaging" target="_blank" rel="noopener">Kafka transactional messaging</a> to provide exactly once semantic for the producer.</td></tr><tr><td>flink-connector-kafka_2.11</td><td>1.7.0</td><td>FlinkKafkaConsumer FlinkKafkaProducer</td><td>&gt;= 1.0.0</td><td>This universal Kafka connector attempts to track the latest version of the Kafka client.The version of the client it uses may change between Flink releases.Modern Kafka clients are backwards compatible with broker versions 0.10.0 or later.However for Kafka 0.11.x and 0.10.x versions, we recommend using dedicatedflink-connector-kafka-0.11_2.11 and flink-connector-kafka-0.10_2.11 respectively.Attention: as of Flink 1.7 the universal Kafka connector is considered to be in a BETA status and might not be as stable as the 0.11 connector. In case of problems withthe universal connector, you can try to use flink-connector-kafka-0.11_2.11 which should be compatible with all of the Kafka versions starting from 0.11.</td></tr></tbody></table><h3 id="关于数据仓库数据中台数据湖的一部分图片"><a href="#关于数据仓库数据中台数据湖的一部分图片" class="headerlink" title="关于数据仓库数据中台数据湖的一部分图片"></a>关于数据仓库数据中台数据湖的一部分图片</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vv1ur3j20lr0afmyg.jpg" alt="2B5AE031-28F3-4273-96BA-AAA9D3A1A25E.png"><br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vuyywpj209b06sjro.jpg" alt="68C1B34D-B7F7-4026-ACDE-9C0C53A57F71.png"><br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vv0bgvj20jh092gm0.jpg" alt="365E67AF-D9E0-49f7-A847-7657EF3FFCAA.png"><br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vv15apj20m209z3zk.jpg" alt="788AA5A9-709B-471e-AB31-2AB8D79EEC14.png"><br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vv5fk0j20nl0d1afi.jpg" alt="5234F018-146E-4c51-97FA-6206F82EC8B6.png"><br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq4vv5hsqj20rn0i80w9.jpg" alt="1CAFEC39-30A9-4b51-9B16-1B9D11A3DD09.png"></p><p>元数据管理还有个普元元数据</p><h3 id="Mac版本的终端要走Proxy除了梯子还需要一个设置"><a href="#Mac版本的终端要走Proxy除了梯子还需要一个设置" class="headerlink" title="Mac版本的终端要走Proxy除了梯子还需要一个设置"></a>Mac版本的终端要走Proxy除了梯子还需要一个设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~ vim ~/.zshrc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># proxy list</span><br><span class="line">alias proxy=&apos;export all_proxy=socks5://127.0.0.1:1080&apos;</span><br><span class="line">alias unproxy=&apos;unset all_proxy&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~ source ~/.zshrc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">切换：</span><br><span class="line">~ proxy</span><br><span class="line">~ unproxy</span><br></pre></td></tr></table></figure><h3 id="无状态-和-有状态-的区别"><a href="#无状态-和-有状态-的区别" class="headerlink" title="无状态 和 有状态 的区别"></a>无状态 和 有状态 的区别</h3><p>在整个程序生态圈中，无状态的意思总是 不需要自己手动关闭，有状态的意识是 总是需要自己手动关闭</p><h3 id="Linux-Command"><a href="#Linux-Command" class="headerlink" title="Linux Command"></a>Linux Command</h3><h4 id="most-more-less"><a href="#most-more-less" class="headerlink" title="most + more + less"></a>most + more + less</h4><p><code>more</code>, <code>less</code> and <code>most</code> are three pagers, we can compare them this way:</p><blockquote><p><code>less</code> is more than <code>more</code>,<br><code>most</code> is more than <code>more</code>, aproximatly,<br><code>less</code> and <code>most</code> are different, none is better.</p></blockquote><h4 id="linux通过进程号查看运行文件目录"><a href="#linux通过进程号查看运行文件目录" class="headerlink" title="linux通过进程号查看运行文件目录"></a>linux通过进程号查看运行文件目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/&#123;进程号&#125;/cwd</span><br></pre></td></tr></table></figure><h4 id="CentOS查看版本"><a href="#CentOS查看版本" class="headerlink" title="CentOS查看版本"></a>CentOS查看版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl </span><br><span class="line"></span><br><span class="line">   Static hostname: datanode127</span><br><span class="line">         Icon name: computer-server</span><br><span class="line">           Chassis: server</span><br><span class="line">        Machine ID: abe6faef122d47c1a66436e7936b4301</span><br><span class="line">           Boot ID: 8010542f5e21440797d9e3fc669fb752</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-693.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br></pre></td></tr></table></figure><h4 id="文件目录大小常见的命令"><a href="#文件目录大小常见的命令" class="headerlink" title="文件目录大小常见的命令"></a>文件目录大小常见的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> flyhugh@MacBook-Pro-2  ~/Documents/Env  pwd</span><br><span class="line">/Users/flyhugh/Documents/Env</span><br><span class="line"> flyhugh@MacBook-Pro-2  ~/Documents/Env  ls</span><br><span class="line">apache-maven-3.6.3 brew_install.rb</span><br><span class="line"> flyhugh@MacBook-Pro-2  ~/Documents/Env  du -sh</span><br><span class="line">7.2G.</span><br><span class="line"> flyhugh@MacBook-Pro-2  ~/Documents/Env  df -h  </span><br><span class="line">Filesystem      Size   Used  Avail Capacity iused      ifree %iused  Mounted on</span><br><span class="line">/dev/disk1s5   466Gi   10Gi  180Gi     6%  488290 4882988630    0%   /</span><br><span class="line">devfs          187Ki  187Ki    0Bi   100%     646          0  100%   /dev</span><br><span class="line">/dev/disk1s1   466Gi  271Gi  180Gi    61% 2520713 4880956207    0%   /System/Volumes/Data</span><br><span class="line">/dev/disk1s4   466Gi  3.0Gi  180Gi     2%       4 4883476916    0%   /private/var/vm</span><br><span class="line">map auto_home    0Bi    0Bi    0Bi   100%       0          0  100%   /System/Volumes/Data/home</span><br><span class="line">/dev/disk1s3   466Gi  504Mi  180Gi     1%      54 4883476866    0%   /Volumes/Recovery</span><br></pre></td></tr></table></figure><h3 id="Win10网络问题汇总"><a href="#Win10网络问题汇总" class="headerlink" title="Win10网络问题汇总"></a>Win10网络问题汇总</h3><p>用无线网有个问题就是电脑开机时间久了 加上我使用科学上网频繁开关，导致网络会有错乱问题，在系统开了很多东西的情况下，直接重启，导致了网络错误，打开IDEA的时候出现了错误提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Internal error. Please refer to http://jb.gg/ide/critical-startup-errors</span><br><span class="line"></span><br><span class="line">java.net.BindException: Address already in use: bind</span><br><span class="line">    at java.base/sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">    at java.base/sun.nio.ch.Net.bind(Net.java:461)</span><br><span class="line">    at java.base/sun.nio.ch.Net.bind(Net.java:453)</span><br><span class="line">    at java.base/sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:227)</span><br><span class="line">    at io.netty.channel.socket.nio.NioServerSocketChannel.doBind(NioServerSocketChannel.java:132)</span><br><span class="line">    at io.netty.channel.AbstractChannel$AbstractUnsafe.bind(AbstractChannel.java:551)</span><br><span class="line">    at io.netty.channel.DefaultChannelPipeline$HeadContext.bind(DefaultChannelPipeline.java:1345)</span><br><span class="line">    at io.netty.channel.AbstractChannelHandlerContext.invokeBind(AbstractChannelHandlerContext.java:503)</span><br><span class="line">    at io.netty.channel.AbstractChannelHandlerContext.bind(AbstractChannelHandlerContext.java:488)</span><br><span class="line">    at io.netty.channel.DefaultChannelPipeline.bind(DefaultChannelPipeline.java:984)</span><br><span class="line">    at io.netty.channel.AbstractChannel.bind(AbstractChannel.java:247)</span><br><span class="line">    at io.netty.bootstrap.AbstractBootstrap$2.run(AbstractBootstrap.java:355)</span><br><span class="line">    at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)</span><br><span class="line">    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:416)</span><br><span class="line">    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:515)</span><br><span class="line">    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">    at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">    at java.base/java.lang.Thread.run(Thread.java:834)</span><br></pre></td></tr></table></figure><p>这个错误造成的原因就是<em>hypervisior(Windows 10的Hyper-V虚拟机)，把端口保留了</em></p><p>解决方法也很简单，<em>hypervisior</em>重新开关一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Disable hyper-v (which will required a couple of restarts)</span><br><span class="line">dism.exe /Online /Disable-Feature:Microsoft-Hyper-V</span><br><span class="line"></span><br><span class="line">When you finish all the required restarts, reserve the port you want so hyper-v doesn&apos;t reserve it back</span><br><span class="line">netsh int ipv4 add excludedportrange protocol=tcp startport=&lt;端口号&gt; numberofports=1</span><br><span class="line"></span><br><span class="line">Re-Enable hyper-V (which will require a couple of restart)</span><br><span class="line">dism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All</span><br></pre></td></tr></table></figure><p>实际使用中第一个命令执行完直接重启就行了。</p><h4 id="win10图形化查看端口占用工具"><a href="#win10图形化查看端口占用工具" class="headerlink" title="win10图形化查看端口占用工具"></a>win10图形化查看端口占用工具</h4><p><code>cports</code></p><h4 id="重置win10网络命令"><a href="#重置win10网络命令" class="headerlink" title="重置win10网络命令"></a>重置win10网络命令</h4><p><code>netsh winsock reset</code></p><h4 id="win10远程窗口大小不可调的问题"><a href="#win10远程窗口大小不可调的问题" class="headerlink" title="win10远程窗口大小不可调的问题"></a>win10远程窗口大小不可调的问题</h4><p>我的显示器分辨率比较高，两台显示器都是4K分辨率的，但是远程的时候默认是锁定1600 * 1200的</p><p>并且默认是窗口化的，无法调整大小，这个时候需要使用命令行配置一下远程窗口的分辨率</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstsc /w:<span class="number">2560</span> /h:<span class="number">1440</span> /f</span><br></pre></td></tr></table></figure><p>这个命令分别是长宽和全屏设置。</p><h4 id="给win10商店设置代理"><a href="#给win10商店设置代理" class="headerlink" title="给win10商店设置代理"></a>给win10商店设置代理</h4><p>最近发现。。。只要有一个好的代理服务器，win10的商店原来也是能随便打开的，这里介绍一下win10的商店的流量怎么走代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先通过 Win + R 快捷键打开「运行」窗口，输入「Regedit」打开注册表编辑器，然后定位到 HKEY_CURRENT_USER\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings，接着在左边的注册表项中找到你想解除网络隔离的应用，右边的 DisplayName 就是应用名称，而左边那一大串字符就是应用的 SID 值了。</span><br></pre></td></tr></table></figure><p>找到这个值之后，然后在cmd命令行中输入：</p><p><code>CheckNetIsolation.exe loopbackexempt -a -p=SID</code></p><p>这SID就是上面搜索到的，这样就行</p><h4 id="关于SSTap转发UDP的问题"><a href="#关于SSTap转发UDP的问题" class="headerlink" title="关于SSTap转发UDP的问题"></a>关于SSTap转发UDP的问题</h4><p>查看SSTap是否成功转发UDP需要用到一个工具，netcat，简称nc，使用这个工具，在命令行中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\nc64.exe -u ip <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>就可以像服务器发送UDP请求，然后在服务器上使用root用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump udp port 10000</span><br></pre></td></tr></table></figure><p>就可以查看转发日志</p><p>Tips：我在ubuntu上设置的ss-server 默认是不打开udp的端口的，需要在开启的时候手动打开。(加上 -u)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ss-server -c /etc/shadowsocks.json -u</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnp | grep 10000</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/ubuntu# netstat -lnp | grep 10000</span><br><span class="line">tcp        0      0 0.0.0.0:10000           0.0.0.0:*               LISTEN      25056/ss-server     </span><br><span class="line">udp        0      0 0.0.0.0:10000           0.0.0.0:*                           25056/ss-server</span><br></pre></td></tr></table></figure><p>如图可以看到端口已经开放了udp和tcp即可，udp是无状态的，不会显示LISTEN，这个是正确的。</p><p>最终结论：是服务器上的SSR没有开启UDP转发，默认是不转发UDP的，这个是有问题的。</p><h4 id="win10-访问墙外世界的最终办法："><a href="#win10-访问墙外世界的最终办法：" class="headerlink" title="win10 访问墙外世界的最终办法："></a>win10 访问墙外世界的最终办法：</h4><p>使用 <code>SSTap</code>这类软件，<code>SSTap</code>是比较简单的，复杂的软件会有流量分流等等功能。</p><p><code>SSTap</code>新建了一个虚拟网卡，所有的流量从新的虚拟网卡中转发出去，不用再考虑软件的流量进出口有没有被代理等等问题。</p><h4 id="Win下Chrome无法访问新浪外链地址"><a href="#Win下Chrome无法访问新浪外链地址" class="headerlink" title="Win下Chrome无法访问新浪外链地址"></a>Win下Chrome无法访问新浪外链地址</h4><p>拓展解决：</p><p><a href="https://chrome.google.com/webstore/detail/wbimgfix/bdhgcfmghkbbdmejdaadfdhhdjphogkp/related" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/wbimgfix/bdhgcfmghkbbdmejdaadfdhhdjphogkp/related</a></p><h4 id="云服务器通过转发windows的3389端口，实现远程对PC的访问"><a href="#云服务器通过转发windows的3389端口，实现远程对PC的访问" class="headerlink" title="云服务器通过转发windows的3389端口，实现远程对PC的访问"></a>云服务器通过转发windows的3389端口，实现远程对PC的访问</h4><p><a href="https://www.jianshu.com/p/939dd2f78399" target="_blank" rel="noopener">https://www.jianshu.com/p/939dd2f78399</a></p><p>使用了文中的方法，需要注意的方法不是很多，一个是和 <code>ssh</code> 配置有关的问题，最后采用的配置文件，我在最后贴出来(这种配置文件下可以使用root帐号登录)。配置完成后使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><p>重启服务。</p><p>登录用到的keygen需要在cygwin64的文件系统中单独保存，使用的并不是windows下面的路径。</p><p>我最终使用的命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=180 -i /home/key/id_rsa_oracle_2 root@#服务器IP# -p 22 -R #以后远程登录要使用的端口，不建议使用3389，为了安全#:127.0.0.1:3389 -fN</span><br></pre></td></tr></table></figure><p><code>ssh</code>配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>       $OpenBSD: sshd_config,v 1.100 2016/08/15 12:32:04 naddy Exp $</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> This is the sshd server system-wide configuration file.  See</span><br><span class="line"><span class="meta">#</span> sshd_config(5) for more information.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> This sshd was compiled with PATH=/usr/local/bin:/usr/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The strategy used for options in the default sshd_config shipped with</span><br><span class="line"><span class="meta">#</span> OpenSSH is to specify options with their default value where</span><br><span class="line"><span class="meta">#</span> possible, but leave them commented.  Uncommented options override the</span><br><span class="line"><span class="meta">#</span> default value.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> If you want to change the port on a SELinux system, you have to tell</span><br><span class="line"><span class="meta">#</span> SELinux about this change.</span><br><span class="line"><span class="meta">#</span> semanage port -a -t ssh_port_t -p tcp #PORTNUMBER</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Port 22</span><br><span class="line"><span class="meta">#</span>AddressFamily any</span><br><span class="line"><span class="meta">#</span>ListenAddress 0.0.0.0</span><br><span class="line"><span class="meta">#</span>ListenAddress ::</span><br><span class="line"></span><br><span class="line">HostKey /etc/ssh/ssh_host_rsa_key</span><br><span class="line"><span class="meta">#</span>HostKey /etc/ssh/ssh_host_dsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ed25519_key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Ciphers and keying</span><br><span class="line"><span class="meta">#</span>RekeyLimit default none</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Logging</span><br><span class="line"><span class="meta">#</span>SyslogFacility AUTH</span><br><span class="line">SyslogFacility AUTHPRIV</span><br><span class="line"><span class="meta">#</span>LogLevel INFO</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Authentication:</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>LoginGraceTime 2m</span><br><span class="line">PermitRootLogin yes</span><br><span class="line"><span class="meta">#</span>StrictModes yes</span><br><span class="line"><span class="meta">#</span>MaxAuthTries 6</span><br><span class="line"><span class="meta">#</span>MaxSessions 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2</span><br><span class="line"><span class="meta">#</span> but this is overridden so installations will only check .ssh/authorized_keys</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>AuthorizedPrincipalsFile none</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>AuthorizedKeysCommand none</span><br><span class="line"><span class="meta">#</span>AuthorizedKeysCommandUser nobody</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> For this to work you will also need host keys in /etc/ssh/ssh_known_hosts</span><br><span class="line"><span class="meta">#</span>HostbasedAuthentication no</span><br><span class="line"><span class="meta">#</span> Change to yes if you don't trust ~/.ssh/known_hosts for</span><br><span class="line"><span class="meta">#</span> HostbasedAuthentication</span><br><span class="line"><span class="meta">#</span>IgnoreUserKnownHosts no</span><br><span class="line"><span class="meta">#</span> Don't read the user's ~/.rhosts and ~/.shosts files</span><br><span class="line"><span class="meta">#</span>IgnoreRhosts yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> To disable tunneled clear text passwords, change to no here!</span><br><span class="line"><span class="meta">#</span>PasswordAuthentication yes</span><br><span class="line"><span class="meta">#</span>PermitEmptyPasswords no</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Change to no to disable s/key passwords</span><br><span class="line"><span class="meta">#</span>ChallengeResponseAuthentication yes</span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Kerberos options</span><br><span class="line"><span class="meta">#</span>KerberosAuthentication no</span><br><span class="line"><span class="meta">#</span>KerberosOrLocalPasswd yes</span><br><span class="line"><span class="meta">#</span>KerberosTicketCleanup yes</span><br><span class="line"><span class="meta">#</span>KerberosGetAFSToken no</span><br><span class="line"><span class="meta">#</span>KerberosUseKuserok yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> GSSAPI options</span><br><span class="line">GSSAPIAuthentication yes</span><br><span class="line">GSSAPICleanupCredentials no</span><br><span class="line"><span class="meta">#</span>GSSAPIStrictAcceptorCheck yes</span><br><span class="line"><span class="meta">#</span>GSSAPIKeyExchange no</span><br><span class="line"><span class="meta">#</span>GSSAPIEnablek5users no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Set this to 'yes' to enable PAM authentication, account processing,</span><br><span class="line"><span class="meta">#</span> and session processing. If this is enabled, PAM authentication will</span><br><span class="line"><span class="meta">#</span> be allowed through the ChallengeResponseAuthentication and</span><br><span class="line"><span class="meta">#</span> PasswordAuthentication.  Depending on your PAM configuration,</span><br><span class="line"><span class="meta">#</span> PAM authentication via ChallengeResponseAuthentication may bypass</span><br><span class="line"><span class="meta">#</span> the setting of "PermitRootLogin without-password".</span><br><span class="line"><span class="meta">#</span> If you just want the PAM account and session checks to run without</span><br><span class="line"><span class="meta">#</span> PAM authentication, then enable this but set PasswordAuthentication</span><br><span class="line"><span class="meta">#</span> and ChallengeResponseAuthentication to 'no'.</span><br><span class="line"><span class="meta">#</span> WARNING: 'UsePAM no' is not supported in Red Hat Enterprise Linux and may cause several</span><br><span class="line"><span class="meta">#</span> problems.</span><br><span class="line">UsePAM yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>AllowAgentForwarding yes</span><br><span class="line"><span class="meta">#</span>AllowTcpForwarding yes</span><br><span class="line">GatewayPorts yes</span><br><span class="line">X11Forwarding yes</span><br><span class="line"><span class="meta">#</span>X11DisplayOffset 10</span><br><span class="line"><span class="meta">#</span>X11UseLocalhost yes</span><br><span class="line"><span class="meta">#</span>PermitTTY yes</span><br><span class="line"><span class="meta">#</span>PrintMotd yes</span><br><span class="line"><span class="meta">#</span>PrintLastLog yes</span><br><span class="line"><span class="meta">#</span>TCPKeepAlive yes</span><br><span class="line"><span class="meta">#</span>UseLogin no</span><br><span class="line"><span class="meta">#</span>UsePrivilegeSeparation sandbox</span><br><span class="line"><span class="meta">#</span>PermitUserEnvironment no</span><br><span class="line"><span class="meta">#</span>Compression delayed</span><br><span class="line"><span class="meta">#</span>ClientAliveInterval 0</span><br><span class="line"><span class="meta">#</span>ClientAliveCountMax 3</span><br><span class="line"><span class="meta">#</span>ShowPatchLevel no</span><br><span class="line"><span class="meta">#</span>UseDNS yes</span><br><span class="line"><span class="meta">#</span>PidFile /var/run/sshd.pid</span><br><span class="line"><span class="meta">#</span>MaxStartups 10:30:100</span><br><span class="line"><span class="meta">#</span>PermitTunnel no</span><br><span class="line"><span class="meta">#</span>ChrootDirectory none</span><br><span class="line"><span class="meta">#</span>VersionAddendum none</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> no default banner path</span><br><span class="line"><span class="meta">#</span>Banner none</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Accept locale-related environment variables</span><br><span class="line">AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES</span><br><span class="line">AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT</span><br><span class="line">AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE</span><br><span class="line">AcceptEnv XMODIFIERS</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> override default of no subsystems</span><br><span class="line">Subsystem sftp  /usr/libexec/openssh/sftp-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Example of overriding settings on a per-user basis</span><br><span class="line"><span class="meta">#</span>Match User anoncvs</span><br><span class="line"><span class="meta">#</span>       X11Forwarding no</span><br><span class="line"><span class="meta">#</span>       AllowTcpForwarding no</span><br><span class="line"><span class="meta">#</span>       PermitTTY no</span><br><span class="line"><span class="meta">#</span>       ForceCommand cvs server</span><br></pre></td></tr></table></figure><p>这种访问方式有点过于笨重，后来采用了<code>frp</code>工具来实现了远程代理</p><p><a href="https://zhuanlan.zhihu.com/p/138092534" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/138092534</a></p><h3 id="网络知识点"><a href="#网络知识点" class="headerlink" title="网络知识点"></a>网络知识点</h3><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>建立TCP需要三次握手才能建立（客户端发起SYN,服务端SYN+ACK,客户端ACK），</p><p>断开连接则需要四次握手（客户端和服务端都可以发起，FIN-ACK-FIN-ACK）。</p><p><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p><p>答：<br>   因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>SYN攻击：发送大量的SYN,导致服务端无法识别哪些是有效的</p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>RPC是指远程调用，两服务器A,B，A要调用B上的一个方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据</p><ol><li><p>通讯问题：在客户端和服务端建立TCP连接，远程调用的所有交换数据都在这个连接里传输。</p></li><li><p>解决寻址问题：IP及端口寻址，方法名</p></li><li><p>序列化（Serialize）：发生远程调用时，方法的参数需要通过底层的网络协议如TCP传送到服务器，由于网络协议是基于二进制的，内存中的参数值需要序列化成二进制的形式，通过寻址和传输序列化的二进制发送给服务器。</p></li><li><p>服务器反序列化：服务器收到请求后需要反序列化，恢复内存中的表达方式，然后找到对应的方法（寻址的一部分），进行本地调用。</p></li><li><p>返回值发送给客户端，这个部分也需要序列化和反序列化。</p></li></ol><p><strong>SOA</strong></p><p>采用一组服务的方式来构建一个应用，服务（hedwig、jsf、RESTful）独立部署在不同的进程中，不同服务通过一些轻量级交互机制来通信，例如RPC、HTTP等。服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。</p><p>RPC 的实现是基于SOA这样的一个架构 C/S模式 远程调用的通讯使用TCP 然后hedwig restful jsf这些就是不同的服务形式</p><p>**http协议和tcp/ip 协议的关系<br>**(1) http是应用层协议，tcp协议是传输层协议，ip协议是网络协议。<br>(2) IP协议主要解决网络路由和寻址问题<br>(3) tcp协议主要解决在IP层协议之上，如何可靠的传输数据，即接收端收到的数据包的大小和顺序，和发送端保持一致。tcp协议是可靠的面相连接的。</p><p><strong>1.   http协议是无状态的</strong>，指的是http协议对于事务处理没有记忆功能，客户端向服务端请求完数据之后，服务端不知道客户端是什么状态。</p><p><strong>2. http的长连接和短连接，本质上是tcp层的长连接和短连接：</strong></p><p>http 1.0 默认使用短连接，http 1.1 默认使用长连接，在使用的http协议，在响应头会加上 Connection:keep-alive</p><p><strong>3. RPC比http请求快的原因</strong>：http使用http协议，rpc使用tcp协议，比http少了应用层，表示层，会话层，这3层，rpc使用长连接，而长连接比短连接更节省资源，效率更高（每个连接的建立和释放都是需要资源和时间的）。</p><p><strong>TCP/IP</strong></p><p>是个协议组，可分为三个层次：<strong>网络层、传输层和应用层。</strong></p><p>在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。</p><p>在<strong>传输层中有TCP协议与UDP协议。</strong></p><p>在应用层有:TCP包括FTP、HTTP、TELNET、SMTP等协议</p><p><strong>UDP包括DNS、TFTP等协议</strong></p><p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。</p><p><strong>通信过程：</strong></p><p>主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。</p><p><strong>建立通信链路</strong></p><p>当<strong>客户端</strong>要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。</p><p>与之对应的<strong>服务端</strong>将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的TCP 连接。</p><p><strong>TCP短连接</strong></p><p>TCP短连接，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。因为一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作。短连接的优点是：<strong>管理起来比较简单，存在的连接都是有用的连接</strong>，不需要额外的控制手段。</p><p><strong>TCP长连接</strong></p><p>长连接，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p><strong>TCP保活功能</strong>，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资 源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段。客户主机必须处于以下4个状态之一：</p><p>1.客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</p><p>2.客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</p><p>3.客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</p><p>4.客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</p><p>从上面可以看出，TCP保活功能主要为探测长连接的存活状况，不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。</p><p>在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问 题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p><p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p><p><strong>HTTP长连接与短连接</strong></p><p><strong>长连接</strong>：client方与server方先建立连接，连接建立后不断开，然后再进行报文发送和接收。</p><p>这种方式下由于通讯连接一直存在。此种方式常用于P2P通信。</p><p><strong>短连接</strong>：Client方与server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。</p><p>此方式常用于一点对多点通讯。C/S通信。</p><p><strong>长连接和短连接异同</strong></p><p><strong>长连接：</strong>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。</p><p>每个TCP连接的建立都需要三次握手，每个TCP连接的断开要四次握手。</p><p>如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作后，下次操作时直接发送数据就可以了，不用再建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，频繁的socket创建也是对资源的浪费。</p><p><strong><em>\</em>短连接\</strong>：**web网站的http服务一般都用短连接。因为长连接对于服务器来说要耗费一定的资源。像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。</p><p><strong>发送接收方式</strong></p><p>1、异步：报文发送和接收是分开的，相互独立，互不影响的。这种方式又分两种情况：</p><p><strong>异步双工：</strong>接收和发送在同一个程序中，有两个不同的子进程分别负责发送和接送。</p><p><strong>异步单工：</strong>接送和发送使用两个不同的程序来完成。</p><p>2、同步：报文发送和接收是同步进行，即报文发送后等待接送返回报文。同步方式一般需要考虑超时问题，试想我们发送报文以后也不能无限等待啊，所以我们要设定一个等待时候。超过等待时间发送方不再等待读返回报文。直接通知超时返回。</p><p><strong>阻塞与非阻塞方式</strong></p><p>1、非阻塞方式：读函数不停的进行读动作，如果没有报文接收到，等待一段时间后超时返回，这种情况一般需要指定超时时间。</p><p>2、阻塞方式：如果没有接收到报文，则读函数一直处于等待状态，知道报文到达。</p><p><strong>及时通信与游戏的长短连接</strong></p><p>实际场合究竟需要使用短连接还是长连接，主要看实时性要求、数据流向和并发量这三个问题。</p><p><strong>长连接优点：</strong>节约TCP握手时间，可以保证高实时性，数据流向可以采用服务器端的主动推模式。<br><strong>长连接缺点</strong>：并发量不宜太高，持续占用服务端口（相对消耗资源）。</p><p>长连接、长轮询一般应用与WebIM、ChatRoom和一些需要及时交互的网站应用中。其真实案例有：WebQQ、Hi网页版、Facebook IM等。</p><p>1.现在游戏中的玩家与玩家之间的聊天无法实现实时性，而且系统有邮件或信息时也不能及时的通知玩家<br>—— 如果涉及到聊天的话，一般来说还是用长连接会更合适，否则大量时间浪费到握手上了；<br>—— 但是手机的网络长连接网络质量可能会比较撮，你需要严重考虑容错和重链机制。</p><p>2.客户端每隔几秒就会发送一个请求，这样服务器的压力岂不是很大？<br>—— 压力会比较大，关键是聊天往往对时间的要求很高，如果是团战的话，1秒内没看到信息，可能就会觉得完全受不了了；当然也看你聊天的场景如何，是群聊还是单聊，以后会不会发展为语音啥的；</p><p>NIO没有任何问题，大规模长连接处理的主流都是用NIO；而且也不是Java发明的，本身就是借助了操作系统的网络管理能力。</p><p><strong>http keep-alive与tcp keep-alive</strong>，不是同一回事，意图不一样。http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制</p><h3 id="Maven问题汇总"><a href="#Maven问题汇总" class="headerlink" title="Maven问题汇总"></a>Maven问题汇总</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- Execute the shell script to generate the spark build information. --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">target</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- windows 目录下修改成CMD Linux下面用的是Bash--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">exec</span> <span class="attr">executable</span>=<span class="string">"cmd"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"$&#123;project.basedir&#125;/../build/spark-build-info"</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"$&#123;project.build.directory&#125;/extra-resources"</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"$&#123;project.version&#125;"</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">exec</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的这个插件 antrun里面的命令在linux环境下使用bash没有问题，在linux环境下应该配置bash</p><h4 id="Maven手动添加Jar包之后没有加载"><a href="#Maven手动添加Jar包之后没有加载" class="headerlink" title="Maven手动添加Jar包之后没有加载"></a>Maven手动添加Jar包之后没有加载</h4><p>File-&gt;Setting-&gt;Maven-&gt;Repositories-&gt;Update（选择本地仓库的路径）</p><h3 id="Active-使用遇到的坑"><a href="#Active-使用遇到的坑" class="headerlink" title="Active 使用遇到的坑"></a>Active 使用遇到的坑</h3><p>线上activemq内存超过限制，导致生产者无法推送告警信息。Activemq重启，导致部分堆积数据丢失</p><p>考虑一下ActiveMQ的监控</p><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>RDB模式全栈快照，当内存比较大，访问比较频繁时（我们的设备实时信息是典形的写多读少，异于一般的写少读多的情况），刷新频率高，磁盘IO要求非常大。</p><p>AOF模式，文件体大，Rewrite时会有RDB类似的情况</p><p>AOF重写或是RDB进行Dump时都会fork子进程，当Redis使用物理内存过半时，会失败</p><h3 id="LinkedList等队列size"><a href="#LinkedList等队列size" class="headerlink" title="LinkedList等队列size()"></a>LinkedList等队列size()</h3><p>JDK自带队列size()需要遍历集合，如果集合数据比较大，且该函数比较频繁访问情况下，可能会有性能问题。并发接近万数量级慎用</p><p>（可以用Stopwatch监控程序每个步骤运行时间）</p><h3 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk86kqo1adj20fa09kq5t.jpg" alt="undefined"></p><h3 id="Flink问题汇总"><a href="#Flink问题汇总" class="headerlink" title="Flink问题汇总"></a>Flink问题汇总</h3><h4 id="Flink使用滑动窗口出现的一个问题"><a href="#Flink使用滑动窗口出现的一个问题" class="headerlink" title="Flink使用滑动窗口出现的一个问题"></a>Flink使用滑动窗口出现的一个问题</h4><p>使用滑动窗口保存checkpoint失败，日志里面没有错误日志，个别情况下在使用不同的时间语义会出现成功的情况。</p><h5 id="Flink数据写入了HDFS，Hive没有识别"><a href="#Flink数据写入了HDFS，Hive没有识别" class="headerlink" title="Flink数据写入了HDFS，Hive没有识别"></a>Flink数据写入了HDFS，Hive没有识别</h5><p>1.11版本，需要设置<code>sink.partition.commit</code>参数，分区表</p><h5 id="Flink-1-12-0编译密码："><a href="#Flink-1-12-0编译密码：" class="headerlink" title="Flink-1.12.0编译密码："></a>Flink-1.12.0编译密码：</h5><p><code>flink-runtime-web</code>工程有几个特点，</p><p>=&gt; 在网络OK，别的问题都没有的情况下，第一次编译成功，后面编译的话会报错（npm或者node.js被占用的错误），也就是说，只有第一次能编译成功。</p><h3 id="时空数据结构简介"><a href="#时空数据结构简介" class="headerlink" title="时空数据结构简介"></a>时空数据结构简介</h3><blockquote><p> 后面如果有时间的话 会把这部分独立出去重新整理一章</p></blockquote><p>所谓时空数据，顾名思义，包含了两个维度的信息：空间信息与时间信息。空间信息，以地理位置点最为基础，还包括线、多边形以及更为复杂的多维结构。最典型的时空数据，莫过于移动对象的轨迹点数据，如每隔5秒钟记录的车辆实时位置信息。这类数据，在物联网领域司空见惯，在可预见的未来，这类数据将会出现爆炸性的增长。</p><p>关于时空索引，这里，了解到的主流技术有R-Trees、Quad-Trees、K-D Trees以及Space Filling Curve这四种技术。</p><h4 id="RTree"><a href="#RTree" class="headerlink" title="RTree"></a>RTree</h4><p>R-Trees源自论文《R-Trees: A Dynamic Index Structure For Spatial Searching》，下面的图也源自此论文：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnmhkz89j20lj0hpmx9.jpg" alt="undefined"></p><p>R-Trees基于这样的思想设计：</p><p>每一个空间对象，如一个多边形区域，都存在一个最小的矩形，能够恰好包含此时空对象，如上图中的矩形R6所包含的弯月形区域。这个最小包围矩形被称之为MBR(Minimum Bounding Rectangle)。</p><p>多个相邻的矩形，可以被包含在一个更大的最小包围矩形中。如R6、R9以及R10三个矩形，可以被包含在R3中，而R11与R12则被包含在R4中。</p><p>继续迭代，总能找到若干个最大的区域，以一种树状的形式，将所有的时空对象给容纳进去，如上图中的R1, R2。这样，整个树状结构，呈现如下：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnn72zvnj20lq097jrc.jpg" alt="undefined"></p><p>从最小的矩形区域，到最大的矩形区域，就好比地图中的行政区域划分：村 -&gt; 县 -&gt; 市 -&gt; 省份。查询时，先从锁定的最大区域开始，逐级缩小比例尺后，就可找到最终的对象。如若将上图中的R1与R2理解成两个平级的”行政区域”，却又存在本质的区别：不同的行政区域，并不存在相互重叠，而R1与R2却可能是重叠的。</p><p>R-Trees的定义：</p><ol><li><p>每一个Leaf Node包含m到M个索引记录（Root节点除外）。</p></li><li><p>每一个索引记录是一个关于(I, tuple-identifier)的二元组信息，I是空间对象的最小包围矩形，而tuple-identifier用来描述空间对象本身。</p></li><li><p>每一个Non-leaf节点，包含m到M个子节点（Root节点除外）。</p></li><li><p>Non-leaf节点上的每一个数据元素，是一个(I, child-pointer)的二元组信息，child-pointer指向其中一个子节点，而I则是这个子节点上所有矩形的最小包围矩形。</p></li></ol><p>上图中，R3、R4以及R5，共同构成一个non-leaf节如点，R3指向包含元素R8，R9以及R10的子节点，这个指针就是child-pointer，而与R8，R9以及R10相关的最小包围矩形，就是I。</p><ol start="5"><li>Root节点至少包含两个子节点，除非它本身也是一个Leaf Node。</li><li>所有的Leaf Nodes都出现在树的同一层上。</li></ol><p>从定义上来看，R-Trees与B-Trees存在诸多类似：Root节点与Non-Leaf节点，均包含限定数量的子节点；所有的Leaf Nodes都出现在树的同一层上。这两种树也都是<strong>自平衡</strong>的。</p><p>前面也已经提到了，B-Trees主要用来存放一维排序的数据元素，而R-Tree存放的则是多维空间数据元素。从查询方式上来看，两者也存在显著的差异：B-Trees更擅长于数据点查，它的设计并不利于数据的范围查询。基于空间元素的查询，却以范围查询为主，而且往往需要对多个子树进行并行查询，例如，在地图上划定某一个区域，查询这个区域内有哪些公园，可能有多个子树都与划定的这个区域存在交集。从这一点看来，R-Tree的搜索性能其实并没有很好的保障。</p><p>R-Trees有多种变种，如R+-Trees，R*-Trees，X-Trees, M-Trees，BR-Trees等等，不再展开过多的介绍。</p><h4 id="Quad-Trees"><a href="#Quad-Trees" class="headerlink" title="Quad-Trees"></a>Quad-Trees</h4><p>HBase中的数据按照RowKey单维度排序组织，而我们现在却面临的是一个多维数据问题。因此，HBase如果想很好的支持时空数据的存储，需要引入时空索引技术。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnu0iuf9j20u20if0sm.jpg" alt="undefined"></p><p>上图中的A,B,C,E,F,G均为Point，以每一个Point作为中心点，可以将一个区间分成4个象限。</p><p>假设，先写入Point A，以A为中心，将整个区间分成了4个象限。</p><p>写入Point B，Point B位于A的东北象限中，同样，以B为中心，依然可以将A东北象限进一步细分为4个子象限。</p><p>写入Point C，Point C位于A的东南象限中，以C为中心，可以将A的东南象限细分成4个子象限。</p><p>…..</p><p>任何新写入的一个Point，总能找到一个某一个已存在的Point的子象限，来存放这个新的Point。</p><p>整个树状结构呈现如下：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnuq702mj210w0dqweg.jpg" alt="undefined"></p><p>可见，Quad-Trees有几个鲜明的特点：1. 对于非叶子节点，均包含4个子节点，对应4个面积不一的象限。2.<strong>不平衡，树的结构与数据的写入顺序直接相关</strong>。3.有空的Leaf Nodes，且所有的Leaf Nodes则是”参差不齐”的(并不一定都出现在树的同一层中)。4.数据既可能出现在分枝节点中，也可能出现在叶子节点中。</p><p>因为Quad-Trees存在诸多变种，为了有所区分，上面提到的最简单的这种Quad-Tree，被称之为Point Quad-Trees。还有一种典型的Quad-Trees，被称之为Point Region QuadTrees(简称为PR QuadTrees)：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnv4pghhj20jw0jvwed.jpg" alt="undefined"></p><p>PR Quad-Trees中，每一次迭代出来的4个象限，面积相同，且不依赖于用户数据Point作为分割点，或者说，<strong>数据分区与用户数据无关</strong>。每一个划分出来的子象限中，只允许存在一个Point。</p><p>与Point Quad-Trees相比，PR Quad-Trees允许两份不同的数据集，拥有相同的分区信息。但PR Quad-Trees存在的问题也明显：1. 两个相邻的Points，可能在树的Level高度上相隔甚远。2.两份数据集如果追求相同的分区信息，可能需要进行足够粒度的分割，这可能导致空间浪费。</p><h4 id="K-D-Trees"><a href="#K-D-Trees" class="headerlink" title="K-D Trees"></a>K-D Trees</h4><p>K-D Trees是一种针对高维点向量数据的索引结构，一棵简单的K-D Tree如下图所示(原图源自James Fogarty的”K-D Trees and Quad Trees”，但为了更直观，关于分区分割线的线条做了改动)：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvnwwojz8j20qq0emdg0.jpg" alt="undefined"></p><p>与Quad Trees思想类似，K-D Trees也是将整个区间进行不断分割，不同之处在于，Quad Trees每一次迭代，将一个区间分割成四个象限，而K-D Trees则是分成左右或上下两个区间。如上图所示：S1把整个空间分成了左右两个区间，左侧区间中，又被S2横向分割成了上下两个区间，而S3又在S2的分割基础上，将下部分分割成了左右两个区间，….</p><h4 id="Space-Filling-Curve"><a href="#Space-Filling-Curve" class="headerlink" title="Space Filling Curve"></a>Space Filling Curve</h4><p>如果将一个完整的二维空间，分割成一个个大小相同的矩形，可以将Space Filling Curve简单理解为它是一种将所有的矩形区域用一条线”串”起来的方法，因”串”的方式不同，也就引申出了不同的Space Filling Curve算法。</p><p>比较典型的如Z-Order Curve：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvo2jc2z0j20hb0d5q38.jpg" alt="undefined"></p><p>再如Hilbert Curve:</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkvo3097w9j20ha0d3dfx.jpg" alt="undefined"></p><p>GeoMesa使用了基于Z-order填充曲线的GeoHash空间索引技术， 并针对时间维度进行了扩展，具体分为: • Z2:空间，点索引 • Z3:时间+空间，点索引 • XZ2:空间，线\面索引 • XZ3:时间+空间，线\面索引。</p><p>为什么选择了RTree =&gt;</p><ul><li>原先的项目中选择<code>RTree</code></li><li>别的项目没有<code>RTree</code>这么成熟的工业库</li></ul><p><img src="C:\Users\liu.gaoming\AppData\Roaming\Typora\typora-user-images\image-20201120152806907.png" alt="image-20201120152806907"></p><ul><li><p><code>RTree</code>的优化方向比较好找</p></li><li><p><code>RTree</code>可以理解为<code>BTree</code>的多维版本，相对来说比较熟悉，此外R树还可以退化成一维，但是分割的线段存在重叠问题，效果不如<code>Btree</code>。</p></li></ul><h5 id="R树的操作"><a href="#R树的操作" class="headerlink" title="R树的操作"></a>R树的操作</h5><h6 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h6><p>R树的搜索操作很简单，跟B树上的搜索十分相似。它返回的结果是所有符合查找信息的记录条目。而输入是什么？输入不仅仅是一个范围了，它更可以看成是一个空间中的矩形。也就是说，我们输入的是一个搜索矩形。</p><h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><p>R树的插入操作也同B树的插入操作类似。当新的数据记录需要被添加入叶子结点时，若叶子结点溢出，那么我们需要对叶子结点进行分裂操作。显然，叶子结点的插入操作会比搜索操作要复杂。插入操作需要一些辅助方法才能够完成。<br>来看一下伪代码：</p><h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><p>R树的删除操作与B树的删除操作会有所不同，不过同B树一样，会涉及到压缩等操作。相信读者看完以下的伪代码之后会有所体会。R树的删除同样是比较复杂的，需要用到一些辅助函数来完成整个操作。</p><h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><ul><li>为了最小化内存使用可以针对数据类型优化–&gt;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rectangle r = Geometries.rectangle(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line"></span><br><span class="line">Rectangle r = Geometries.rectangle(<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span>);</span><br></pre></td></tr></table></figure><p>理论上这样使用RTree消耗的内存只有Double的一半。</p><ul><li>使用R-Tree的变种 R*-Tree，对数据结构进行了优化，并且同样存在成熟的常用项目 <code>RTee2</code> 可以使用。</li></ul><h3 id="Base4BigData-Version-1"><a href="#Base4BigData-Version-1" class="headerlink" title="Base4BigData(Version.1)"></a>Base4BigData(Version.1)</h3><h4 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h4><p>MapReduce产生的灵感来源于2004年Google发表的《MapReduce》论文中的大数据计算模型，用于大规模数据集（TB甚至PB级）的并行计算，利用分治策略，将计算过程分两个阶段，Map阶段和Reduce阶段，可谓是第一代大数据分布式计算引擎，为后来各类优秀的大数据计算引擎的出现提供了基础和可行性。</p><h5 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h5><p>MapReduce 1.x架构如下：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/640" alt="图片"></p><ol><li>客户端向<code>JobTracker</code>提交任务</li><li><code>JobTraker</code>将任务拆解为多个子任务，分配给<code>TaskTracker</code>执行</li><li><code>TaskTracker</code>定时与<code>JobTracker</code>保持心跳，汇报任务执行情况</li></ol><p>存在的问题：</p><ul><li>单点故障：一旦JobTracker出现故障，会导致任务无法提交和正常执行</li><li>JobTracker负载高：所有的任务的提交和分配以及资源管理都是由JobTracker控制，压力过于集中</li><li>场景有限制：只能运行MapReduce作业，可兼容性差</li></ul><p>为了解决MR v1的问题，MapReduce v2引入了资源管理器YARN (Yet Another Resource Negotiator)，即新一代的MapReduce 2.0。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230094755.png"></p><p>YARN中的重要角色及功能：</p><ol><li><p><strong>ResourceManager</strong>：资源管理节点（RM），对应MR v1的JobTracker</p></li><li><ol><li>负责处理来自客户端的提交的Job</li><li>启动Application Master管理任务</li><li>监控Application Master状态</li><li>为NodeManager分配资源（CPU、内存、磁盘、网络）</li></ol></li><li><p><strong>NodeManager</strong>：工作节点（NM），对应MR v1的TaskTracker</p></li><li><ol><li>管理节点container任务资源和运行情况</li><li>与ResourceManager保持通信，汇报自身的状态</li></ol></li><li><p><strong>Application Master</strong>：任务管理服务（AM），其实就是ResourceManager的小弟</p></li><li><ol><li>负责检查集群资源，申请mr程序所需资源</li><li>分配任务到相应的container容器执行</li><li>监控任务执行状态并向ResourceManager汇报任务执行情况</li></ol></li><li><p><strong>Container</strong>：YARN资源抽象，封装了节点上的资源，如内存、CPU、磁盘等</p></li></ol><p>YARN的优势：</p><ol><li>ResourceManager支持HA，解决了JobTracker单点故障的问题，提高集群可用性</li><li>实现资源管理和job管理分离，解决了JobTracker负载高的难题</li><li>提供Application Master负责监控所有的任务，解决了JobTracker集中管理监控的压力</li><li>高扩展性，不仅可以跑mr任务，还支持spark作业以及其他计算引擎任务</li><li>提高了资源的利用率</li></ol><h5 id="MapReduce核心计算阶段"><a href="#MapReduce核心计算阶段" class="headerlink" title="MapReduce核心计算阶段"></a>MapReduce核心计算阶段</h5><p>Mapper阶段：负责数据 的载入、解析、转换和过滤，map任务的输出被称为中间键和中间值 </p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230095256.png"></p><p>Reducer阶段：负责处理map任务输出结果，对map任务处理完的结果集进行排序、局部聚合计算再汇总结果</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230095337.png"></p><h5 id="MapReduce为什么慢？"><a href="#MapReduce为什么慢？" class="headerlink" title="MapReduce为什么慢？"></a>MapReduce为什么慢？</h5><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230095416.png"></p><ul><li>MapReduce是基于磁盘数据进行计算的</li><li>Shuffle过程进行一系列分区、排序，耗费大量时间</li><li>map计算结果频繁落盘</li><li>reduce任务通过磁盘获取数据，占用IO</li><li>spill会会产生大量的小文件，极大占用集群的资源</li><li>容错性差，错了就重头来过</li><li>MapReduce抽象层次低，只有map和reduce两种，处理数据效率较低</li></ul><p>因此MapReduce只适用于处理大规模离线数据，延时高。MapReduce的局限性推动了计算引擎技术的革新，Spark的出现是为了解决MapReduce计算慢的问题，随着数据量的指数增长，对数据处理效率有了更高的要求，我们需要在更短的时间内得到正确的结果。</p><h4 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h4><p>Apache Spark是用于大规模数据处理的统一分析计算引擎，最初诞生于加州大学伯克利分校的AMP Lab实验室。基于内存进行并行计算，通过使用最先进的DAG调度器、查询优化器和物理执行引擎，实现了批处理和流处理的高性能，与Hadoop MapReduce相比，运行在内存中的计算速度要快上100倍（实际上或许没有快这么多），但是可见spark是要比Hadoop MapReduce计算能力更强的计算引擎。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230095750.png"></p><h5 id="组件角色"><a href="#组件角色" class="headerlink" title="组件角色"></a>组件角色</h5><p>Spark由Spark Core、Spark SQL、Spark Streaming、MLib和GraphX四大组件构成 .</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230095825.png"></p><p>角色说明：</p><ul><li>Spark Core：spark的核心，将数据抽象为弹性分布式数据集（RDD），提供了分布式任务调度，RPC通信、序列化和压缩等特性，是内存计算的框架，用于离线计算</li><li>Spark SQL：基于Spark Core之上用于结构化数据建模和数据处理组件，实现交互式查询</li><li>Spark Streaming：利用Spark Core快速调度能力进行流式计算</li><li>MLib：是Spark上分布式机器学习框架，提供了大量的算法</li><li>GraphX：是Spark上的分布式图形处理框架，能进行高效的图计算</li></ul><h5 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h5><p>Spark是一个典型的master/slave主从架构，基于内存计算引擎，提供了多种缓存机制，将RDD 缓存到内存或者磁盘中，这种机制使得Spark可以进行迭代计算和数据共享，从而减少数据读取的IO开销，架构如下：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230100453.png"></p><ul><li><strong>Driver</strong>：初始化Spark运行环境，创建SparkContext上下文环境，是用户程序的入口，即main() 方法</li><li><strong>Cluster Manager</strong>：资源管理器，目前支持Standalone、YARN、Mesos和Kubernetes这几种模式，在Standalone模式中，Cluster Manager即为Master节点，控制整个集群</li><li><strong>Worker</strong>：spark计算节点，负责计算任务的管理，为task分配并启动Executor，定时向Cluster Manager汇报任务执行情况</li><li><strong>Executor</strong>：Spark Task工作的容器，是用户程序在worker节点上的一个进程，运行计算任务，负责数据的读取和写入，缓存中间数据</li></ul><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230100533.png"></p><ol><li>Driver驱动程序会初始化<code>SparkContext</code></li><li>初始化过程中会启动<code>DAGScheduler</code>和<code>TaskScheduler</code></li><li><code>TaskScheduler</code>通过后台进程向Master注册用户程序</li><li>Master收到注册请求之后会通知Worker为用户程序启动多个Executor容器</li><li>Executor反向<code>SparkContext</code>注册</li><li><code>SparkContext</code>将应用程序发给Executor</li><li><code>SparkContext</code>完成初始化，构建DAG，创建Job并且根据action操作划分Stage，形成<code>TaskSet</code>发送给<code>TaskScheduler</code>，最后发给Executor执行</li><li>运行完释放资源</li></ol><h5 id="Spark-为什么比MapReduce快"><a href="#Spark-为什么比MapReduce快" class="headerlink" title="Spark 为什么比MapReduce快"></a>Spark 为什么比MapReduce快</h5><ul><li>Spark相对于MapReduce减少了磁盘IO，没有太多中间结果落盘</li><li>Spark采用了多线程模型，基于线程池复用降低task线程的开销</li><li>spark提供了多种缓存策略，避免了重复计算</li><li>灵活的内存管理策略</li><li>Spark的DAG（有向无环图）算法</li><li>提供丰富的抽象方法，MapReduce只有map和reduce两种抽象</li><li>缓存和checkpoint，通过lineage实现高度容错性</li></ul><p>以上列举了spark比MapReduce快的部分特性，Spark的出现逐步取代了MapReduce成为新一代离线计算引擎的最佳选择，不仅如此，spark还提供了Spark Streaming组件作为流式计算引擎。</p><h4 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h4><p>Spark Streaming是Spark Core API的扩展，支持实时数据流的可伸缩、高吞吐量、容错流处理。支持多种数据源，数据可以从Kafka、Flume、HDFS、S3、Kinesis或TCP套接字等许多来源获取，并可以使用复杂的算法处理，这些算法由map、reduce、join和window等高级函数表达。最后，可以将处理过的数据推送到文件系统、数据库和实时仪表板中。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230102906.png"></p><h5 id="工作模型"><a href="#工作模型" class="headerlink" title="工作模型"></a>工作模型</h5><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230103446.png" alt="image-20201230103445976"></p><p>Spark Streaming基于micro batch方式的计算和处理流数据，提供了称为离散流或DStream的高级抽象，它表示连续的数据流。将接收到的数据流切分为多个独立的DStream，本质上也是一系列RDD，通过spark计算引擎进行计算。</p><h5 id="DStreams（Discretized-Streams）"><a href="#DStreams（Discretized-Streams）" class="headerlink" title="DStreams（Discretized Streams）"></a>DStreams（Discretized Streams）</h5><p>离散数据流是Spark Streaming提供的基本抽象，将待处理数据转变为连续不断的数据流，可以是外部数据源转换而来，也可以通过内部流之间的转换生成，从DStream的内部流模型可以看到Dstream就是由一系列的RDD组成。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230103618.png" alt="image-20201230103618209"></p><p>实际上，Dstream执行的操作都会转换为对底层RDD的操作。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230103652.png" alt="v"></p><p>Spark Streaming是怎么实现数据实时计算的呢？</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230103754.png" alt="image-20201230103754154"></p><p>当spark Streaming接收到数据后，会将数据流切分成多个批次，形成有界的数据集，设置时间间隔，当不同批次的数据进入窗口后会触发计算机制，通过Spark Core进行一系列tranformation和action操作，因为划分批次之后的数据比较小，实时计算得出结果。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230103843.png" alt="图片"></p><h5 id="为什么要用Spark-Streaming呢？"><a href="#为什么要用Spark-Streaming呢？" class="headerlink" title="为什么要用Spark Streaming呢？"></a>为什么要用Spark Streaming呢？</h5><p>从数据的边界来说，我们可以把数据分为有界数据和无界数据。顾名思义，有界数据是有范围的，一般来说与时间是强关联的，以历史数据最为典型。而无界数据就是难以限定范围的数据，会持续不断发生变化，最常见的场景就是实时数据流，看不到数据的尽头，一直在发生。</p><p>MapReduce和Spark SQL等框架只能进行离线计算，无法满足实时性要求高的业务场景，如购买商品后进行实时推荐、实时交易业务等等。而spark Streaming巧妙地将数据细分为多个微小的批次，依赖于spark计算引擎能做到准实时计算，不是真正意义上的实时计算，尽管如此，spark Streaming还是得到了业界的认可和广泛应用。</p><p>Spark Streaming优势：</p><ul><li>实时性：Spark Streaming 是一个实时计算框架，微批处理数据，延迟可以控制到秒级</li><li>高容错性：Spark Streaming底层依赖RDD lineage特性、缓存机制、checkpoint机制以及WAL预写日志，可以实现高度容错</li><li>高吞吐：相对于实时计算框架Storm吞吐量更高</li><li>一体化：依托spark生态，不仅能进行实时计算，还能应用于机器学习和Spark SQL场景</li></ul><p>对于大部分企业来说，秒级的延时是可以接受的，而且一个大数据项目通常会包含离线计算、交互式查询、数据分析、实时计算等模块，Spark Streaming毫无疑问是很好的选择。</p><h4 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h4><p>storm是一个真正的实时流计算引擎，相对于Spark Streaming的微批处理，storm则是来一条数据计算一条数据，延时可以控制到毫秒级。</p><h5 id="Storm架构"><a href="#Storm架构" class="headerlink" title="Storm架构"></a>Storm架构</h5><p>storm的架构与Hadoop相似，都是master/slave主从架构。</p><table><thead><tr><th>成员</th><th>Storm</th><th>Hadoop</th></tr></thead><tbody><tr><td>主节点</td><td>Nimbus</td><td>JobTracker</td></tr><tr><td>从节点</td><td>Supervisor</td><td>TaskTracker</td></tr><tr><td>计算模型</td><td>Spout / Bolt</td><td>Map / Reduce</td></tr><tr><td>应用程序</td><td>Topology</td><td>Job</td></tr><tr><td>工作进程</td><td>Worker</td><td>Child</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230104329.png" alt="图片"></p><p>Nimbus：master节点，负责提交任务，分配到supervisor的worker上，运行Topology上的Spout/Bolt任务</p><p>Zookeeper：协调节点，负责管理storm集群的元数据信息，比如heartbeat信息、集群状态和配置信息以及Nimbus分配的任务信息等</p><p>Supervisor：slave节点，负责管理运行在supervisor节点上的worker进程</p><h5 id="Storm工作流程"><a href="#Storm工作流程" class="headerlink" title="Storm工作流程"></a>Storm工作流程</h5><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230104612.png" alt="图片"></p><ol><li>客户端提交topology任务到Nimbus节点</li><li>Nimbus主节点将任务提交到zookeeper集群管理</li><li>Supervisor节点从Zookeeper集群获取任务信息</li><li>启动worker进程开始执行任务</li></ol><h5 id="Storm-Vs-Spark-Streaming"><a href="#Storm-Vs-Spark-Streaming" class="headerlink" title="Storm Vs Spark Streaming"></a>Storm Vs Spark Streaming</h5><p>用一个生动形象的生活场景来比喻Storm和Spark Streaming，Storm好比是手扶电梯，一直在运行，来一个人都会将他带上/下楼，而Spark Streaming更像是升降电梯，要装满一批人才开始启动。</p><ul><li>storm可以实现毫米级计算响应 VS Spark Streaming只能做到秒级响应</li><li>Storm吞吐量低 VS Spark Streaming吞吐量高</li></ul><table><thead><tr><th>Item</th><th>Storm</th><th>Spark Streaming</th></tr></thead><tbody><tr><td>Streaming Model</td><td>Native</td><td>Micro-Batch</td></tr><tr><td>Guarantees</td><td>At-Least-Once</td><td>Exactly-Once</td></tr><tr><td>Back Pressure</td><td>No</td><td>Yes</td></tr><tr><td>Latency</td><td>Very Low</td><td>Low</td></tr><tr><td>Throughput</td><td>Low</td><td>High</td></tr><tr><td>Fault Tolerance</td><td>Record ACKs</td><td>RDD Based CheckPoint</td></tr><tr><td>Stateful</td><td>No</td><td>Yes（DStream）</td></tr></tbody></table><h4 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h4><p>Apache Flink是一个分布式处理引擎，用于在<em>无边界和有边界</em>数据流上进行有状态的计算。Flink能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。现在Flink也是主流的实时流计算框架并且同时支持批处理，支持基于有状态的事件时间进行计算，成为大数据计算引擎的领头羊，大有盖过Spark风头之势。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230104908.png" alt="图片"></p><p>擅长处理有界（bounded）数据和无界（unbounded）数据，有界数据通常指的是离线历史数据，用于批处理，而无界数据指数据流有定义数据产生的开始，却无法定义数据何时结束，因此无界数据流通常说的就是实时流，用于实时计算。</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230104939.png" alt="图片"></p><h5 id="架构-2"><a href="#架构-2" class="headerlink" title="架构"></a>架构</h5><p>Flink和Spark一样，也是主从架构，由JobManager和TaskManager组成</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230105021.png" alt="图片"></p><p>JobManager：主节点，负责处理客户端提交的Job，管理Job状态信息，调度分配集群任务，对完成的 Task 或执行失败做出反应、协调 checkpoint、并且协调从失败中恢复</p><p>TaskManager：从节点，负责管理节点上的资源，向JobManager汇报集群状态，执行计算JobManager分配的Task</p><p>Flink工作调度</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20201230105309.png" alt="img"></p><ol><li>用户提交Flink程序时，client会对程序进行预处理，构建Dataflow graph，封装成Job提交到JobManager</li><li>JobManager接收到client提交的Job，获取并管理Job的基本信息，构建DAG执行计划，通过Scheduler调度任务并分配到对应的TaskManager节点</li><li>TaskManager向JobManager注册，JobManager将Job分配到TaskManager执行，每个Task Slot代表着用来执行Task的资源，包括了内存、cpu等</li><li>TaskManager与JobManager保持心跳，定时汇报节点资源情况以及任务执行情况</li><li>JobManager将将任务执行的状态和结果反馈给客户端</li></ol><h5 id="Flink的优势"><a href="#Flink的优势" class="headerlink" title="Flink的优势"></a>Flink的优势</h5><ul><li>Flink支持实时计算，且基于内存管理，性能优越</li><li>具有高吞吐、低延迟、高性能的流处理特性</li><li>Flink与Hadoop生态高度融合</li><li>高度灵活的时间窗口语义</li><li>流批一体化，同时支持批处理和流计算</li><li>高容错，基于分布式快照（snapshot）和checkpoint检查点机制</li><li>具有反压（Backpressure）功能</li><li>支持有状态计算的Exactly-once语义</li><li>可以进行机器学习处理（FlinkML）、图分析（Gelly）、关系数据处理（FLink SQL）以及复杂事件处理（CEP）</li></ul><h4 id="Flink-VS-Storm-VS-Spark-Streaming"><a href="#Flink-VS-Storm-VS-Spark-Streaming" class="headerlink" title="Flink VS Storm VS Spark Streaming"></a>Flink VS Storm VS Spark Streaming</h4><table><thead><tr><th>Item</th><th>Flink</th><th>Storm</th><th>Spark Streaming</th></tr></thead><tbody><tr><td>Streaming Model</td><td>Native</td><td>Native</td><td>Micro-Batch</td></tr><tr><td>Guarantees</td><td>Exactly-Once</td><td>At-Least-Once</td><td>Exactly-Once</td></tr><tr><td>Back Pressure</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>Latency</td><td>Medium</td><td>Very Low</td><td>Low</td></tr><tr><td>Throughput</td><td>High</td><td>Low</td><td>High</td></tr><tr><td>Fault Tolerance</td><td>Checkouting</td><td>Record ACKs</td><td>RDD Based CheckPoint</td></tr><tr><td>Stateful</td><td>Yes（Operators）</td><td>No</td><td>Yes（DStream）</td></tr></tbody></table><h3 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h3><script src="https://gist.github.com/FlyMeToTheMars/43f8f342d907d1eba39d270324b3653f.js"></script>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gjq5gjm1gmj22541j9kjm.jpg&quot; alt=&quot;IMG_20201015_173131.jpg&quot; style=&quot;zoom: 25%;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;笨猫不如烂笔头&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Interview" scheme="http://yoursite.com/categories/Interview/"/>
    
    
    <category term="PICKS" scheme="http://yoursite.com/tags/PICKS/"/>
    
  </entry>
  
  <entry>
    <title>碎碎念</title>
    <link href="http://yoursite.com/2050/10/14/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>http://yoursite.com/2050/10/14/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</id>
    <published>2050-10-13T22:31:42.000Z</published>
    <updated>2021-02-09T13:07:11.437Z</updated>
    
    <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjq55jd0gnj20u0140abo.jpg" alt="mmexport1602753647068.jpg" style="zoom: 33%;"><blockquote><p>我的戒烟日记    My Quit Smoking Diary</p></blockquote><a id="more"></a> <h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><blockquote><p>如果没有烟草，那么肺癌会是一种罕见病</p></blockquote><blockquote><p>Day 0    Quit Smoking Day</p><p>Day 1    Quit Smoking Day</p><p>Day 2    QuitSmoking Day</p><p>Day 3    QuitSmkoing Day</p><p>Day 4    QuitSmkoing Day</p><p>Day 5    QuitSmkoing Day</p><p>Day 6    QuitSmkoing Day</p><p>Day 7    QuitSmkoing Day</p><p>Day 8    QuitSmkoing Day    有一点点想吸的欲望</p><p>Day 9    QuitSmkoing Day    恢复正常</p><p>Day10   QuitSmkoing Day    异常艰难的一天，我寻思着要来打卡，总算顶住了 《论打卡的重要性》</p><hr><p>在 Day 10 -&gt; Day 11的过程中因为不知明原因抽了煊赫门，重新计数。</p><hr><p>Day 0    QuitSmkoing Day    开天辟地第一天</p><p>Day 1    QuitSmkoing Day    </p><p>Day 2    QuitSmkoing Day    失败 拉闸了 烂了</p><hr><p>Day 0    QuitSmoking Day    # Remake</p><p>Day 1    QuitSmoking Day    My Last Chance</p><p>Day 2    QuitSmoking Day    My Last Chance</p><p>Day 3    QuitSmoking Day</p><p>Day 4    QuitSmoking Day</p><p>Day 5    QuitSmoking Day</p><p>Day 6    QuitSmoking Day</p><p>Day 7    QuitSmoking Day</p><p>Day 8    QuitSmoking Day</p><p>Day 9    QuitSmoking Day</p><p>Day 10  QuitSmoking Day</p><p>Day 11  QuitSmoking Day</p><p>Day 12  QuitSmoking Day</p><p>Day 13  QuitSmoking Day</p><p>Day 14  QuitSmoking Day</p><p>Day 15  QuitSmoking Day</p><p>Day 16  QuitSmoking Day</p><p>Day 17  QuitSmoking Day    傻逼章鱼骗我抽烟 我直接过嘴烟</p><p>Day 18  QuitSmoking Day</p><p>Day 19 QuitSmoking Day</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gjq55jd0gnj20u0140abo.jpg&quot; alt=&quot;mmexport1602753647068.jpg&quot; style=&quot;zoom: 33%;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;我的戒烟日记    My Quit Smoking Diary&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="碎碎念" scheme="http://yoursite.com/tags/碎碎念/"/>
    
  </entry>
  
  <entry>
    <title>Blog Note</title>
    <link href="http://yoursite.com/2021/01/28/Blog-Note/"/>
    <id>http://yoursite.com/2021/01/28/Blog-Note/</id>
    <published>2021-01-28T07:55:10.000Z</published>
    <updated>2021-01-28T08:31:46.552Z</updated>
    
    <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210128160226.jpg" style="zoom: 50%;"><blockquote><p>Blog Record</p></blockquote><blockquote><p>目的: 消化优秀的博文</p></blockquote><a id="more"></a> <h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><p><a href="https://medium.com/disney-streaming/a-step-by-step-guide-for-debugging-memory-leaks-in-spark-applications-e0dd05118958" target="_blank" rel="noopener">A step-by-step guide for debugging memory leaks in Spark Applications</a></p><blockquote><p>Spark内存调优Blog，特点就是非常详细，Disney有个Spark任务，每三天重启一次，从executor log查起，发现了存在两种OOM，一个是G1CG引起的，使用了Spark的配置参数<code>spark.executor.extraJavaOptions: -XX:+UseG1GC</code>解决了其中的一个OOM问题，然后又详细介绍了如何排查另一个OOM，使用Ganglia进行内存监控，得到了两个结论：</p><blockquote><ol><li><p>This was a stateful job so maybe we were not clearing out the <em>state</em> over time.</p></li><li><p>A memory leak could have occurred.</p></li></ol></blockquote><p>然后通过监控Streaming Metrics，得到一个结论:</p><blockquote><p>The conclusion: a memory leak occurred, and we needed to find it. To do so, we enabled the heap dump to see what is occupying so much memory.</p></blockquote><p>后续通过堆内存转储</p><blockquote><p>spark.executor.extraJavaOptions: -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/dbfs/heapDumps</p></blockquote><p>然后分别从SparkUI界面和YourKit分析 Heap Dumps，发现里面莫名其妙的HashMap特别多，不符合逻辑，然后针对这个问题</p><blockquote><p>A quick Google search and code analysis gave us our answer: we were not closing the connection correctly. The same issue has also been addressed on the <a href="https://github.com/aws/aws-sdk-java-v2/issues/1679" target="_blank" rel="noopener">aws-sdk Github issues</a>.</p></blockquote><p>哈哈 原来连Disney的工程师也是 Google 来的答案，我还以为要有什么顶级操作。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210128160226.jpg&quot; style=&quot;zoom: 50%;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;Blog Record&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;目的: 消化优秀的博文&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Blog" scheme="http://yoursite.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Dawn Dew-light Collected at Dusk 4 Python</title>
    <link href="http://yoursite.com/2021/01/14/Dawn-Dew-light-Collected-at-Dusk-4-Python/"/>
    <id>http://yoursite.com/2021/01/14/Dawn-Dew-light-Collected-at-Dusk-4-Python/</id>
    <published>2021-01-14T03:01:34.000Z</published>
    <updated>2021-01-14T03:16:43.621Z</updated>
    
    <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210114111428.png" style="zoom: 25%;"><blockquote><p>人生苦短，我选Python</p></blockquote><a id="more"></a> <hr>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210114111428.png&quot; style=&quot;zoom: 25%;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;人生苦短，我选Python&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Tips4Python" scheme="http://yoursite.com/tags/Tips4Python/"/>
    
  </entry>
  
  <entry>
    <title>Dawn Dew-light Collected at Dusk 4 Scala</title>
    <link href="http://yoursite.com/2020/12/16/Dawn-Dew-light-Collected-at-Dusk-4-Scala/"/>
    <id>http://yoursite.com/2020/12/16/Dawn-Dew-light-Collected-at-Dusk-4-Scala/</id>
    <published>2020-12-16T09:24:43.000Z</published>
    <updated>2021-01-28T08:54:18.645Z</updated>
    
    <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glptqgll6ej2098048a9w.jpg" alt="undefined" style="zoom: 150%;"><a id="more"></a> <h1 id="Scala-类型"><a href="#Scala-类型" class="headerlink" title="Scala 类型"></a>Scala 类型</h1><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gls6d1a89cj20of0gtta1.jpg" alt="1.png"></p><p>Scala中，所有的值都是类对象，而所有的类，包括值类型，都最终继承自一个统一的根类型Any。统一类型，是Scala的又一大特点。更特别的是，Scala中还定义了几个底层类（Bottom Class），比如Null和Nothing。</p><ol><li><p>Null是所有引用类型的子类型，而Nothing是所有类型的子类型。Null类只有一个实例对象，null，类似于Java中的null引用。null可以赋值给任意引用类型，但是不能赋值给值类型。</p></li><li><p>Nothing，可以作为没有正常返回值的方法的返回类型，非常直观的告诉你这个方法不会正常返回，而且由于Nothing是其他任意类型的子类，他还能跟要求返回值的方法兼容。</p></li><li><p>Unit类型用来标识过程，也就是没有明确返回值的函数。 由此可见，Unit类似于Java里的void。Unit只有一个实例，()，这个实例也没有实质的意义。</p></li></ol><h1 id="Option-Some-None"><a href="#Option-Some-None" class="headerlink" title="Option Some None"></a>Option Some None</h1><p><strong>设计目的</strong>：避免使用null</p><p>大多数语言都有一个特殊的关键字或者对象来表示一个对象引用的是“无”，在Java，它是null。在Java 里，null 是一个关键字，不是一个对象，所以对它调用任何方法都是非法的。但是这对语言设计者来说是一件令人疑惑的选择。为什么要在程序员希望返回一个对象的时候返回一个关键字呢？</p><p><strong>Scala鼓励在变量和函数返回值可能不会引用任何值的时候使用Option类型。在没有值的时候，使用None，这是Option的一个子类。如果有值可以引用，就使用Some来包含这个值。Some也是Option的子类。</strong><br> None被声明为一个对象，而不是一个类，因为我们只需要它的一个实例。这样，它多少有点像null关键字，但它却是一个实实在在的，有方法的对象。</p><p>Option类型的值通常作为Scala集合类型（List,Map等）操作的返回类型。比如Map的get方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> capitals = <span class="type">Map</span>(<span class="string">"France"</span>-&gt;<span class="string">"Paris"</span>, <span class="string">"Japan"</span>-&gt;<span class="string">"Tokyo"</span>, <span class="string">"China"</span>-&gt;<span class="string">"Beijing"</span>)</span><br><span class="line">capitals: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(<span class="type">France</span> -&gt; <span class="type">Paris</span>, <span class="type">Japan</span> -&gt; <span class="type">Tokyo</span>, <span class="type">China</span> -&gt; <span class="type">Beijing</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; capitals get <span class="string">"France"</span></span><br><span class="line">res0: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Some</span>(<span class="type">Paris</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; capitals get <span class="string">"North Pole"</span></span><br><span class="line">res1: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br></pre></td></tr></table></figure><p>Option有两个子类别，Some和None。当程序回传Some的时候，代表这个函式成功地给了你一个String，而你可以透过get()函数拿到那个String，如果程序返回的是None，则代表没有字符串可以给你。</p><p>在返回None，也就是没有String给你的时候，如果你还硬要调用get()来取得 String 的话，Scala一样是会抛出一个<code>NoSuchElementException</code>异常给你的。</p><p>我们也可以选用另外一个方法，<code>getOrElse</code>。这个方法在这个Option是Some的实例时返回对应的值，而在是None的实例时返回传入的参数。换句话说，传入<code>getOrElse</code>的参数实际上是默认返回值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; capitals get <span class="string">"North Pole"</span> get</span><br><span class="line">warning: there was one feature warning; re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</span><br><span class="line">java.util.<span class="type">NoSuchElementException</span>: <span class="type">None</span>.get</span><br><span class="line">  at scala.<span class="type">None</span>$.get(<span class="type">Option</span>.scala:<span class="number">347</span>)</span><br><span class="line">  at scala.<span class="type">None</span>$.get(<span class="type">Option</span>.scala:<span class="number">345</span>)</span><br><span class="line">  ... <span class="number">33</span> elided</span><br><span class="line"></span><br><span class="line">scala&gt; capitals get <span class="string">"France"</span> get</span><br><span class="line">warning: there was one feature warning; re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</span><br><span class="line">res3: <span class="type">String</span> = <span class="type">Paris</span></span><br><span class="line"></span><br><span class="line">scala&gt; (capitals get <span class="string">"North Pole"</span>) getOrElse <span class="string">"Oops"</span></span><br><span class="line">res7: <span class="type">String</span> = <span class="type">Oops</span></span><br><span class="line"></span><br><span class="line">scala&gt; capitals get <span class="string">"France"</span> getOrElse <span class="string">"Oops"</span></span><br><span class="line">res8: <span class="type">String</span> = <span class="type">Paris</span></span><br></pre></td></tr></table></figure><p>通过模式匹配分离可选值，如果匹配的值是Some的话，将Some里的值抽出赋给x变量：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showCapital</span></span>(x: <span class="type">Option</span>[<span class="type">String</span>]) = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(s) =&gt; s</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="string">"?"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Scala里Option[T]实际上是一个容器，就像数组或是List一样，你可以把他看成是一个可能有零到一个元素的List。<br> 当你的Option里面有东西的时候，这个List的长度是1（也就是 Some），而当你的Option里没有东西的时候，它的长度是0（也就是 None）。</p><h2 id="Tips4For-循环"><a href="#Tips4For-循环" class="headerlink" title="Tips4For 循环"></a>Tips4For 循环</h2><p>如果我们把Option当成一般的List来用，并且用一个for循环来走访这个Option的时候，如果Option是None，那这个for循环里的程序代码自然不会执行，于是我们就达到了<strong>不用检查Option是否为None这件事</strong>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> map1 = <span class="type">Map</span>(<span class="string">"key1"</span> -&gt; <span class="string">"value1"</span>)</span><br><span class="line">map1: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(key1 -&gt; value1)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> value1 = map1.get(<span class="string">"key1"</span>)</span><br><span class="line">value1: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Some</span>(value1)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> value2 = map1.get(<span class="string">"key2"</span>)</span><br><span class="line">value2: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">printContentLength</span></span>(x: <span class="type">Option</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">     |   <span class="keyword">for</span> (c &lt;- x)&#123;</span><br><span class="line">     |     println(c.length)</span><br><span class="line">     |   &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">printContentLength: (x: <span class="type">Option</span>[<span class="type">String</span>])<span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">scala&gt; printContentLength(value1)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"></span><br><span class="line">scala&gt; printContentLength(value2)</span><br></pre></td></tr></table></figure><h2 id="Tips4map操作"><a href="#Tips4map操作" class="headerlink" title="Tips4map操作"></a>Tips4map操作</h2><p>在函数式编程中有一个核心的概念之一是转换，所以大部份支持函数式编程语言，都支持一种叫map()的动作，这个动作是可以帮你把某个容器的内容，套上一些动作之后，变成另一个新的容器。<br> 现在我们考虑如何用Option的map方法实现<code>length: xxx</code>的输出形式：</p><blockquote><p>先算出 Option 容器内字符串的长度<br> 然后在长度前面加上 “length: “ 字样<br> 最后把容器走访一次，印出容器内的东西</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; value1.map(_.length).map(<span class="string">"length: "</span> + _).foreach(println)</span><br><span class="line">length: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">scala&gt; value1.map(<span class="string">"length: "</span> + _.length).foreach(println)</span><br><span class="line">length: <span class="number">6</span></span><br></pre></td></tr></table></figure><p>透过这样「转换」的方法，我们一样可以达成想要的效果，而且同样不用去做「是否为 None」的判断。</p><h1 id="Scala-Java-Map"><a href="#Scala-Java-Map" class="headerlink" title="Scala Java Map"></a>Scala Java Map</h1><h2 id="Scala内部Map转换："><a href="#Scala内部Map转换：" class="headerlink" title="Scala内部Map转换："></a>Scala内部Map转换：</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> im: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = scala.collection.immutable.<span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="string">"one"</span>,<span class="number">2</span>-&gt;<span class="string">"two"</span>) <span class="comment">//不可变map</span></span><br><span class="line">  <span class="keyword">val</span> imh: <span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">String</span>] = scala.collection.immutable.<span class="type">HashMap</span>(<span class="number">1</span>-&gt;<span class="string">"one"</span>,<span class="number">2</span>-&gt;<span class="string">"two"</span>) <span class="comment">//不可变hashmap</span></span><br><span class="line">  <span class="keyword">val</span> mu: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = scala.collection.mutable.<span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="string">"one"</span>,<span class="number">2</span>-&gt;<span class="string">"two"</span>) <span class="comment">//可变map</span></span><br><span class="line">  println(im,manOf(im))</span><br><span class="line">  println(imh,manOf(imh))</span><br><span class="line">  println(mu,manOf(mu))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mutable.Map 2 immutable.Map</span></span><br><span class="line">  <span class="keyword">val</span> mui: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = mu.toMap</span><br><span class="line">  println(mui,manOf(mui))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// immutable.Map 2 mutable.Map</span></span><br><span class="line">  <span class="keyword">val</span> immu: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = scala.collection.mutable.<span class="type">Map</span>(im.toSeq: _*)</span><br><span class="line">  println(immu,manOf(immu))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> imhmu: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = scala.collection.mutable.<span class="type">Map</span>(imh.toSeq: _*)</span><br><span class="line">  println(imhmu,manOf(imhmu))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(Map(1 -&gt; one, 2 -&gt; two),scala.collection.immutable.Map[Int, java.lang.String])</span><br><span class="line">(Map(1 -&gt; one, 2 -&gt; two),scala.collection.immutable.HashMap[Int, java.lang.String])</span><br><span class="line">(Map(2 -&gt; two, 1 -&gt; one),scala.collection.mutable.Map[Int, java.lang.String])</span><br><span class="line"></span><br><span class="line">(Map(2 -&gt; two, 1 -&gt; one),scala.collection.immutable.Map[Int, java.lang.String])</span><br><span class="line"></span><br><span class="line">(Map(2 -&gt; two, 1 -&gt; one),scala.collection.mutable.Map[Int, java.lang.String])</span><br><span class="line">(Map(2 -&gt; two, 1 -&gt; one),scala.collection.mutable.Map[Int, java.lang.String])</span><br></pre></td></tr></table></figure><h2 id="Java中-把Java-Map-转化成-Scala-Map"><a href="#Java中-把Java-Map-转化成-Scala-Map" class="headerlink" title="Java中 把Java Map 转化成 Scala Map"></a>Java中 把Java Map 转化成 Scala Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put(<span class="string">"1"</span>, <span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    scala.collection.mutable.Map&lt;String,String&gt; mapTest = JavaConverters.mapAsScalaMapConverter(map).asScala();</span><br><span class="line">    Object objTest = Map$.MODULE$.&lt;String,String&gt;newBuilder().$plus$plus$eq(mapTest.toSeq());</span><br><span class="line">    Object resultTest = ((scala.collection.mutable.Builder) objTest).result();</span><br><span class="line">    scala.collection.immutable.Map&lt;String,String&gt; resultTest2 = (scala.collection.immutable.Map)resultTest;</span><br><span class="line">    System.out.println(resultTest2.keySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微有点鸡肋，代码看不懂，笑</p><h2 id="Scala中的双向转换"><a href="#Scala中的双向转换" class="headerlink" title="Scala中的双向转换"></a>Scala中的双向转换</h2><p>Scala提供了大量的方法来隐式转换所有主要的Java和Scala容器类型。其中提供了如下的双向类型转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator               &lt;=&gt;     java.util.Iterator</span><br><span class="line">Iterator               &lt;=&gt;     java.util.Enumeration</span><br><span class="line">Iterable               &lt;=&gt;     java.lang.Iterable</span><br><span class="line">Iterable               &lt;=&gt;     java.util.Collection</span><br><span class="line">mutable.Buffer         &lt;=&gt;     java.util.List</span><br><span class="line">mutable.Set            &lt;=&gt;     java.util.Set</span><br><span class="line">mutable.Map            &lt;=&gt;     java.util.Map</span><br><span class="line">mutable.ConcurrentMap  &lt;=&gt;     java.util.concurrent.ConcurrentMap</span><br></pre></td></tr></table></figure><p>使用这些转换很简单，只需从JavaConverters对象中import它们即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import collection.JavaConverters._</span><br><span class="line">import collection.JavaConverters._</span><br></pre></td></tr></table></figure><p>import之后，通过扩展方法 asScala 和 asJava 就可以在Scala容器和与之对应的Java容器之间进行隐式转换了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import collection.mutable._</span><br><span class="line">import collection.mutable._</span><br><span class="line"></span><br><span class="line">scala&gt; val jul: java.util.List[Int] = ArrayBuffer(1, 2, 3).asJava</span><br><span class="line">jul: java.util.List[Int] = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">scala&gt; val buf: Seq[Int] = jul.asScala</span><br><span class="line">buf: scala.collection.mutable.Seq[Int] = ArrayBuffer(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; val m: java.util.Map[String, Int] = HashMap(&quot;abc&quot; -&gt; 1, &quot;hello&quot; -&gt; 2).asJava</span><br><span class="line">m: java.util.Map[String,Int] = &#123;abc=1, hello=2&#125;</span><br></pre></td></tr></table></figure><p>还有一些Scala容器类型可以转换成对应的Java类型，但是并没有将相应的Java类型转换成Scala类型的能力，它们是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Seq           =&gt;    java.util.List</span><br><span class="line">mutable.Seq   =&gt;    java.util.List</span><br><span class="line">Set           =&gt;    java.util.Set</span><br><span class="line">Map           =&gt;    java.util.Map</span><br></pre></td></tr></table></figure><p>因为Java并未区分可变容器不可变容器类型，所以，虽然能将<code>scala.immutable.List</code>转换成<code>java.util.List</code>，但所有的修改操作都会抛出“UnsupportedOperationException”。参见下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val jul = List(1, 2, 3).asJava</span><br><span class="line">jul: java.util.List[Int] = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">scala&gt; jul.add(7)</span><br><span class="line">java.lang.UnsupportedOperationException</span><br><span class="line">  at java.util.AbstractList.add(AbstractList.java:148)</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>完整的Java Map =&gt; Scala mutbale Map =&gt; Scala Immutable Map =&gt; Option =&gt; 模式匹配得到结果</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Java Map =&gt; mutable.Map =&gt; Scala Map</span></span><br><span class="line">  <span class="keyword">import</span> scala.collection.<span class="type">JavaConversions</span>._</span><br><span class="line">  <span class="keyword">val</span> javaMap: util.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = <span class="keyword">new</span> util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>]()</span><br><span class="line">  javaMap.put(<span class="string">"1"</span>,<span class="string">"2"</span>)</span><br><span class="line">  <span class="keyword">for</span> (m &lt;- javaMap) &#123;</span><br><span class="line">    println(m)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> scalaMuMap: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = javaMap.asScala</span><br><span class="line">  <span class="comment">// Predef里定义的map类型是一个类型别名，实际类型是immutable.Map</span></span><br><span class="line">  <span class="keyword">val</span> scalaImmuMap: <span class="type">Predef</span>.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = scalaMuMap.toMap</span><br><span class="line">  <span class="keyword">val</span> maybeString: <span class="type">Option</span>[<span class="type">String</span>] = scalaImmuMap.get(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> show = (x: <span class="type">Option</span>[<span class="type">String</span>]) =&gt; x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(str) =&gt; str</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="string">"?"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> str: <span class="type">String</span> = show(maybeString)</span><br><span class="line"></span><br><span class="line">  println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scala-mutable-Map-Test"><a href="#Scala-mutable-Map-Test" class="headerlink" title="Scala mutable Map Test"></a>Scala mutable Map Test</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试可变Map返回值类型 确认是Option</span></span><br><span class="line"><span class="keyword">val</span> muMapTest: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = mutable.<span class="type">Map</span>(<span class="string">"Alice"</span> -&gt; <span class="number">10</span>, <span class="string">"Bob"</span> -&gt; <span class="number">20</span>, <span class="string">"Kotlin"</span> -&gt; <span class="number">30</span>)</span><br><span class="line">muMapTest(<span class="string">"Alice"</span>) = <span class="number">99</span></span><br><span class="line">println(muMapTest(<span class="string">"Alice"</span>))</span><br><span class="line">muMapTest += (<span class="string">"Bob"</span> -&gt; <span class="number">98</span>)</span><br><span class="line">println(muMapTest) <span class="comment">// Map(Bob -&gt; 98, Kotlin -&gt; 30, Alice -&gt; 99)</span></span><br><span class="line">muMapTest -= (<span class="string">"Alice"</span>, <span class="string">"Kotlin"</span>)</span><br><span class="line">println(muMapTest) <span class="comment">// Map(Bob -&gt; 98)</span></span><br><span class="line">println(muMapTest.get(<span class="string">"Bob"</span>)) <span class="comment">// Some(98)</span></span><br></pre></td></tr></table></figure><h2 id="More-4-Scala-Map-Action"><a href="#More-4-Scala-Map-Action" class="headerlink" title="More 4 Scala Map Action"></a>More 4 Scala Map Action</h2><p>map1 ++ map2 (类似于Java Map的 putAll)</p><h1 id="Scala-的-Seq"><a href="#Scala-的-Seq" class="headerlink" title="Scala 的 Seq"></a>Scala 的 Seq</h1><p>Scala的 Seq将是Java的List，Scala 的 List将是Java的 LinkedList。</p><p>Seq是一个trait，它相当于Java的接口，但相当于即将到来的防御者方法。 </p><p>Scala的List是一个抽象类，由Nil和::扩展，这是List的具体实现。</p><p>所以，在Java的List是一个接口，Scala的List是一个实现。</p><p>除此之外，Scala的List是不可变的，这不是LinkedList的情况。事实上，Java没有等价的不可变集合(只读的东西只保证新的对象不能改变，但你仍然可以改变旧的，因此，“只读”一个)。<br>Scala的List是由编译器和库高度优化的，它是函数式编程中的基本数据类型。然而，它有限制，它不足以并行编程。这些天，Vector是一个比List更好的选择，但习惯是很难打破。<br>Seq是一个很好的泛化序列，所以如果你编程到接口，你应该使用它。注意，实际上有三个：collection.Seq，collection.mutable.Seq和collection.immutable.Seq，它是后一个是“默认”导入到范围。<br>还有GenSeq和ParSeq。后面的方法在可能的情况下并行运行，前者是Seq和ParSeq的父代，这是当代码的并行性无关紧要的合适的泛化。它们都是相对新引入的，因此人们不会使用它们。</p><h1 id="Scala-match"><a href="#Scala-match" class="headerlink" title="Scala match"></a>Scala match</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>模式匹配语法中，采用 match 关键字声明，每个分支采用 case 关键字进行声明，当需要匹配时， 会从第一个 case 分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下 一个分支进行判断。如果所有 case 都不匹配，那么会执行 case _ 分支，类似于 Java 中 default 语句。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol><li><p>如果所有 case 都不匹配，那么会执行 case _ 分支，类似于 Java 中 default 语句 </p></li><li><p>如果所有 case 都不匹配，又没有写 case _ 分支，那么会抛出 MatchError </p></li><li><p>每个 case 中，不用 break 语句，自动中断 case </p></li><li><p>可以在 match 中使用其它类型，而不仅仅是字符 </p></li><li><p>=&gt; 等价于 java swtich 的 : </p></li><li><p>=&gt; 后面的代码块到下一个 case， 是作为一个整体执行，可以使用{} 扩起来，也可以不扩</p></li></ol><h2 id="守卫"><a href="#守卫" class="headerlink" title="守卫"></a>守卫</h2><p>如果想要表达匹配某个范围的数据，那么就需要在模式匹配中增加守卫条件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MatchIfDemo01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span> (ch &lt;- <span class="string">"+-3!"</span>) &#123; <span class="comment">//是对"+-3!" 遍历</span></span><br><span class="line">      <span class="keyword">var</span> sign = <span class="number">0</span></span><br><span class="line">      <span class="keyword">var</span> digit = <span class="number">0</span></span><br><span class="line">      ch <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> '+' <span class="keyword">if</span> ch.toString.equals(<span class="string">"3"</span>) =&gt; sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> '-' =&gt; sign = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 说明..</span></span><br><span class="line">        <span class="comment">// 如果 case 后有 条件守卫即 if ,那么这时的 _ 不是表示默认匹配</span></span><br><span class="line">        <span class="comment">// 表示忽略 传入 的 ch</span></span><br><span class="line">        <span class="keyword">case</span> _ <span class="keyword">if</span> ch.toString.equals(<span class="string">"3"</span>) =&gt; digit = <span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> _ <span class="keyword">if</span> (ch &gt; <span class="number">1110</span> || ch &lt; <span class="number">120</span>) =&gt; println(<span class="string">"ch &gt; 10"</span>)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; sign = <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">      println(ch + <span class="string">" "</span> + sign + <span class="string">" "</span> + digit)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码值得一提的是ch是<code>‘+’</code>的时候，第一次匹配会匹配上 第一个判断，因为没有匹配上，所以接下来会匹配第三个，没有匹配上，匹配第四个，匹配上了，直接跳出。</p><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ch = '<span class="type">U</span>'</span><br><span class="line">ch <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> '+' =&gt; println(<span class="string">"ok~"</span>)</span><br><span class="line">  <span class="comment">// 下面 case mychar 含义是 mychar = ch   下面这个case就啥都可以匹配上.这样不好</span></span><br><span class="line">  <span class="keyword">case</span> mychar =&gt; println(<span class="string">"ok~"</span> + mychar)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println (<span class="string">"ok~~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> ch1 = '+'</span><br><span class="line"><span class="comment">//match 是一个表达式，因此可以有返回值</span></span><br><span class="line"><span class="comment">//返回值就是匹配到的代码块的最后一句话的值</span></span><br><span class="line"><span class="keyword">val</span> res1 = ch1 <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> '+' =&gt; &#123;</span><br><span class="line">    print(<span class="string">"使用这种方式,case里的最后一行就会返回结果给变量res,这种方式好,"</span>)</span><br><span class="line">    ch1 + <span class="string">" hello "</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 下面 case mychar 含义是 mychar = ch</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println (<span class="string">"ok~~"</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"res="</span> + res1)</span><br></pre></td></tr></table></figure><h2 id="类型匹配"><a href="#类型匹配" class="headerlink" title="类型匹配"></a>类型匹配</h2><p>可以匹配 对象的任意类型，这样做避免了使用 isInstanceOf 和 asInstanceOf 方法</p><p>类型匹配注意事项 </p><ol><li><p>Map[String, Int] 和 Map[Int, String]是两种不同的类型，其它类推。 </p></li><li><p>在进行类型匹配时，编译器会预先检测是否有可能的匹配，如果没有则报错.</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> obj = <span class="number">10</span></span><br><span class="line">    obj <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> a:<span class="type">Int</span> =&gt; a</span><br><span class="line"><span class="comment">//        编译报错</span></span><br><span class="line"><span class="comment">//      case b:Map[String, Int] =&gt; "map集合"</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="string">"啥也不是"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果 case _ 出现在 match 中间，则表示隐藏变量名，即不使用,而不是表示默认匹配</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">//说明 obj 实例的类型 根据 a 的值来返回</span></span><br><span class="line"><span class="keyword">val</span> obj1: <span class="type">Any</span> = <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) <span class="string">"2"</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>) <span class="type">BigInt</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>) <span class="type">Map</span>(<span class="string">"aa"</span> -&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">5</span>) <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="string">"aa"</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">6</span>)<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">7</span>)<span class="type">Array</span>(<span class="string">"aa"</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">8</span>)<span class="type">Array</span>(<span class="string">"aa"</span>)</span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 根据 obj 的类型来匹配</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="keyword">val</span> result = obj1 <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> a: <span class="type">Int</span> =&gt; a</span><br><span class="line">  <span class="keyword">case</span> b: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] =&gt; <span class="string">"对象是一个字符串-数字的 Map 集合"</span></span><br><span class="line">  <span class="keyword">case</span> c: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] =&gt; <span class="string">"对象是一个数字-字符串的 Map 集合"</span></span><br><span class="line">  <span class="keyword">case</span> d: <span class="type">Array</span>[<span class="type">String</span>] =&gt; d <span class="comment">//"对象是一个字符串数组"</span></span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">Array</span>[<span class="type">Int</span>] =&gt; <span class="string">"对象是一个数字数组"</span></span><br><span class="line">  <span class="keyword">case</span> _: <span class="type">BigInt</span> =&gt; <span class="type">Int</span>.<span class="type">MaxValue</span> <span class="comment">// 隐藏了变量名</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"啥也不是"</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><h2 id="匹配数组"><a href="#匹配数组" class="headerlink" title="匹配数组"></a>匹配数组</h2><ol><li>Array(0) 匹配只有一个元素且为 0 的数组。</li><li>Array(x,y) 匹配数组有两个元素，并将两个元素赋值为 x 和 y。当然可以依次类推 Array(x,y,z) 匹配数组有 3 个元素的等等….</li><li>Array(0,_*) 匹配数组以 0 开始</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arrs: <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">Int</span>]] =<span class="type">Array</span>(<span class="type">Array</span>(<span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (arr &lt;- arrs ) &#123;</span><br><span class="line">  <span class="keyword">val</span> result = arr <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>) =&gt; <span class="string">"0"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(x, y) =&gt; x + <span class="string">"="</span> + y</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>, _*) =&gt; <span class="string">"以 0 开头和数组"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"什么集合都不是"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// result = 0</span></span><br><span class="line">  <span class="comment">// result = 1 = 0</span></span><br><span class="line">  <span class="comment">// result = 以 0 开头和数组</span></span><br><span class="line">  <span class="comment">// result = 什么集合都不是</span></span><br><span class="line">  <span class="comment">// result = 什么集合都不是</span></span><br><span class="line">  println(<span class="string">"result = "</span> + result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给你一个数组集合，如果该数组时 Array(10,20) , 请使用默认匹配，返回 Array(20,10)</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"><span class="keyword">val</span> arrs2 = <span class="type">Array</span>(<span class="type">Array</span>(<span class="number">0</span>),<span class="type">Array</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> (arr &lt;- arrs2 ) &#123;</span><br><span class="line">  <span class="keyword">val</span> result = arr <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="comment">//caseArray(0) =&gt; "0"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(x,y)=&gt;<span class="type">ArrayBuffer</span>(y,x) <span class="comment">//?ArrayB(y,x)</span></span><br><span class="line">    <span class="comment">//caseArray(0, _*) =&gt; "以 0 开头和数组"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"不处理~~"</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配列表"><a href="#匹配列表" class="headerlink" title="匹配列表"></a>匹配列表</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  Nil 表示空列表  0 :: 连接上一个空列表 表示List中只有0</span></span><br><span class="line">    <span class="comment">//  println(s"x : $x  y: $y ")  拼接字符串,必须以s 开头, $ 取值</span></span><br><span class="line">    <span class="keyword">for</span> (list &lt;-<span class="type">Array</span>(<span class="type">List</span>(<span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">88</span>), <span class="type">List</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = list <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> :: <span class="type">Nil</span> =&gt; <span class="string">"0"</span> <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> x :: y :: <span class="type">Nil</span> =&gt; x + <span class="string">" "</span> + y <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> :: tail =&gt; <span class="string">"0 ..."</span> <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> x :: <span class="type">Nil</span> =&gt; x</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//      0</span></span><br><span class="line"><span class="comment">//      1 0</span></span><br><span class="line"><span class="comment">//      88</span></span><br><span class="line"><span class="comment">//      0 ...</span></span><br><span class="line"><span class="comment">//      something else</span></span><br><span class="line">      println(result)</span><br><span class="line"></span><br><span class="line">      println(<span class="string">"=================================="</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> site: immutable.<span class="type">Seq</span>[<span class="type">String</span>] = <span class="string">"Runoob"</span> :: (<span class="string">"Google"</span> :: (<span class="string">"Baidu"</span> :: <span class="type">Nil</span>))</span><br><span class="line">      <span class="keyword">val</span> site2 = site</span><br><span class="line">      site.foreach(println)</span><br><span class="line">      <span class="keyword">val</span> nums = <span class="number">1</span> :: (<span class="number">2</span> :: (<span class="number">3</span> :: (<span class="number">4</span> :: <span class="type">Nil</span>)))</span><br><span class="line">      <span class="keyword">val</span> nums2: <span class="type">List</span>[<span class="type">Int</span>] = nums</span><br><span class="line">      nums.foreach(println)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 二维列表</span></span><br><span class="line">      <span class="keyword">val</span> dim = (<span class="number">1</span> :: (<span class="number">0</span> :: (<span class="number">0</span> :: <span class="type">Nil</span>))) ::</span><br><span class="line">        (<span class="number">0</span> :: (<span class="number">1</span> :: (<span class="number">0</span> :: <span class="type">Nil</span>))) ::</span><br><span class="line">        (<span class="number">0</span> :: (<span class="number">0</span> :: (<span class="number">1</span> :: <span class="type">Nil</span>))) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> dim2: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = dim</span><br><span class="line">      dim.foreach(println)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>补充一部分列表操作：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> reslist0: <span class="type">List</span>[<span class="type">String</span>] = <span class="string">"A"</span>::<span class="string">"B"</span>::<span class="type">Nil</span>  <span class="comment">// List(A, B)</span></span><br><span class="line"><span class="keyword">val</span> reslist1: <span class="type">List</span>[<span class="type">String</span>] = <span class="string">"C"</span>+:<span class="string">"D"</span>+:<span class="type">Nil</span>  <span class="comment">// List(C, D)</span></span><br><span class="line"><span class="keyword">val</span> reslist2: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">Nil</span>:+<span class="string">"E"</span>:+<span class="string">"F"</span>  <span class="comment">// List(E, F)</span></span><br><span class="line">println(reslist0)</span><br><span class="line">println(reslist1)</span><br><span class="line">println(reslist2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> reslist3 = reslist0 ++ reslist1 <span class="comment">// List(A, B, C, D)</span></span><br><span class="line">println(reslist3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> reslist4 = reslist0 ::: reslist1 <span class="comment">// List(A, B, C, D)</span></span><br><span class="line">println(reslist4)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> reslist5 = reslist0 :: reslist1 <span class="comment">// List(List(A, B), C, D)</span></span><br><span class="line">println(reslist5)</span><br></pre></td></tr></table></figure><ul><li><code>::</code> 该方法被称为cons，意为构造，向队列的头部追加数据，创造新的列表。用法为 <code>x::list</code>,其中<code>x</code>为加入到头部的元素，无论<code>x</code>是列表与否，它都只将成为新生成列表的第一个元素，也就是说新生成的列表长度为list的长度＋1(btw, <code>x::list</code>等价于<code>list.::(x)</code>)</li><li><code>:+</code>和<code>+:</code> 两者的区别在于<code>:+</code>方法用于在尾部追加元素，<code>+:</code>方法用于在头部追加元素，和<code>::</code>很类似，但是<code>::</code>可以用于pattern match ，而<code>+:</code>则不行. 关于<code>+:</code>和<code>:+</code>,只要记住冒号永远靠近集合类型就OK了。</li><li><code>++</code> 该方法用于连接两个集合，<code>list1++list2</code></li><li><code>:::</code> 该方法只能用于连接两个List类型的集合</li></ul><h2 id="匹配元组"><a href="#匹配元组" class="headerlink" title="匹配元组"></a>匹配元组</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (pair &lt;- <span class="type">Array</span>((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">10</span>, <span class="number">30</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = pair <span class="keyword">match</span> &#123; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> (<span class="number">0</span>, _) =&gt; <span class="string">"0 ..."</span> <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> (y, <span class="number">0</span>) =&gt; y <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> (x, y) =&gt; (y, x) <span class="comment">//"匹配到(x,y)" + x + " " + y</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">"other"</span> <span class="comment">//.</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//      0 ...</span></span><br><span class="line"><span class="comment">//      1</span></span><br><span class="line"><span class="comment">//      (30,10)</span></span><br><span class="line"><span class="comment">//      (1,1)</span></span><br><span class="line"><span class="comment">//      other</span></span><br><span class="line">      println(result)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="对象匹配"><a href="#对象匹配" class="headerlink" title="对象匹配"></a>对象匹配</h2><p>基本介绍 对象匹配，什么才算是匹配呢？，规则如下: 1) case 中对象的 unapply 方法(对象提取器)返回 Some 集合则为匹配成功 2) 返回 None 集合则为匹配失败</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 对象匹配</span></span><br><span class="line">  <span class="keyword">val</span> number: <span class="type">Double</span> = <span class="type">Square</span>(<span class="number">5.0</span>)</span><br><span class="line">  number <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Square</span>(n) =&gt; println(<span class="string">"匹配成功 n="</span> + n)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">"nothing matched"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Object</span> <span class="type">Square</span>&#123;</span><br><span class="line">  <span class="comment">// 说明</span></span><br><span class="line">  <span class="comment">// unapply 是对象提取器</span></span><br><span class="line">  <span class="comment">// 接受 z:Double 类型</span></span><br><span class="line">  <span class="comment">// 返回类型是 Optionp[Double]</span></span><br><span class="line">  <span class="comment">// 返回值是 Some(math.sqrt(z)) 返回 z 的开平方的值，并放到Some(x)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(z:<span class="type">Double</span>): <span class="type">Option</span>[<span class="type">Double</span>] = &#123;</span><br><span class="line">    println(<span class="string">"unapple 被调用 z 是="</span> + z)</span><br><span class="line">    <span class="comment">//Some(z)  unapple 被调用 z 是=25.0 匹配成功 n=25.0</span></span><br><span class="line">    <span class="type">Some</span>(<span class="type">Math</span>.sqrt(z))</span><br><span class="line">    <span class="comment">// None</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(z:<span class="type">Double</span>):<span class="type">Double</span> = z * z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的unapply方法就是模式匹配中调用的方法。这个例子可以深刻的理解模式匹配和unapply的关系。</p><h3 id="对象匹配的特殊情况"><a href="#对象匹配的特殊情况" class="headerlink" title="对象匹配的特殊情况"></a>对象匹配的特殊情况</h3><ol><li><p>当 case 后面的对象提取器方法的参数为多个，则会默认调用 def unapplySeq() 方法 </p></li><li><p>如果 unapplySeq 返回是 Some，获取其中的值,判断得到的 sequence 中的元素的个数是否是三个 如果是三个，则把三个元素分别取出，赋值给 first，second 和 third </p></li><li><p>其它的规则不变.</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MatchObjectDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> namesString = <span class="string">"Alice,Bob,Thomas"</span> <span class="comment">//字符串</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    namesString <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="comment">// 当 执行 case Names(first, second, third)</span></span><br><span class="line">      <span class="comment">// 1. 会调用 unapplySeq（str）,把 "Alice,Bob,Thomas" 传入给 str</span></span><br><span class="line">      <span class="comment">// 2. 如果 返回的是 Some("Alice","Bob","Thomas"),分别给 （first, second, third）</span></span><br><span class="line">      <span class="comment">// 注意，这里的返回的值unapplySeq的个数需要和 case（first, second, third）要一样</span></span><br><span class="line">      <span class="comment">// 3. 如果返回的 None ,表示匹配失败</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Names</span>(first, second, third) =&gt; &#123;</span><br><span class="line">          println(<span class="string">"the string contains three people's names"</span>)</span><br><span class="line">        <span class="comment">// 打印字符串</span></span><br><span class="line">        println(<span class="string">s"<span class="subst">$first</span> <span class="subst">$second</span> <span class="subst">$third</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">"nothing matched"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//object</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Names</span> </span>&#123;</span><br><span class="line">  <span class="comment">//当构造器是多个参数时，就会触发这个对象提取器</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapplySeq</span></span>(str: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Seq</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.contains(<span class="string">","</span>)) <span class="type">Some</span>(str.split(<span class="string">","</span>))</span><br><span class="line">    <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量声明中的模式"><a href="#变量声明中的模式" class="headerlink" title="变量声明中的模式"></a>变量声明中的模式</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明中的模式匹配</span></span><br><span class="line"><span class="keyword">val</span> (x,y,z) = (<span class="number">1</span>,<span class="number">2</span>,<span class="string">"hello"</span>)</span><br><span class="line">println(<span class="string">"x="</span> + x)</span><br><span class="line"><span class="keyword">val</span> (q,r) = <span class="type">BigInt</span>(<span class="number">10</span>) /% <span class="number">3</span> <span class="comment">// 说明 q = BigInt(10) / 3 r = BigInt(10) % 3</span></span><br><span class="line">println(q,r)</span><br><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">Array</span>(first,second, _*) = arr <span class="comment">// 提取出arr的其哪两个元素</span></span><br><span class="line">println(first,second)</span><br></pre></td></tr></table></figure><h2 id="for表达式中的模式"><a href="#for表达式中的模式" class="headerlink" title="for表达式中的模式"></a>for表达式中的模式</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">"A"</span> -&gt; <span class="number">1</span>, <span class="string">"B"</span> -&gt; <span class="number">0</span>, <span class="string">"C"</span> -&gt; <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> ((k, v) &lt;- map) &#123;</span><br><span class="line">  println(k + <span class="string">" -&gt; "</span> + v) <span class="comment">// 出来三个 key-value ("A"-&gt;1), ("B"-&gt;0), ("C"-&gt;3)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明 : 只遍历出 value =0 的 key-value ,其它的过滤掉</span></span><br><span class="line">println(<span class="string">"--------------(k, 0) &lt;- map-------------------"</span>)</span><br><span class="line"><span class="keyword">for</span> ((k, <span class="number">0</span>) &lt;- map) &#123;</span><br><span class="line">  println(k + <span class="string">" --&gt; "</span> + <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明, 这个就是上面代码的另外写法, 只是下面的用法灵活和强大</span></span><br><span class="line">println(<span class="string">"--------------(k, v) &lt;- map if v == 0-------------------"</span>)</span><br><span class="line"><span class="keyword">for</span> ((k, v) &lt;- map <span class="keyword">if</span> v &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">  println(k + <span class="string">" ---&gt; "</span> + v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="样例类"><a href="#样例类" class="headerlink" title="样例类"></a>样例类</h2><ol><li>样例类仍然是类 </li></ol><ol start="2"><li><p>样例类用 case 关键字进行声明。 </p></li><li><p>样例类是为 模式匹配而优化的类 </p></li><li><p>构造器中的每一个参数都成为 val——除非它被显式地声明为 var（不建议这样做） </p></li><li><p>在样例类对应的伴生对象中提供 apply 方法让你不用 new 关键字就能构造出相应的对象 </p></li><li><p>提供 unapply 方法让模式匹配可以工作 </p></li><li><p>将自动生成 toString 、equals 、hashCode 和 和 copy 方法(有点类似模板类，直接给生成，供程序员使用) 8) 除上述外，样例类和其他类完全一样。你可以添加方法和字段，扩展它们</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CaseClassDemo02</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//该案例的作用就是体验使用样例类方式进行对象匹配简洁性</span></span><br><span class="line">    <span class="keyword">for</span> (amt &lt;- <span class="type">Array</span>(<span class="type">Dollar2</span>(<span class="number">1000.0</span>), <span class="type">Currency2</span>(<span class="number">1000.0</span>, <span class="string">"RMB"</span>), <span class="type">NoAmount2</span>)) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = amt <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Dollar2</span>(v) =&gt; <span class="string">"$"</span> + v <span class="comment">// $1000.0</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Currency2</span>(v, u) =&gt; v + <span class="string">" "</span> + u <span class="comment">// 1000.0 RMB</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">NoAmount2</span> =&gt; <span class="string">""</span> <span class="comment">// ""</span></span><br><span class="line">      &#125;</span><br><span class="line">      println(amt + <span class="string">": "</span> + result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Amount2</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Dollar2</span>(<span class="params">value: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Amount2</span> <span class="title">//样例类</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Currency2</span>(<span class="params">value: <span class="type">Double</span>, unit: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Amount2</span> <span class="title">//样例类</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">NoAmount2</span> <span class="keyword">extends</span> <span class="title">Amount2</span> <span class="title">//样例类</span></span></span><br></pre></td></tr></table></figure><p>语句的中置表达式</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>) <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> first :: second :: rest =&gt; println(first + <span class="string">" "</span> + second + <span class="string">" "</span> + rest.length + <span class="string">" "</span> + rest)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">"匹配不到..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：1 3 2 List(5, 9)</p><p>什么是中置表达式？1 + 2，这就是一个中置表达式。如果 unapply 方法产出一个元组，你可以在 case 语句中使用中置表示法。比如可以匹配一个 List 序列 </p><h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    密封类</span></span><br><span class="line"><span class="comment">    1.可以避免滥用继承</span></span><br><span class="line"><span class="comment">    2.用在模式匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>  <span class="title">Furniture</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span>  <span class="title">Couch</span>(<span class="params"></span>) <span class="keyword">extends</span>  <span class="title">Furniture</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span>  <span class="title">Chair</span>(<span class="params"></span>) <span class="keyword">extends</span>  <span class="title">Furniture</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SealedDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findPlaceTosit</span></span>(furniture: <span class="type">Furniture</span>):<span class="type">String</span>=furniture <span class="keyword">match</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> a:<span class="type">Couch</span>=&gt;<span class="string">"lie on the couch"</span></span><br><span class="line">    <span class="keyword">case</span> b:<span class="type">Chair</span>=&gt;<span class="string">"site on the chair"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> chair=<span class="type">Chair</span>()</span><br><span class="line">      <span class="keyword">val</span> sea=<span class="keyword">new</span> <span class="type">SealedDemo</span>()</span><br><span class="line">      println(sea.findPlaceTosit(chair))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Match-Example"><a href="#Match-Example" class="headerlink" title="Match Example"></a>Match Example</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Example 商品捆绑打折出售</span></span><br><span class="line"><span class="comment">//    1) 商品捆绑可以是单个商品，也可以是多个商品</span></span><br><span class="line"><span class="comment">//    2) 打折时按照折扣 x 元进行设计</span></span><br><span class="line"><span class="comment">//    3) 能够统计出所有捆绑商品打折后的最终价格</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设计的样例类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="title">//</span> <span class="title">项</span></span></span><br><span class="line"><span class="class">    <span class="title">case</span> <span class="title">class</span> <span class="title">Book</span>(<span class="params">description: <span class="type">String</span>, price: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class">    <span class="title">//Bundle</span> <span class="title">捆</span> <span class="title">，</span> <span class="title">discount</span></span>: <span class="type">Double</span> 折扣 ， item: <span class="type">Item</span>* ,可变参数</span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Bundle</span>(<span class="params">description: <span class="type">String</span>, discount: <span class="type">Double</span>, item: <span class="type">Item</span>*</span>) <span class="keyword">extends</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">//</span> <span class="title">打折案例</span> 120</span></span><br><span class="line"><span class="class">    <span class="title">val</span> <span class="title">sale</span> </span>= <span class="type">Bundle</span>(<span class="string">"书籍"</span>,<span class="number">10</span>,<span class="type">Book</span>(<span class="string">"漫画"</span>,<span class="number">40</span>),<span class="type">Bundle</span>(<span class="string">"文学作品"</span>, <span class="number">20</span>, <span class="type">Book</span>(<span class="string">"《阳关》"</span>, <span class="number">80</span>), <span class="type">Book</span>(<span class="string">"《围城》"</span>, <span class="number">30</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1- 使用case语句，得到"漫画"</span></span><br><span class="line">    <span class="keyword">val</span> demo = sale <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Bundle</span>(_, _, <span class="type">Book</span>(desc, _), _*) =&gt; desc</span><br><span class="line">    &#125;</span><br><span class="line">    println(demo)<span class="comment">// 漫画</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2- 通过@表示法将嵌套的值绑定到变量。 _* 绑定剩余 Item 到 rest</span></span><br><span class="line">    <span class="keyword">val</span> demo2 = sale <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="comment">//  如果我们进行对象匹配时，不想接受某些值，则使用_忽略即可， _* 代表所有</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Bundle</span>(_, _, art @ <span class="type">Book</span>(_,_),rest @ _*) =&gt; (art, rest)</span><br><span class="line">    &#125;</span><br><span class="line">    println(demo2) <span class="comment">//(Book(漫画,40.0),WrappedArray(Bundle(文学作品,20.0,WrappedArray(Book(《阳关》,80.0), Book(《围城》,30.0)))))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> demo3 = sale <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Bundle</span>(_,_,art3 @ <span class="type">Book</span>(_, _),rest3) =&gt; (art3, rest3)</span><br><span class="line">    &#125;</span><br><span class="line">    println(demo3) <span class="comment">//(Book(漫画,40.0),Bundle(文学作品,20.0,WrappedArray(Book(《阳关》,80.0), Book(《围城》,30.0))))</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span></span>(it:<span class="type">Item</span>):<span class="type">Double</span> = &#123;</span><br><span class="line">      it <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Book</span>(_,p) =&gt; p</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Bundle</span>(_,disc,its @ _*) =&gt; its.map(price).sum - disc</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"price="</span> + price(sale)) <span class="comment">// 120.0</span></span><br></pre></td></tr></table></figure><h2 id="模式匹配和if-else-的区别"><a href="#模式匹配和if-else-的区别" class="headerlink" title="模式匹配和if else 的区别"></a>模式匹配和if else 的区别</h2><p>模式匹配其实本质上是提供一个方便的解构 (Destructuring) 数据结构的方式，以 scala 为例， pattern matching 其实用到了 scala 中提取器的功能， 提取器其实就是类中的 unapply () 方法。</p><p>其实 if else 只是 pattern matching 中的一个典型的用法，但并非它的全部。</p><p>同时， pattern matching 允许你解耦两个并不真正属于彼此的东西，也使得你的代码更易于测试。</p><h2 id="apply-amp-unapply"><a href="#apply-amp-unapply" class="headerlink" title="apply() &amp; unapply()"></a>apply() &amp; unapply()</h2><ul><li><p>apply方法被称作注入方法，在类的伴生对象中做一个初始化操作</p></li><li><p>apply方法的参数列表不需要跟构造器的参数列表统一</p></li><li><p>apply方法是定义在伴生对象中的</p></li></ul><p>当Scala中类或者对象有一个主要用途的时候，apply方法就是很好的语法糖。</p><p>apply方法 =&gt; 类似 constructor4Java</p><p>unapply方法完全相反，unapply接受一个对象，从对象中提取出相应的值。</p><p>unapply方法主要用于模式匹配中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span>(<span class="params">val value: <span class="type">Double</span>, val country: <span class="type">String</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">Double</span>, country: <span class="type">String</span>) : <span class="type">Money</span> = <span class="keyword">new</span> <span class="type">Money</span>(value, country)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(money: <span class="type">Money</span>): <span class="type">Option</span>[(<span class="type">Double</span>, <span class="type">String</span>)] = &#123;</span><br><span class="line">        <span class="keyword">if</span>(money == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Some</span>(money.value, money.country)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testUnapply</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">val</span> money = <span class="type">Money</span>(<span class="number">10.1</span>, <span class="string">"RMB"</span>)</span><br><span class="line">    money <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Money</span>(num, <span class="string">"RMB"</span>) =&gt;  println(<span class="string">"RMB: "</span> + num)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; println(<span class="string">"Not RMB!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么只能在object对象定义main方法才能作为入口？"><a href="#为什么只能在object对象定义main方法才能作为入口？" class="headerlink" title="为什么只能在object对象定义main方法才能作为入口？"></a>为什么只能在object对象定义main方法才能作为入口？</h2><p>类比java中的main方法的修饰词public static得知main方法是static（静态的），在scala中静态方法或者属性是在object修改的对象中的，object修饰的对象是singleton，用于保存静态成员等。</p><h1 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span>.&#123;<span class="keyword">break</span>, breakable&#125;</span><br></pre></td></tr></table></figure><p>break:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">breakable(</span><br><span class="line">    <span class="keyword">for</span>(i&lt;<span class="number">-0</span> until <span class="number">10</span>) &#123;</span><br><span class="line">      println(i)</span><br><span class="line">      <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"> <span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p>continue:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i&lt;<span class="number">-0</span> until <span class="number">10</span>)&#123;</span><br><span class="line">      breakable&#123;</span><br><span class="line">      <span class="keyword">if</span>(i==<span class="number">3</span>||i==<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      println(i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0,1,2,3,5,7,8,9</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1glptqgll6ej2098048a9w.jpg&quot; alt=&quot;undefined&quot; style=&quot;zoom: 150%;&quot;&gt;</summary>
    
    
    
    
    <category term="Tips4Scala" scheme="http://yoursite.com/tags/Tips4Scala/"/>
    
  </entry>
  
  <entry>
    <title>Dawn Dew-light Collected at Dusk 4 Java</title>
    <link href="http://yoursite.com/2020/10/31/Dawn-Dew-light-Collected-at-Dusk-4-Java/"/>
    <id>http://yoursite.com/2020/10/31/Dawn-Dew-light-Collected-at-Dusk-4-Java/</id>
    <published>2020-10-31T02:55:40.000Z</published>
    <updated>2021-01-28T08:54:40.490Z</updated>
    
    <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk8bz1ze11j20xc0m8gob.jpg" alt="undefined" style="zoom: 50%;"><blockquote><p>JAVA 的随手PICK</p></blockquote><a id="more"></a> <h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>Java 8 引入了 Optional，目的主要是为了解决空值问题，这个Optional是借鉴的<code>Google Guava</code>类库的Optional类，捏妈的，谷歌好顶</p><h2 id="of"><a href="#of" class="headerlink" title="of"></a>of</h2><p>为非Null值创建一个Optional</p><p>of方法通过工厂方法创建Optional实例，需要注意的是传入的参数不能为null，否则抛出<code>NullPointerException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给与一个非空值</span></span><br><span class="line">Optional&lt;String&gt; username = Optional.of(<span class="string">"cwl"</span>);</span><br><span class="line"><span class="comment">// 传入参数为null，抛出NullPointerException.</span></span><br><span class="line">Optional&lt;String&gt; nullValue = Optional.of(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a>ofNullable</h2><p>为指定的值创建一个Optional,如果指定的值为null，则返回一个空的Optional。可为空的Optional</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面创建了一个不包含任何值的Optional实例</span></span><br><span class="line"><span class="comment">// 输出Optional.empty</span></span><br><span class="line">Optional empty = Optional.ofNullable(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a>isPresent</h2><p>如果值存在返回true,否则返回false<br>类似下面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isPresent方法用来检查Optional实例中是否包含值</span></span><br><span class="line"><span class="keyword">if</span> (username.isPresent()) &#123;</span><br><span class="line">    <span class="comment">//在Optional实例内调用get()返回已存在的值</span></span><br><span class="line">    System.out.println(username.get());      <span class="comment">//输出cwl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>如果Optional有值则将其返回，否则跑出<code>NoSuchElementException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行下面的代码抛出NoSuchElementException</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 在空的Optional实例上调用get()</span></span><br><span class="line">     System.out.println(empty.get());</span><br><span class="line"> &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">     System.out.println(ex.getMessage());         <span class="comment">// 输出：No value present</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a>ifPresent</h2><p>如果Optional实例有值则为其调用consumer ,否则不做处理。<br>要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。 Java8支持不用接口直接通过lambda表达式传入参数。<br>如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。类似下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ifPresent方法接受lambda表达式作为参数。</span></span><br><span class="line"><span class="comment">// lambda表达式对Optional的值调用consumer进行处理。</span></span><br><span class="line">username.ifPresent((value) -&gt; &#123;</span><br><span class="line">     System.out.println(<span class="string">"The length of the value is: "</span> + value.length());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h2><p>如果有值则将其返回，否则返回指定的其它值。<br>如果Optional实例有值则将其返回，否则返回orElse方法传入的参数。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果值不为null，orElse方法返回Optional实例的值,否则返回传入的消息</span></span><br><span class="line">System.out.println(empty.orElse(<span class="string">"There is no value present!"</span>));<span class="comment">// 输出：There is no value present!</span></span><br><span class="line">System.out.println(username.orElse(<span class="string">"There is some value!"</span>));  <span class="comment">// 输出：cwl</span></span><br></pre></td></tr></table></figure><h2 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a>orElseGet</h2><p>orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orElseGet与orElse方法类似，区别在于orElse传入的是默认值，</span></span><br><span class="line"><span class="comment">// orElseGet可以接受一个lambda表达式生成默认值。</span></span><br><span class="line"><span class="comment">// 输出：Default Value</span></span><br><span class="line">System.out.println(empty.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line"><span class="comment">// 输出：cwl</span></span><br><span class="line">System.out.println(username.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br></pre></td></tr></table></figure><h2 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a>orElseThrow</h2><p>如果有值则将其返回，否则抛出supplier接口创建的异常。<br>在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// orElseThrow与orElse方法类似。与返回默认值不同，</span></span><br><span class="line">    <span class="comment">// orElseThrow会抛出lambda表达式或方法生成的异常</span></span><br><span class="line">    empty.orElseThrow(ValueAbsentException::<span class="keyword">new</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">//输出: No value present in the Optional instance</span></span><br><span class="line">    System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ValueAbsentException</code>定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueAbsentException</span> <span class="keyword">extends</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ValueAbsentException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValueAbsentException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"No value present in the Optional instance"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。<br>map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。如果你不熟悉Function接口，可以参考这篇博客。map方法示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map方法执行传入的lambda表达式参数对Optional实例的值进行修改。</span></span><br><span class="line"><span class="comment">// 为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。</span></span><br><span class="line">Optional&lt;String&gt; upperName = username.map((value) -&gt; value.toUpperCase());  </span><br><span class="line">System.out.println(upperName.orElse(<span class="string">"No value found"</span>));      <span class="comment">//输出: CWL</span></span><br></pre></td></tr></table></figure><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。<br>参照map函数，使用flatMap重写的示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flatMap与map（Function）非常类似，区别在于传入方法的lambda表达式的返回类型。</span></span><br><span class="line"><span class="comment">// map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 </span></span><br><span class="line"><span class="comment">// 但flatMap方法中的lambda表达式返回值必须是Optionl实例。 </span></span><br><span class="line"> upperName = username.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line"> System.out.println(upperName.orElse(<span class="string">"No value found"</span>));<span class="comment">//输出 CWL</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter个方法通过传入限定条件对Optional实例的值进行过滤。文档描述如下：<br>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。<br>读到这里，可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了Predicate接口的lambda表达式。如果你不熟悉Predicate接口，可以参考 这篇文章。<br>现在我来看看filter的各种用法，下面的示例介绍了满足限定条件和不满足两种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter方法检查给定的Option值是否满足某些条件。</span></span><br><span class="line"><span class="comment">// 如果满足则返回同一个Option实例，否则返回空Optional。</span></span><br><span class="line">Optional&lt;String&gt; longName = username.filter((value) -&gt; value.length() &gt; <span class="number">2</span>);</span><br><span class="line">System.out.println(longName.orElse(<span class="string">"The name is less than 2 characters"</span>));<span class="comment">//cwl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子是Optional值不满足filter指定的条件。</span></span><br><span class="line">Optional&lt;String&gt; anotherName = Optional.of(<span class="string">"y"</span>);</span><br><span class="line">Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 输出：The name is less than 2 characters</span></span><br><span class="line">System.out.println(shortName.orElse(<span class="string">"The name is less than 2 characters"</span>));</span><br></pre></td></tr></table></figure><h1 id="双冒号"><a href="#双冒号" class="headerlink" title="双冒号"></a>双冒号</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>双冒号运算操作符是类方法的句柄，lambda表达式的一种简写，这种简写的学名叫eta-conversion或者叫η-conversion。</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a><strong>理解</strong></h2><p>英文格式双冒号<code>::</code>，读：double colon，双冒号（::）运算符在Java 8中被用作<strong>方法引用</strong>（method reference），方法引用是与lambda表达式相关的一个重要特性。它提供了一种执行方法的方法,为此，方法引用需要由兼容的函数式接口组成的目标类型上下文。</p><p>使用lambda表达式会创建匿名函数， 但有时候需要使用一个lambda表达式只调用一个已经存在的方法（不做其它）， 所以这才有了方法引用！</p><table><thead><tr><th>类型</th><th>引用语法</th><th>案例</th></tr></thead><tbody><tr><td>引用静态方法</td><td>类名::静态方法名</td><td>Integer::parseInt</td></tr><tr><td>引用特定对象实例方法</td><td>对象::实例方法名</td><td>System.out::println</td></tr><tr><td>引用特定类型的任意对象的实例方法</td><td>特定类型::实例方法名</td><td>String::compareTolgnoreCase</td></tr><tr><td>引用父类实例方法</td><td>super::方法名</td><td></td></tr><tr><td>引用类构造方法</td><td>类名::new</td><td>ArrayList::new</td></tr><tr><td>引用数组构造方法</td><td>数组类型[]::new</td><td>String[]::new</td></tr></tbody></table><h2 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">//静态方法引用  ClassName::methodName</span></span><br><span class="line">        list.forEach(Colon::print);</span><br><span class="line">        <span class="comment">//上一行等价于</span></span><br><span class="line">        <span class="comment">//list.forEach((x)-&gt;Colon.print(x));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">//实例方法引用  instanceRef::methodName</span></span><br><span class="line">        list.forEach(<span class="keyword">new</span> Colon()::print);</span><br><span class="line">        <span class="comment">//上一行等价于</span></span><br><span class="line">        <span class="comment">//list.forEach((x)-&gt;new Colon().print(x));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String[] arr = &#123; <span class="string">"Barbara"</span>, <span class="string">"James"</span>, <span class="string">"Mary"</span>, <span class="string">"John"</span>,</span><br><span class="line">                <span class="string">"Patricia"</span>, <span class="string">"Robert"</span>, <span class="string">"Michael"</span>, <span class="string">"Linda"</span> &#125;;</span><br><span class="line">        <span class="comment">//引用String类型的任意对象的compareToIgnoreCase方法实现忽略大小写排序</span></span><br><span class="line">        Arrays.sort(arr, String::compareToIgnoreCase);</span><br><span class="line">        <span class="comment">//上一行等价于</span></span><br><span class="line">        <span class="comment">//Arrays.sort(arr, (a,b)-&gt;a.compareToIgnoreCase(b));</span></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span>(String s:arr)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：不要和引用静态方法搞混，认为为什么<code>compareToIgnoreCase</code>是非静态方法却可以使用类名去引用，这两者根本不是一回事，双冒号前的类含义也不同，就是两个应用方向</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span> <span class="keyword">extends</span> <span class="title">BaseColon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">//实例方法引用  instanceRef::methodName</span></span><br><span class="line">        list.forEach(<span class="keyword">super</span>::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseColon</span></span>&#123;</span><br><span class="line">    <span class="comment">//实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：该类无需实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colon</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//无参构造引用</span></span><br><span class="line">        ColonNoParam cnp = Colon::<span class="keyword">new</span>;</span><br><span class="line">        Colon c1 = cnp.createColon();</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        <span class="comment">//有参构造引用</span></span><br><span class="line">        ColonWithParam cwp = Colon::<span class="keyword">new</span>;</span><br><span class="line">        Colon c2 = cwp.createColon(<span class="string">"小明"</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//生成toString方法打印查看</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Colon&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ColonNoParam</span></span>&#123;</span><br><span class="line">    <span class="comment">//无参方法提供对象</span></span><br><span class="line">    <span class="function">Colon <span class="title">createColon</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ColonWithParam</span></span>&#123;</span><br><span class="line">    <span class="comment">//有参方法提供对象（数据类型要与Colon有参构造函数对应）</span></span><br><span class="line">    <span class="function">Colon <span class="title">createColon</span><span class="params">(String s,<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;Integer,Colon[]&gt; function = Colon[]::<span class="keyword">new</span>;</span><br><span class="line">        <span class="comment">//调用apply方法创建数组，这里的5是数组的长度</span></span><br><span class="line">        Colon[] arr = function.apply(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//循环输出-初始都为null</span></span><br><span class="line">        <span class="keyword">for</span>(Colon c:arr)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colon</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyArrayFunction&lt;Integer,Colon[]&gt; function = Colon[]::<span class="keyword">new</span>;</span><br><span class="line">        <span class="comment">//调用apply方法创建数组，这里的5是数组的长度</span></span><br><span class="line">        Colon[] arr = function.apply(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//循环输出-初始都为null</span></span><br><span class="line">        <span class="keyword">for</span>(Colon c:arr)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyArrayFunction</span>&lt;<span class="title">A</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">apply</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Expansion"><a href="#Expansion" class="headerlink" title="Expansion"></a>Expansion</h2><p>上面的写法里面我有个疑惑的地方就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ColonNoParam cnp = Colon::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><p>为什么这个地方能直接实例化接口，其实这个是一个匿名内部类+Lamda复合的实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ColonWithParam cwp = Colon::<span class="keyword">new</span>;</span><br><span class="line">Colon c2 = cwp.createColon(<span class="string">"小明"</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>这个和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 整了一个匿名内部函数，同时这里只是定义了函数内容，并没有执行，在下面一行createColon的时候才执行了</span></span><br><span class="line">ColonWithParam colonWithParam = <span class="keyword">new</span> ColonWithParam() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Colon <span class="title">createColon</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Colon(s, i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      Colon colon1 = colonWithParam.createColon(<span class="string">"321"</span>,<span class="number">123</span>);</span><br><span class="line">      System.out.println(colon1);</span><br></pre></td></tr></table></figure><p>这样的写法是等价的，属实让人有点摸不清楚，</p><p>这里还涉及一个Lamda的注释<code>@FunctionalInterface</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface 是 Java 8 新加入的一种接口，用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。Java 8 还声明了一些 Lambda 表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用 @FunctionalInterface 解决编译层面的错误。</span><br></pre></td></tr></table></figure><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>String 内部实际存储结构为 char 数组，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于存储字符串的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">// 缓存字符串的 hash code</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    <span class="comment">// ......其他内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>String 字符串有以下 4 个重要的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// char[] 为参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuilder 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer StringBuilder char[] 和 String</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对象引用相同直接返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断需要对比的值是否为 String 类型，如果不是则直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="comment">// 把两个字符串都转换为 char 数组对比</span></span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 循环比对两个字符串的每一个字符</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果其中有一个字符不相等就 true false，否则继续对比</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 类型重写了 Object 中的 equals() 方法，equals() 方法需要传递一个 Object 类型的参数值，在比较时会先通过 instanceof 判断是否为 String 类型.</p><p>还有一个和 equals() 比较类似的方法 equalsIgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。</p><h2 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h2><p>compareTo() 方法用于比较两个字符串，返回的结果为 int 类型的值，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="comment">// 获取到两个字符串长度最短的那个 int 值</span></span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对比每一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="comment">// 有字符不相等就返回差值</span></span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，compareTo() 方法会循环对比所有的字符，当两个字符串中有任意一个字符不相同时，则 return char1-char2。比如，两个字符串分别存储的是 1 和 2，返回的值是 -1；如果存储的是 1 和 1，则返回的值是 0 ，如果存储的是 2 和 1，则返回的值是 1。</p><p>还有一个和 compareTo() 比较类似的方法 compareToIgnoreCase()，用于忽略大小写后比较两个字符串。</p><p>可以看出 compareTo() 方法和 equals() 方法都是用于比较两个字符串的，但它们有两点不同：</p><ul><li>equals() 可以接收一个 Object 类型的参数，而 compareTo() 只能接收一个 String 类型的参数；</li><li>equals() 返回值为 Boolean，而 compareTo() 的返回值则为 int。</li></ul><p>它们都可以用于两个字符串的比较，当 equals() 方法返回 true 时，或者是 compareTo() 方法返回 0 时，则表示两个字符串完全相同。</p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><ul><li>indexOf()：查询字符串首次出现的下标位置</li><li>lastIndexOf()：查询字符串最后出现的下标位置</li><li>contains()：查询字符串中是否包含另一个字符串</li><li>toLowerCase()：把字符串全部转换成小写</li><li>toUpperCase()：把字符串全部转换成大写</li><li>length()：查询字符串的长度</li><li>trim()：去掉字符串首尾空格</li><li>replace()：替换字符串中的某些字符</li><li>split()：把字符串分割并返回字符串数组</li><li>join()：把字符串数组转为字符串</li></ul><p>个人不太熟悉的就是join()了 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String message = String.join(<span class="string">"-"</span>, <span class="string">"Java"</span>, <span class="string">"is"</span>, <span class="string">"cool"</span>);</span><br><span class="line"><span class="comment">// message returned is: "Java-is-cool"</span></span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="为什么-String-类型要用-final-修饰？"><a href="#为什么-String-类型要用-final-修饰？" class="headerlink" title="为什么 String 类型要用 final 修饰？"></a>为什么 String 类型要用 final 修饰？</h3><blockquote><p>从 String 类的源码我们可以看出 String 是被 final 修饰的不可继承类</p><p>Java 语言之父 James Gosling 的回答是，他会更倾向于使用 final，因为它能够缓存结果，当你在传参时不需要考虑谁会修改它的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。– 性能</p><p>James Gosling 还说迫使 String 类设计成不可变的另一个原因是<strong>安全</strong>，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，它的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使 String 类设计成不可变类的一个重要原因。 – 安全</p></blockquote><blockquote><p>另外只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glwoovq0i5j20ge092dfw.jpg" alt="undefined"></p><p>试想一下如果 String 是可变的，那当 s1 的值修改之后，s2 的值也跟着改变了，这样就和我们预期的结果不相符了，因此也就没有办法实现字符串常量池的功能了。</p><p>因为final修饰了，1.所以String天生线程安全 2. 非常适合做HashMap的key 3.利用不可变性实现字符串常量池</p></blockquote><h3 id="和-equals-的区别是什么？"><a href="#和-equals-的区别是什么？" class="headerlink" title="== 和 equals 的区别是什么？"></a>== 和 equals 的区别是什么？</h3><blockquote><p>== 对于<strong>基本数据类型</strong>来说，是用于比较 “值”是否相等的；而对于<strong>引用类型</strong>来说，是用于比较引用地址是否相同的。</p></blockquote><h3 id="String-和-StringBuilder、StringBuffer-有什么区别？"><a href="#String-和-StringBuilder、StringBuffer-有什么区别？" class="headerlink" title="String 和 StringBuilder、StringBuffer 有什么区别？"></a>String 和 StringBuilder、StringBuffer 有什么区别？</h3><blockquote><p>因为 String 类型是不可变的，所以在字符串拼接的时候如果使用 String 的话性能会很低，因此我们就需要使用另一个数据类型 StringBuffer，它提供了 append 和 insert 方法可用于字符串的拼接，它使用 synchronized 来保证线程安全，如下源码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">&gt;     toStringCache = <span class="keyword">null</span>;</span><br><span class="line">&gt;     <span class="keyword">super</span>.append(String.valueOf(obj));</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">&gt;     toStringCache = <span class="keyword">null</span>;</span><br><span class="line">&gt;     <span class="keyword">super</span>.append(str);</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>因为它使用了 synchronized 来保证线程安全，所以性能不是很高，于是在 JDK 1.5 就有了 StringBuilder，它同样提供了 append 和 insert 的拼接方法，但它没有使用 synchronized 来修饰，因此在性能上要优于 StringBuffer，所以在非并发操作的环境下可使用 StringBuilder 来进行字符串拼接。</p></blockquote><h3 id="String-的-intern-方法有什么含义？"><a href="#String-的-intern-方法有什么含义？" class="headerlink" title="String 的 intern() 方法有什么含义？"></a>String 的 intern() 方法有什么含义？</h3><blockquote><p>new String都是在堆上创建字符串对象。当调用 intern() 方法时，编译器会将字符串添加到常量池中（stringTable维护），并返回指向该常量的引用。</p></blockquote><h3 id="String-类型在-JVM（Java-虚拟机）中是如何存储的？编译器对-String-做了哪些优化？"><a href="#String-类型在-JVM（Java-虚拟机）中是如何存储的？编译器对-String-做了哪些优化？" class="headerlink" title="String 类型在 JVM（Java 虚拟机）中是如何存储的？编译器对 String 做了哪些优化？"></a>String 类型在 JVM（Java 虚拟机）中是如何存储的？编译器对 String 做了哪些优化？</h3><blockquote><p>String 常见的创建方式有两种，new String() 的方式和直接赋值的方式，直接赋值的方式会先去字符串常量池中查找是否已经有此值，如果有则把引用地址直接指向此值，否则会先在常量池中创建，然后再把引用指向此值；而 new String() 的方式一定会先在堆上创建一个字符串对象，然后再去常量池中查询此字符串的值是否已经存在，如果不存在会先在常量池中创建此字符串，然后把引用的值指向此字符串，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; String s1 = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br><span class="line">&gt; String s2 = s1.intern();</span><br><span class="line">&gt; String s3 = <span class="string">"Java"</span>;</span><br><span class="line">&gt; System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">&gt; System.out.println(s2 == s3); <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>它们在 JVM 存储的位置，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glwosriy2gj20l00990th.jpg" alt="undefined"></p><p>小贴士：JDK 1.7 之后把永生代换成的元空间，把字符串常量池从方法区移到了 Java 堆上。</p><p>除此之外编译器还会对 String 字符串做一些优化，例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; String s1 = <span class="string">"Ja"</span> + <span class="string">"va"</span>;</span><br><span class="line">&gt; String s2 = <span class="string">"Java"</span>;</span><br><span class="line">&gt; System.out.println(s1 == s2);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>虽然 s1 拼接了多个字符串，但对比的结果却是 true，我们使用反编译工具，看到的结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; Compiled from <span class="string">"StringExample.java"</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lagou</span>.<span class="title">interview</span>.<span class="title">StringExample</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">public</span> com.lagou.interview.StringExample();</span><br><span class="line">&gt;     Code:</span><br><span class="line">&gt;        <span class="number">0</span>: aload_0</span><br><span class="line">&gt;        1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">&gt;        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">&gt;     LineNumberTable:</span><br><span class="line">&gt;       line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">&gt;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">&gt;     Code:</span><br><span class="line">&gt;        0: ldc           #2                  // String Java</span><br><span class="line">&gt;        <span class="number">2</span>: astore_1</span><br><span class="line">&gt;        3: ldc           #2                  // String Java</span><br><span class="line">&gt;        <span class="number">5</span>: astore_2</span><br><span class="line">&gt;        6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">&gt;        <span class="number">9</span>: aload_1</span><br><span class="line">&gt;       <span class="number">10</span>: aload_2</span><br><span class="line">&gt;       <span class="number">11</span>: if_acmpne     <span class="number">18</span></span><br><span class="line">&gt;       <span class="number">14</span>: iconst_1</span><br><span class="line">&gt;       <span class="number">15</span>: goto          <span class="number">19</span></span><br><span class="line">&gt;       <span class="number">18</span>: iconst_0</span><br><span class="line">&gt;       19: invokevirtual #4                  // Method java/io/PrintStream.println:(Z)V</span><br><span class="line">&gt;       <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">&gt;     LineNumberTable:</span><br><span class="line">&gt;       line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">&gt;       line <span class="number">6</span>: <span class="number">3</span></span><br><span class="line">&gt;       line <span class="number">7</span>: <span class="number">6</span></span><br><span class="line">&gt;       line <span class="number">8</span>: <span class="number">22</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap 底层是如何实现的？在 JDK 1.8 中它都做了哪些优化？</p><p>在 JDK 1.7 中 HashMap 是以数组加链表的形式组成的, JDK 1.8 之后新增了红黑树的组成结构，当链表大于 8 并且容量大于 64 时， 链表结构会转换成红黑树结构，它的组成结构如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glzamaae9rj20ne0evwez.jpg" alt="undefined"></p><p>数组中的元素我们称之为哈希桶, JDK 1.8 之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap 的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><ul><li>JDK 1.8 HashMap 扩容时做了哪些优化？</li></ul><blockquote><p>JDK 1.8 则新增了红黑树结构，当链表长度达到 8 并且容器达到 64 时会转换为红黑树存储，以提升元素的操作性能。</p></blockquote><ul><li>加载因子为什么是 0.75？</li></ul><blockquote><p>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是 0.5，HashMap 的初始化容量是 16，那么当 HashMap 中有 16*0.5=8 个元素时，HashMap 就会进行扩容。</p><p>那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？</p><p>这其实是出于容量和性能之间平衡的结果：</p><p>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生 Hash 冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</p><p>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</p><p>所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p></blockquote><ul><li>当有哈希冲突时，HashMap 是如何查找并确认元素的？</li></ul><blockquote><p>当哈希冲突时我们需要通过判断 key 值是否相等，才能确认此元素是不是我们想要的元素。</p></blockquote><ul><li>HashMap 源码中有哪些重要的方法？</li></ul><blockquote><p>下方源码</p></blockquote><ul><li>HashMap 是如何导致死循环的？</li></ul><blockquote><p>以 JDK 1.7 为例，假设 HashMap 默认大小为 2，原本 HashMap 中有一个元素 key(5)，我们再使用两个线程：t1 添加元素 key(3)，t2 添加元素 key(7)，当元素 key(3) 和 key(7) 都添加到 HashMap 中之后，线程 t1 在执行到 Entry&lt;K,V&gt; next = e.next; 时，交出了 CPU 的使用权，源码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程一执行此处</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么此时线程 t1 中的 e 指向了 key(3)，而 next 指向了 key(7) ；之后线程 t2 重新 rehash 之后链表的顺序被反转，链表的位置变成了 key(5) → key(7) → key(3)，其中 “→” 用来表示下一个元素。</p></blockquote><blockquote><p>当 t1 重新获得执行权之后，先执行 newTalbe[i] = e 把 key(3) 的 next 设置为 key(7)，而下次循环时查询到 key(7) 的 next 元素为 key(3)，于是就形成了 key(3) 和 key(7) 的循环引用，因此就导致了死循环的发生，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glzaxp7o0aj20jt0f0gm1.jpg" alt="undefined"></p><p>当然发生死循环的原因是 JDK 1.7 链表插入方式为首部倒序插入，这个问题在 JDK 1.8 得到了改善，变成了尾部正序插入。</p><p>有人曾经把这个问题反馈给了 Sun 公司，但 Sun 公司认为这不是一个问题，<strong>因为 HashMap 本身就是非线程安全的，如果要在多线程下，建议使用 ConcurrentHashMap 替代</strong>，但这个问题在面试中被问到的几率依然很大，所以在这里需要特别说明一下。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>HashMap 源码中包含了以下几个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 最大长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的加载因子 (扩容因子)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当链表长度大于此值且容量大于 64 时</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换链表的临界值，当元素小于此值时，会将红黑树结构转换成链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小树容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY =</span><br></pre></td></tr></table></figure><p>HashMap 源码中三个重要方法：<strong>查询、新增</strong>和<strong>数据扩容</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个元素是否是要查询的元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 下一个节点非空判断</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果第一节点是树结构，则使用 getTreeNode 直接获取相应的数据</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">// 非树结构，循环节点判断</span></span><br><span class="line">                <span class="comment">// hash 相等并且 key 相同，则返回此节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，当哈希冲突时我们需要通过判断 key 值是否相等，才能确认此元素是不是我们想要的元素。</p><p>HashMap 第二个重要方法：<strong>新增方法</strong>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 哈希表为空则创建表</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据 key 的哈希值计算出要插入的数组索引 i</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果 table[i] 等于 null，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果 key 已经存在了，直接覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果 key 不存在，判断是否为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 红黑树直接插入键值对</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 为链表结构，循环准备插入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 下一个元素为空时</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  key 已经存在直接覆盖 value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过最大容量，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增方法的执行流程，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glzars7sxoj20jk0mwt99.jpg" alt="undefined"></p><p>HashMap 第三个重要的方法是<strong>扩容方法</strong>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容前的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容前的数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预定义新数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩大容量为当前容量的两倍，但不能超过 MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前数组没有数据，使用初始化的值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 如果初始化的值为 0，则使用默认的初始化容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的容量等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threshold = newThr; </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始扩容，将新的容量赋值给 table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 原数据不为空，将原数据复制到新 table 中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据容量循环数组，复制非空元素到新 table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果链表只有一个，则进行直接赋值</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 红黑树相关的操作</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表复制，JDK 1.8 扩容优化部分</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将原索引放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将原索引 + oldCap 放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，JDK 1.8 在扩容时并没有像 JDK 1.7 那样，重新计算每个元素的哈希值，而是通过高位运算（e.hash &amp; oldCap）来确定元素是否需要移动，比如 key1 的信息如下：</p><ul><li>key1.hash = 10 0000 1010</li><li>oldCap = 16 0001 0000</li></ul><p>使用 e.hash &amp; oldCap 得到的结果，高一位为 0，当结果为 0 时表示元素在扩容时位置不会发生任何变化，而 key 2 信息如下：</p><ul><li>key2.hash = 10 0001 0001</li><li>oldCap = 16 0001 0000</li></ul><p>这时候得到的结果，高一位为 1，当结果为 1 时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glzaw5h0vwj20le0byt8q.jpg" alt="undefined"></p><p>其中红色的虚线图代表了扩容时元素移动的位置。</p><h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><p>线程（Thread）是并发编程的基础，也是程序执行的最小单元，它依托进程而存在。一个进程中可以包含多个线程，多线程可以共享一块内存空间和一组系统资源，因此线程之间的切换更加节省资源、更加轻量化，也因此被称为轻量级的进程。</p><p>线程的状态在 JDK 1.5 之后以枚举的方式被定义在 Thread 的源码中，它总共包含以下 6 个状态：</p><blockquote><p>NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；<br>RUNNABLE，就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；<br>BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法；<br>WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了 Object.wait() 方法，那它就在等待另一个线程调用 Object.notify() 或 Object.notifyAll() 方法；<br>TIMED_WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；<br>TERMINATED，终止状态，表示线程已经执行完成。</p></blockquote><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gm4ggmh9ohj20j90ntaba.jpg" alt="微信图片_20201229090916.png"></p><p>线程的工作模式是，首先先要创建线程并指定线程需要执行的业务方法，然后再调用线程的 start() 方法，此时线程就从 NEW（新建）状态变成了 RUNNABLE（就绪）状态，此时线程会判断要执行的方法中有没有 synchronized 同步代码块，如果有并且其他线程也在使用此锁，那么线程就会变为 BLOCKED（阻塞等待）状态，当其他线程使用完此锁之后，线程会继续执行剩余的方法。</p><p>当遇到 Object.wait() 或 Thread.join() 方法时，线程会变为 WAITING（等待状态）状态，如果是带了超时时间的等待方法，那么线程会进入 TIMED_WAITING（计时等待）状态，当有其他线程执行了 notify() 或 notifyAll() 方法之后，线程被唤醒继续执行剩余的业务方法，直到方法执行完成为止，此时整个线程的流程就执行完了，执行流程如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gm3xhm2bxaj21af0kd764.jpg" alt="undefined"></p><p>转化图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gm4gvpumgjj20q00ccaag.jpg" alt="undefined"></p><h2 id="重点问题"><a href="#重点问题" class="headerlink" title="重点问题"></a>重点问题</h2><h3 id="为什么State里面没有Running状态"><a href="#为什么State里面没有Running状态" class="headerlink" title="为什么State里面没有Running状态"></a>为什么State里面没有Running状态</h3><blockquote><p>有人常觉得 Java 线程状态中还少了个 running 状态，这其实是把两个不同层面的状态混淆了。对 Java 线程状态而言，不存在所谓的running 状态，它的 runnable 状态包含了 running 状态。</p><p>我们可能会问，为何 JVM 中没有去区分这两种状态呢？现在的<strong>时分</strong>（time-sharing）<strong>多任务</strong>（multi-task）操作系统架构通常都是用所谓的“<strong>时间分片</strong>（time quantum or time slice）”方式进行<strong>抢占式</strong>（preemptive）轮转调度（round-robin式）。</p><blockquote><p>更复杂的可能还会加入优先级（priority）的机制。</p></blockquote><p>这个时间分片通常是很小的，一个线程一次最多只能在 cpu 上运行比如10-20ms 的时间（此时处于 running 状态），也即大概只有0.01秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）</p><p>这一切换的过程称为线程的<strong>上下文切换</strong>（context switch），当然 cpu 不是简单地把线程踢开就完了，还需要把被相应的执行状态保存到内存中以便后续的恢复执行。显然，10-20ms 对人而言是很快的，</p><blockquote><p>不计切换开销（每次在1ms 以内），相当于1秒内有50-100次切换。事实上时间片经常没用完，线程就因为各种原因被中断，实际发生的切换次数还会更多。</p></blockquote><p>也这正是<strong>单核 *CPU 上实现所谓的“</strong>并发*（concurrent）”的基本原理，但其实是快速切换所带来的假象，这有点类似一个手脚非常快的杂耍演员可以让好多个球同时在空中运转那般。</p><p>时间分片也是可配置的，如果不追求在多个线程间很快的响应，也可以把这个时间配置得大一点，以减少切换带来的开销。如果是多核CPU，才有可能实现真正意义上的并发，这种情况通常也叫<strong>并行</strong>（pararell），不过你可能也会看到这两词会被混着用，这里就不去纠结它们的区别了。</p><p>通常，Java的线程状态是服务于监控的，如果线程切换得是如此之快，那么区分 ready 与 running 就没什么太大意义了。</p><p>当你看到监控上显示是 running 时，对应的线程可能早就被切换下去了，甚至又再次地切换了上来，也许你只能看到 ready 与 running 两个状态在快速地闪烁。当然，对于精确的性能评估而言，获得准确的 running 时间是有必要的。</p><p>现今主流的 JVM 实现都把 Java 线程一一映射到操作系统底层的线程上，把调度委托给了操作系统，我们在虚拟机层面看到的状态实质是对底层状态的映射及包装。JVM 本身没有做什么实质的调度，把底层的 ready 及 running 状态映射上来也没多大意义，因此，统一成为runnable 状态是不错的选择。</p><blockquote><p>我们将看到，Java 线程状态的改变通常只与自身显式引入的机制有关。</p></blockquote><p>我们知道传统的I/O都是阻塞式（blocked）的，原因是I/O操作比起cpu来实在是太慢了，可能差到好几个数量级都说不定。如果让 cpu 去等I/O 的操作，很可能时间片都用完了，I/O 操作还没完成呢，不管怎样，它会导致 cpu 的利用率极低。所以，解决办法就是：一旦线程中执行到 I/O 有关的代码，相应线程立马被切走，然后调度 ready 队列中另一个线程来运行。这时执行了 I/O 的线程就不再运行，即所谓的被阻塞了。它也不会被放到调度队列中去，因为很可能再次调度到它时，I/O 可能仍没有完成。线程会被放到所谓的等待队列中，处于上图中的 waiting 状态：</p><p>当然了，我们所谓阻塞只是指这段时间 cpu 暂时不会理它了，但另一个部件比如硬盘则在努力地为它服务。cpu 与硬盘间是并发的。如果把线程视作为一个 job，这一 job 由 cpu 与硬盘交替协作完成，当在 cpu 上是 waiting 时，在硬盘上却处于 running，只是我们在操作系统层面讨论线程状态时通常是围绕着 cpu 这一中心去述说的。而当 I/O 完成时，则用一种叫<strong>中断</strong>（interrupt）的机制来通知 cpu：也即所谓的“<strong>中断驱动</strong>（interrupt-driven）”，现代操作系统基本都采用这一机制。某种意义上，这也是<strong>控制反转</strong>（IoC）机制的一种体现，cpu不用反复去询问硬盘，这也是所谓的“好莱坞原则”—Don’t call us, we will call you.好莱坞的经纪人经常对演员们说：“别打电话给我，（有戏时）我们会打电话给你。”在这里，硬盘与 cpu 的互动机制也是类似，硬盘对 cpu 说：”别老来问我 IO 做完了没有，完了我自然会通知你的“当然了，cpu 还是要不断地检查中断，就好比演员们也要时刻注意接听电话，不过这总好过不断主动去询问，毕竟绝大多数的询问都将是徒劳的。cpu 会收到一个比如说来自硬盘的中断信号，并进入中断处理例程，手头正在执行的线程因此被打断，回到 ready 队列。而先前因 I/O 而waiting 的线程随着 I/O 的完成也再次回到 ready 队列，这时 cpu 可能会选择它来执行。另一方面，所谓的时间分片轮转本质上也是由一个定时器定时中断来驱动的，可以使线程从 running 回到 ready 状态.</p><p>现在我们再看一下 Java 中定义的线程状态，嘿，它也有 BLOCKED（阻塞），也有 WAITING（等待），甚至它还更细，还有TIMED_WAITING：</p><p><strong>现在问题来了，进行阻塞式 I/O 操作时，Java 的线程状态究竟是什么？是 BLOCKED？还是 WAITING？</strong></p><p>可能你已经猜到，既然放到 RUNNABLE 这一主题下讨论，其实状态还是 RUNNABLE。我们也可以通过一些测试来验证这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">@Test</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInBlockedIOState</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">&gt;     Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">&gt;     <span class="comment">// 创建一个名为“输入输出”的线程t</span></span><br><span class="line">&gt;     Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt;         <span class="meta">@Override</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;             <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                 <span class="comment">// 命令行中的阻塞读</span></span><br><span class="line">&gt;                 String input = in.nextLine();</span><br><span class="line">&gt;                 System.out.println(input);</span><br><span class="line">&gt;             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&gt;                 e.printStackTrace();</span><br><span class="line">&gt;             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&gt;               IOUtils.closeQuietly(in);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;, <span class="string">"输入输出"</span>); <span class="comment">// 线程的名字</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt;     <span class="comment">// 启动</span></span><br><span class="line">&gt;     t.start();</span><br><span class="line">&gt;  </span><br><span class="line">&gt;     <span class="comment">// 确保run已经得到执行</span></span><br><span class="line">&gt;     Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&gt;  </span><br><span class="line">&gt;     <span class="comment">// 状态为RUNNABLE</span></span><br><span class="line">&gt;     assertThat(t.getState()).isEqualTo(Thread.State.RUNNABLE);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在最后的语句上加一断点，监控上也反映了这一点：</p><p>网络阻塞时同理，比如socket.accept，我们说这是一个“阻塞式(blocked)”式方法，但线程状态还是 RUNNABLE。</p><p>当然，Java 很早就引入了所谓 nio（新的IO）包，至于用 nio 时线程状态究竟是怎样的，这里就不再一一具体去分析了。</p><blockquote><p>至少我们看到了，进行传统上的 IO 操作时，口语上我们也会说“阻塞”，但这个“阻塞”与线程的 BLOCKED 状态是两码事！</p></blockquote><p><u>如何看待RUNNABLE状态？</u></p><p>要分两个层面看待，JVM层面和OS层面</p><p>当进行阻塞式的 IO 操作时，或许底层的操作系统线程确实处在阻塞状态，但我们关心的是 JVM 的线程状态。</p><blockquote><p>JVM 并不关心底层的实现细节，什么时间分片也好，什么 IO 时就要切换也好，它并不关心。</p></blockquote><p>前面说到，“处于 runnable 状态下的线程正在* Java 虚拟机<strong>中执行，但它</strong>可能正在等待*来自于操作系统的其它资源，比如处理器。”</p><p>JVM 把那些都视作资源，cpu 也好，硬盘，网卡也罢，有东西在为线程服务，它就认为线程在“执行”。</p><p>处于 IO 阻塞，只是说 cpu 不执行线程了，但网卡可能还在监听呀，虽然可能暂时没有收到数据：</p><p>所以 JVM 认为线程还在执行。而操作系统的线程状态是围绕着 cpu 这一核心去述说的，这与 JVM 的侧重点是有所不同的。</p><p>前面我们也强调了“Java 线程状态的改变通常只与自身显式引入的机制有关”，如果 JVM 中的线程状态发生改变了，通常是自身机制引发的。</p><p>比如 synchronize 机制有可能让线程进入BLOCKED 状态，sleep，wait等方法则可能让其进入 WATING 之类的状态。</p><p>它与传统的线程状态的对应可以如下来看：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gm4jjiq30vj20k10bkgnf.jpg" alt="1.png"></p></blockquote><h3 id="BLOCKED-和-WAITING-的区别"><a href="#BLOCKED-和-WAITING-的区别" class="headerlink" title="BLOCKED 和 WAITING 的区别"></a>BLOCKED 和 WAITING 的区别</h3><p>虽然 BLOCKED 和 WAITING 都有等待的含义，但二者有着本质的区别，首先它们状态形成的调用方法不同，其次 BLOCKED 可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而 WAITING 则是因为自身调用了 Object.wait() 或着是 Thread.join() 又或者是 LockSupport.park() 而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了 Object.wait() 而进入 WAITING 状态之后，则需要等待另一个线程执行 Object.notify() 或 Object.notifyAll() 才能被唤醒。</p><h3 id="start-和-run-的区别"><a href="#start-和-run-的区别" class="headerlink" title="start() 和 run() 的区别"></a>start() 和 run() 的区别</h3><p>首先从 Thread 源码来看，start() 方法属于 Thread 自身的方法，并且使用了 synchronized 来保证线程安全，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态验证，不等于 NEW 的状态会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    <span class="comment">// 通知线程组，此线程即将启动</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">// 不处理任何异常，如果 start0 抛出异常，则它将被传递到调用堆栈上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run() 方法为 Runnable 的抽象方法，必须由调用类重写此方法，重写的 run() 方法其实就是此线程要执行的业务方法</p><p>从执行的效果来说，start() 方法可以开启多线程，让线程从 NEW 状态转换成 RUNNABLE 状态，而 run() 方法只是一个普通的方法。</p><p>其次，它们可调用的次数不同，start() 方法不能被多次调用，否则会抛出 java.lang.IllegalStateException；而 run() 方法可以进行多次调用，因为它只是一个普通的方法而已。</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在 Thread 源码中和线程优先级相关的属性有 3 个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程可以拥有的最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 线程默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 线程可以拥有的最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>线程的优先级可以理解为线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。</p><p>在程序中我们可以通过 Thread.setPriority() 来设置优先级，setPriority() 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">// 先验证优先级的合理性</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优先级如果超过线程组的最高优先级，则把优先级设置为线程组的最高优先级</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>在一个线程中调用 other.join() ，这时候当前线程会让出执行权给 other 线程，直到 other 线程执行完或者过了超时时间之后再继续执行当前线程，join() 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 超时时间不能小于 0</span></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等于 0 表示无限等待，直到线程执行完为之</span></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断子线程 (其他线程) 为活跃线程，则一直等待</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 循环判断</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            wait(delay);</span><br><span class="line"></span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出 join() 方法底层还是通过 wait() 方法来实现的。</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>看 Thread 的源码可以知道 yield() 为本地方法，也就是说 yield() 是由 C 或 C++ 实现的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>yield() 方法表示给线程调度器一个当前线程愿意出让 CPU 使用权的暗示，但是线程调度器可能会忽略这个暗示。</p><p>比如我们执行这段包含了 yield() 方法的代码，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Runnable runnable = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.println(&quot;线程：&quot; +</span><br><span class="line">                        Thread.currentThread().getName() + &quot; I：&quot; + i);</span><br><span class="line">                if (i == 5) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(runnable, &quot;T1&quot;);</span><br><span class="line">    Thread t2 = new Thread(runnable, &quot;T2&quot;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把这段代码执行多次之后会发现，每次执行的结果都不相同，这是因为 yield() 执行非常不稳定，线程调度器不一定会采纳 yield() 出让 CPU 使用权的建议，从而导致了这样的结果。</p><h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><p>线程池是为了避免线程频繁的创建和销毁带来的性能消耗，而建立的一种池化技术，它是把已创建的线程放入“池”中，当有任务来临时就可以重用已有的线程，无需等待创建的过程，这样就可以有效提高程序的响应速度。但如果要说线程池的话一定离不开 ThreadPoolExecutor ，在阿里巴巴的《Java 开发手册》中是这样规定线程池的：</p><blockquote><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明：Executors 返回的线程池对象的弊端如下：</p><p>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。<br>CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></blockquote><p>其实当我们去看 Executors 的源码会发现，Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor() 和 Executors.newCachedThreadPool() 等方法的底层都是通过 ThreadPoolExecutor 实现的，所以本课时我们就重点来了解一下 ThreadPoolExecutor 的相关知识，比如它有哪些核心的参数？它是如何工作的？</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210101205249.png" alt="image-20210101205249848"></p><p>第 1 个参数：corePoolSize 表示线程池的常驻核心线程数。如果设置为 0，则表示在没有任何任务时，销毁线程池；如果大于 0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程（创建和销毁的原因会在本课时的下半部分讲到）；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。</p><p>第 2 个参数：maximumPoolSize 表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于 0，也必须大于等于 corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。</p><p>第 3 个参数：keepAliveTime 表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于 corePoolSize 为止，如果 maximumPoolSize 等于 corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。</p><p>第 4 个参数：unit 表示存活时间的单位，它是配合 keepAliveTime 参数共同使用的。</p><p>第 5 个参数：workQueue 表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。</p><p>第 6 个参数：threadFactory 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程，源代码如下</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210101205426.png" alt="image-20210101205426204"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Executors.defaultThreadFactory() 为默认的线程创建工厂</span></span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的线程创建工厂，需要实现 ThreadFactory 接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon()) </span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>); <span class="comment">// 创建一个非守护线程</span></span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY); <span class="comment">// 线程优先级设置为默认值</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以自定义一个线程工厂，通过实现 ThreadFactory 接口来完成，这样就可以自定义线程的名称或线程执行的优先级了。</p><p>第 7 个参数：<strong>RejectedExecutionHandler</strong> 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。</p><p>线程池的工作流程要从它的执行方法 <strong>execute()</strong> 说起，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前工作的线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 创建新的线程执行此任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池是否处于运行状态，如果是则把任务添加到队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再出检查线程池是否处于运行状态，防止在第一次校验通过后线程池关闭</span></span><br><span class="line">        <span class="comment">// 如果是非运行状态，则将刚加入队列的任务移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池的线程数为 0 时（当 corePoolSize 设置为 0 时会发生）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 新建线程执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程都在忙且队列都已爆满，尝试新启动一个线程执行失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) </span><br><span class="line">        <span class="comment">// 执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以自定义一个线程工厂，通过实现 ThreadFactory 接口来完成，这样就可以自定义线程的名称或线程执行的优先级了。</p><p>第 7 个参数：RejectedExecutionHandler 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。</p><p>线程池的工作流程要从它的执行方法 execute() 说起，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前工作的线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 创建新的线程执行此任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池是否处于运行状态，如果是则把任务添加到队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再出检查线程池是否处于运行状态，防止在第一次校验通过后线程池关闭</span></span><br><span class="line">        <span class="comment">// 如果是非运行状态，则将刚加入队列的任务移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池的线程数为 0 时（当 corePoolSize 设置为 0 时会发生）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 新建线程执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程都在忙且队列都已爆满，尝试新启动一个线程执行失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) </span><br><span class="line">        <span class="comment">// 执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本课时的这道面试题考察的是你对于线程池和 ThreadPoolExecutor 的掌握程度，也属于 Java 的基础知识，几乎所有的面试都会被问到，其中线程池任务执行的主要流程，可以参考以下流程图：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210101210115.png" alt="image-20210101210115668"></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="ThreadPoolExecutor-的执行方法有几种？它们有什么区别？"><a href="#ThreadPoolExecutor-的执行方法有几种？它们有什么区别？" class="headerlink" title="ThreadPoolExecutor 的执行方法有几种？它们有什么区别？"></a>ThreadPoolExecutor 的执行方法有几种？它们有什么区别？</h3><blockquote><p>execute() VS submit()</p></blockquote><blockquote><p>execute() 和 submit() 都是用来执行线程池任务的，它们最主要的区别是，submit() 方法可以接收线程池执行的返回值，而 execute() 不能接收返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10L</span>,</span><br><span class="line">&gt;         TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">20</span>));</span><br><span class="line">&gt; <span class="comment">// execute 使用</span></span><br><span class="line">&gt; executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"Hello, execute."</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// submit 使用</span></span><br><span class="line">&gt; Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"Hello, submit."</span>);</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="string">"Success"</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt; </span><br><span class="line">&gt; System.out.println(future.get());</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>程序执行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; Hello, submit.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Hello, execute.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Success</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>从以上结果可以看出 submit() 方法可以配合 Futrue 来接收线程执行的返回值。它们的另一个区别是 execute() 方法属于 Executor 接口的方法，而 submit() 方法则是属于 ExecutorService 接口的方法，它们的继承关系如下图所示：</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210101210323.png" alt="image-20210101210323524"></p></blockquote><h3 id="什么是线程的拒绝策略？"><a href="#什么是线程的拒绝策略？" class="headerlink" title="什么是线程的拒绝策略？"></a>什么是线程的拒绝策略？</h3><blockquote><p>当线程池中的任务队列已经被存满，再有任务添加时会先判断当前线程池中的线程数是否大于等于线程池的最大值，如果是，则会触发线程池的拒绝策略。</p></blockquote><h3 id="拒绝策略的分类有哪些？"><a href="#拒绝策略的分类有哪些？" class="headerlink" title="拒绝策略的分类有哪些？"></a>拒绝策略的分类有哪些？</h3><p>Java 自带的拒绝策略有 4 种：</p><ul><li><strong>AbortPolicy</strong>，终止策略，线程池会抛出异常并终止执行，它是默认的拒绝策略；</li><li><strong>CallerRunsPolicy</strong>，把任务交给当前线程来执行；</li><li><strong>DiscardPolicy</strong>，忽略此任务（最新的任务）；</li><li><strong>DiscardOldestPolicy</strong>，忽略最早的任务（最先加入队列的任务）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()); <span class="comment">// 添加 AbortPolicy 拒绝策略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line"></span><br><span class="line">pool-1-thread-1</span><br><span class="line"></span><br><span class="line">pool-1-thread-1</span><br><span class="line"></span><br><span class="line">pool-1-thread-3</span><br><span class="line"></span><br><span class="line">pool-1-thread-2</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.lagou.interview.ThreadPoolExample$$Lambda$1/1096979270@448139f0 rejected from java.util.concurrent.ThreadPoolExecutor@7cca494b[Running, pool size = 3, active threads = 3, queued tasks = 2, completed tasks = 0]</span><br><span class="line"></span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)</span><br><span class="line"></span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)</span><br><span class="line"></span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)</span><br><span class="line"></span><br><span class="line"> at com.lagou.interview.ThreadPoolExample.rejected(ThreadPoolExample.java:35)</span><br><span class="line"></span><br><span class="line"> at com.lagou.interview.ThreadPoolExample.main(ThreadPoolExample.java:26)</span><br></pre></td></tr></table></figure><p>可以看出当第 6 个任务来的时候，线程池则执行了 AbortPolicy  拒绝策略，抛出了异常。因为队列最多存储 2 个任务，最大可以创建 3 个线程来执行任务（2+3=5），所以当第 6 个任务来的时候，此线程池就“忙”不过来了。</p><h3 id="如何自定义拒绝策略？"><a href="#如何自定义拒绝策略？" class="headerlink" title="如何自定义拒绝策略？"></a>如何自定义拒绝策略？</h3><blockquote><p>自定义拒绝策略只需要新建一个 RejectedExecutionHandler 对象，然后重写它的 rejectedExecution() 方法即可，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">&gt;         TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">&gt;         <span class="keyword">new</span> RejectedExecutionHandler() &#123;  <span class="comment">// 添加自定义拒绝策略</span></span><br><span class="line">&gt;             <span class="meta">@Override</span></span><br><span class="line">&gt;             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">&gt;                 <span class="comment">// 业务处理方法</span></span><br><span class="line">&gt;                 System.out.println(<span class="string">"执行自定义拒绝策略"</span>);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;);</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">&gt;     executor.execute(() -&gt; &#123;</span><br><span class="line">&gt;         System.out.println(Thread.currentThread().getName());</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可以看出线程池执行了自定义的拒绝策略，我们可以在 rejectedExecution 中添加自己业务处理的代码。</p></blockquote><h3 id="ThreadPoolExecutor-能不能实现扩展？如何实现扩展？"><a href="#ThreadPoolExecutor-能不能实现扩展？如何实现扩展？" class="headerlink" title="ThreadPoolExecutor 能不能实现扩展？如何实现扩展？"></a>ThreadPoolExecutor 能不能实现扩展？如何实现扩展？</h3><blockquote><p>ThreadPoolExecutor 的扩展主要是通过重写它的 beforeExecute() 和 afterExecute() 方法实现的，我们可以在扩展方法中添加日志或者实现数据统计，比如统计线程的执行时间，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExtend</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">&gt;         <span class="comment">// 线程池扩展调用</span></span><br><span class="line">&gt;         MyThreadPoolExecutor executor = <span class="keyword">new</span> MyThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">&gt;                 TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue());</span><br><span class="line">&gt;         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">&gt;             executor.execute(() -&gt; &#123;</span><br><span class="line">&gt;                 Thread.currentThread().getName();</span><br><span class="line">&gt;             &#125;);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;      * 线程池扩展</span></span><br><span class="line"><span class="comment">&gt;      */</span></span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">&gt;         <span class="comment">// 保存线程执行开始时间</span></span><br><span class="line">&gt;         <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; localTime = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt;                             TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;         <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;          * 开始执行之前</span></span><br><span class="line"><span class="comment">&gt;          * <span class="doctag">@param</span> t 线程</span></span><br><span class="line"><span class="comment">&gt;          * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">&gt;          */</span></span><br><span class="line">&gt;         <span class="meta">@Override</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">&gt;             Long sTime = System.nanoTime(); <span class="comment">// 开始时间 (单位：纳秒)</span></span><br><span class="line">&gt;             localTime.set(sTime);</span><br><span class="line">&gt;             System.out.println(String.format(<span class="string">"%s | before | time=%s"</span>,</span><br><span class="line">&gt;                     t.getName(), sTime));</span><br><span class="line">&gt;             <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;          * 执行完成之后</span></span><br><span class="line"><span class="comment">&gt;          * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">&gt;          * <span class="doctag">@param</span> t 抛出的异常</span></span><br><span class="line"><span class="comment">&gt;          */</span></span><br><span class="line">&gt;         <span class="meta">@Override</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">&gt;             Long eTime = System.nanoTime(); <span class="comment">// 结束时间 (单位：纳秒)</span></span><br><span class="line">&gt;             Long totalTime = eTime - localTime.get(); <span class="comment">// 执行总时间</span></span><br><span class="line">&gt;             System.out.println(String.format(<span class="string">"%s | after | time=%s | 耗时：%s 毫秒"</span>,</span><br><span class="line">&gt;                     Thread.currentThread().getName(), eTime, (totalTime / <span class="number">1000000.0</span>)));</span><br><span class="line">&gt;             <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>以上程序的执行结果如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">1</span> | before | time=<span class="number">4570298843700</span></span><br><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">2</span> | before | time=<span class="number">4570298840000</span></span><br><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">1</span> | after | time=<span class="number">4570327059500</span> | 耗时：<span class="number">28.2158</span> 毫秒</span><br><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">2</span> | after | time=<span class="number">4570327138100</span> | 耗时：<span class="number">28.2981</span> 毫秒</span><br><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">1</span> | before | time=<span class="number">4570328467800</span></span><br><span class="line">&gt; pool-<span class="number">1</span>-thread-<span class="number">1</span> | after | time=<span class="number">4570328636800</span> | 耗时：<span class="number">0.169</span> 毫秒</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="独占锁、共享锁、更新锁，乐观锁、悲观锁"><a href="#独占锁、共享锁、更新锁，乐观锁、悲观锁" class="headerlink" title="独占锁、共享锁、更新锁，乐观锁、悲观锁"></a>独占锁、共享锁、更新锁，乐观锁、悲观锁</h1><h2 id="从数据库系统的角度来看，锁分为以下三种类型"><a href="#从数据库系统的角度来看，锁分为以下三种类型" class="headerlink" title="从数据库系统的角度来看，锁分为以下三种类型"></a>从数据库系统的角度来看，锁分为以下三种类型</h2><h3 id="独占锁（Exclusive-Lock）"><a href="#独占锁（Exclusive-Lock）" class="headerlink" title="独占锁（Exclusive Lock）"></a>独占锁（Exclusive Lock）</h3><p>   独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。执行数据更新命令，即INSERT、 UPDATE 或DELETE 命令时，SQL Server 会自动使用独占锁。但当对象上有其它锁存在时，无法对其加独占锁。独占锁一直到事务结束才能被释放。</p><h3 id="共享锁（Shared-Lock）"><a href="#共享锁（Shared-Lock）" class="headerlink" title="共享锁（Shared Lock）"></a>共享锁（Shared Lock）</h3><p>   共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。在SELECT 命令执行时，SQL Server 通常会对对象进行共享锁锁定。通常加共享锁的数据页被读取完毕后，共享锁就会立即被释放。</p><h3 id="更新锁（Update-Lock）"><a href="#更新锁（Update-Lock）" class="headerlink" title="更新锁（Update Lock）"></a>更新锁（Update Lock）</h3><p>   更新锁是为了防止死锁而设立的。当SQL Server 准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到SQL Server 确定要进行更新数据操作时，它会自动将更新锁换为独占锁。但当对象上有其它锁存在时，无法对其作更新锁锁定。</p><h2 id="从程序员的角度看，锁分为以下两种类型"><a href="#从程序员的角度看，锁分为以下两种类型" class="headerlink" title="从程序员的角度看，锁分为以下两种类型"></a>从程序员的角度看，锁分为以下两种类型</h2><h3 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）"></a>悲观锁（Pessimistic Lock）</h3><p>   悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><h3 id="乐观锁（Optimistic-Lock）"><a href="#乐观锁（Optimistic-Lock）" class="headerlink" title="乐观锁（Optimistic Lock）"></a>乐观锁（Optimistic Lock）</h3><p>   相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。<br>   而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><h1 id="synchronized-amp-ReentrantLock"><a href="#synchronized-amp-ReentrantLock" class="headerlink" title="synchronized &amp; ReentrantLock"></a>synchronized &amp; ReentrantLock</h1><p>在 JDK 1.5 之前共享对象的协调机制只有 synchronized 和 volatile，在 JDK 1.5 中增加了新的机制 ReentrantLock，该机制的诞生并不是为了替代 synchronized，而是在 synchronized 不适用的情况下，提供一种可以选择的高级功能。</p><p>synchronized 属于独占式悲观锁，是通过 JVM 隐式实现的，synchronized 只允许同一时刻只有一个线程操作资源。</p><p>在 Java 中每个对象都隐式包含一个 monitor（监视器）对象，加锁的过程其实就是竞争 monitor 的过程，当线程进入字节码 monitorenter 指令之后，线程将持有 monitor 对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor 对象时，则需要阻塞等待获取该对象。</p><p>ReentrantLock 是 Lock 的默认实现方式之一，它是基于 AQS（Abstract Queued Synchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个 state 的状态字段用于表示锁是否被占用，如果是 0 则表示锁未被占用，此时线程就可以把 state 改为 1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。</p><p>synchronized 和 ReentrantLock 都提供了锁的功能，具备互斥性和不可见性。在 JDK 1.5 中 synchronized 的性能远远低于  ReentrantLock，但在 JDK 1.6 之后  synchronized 的性能略低于  ReentrantLock，它的区别如下：</p><blockquote><p>synchronized 是 JVM 隐式实现的，而 ReentrantLock 是 Java 语言提供的 API；<br>ReentrantLock 可设置为公平锁，而 synchronized 却不行；<br>ReentrantLock 只能修饰代码块，而 synchronized 可以用于修饰方法、修饰代码块等；<br>ReentrantLock 需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而 synchronized 无需手动释放锁；<br>ReentrantLock 可以知道是否成功获得了锁，而 synchronized  却不行。</p></blockquote><p>synchronized 和 ReentrantLock 是比线程池还要高频的面试问题，因为它包含了更多的知识点，且涉及到的知识点更加深入，对面试者的要求也更高，前面我们简要地介绍了 synchronized 和 ReentrantLock 的概念及执行原理，但很多大厂会更加深入的追问更多关于它们的实现细节，比如：</p><p>ReentrantLock 的具体实现细节是什么？<br>JDK 1.6 时锁做了哪些优化？</p><p>首先来看 ReentrantLock 的两个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(); <span class="comment">// 非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参的构造函数创建了一个非公平锁，用户也可以根据第二个构造函数，设置一个 boolean 类型的值，来决定是否使用公平锁来实现线程的调度。</p><p><strong>公平锁 VS 非公平锁</strong></p><p>公平锁的含义是线程需要按照请求的顺序来获得锁；而非公平锁则允许“插队”的情况存在，所谓的“插队”指的是，线程在发送请求的同时该锁的状态恰好变成了可用，那么此线程就可以跳过队列中所有排队的线程直接拥有该锁。</p><p>而公平锁由于有挂起和恢复所以存在一定的开销，因此性能不如非公平锁，所以 ReentrantLock 和 synchronized 默认都是非公平锁的实现方式。</p><p>ReentrantLock 是通过 lock() 来获取锁，并通过 unlock() 释放锁，使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">//......业务处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 中的 lock() 是通过 sync.lock() 实现的，但 Sync 类中的 lock() 是一个抽象方法，需要子类 NonfairSync 或 FairSync 去实现，NonfairSync 中的 lock() 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 将当前线程设置为此锁的持有者</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync 中的 lock() 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出非公平锁比公平锁只是多了一行 compareAndSetState 方法，该方法是尝试将 state 值由 0 置换为 1，如果设置成功的话，则说明当前没有其他线程持有该锁，不用再去排队了，可直接占用该锁，否则，则需要通过 acquire 方法去排队。</p><p>acquire 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire 方法尝试获取锁，如果获取锁失败，则把它加入到阻塞队列中，来看 tryAcquire 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 公平锁比非公平锁多了一行代码 !hasQueuedPredecessors() </span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//尝试获取锁</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">// 获取成功，标记被抢占</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc); <span class="comment">// set state=state+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于此方法来说，公平锁比非公平锁只多一行代码 !hasQueuedPredecessors()，它用来查看队列中是否有比它等待时间更久的线程，如果没有，就尝试一下是否能获取到锁，如果获取成功，则标记为已经被占用。</p><p>如果获取锁失败，则调用 addWaiter 方法把线程包装成 Node 对象，同时放入到队列中，但 addWaiter 方法并不会尝试获取锁，acquireQueued 方法才会尝试获取锁，如果获取失败，则此节点会被挂起，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列中的线程尝试获取锁，失败则会被挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// 获取锁是否成功的状态标识</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 线程是否被中断</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前一个节点（前驱节点）</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 当前节点为头节点的下一个节点时，有权尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node); <span class="comment">// 获取成功，将当前节点设置为 head 节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// 原 head 节点出队，等待被 GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">// 获取成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断获取锁失败后是否可以挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 线程若被中断，返回 true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会使用 for(;;) 无限循环的方式来尝试获取锁，若获取失败，则调用 shouldParkAfterFailedAcquire 方法，尝试挂起当前线程，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断线程是否可以被挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的状态为 SIGNAL，当前线程可以被挂起（阻塞）</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 若前驱节点状态为 CANCELLED，那就一直往前找，直到找到一个正常等待的状态为止</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 并将当前节点排在它后边</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 把前驱节点的状态修改为 SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程入列被挂起的前提条件是，前驱节点的状态为 SIGNAL，SIGNAL 状态的含义是后继节点处于等待状态，当前节点释放锁后将会唤醒后继节点。所以在上面这段代码中，会先判断前驱节点的状态，如果为 SIGNAL，则当前线程可以被挂起并返回 true；如果前驱节点的状态 &gt;0，则表示前驱节点取消了，这时候需要一直往前找，直到找到最近一个正常等待的前驱节点，然后把它作为自己的前驱节点；如果前驱节点正常（未取消），则修改前驱节点状态为 SIGNAL。</p><p>到这里整个加锁的流程就已经走完了，最后的情况是，没有拿到锁的线程会在队列中被挂起，直到拥有锁的线程释放锁之后，才会去唤醒其他的线程去获取锁资源，整个运行流程如下图所示</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210102210705.png" alt="image-20210102210705684"></p><p>unlock 相比于 lock 来说就简单很多了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放成功</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁的释放流程为，先调用 tryRelease 方法尝试释放锁，如果释放成功，则查看头结点的状态是否为 SIGNAL，如果是，则唤醒头结点的下个节点关联的线程；如果释放锁失败，则返回 false。</p><p>tryRelease 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试释放当前线程占有的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 释放锁后的状态，0 表示释放锁成功</span></span><br><span class="line">    <span class="comment">// 如果拥有锁的线程不是当前线程的话抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 锁被成功释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">// 清空独占线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c); <span class="comment">// 更新 state 值，0 表示为释放锁成功</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 tryRelease 方法中，会先判断当前的线程是不是占用锁的线程，如果不是的话，则会抛出异常；如果是的话，则先计算锁的状态值 getState() - releases 是否为 0，如果为 0，则表示可以正常的释放锁，然后清空独占的线程，最后会更新锁的状态并返回执行结果。</p><h4 id="JDK-1-6-锁优化"><a href="#JDK-1-6-锁优化" class="headerlink" title="JDK 1.6 锁优化"></a>JDK 1.6 锁优化</h4><p><strong>自适应自旋锁</strong></p><p>JDK 1.5 在升级为 JDK 1.6 时，HotSpot 虚拟机团队在锁的优化上下了很大功夫，比如实现了自适应式自旋锁、锁升级等。</p><p>JDK 1.6 引入了自适应式自旋锁意味着自旋的时间不再是固定的时间了，比如在同一个锁对象上，如果通过自旋等待成功获取了锁，那么虚拟机就会认为，它下一次很有可能也会成功 (通过自旋获取到锁)，因此允许自旋等待的时间会相对的比较长，而当某个锁通过自旋很少成功获得过锁，那么以后在获取该锁时，可能会直接忽略掉自旋的过程，以避免浪费 CPU 的资源，这就是<strong>自适应自旋锁</strong>的功能。</p><p><strong>锁升级</strong></p><p>锁升级其实就是从偏向锁到轻量级锁再到重量级锁升级的过程，这是 JDK 1.6 提供的优化功能，也称之为锁膨胀。</p><p><strong>偏向锁</strong>是指在无竞争的情况下设置的一种锁状态。偏向锁的意思是它会偏向于第一个获取它的线程，当锁对象第一次被获取到之后，会在此对象头中设置标示为“01”，表示偏向锁的模式，并且在对象头中记录此线程的 ID，这种情况下，如果是持有偏向锁的线程每次在进入的话，不再进行任何同步操作，如 Locking、Unlocking 等，直到另一个线程尝试获取此锁的时候，偏向锁模式才会结束，偏向锁可以提高带有同步但无竞争的程序性能。但如果在多数锁总会被不同的线程访问时，偏向锁模式就比较多余了，此时可以通过 -XX:-UseBiasedLocking 来禁用偏向锁以提高性能。</p><p><strong>轻量锁</strong>是相对于重量锁而言的，在 JDK 1.6 之前，synchronized 是通过操作系统的互斥量（mutex lock）来实现的，这种实现方式需要在用户态和核心态之间做转换，有很大的性能消耗，这种传统实现锁的方式被称之为<strong>重量锁。</strong></p><p>而<strong>轻量锁</strong>是通过比较并交换（CAS，Compare and Swap）来实现的，它对比的是线程和对象的 Mark Word（对象头中的一个区域），如果更新成功则表示当前线程成功拥有此锁；如果失败，虚拟机会先检查对象的 Mark Word 是否指向当前线程的栈帧，如果是，则说明当前线程已经拥有此锁，否则，则说明此锁已经被其他线程占用了。当两个以上的线程争抢此锁时，轻量级锁就膨胀为重量级锁，这就是锁升级的过程，也是 JDK 1.6 锁优化的内容。</p><p>synchronized 刚开始为偏向锁，随着锁竞争越来越激烈，会升级为轻量级锁和重量级锁。如果大多数锁被不同的线程所争抢就不建议使用偏向锁了。</p><h1 id="对锁的理解"><a href="#对锁的理解" class="headerlink" title="对锁的理解"></a>对锁的理解</h1><p>在并发编程中有两个重要的概念：<strong>线程和锁</strong>，多线程是一把双刃剑，它在提高程序性能的同时，也带来了编码的复杂性，对开发者的要求也提高了一个档次。而锁的出现就是为了保障多线程在同时操作一组资源时的数据一致性，当我们给资源加上锁之后，只有拥有此锁的线程才能操作此资源，而其他线程只能排队等待使用此锁。</p><p>如何手动模拟一个死锁？谈谈你对锁的理解。</p><h3 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h3><p>死锁是指两个线程同时占用两个资源，又在彼此等待对方释放锁资源，如下图所示</p><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210103233851.png" alt="image-20210103233851837"></p><p>死锁的代码演示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">public class LockExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        deadLock(); // 死锁</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 死锁</span><br><span class="line">     */</span><br><span class="line">    private static void deadLock() &#123;</span><br><span class="line">        Object lock1 = new Object();</span><br><span class="line">        Object lock2 = new Object();</span><br><span class="line">        // 线程一拥有 lock1 试图获取 lock2</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock1) &#123;</span><br><span class="line">                System.out.println(&quot;获取 lock1 成功&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // 试图获取锁 lock2</span><br><span class="line">                synchronized (lock2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        // 线程二拥有 lock2 试图获取 lock1</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock2) &#123;</span><br><span class="line">                System.out.println(&quot;获取 lock2 成功&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // 试图获取锁 lock1</span><br><span class="line">                synchronized (lock1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取 lock1 成功</span><br><span class="line">获取 lock2 成功</span><br></pre></td></tr></table></figure><p>可以看出当我们使用线程一拥有锁 lock1 的同时试图获取 lock2，而线程二在拥有 lock2 的同时试图获取 lock1，这样就会造成彼此都在等待对方释放资源，于是就形成了<strong>死锁</strong>。</p><p>锁是指在并发编程中，当有多个线程同时操作一个资源时，为了保证数据操作的正确性，我们需要让多线程排队一个一个地操作此资源，而这个过程就是给资源加锁和释放锁的过程，就好像去公共厕所一样，必须一个一个排队使用，并且在使用时需要锁门和开门一样。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>锁的概念不止出现在 Java 语言中，比如<strong>乐观锁和悲观锁</strong>其实很早就存在于数据库中了。锁的概念其实不难理解，但要真正地了解锁的原理和实现过程，才能打动面试官。</p><p>和锁相关的面试问题，还有以下几个：</p><ul><li>什么是乐观锁和悲观锁？它们的应用都有哪些？乐观锁有什么问题？</li><li>什么是可重入锁？用代码如何实现？它的实现原理是什么？</li><li>什么是共享锁和独占锁？</li></ul><h3 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h3><h4 id="1-悲观锁和乐观锁"><a href="#1-悲观锁和乐观锁" class="headerlink" title="1. 悲观锁和乐观锁"></a>1. 悲观锁和乐观锁</h4><p>悲观锁指的是数据对外界的修改采取保守策略，它认为线程很容易会把数据修改掉，因此在整个数据被修改的过程中都会采取锁定状态，直到一个线程使用完，其他线程才可以继续使用。</p><p>我们来看一下悲观锁的实现流程，以 synchronized 为例，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class LockExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        synchronized (LockExample.class) &#123;</span><br><span class="line">            System.out.println(&quot;lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用反编译工具查到的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;LockExample.java&quot;</span><br><span class="line">public class com.lagou.interview.ext.LockExample &#123;</span><br><span class="line">  public com.lagou.interview.ext.LockExample();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"> </span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // class com/lagou/interview/ext/LockExample</span><br><span class="line">       2: dup</span><br><span class="line">       3: astore_1</span><br><span class="line">       4: monitorenter // 加锁</span><br><span class="line">       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       8: ldc           #4                  // String lock</span><br><span class="line">      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      13: aload_1</span><br><span class="line">      14: monitorexit // 释放锁</span><br><span class="line">      15: goto          23</span><br><span class="line">      18: astore_2</span><br><span class="line">      19: aload_1</span><br><span class="line">      20: monitorexit</span><br><span class="line">      21: aload_2</span><br><span class="line">      22: athrow</span><br><span class="line">      23: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           5    15    18   any</span><br><span class="line">          18    21    18   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出被 synchronized 修饰的代码块，在执行之前先使用 monitorenter 指令加锁，然后在执行结束之后再使用 monitorexit 指令释放锁资源，在整个执行期间此代码都是锁定的状态，这就是<strong>典型悲观锁的实现流程</strong>。</p><p>乐观锁和悲观锁的概念恰好相反，乐观锁认为一般情况下数据在修改时不会出现冲突，所以在数据访问之前不会加锁，只是在数据提交更改时，才会对数据进行检测。</p><p>Java 中的乐观锁大部分都是通过 CAS（Compare And Swap，比较并交换）操作实现的，CAS 是一个多线程同步的原子指令，CAS 操作包含三个重要的信息，即内存位置、预期原值和新值。如果内存位置的值和预期的原值相等的话，那么就可以把该位置的值更新为新值，否则不做任何修改。</p><p>CAS 可能会造成 ABA 的问题，ABA 问题指的是，线程拿到了最初的预期原值 A，然而在将要进行 CAS 的时候，被其他线程抢占了执行权，把此值从 A 变成了 B，然后其他线程又把此值从 B 变成了 A，然而此时的 A 值已经并非原来的 A 值了，但最初的线程并不知道这个情况，在它进行 CAS 的时候，只对比了预期原值为 A 就进行了修改，这就造成了 ABA 的问题。</p><p>以警匪剧为例，假如某人把装了 100W 现金的箱子放在了家里，几分钟之后要拿它去赎人，然而在趁他不注意的时候，进来了一个小偷，用空箱子换走了装满钱的箱子，当某人进来之后看到箱子还是一模一样的，他会以为这就是原来的箱子，就拿着它去赎人了，这种情况肯定有问题，因为箱子已经是空的了，这就是 ABA 的问题。</p><p>ABA 的常见处理方式是添加版本号，每次修改之后更新版本号，拿上面的例子来说，假如每次移动箱子之后，箱子的位置就会发生变化，而这个变化的位置就相当于“版本号”，当某人进来之后发现箱子的位置发生了变化就知道有人动了手脚，就会放弃原有的计划，这样就解决了 ABA 的问题。</p><p>JDK 在 1.5 时提供了 AtomicStampedReference 类也可以解决 ABA 的问题，此类维护了一个“版本号” Stamp，每次在比较时不止比较当前值还比较版本号，这样就解决了 ABA 的问题。</p><p>相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicStampedReference&lt;V&gt; &#123;</span><br><span class="line">    private static class Pair&lt;T&gt; &#123;</span><br><span class="line">        final T reference;</span><br><span class="line">        final int stamp; // “版本号”</span><br><span class="line">        private Pair(T reference, int stamp) &#123;</span><br><span class="line">            this.reference = reference;</span><br><span class="line">            this.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;</span><br><span class="line">            return new Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 比较并设置</span><br><span class="line">    public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                                 V   newReference,</span><br><span class="line">                                 int expectedStamp, // 原版本号</span><br><span class="line">                                 int newStamp) &#123; // 新版本号</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        return</span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line">    //.......省略其他源码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出它在修改时会进行原值比较和版本号比较，当比较成功之后会修改值并修改版本号。</p><blockquote><p>小贴士：乐观锁有一个优点，它在提交的时候才进行锁定的，因此不会造成死锁。</p></blockquote><h4 id="2-可重入锁"><a href="#2-可重入锁" class="headerlink" title="2. 可重入锁"></a>2. 可重入锁</h4><p>可重入锁也叫<strong>递归锁</strong>，指的是同一个线程，如果外面的函数拥有此锁之后，内层的函数也可以继续获取该锁。在 Java 语言中 ReentrantLock 和 synchronized 都是可重入锁。</p><p>下面我们用 synchronized 来演示一下什么是可重入锁，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LockExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        reentrantA(); // 可重入锁</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 可重入锁 A 方法</span><br><span class="line">     */</span><br><span class="line">    private synchronized static void reentrantA() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;：执行 reentrantA&quot;);</span><br><span class="line">        reentrantB();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 可重入锁 B 方法</span><br><span class="line">     */</span><br><span class="line">    private synchronized static void reentrantB() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;：执行 reentrantB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main：执行 reentrantA</span><br><span class="line">main：执行 reentrantB</span><br></pre></td></tr></table></figure><p>从结果可以看出 reentrantA 方法和 reentrantB 方法的执行线程都是“main” ，我们调用了 reentrantA 方法，它的方法中嵌套了 reentrantB，如果 synchronized 是不可重入的话，那么线程会被一直堵塞。</p><p>可重入锁的实现原理，是在锁内部存储了一个线程标识，用于判断当前的锁属于哪个线程，并且锁的内部维护了一个计数器，当锁空闲时此计数器的值为 0，当被线程占用和重入时分别加 1，当锁被释放时计数器减 1，直到减到 0 时表示此锁为空闲状态。</p><h4 id="3-共享锁和独占锁"><a href="#3-共享锁和独占锁" class="headerlink" title="3. 共享锁和独占锁"></a>3. 共享锁和独占锁</h4><p>只能被单线程持有的锁叫<strong>独占锁</strong>，可以被多线程持有的锁叫<strong>共享锁</strong>。</p><p>独占锁指的是在任何时候最多只能有一个线程持有该锁，比如 synchronized 就是独占锁，而 ReadWriteLock 读写锁允许同一时间内有多个线程进行读操作，它就属于共享锁。</p><p>独占锁可以理解为悲观锁，当每次访问资源时都要加上互斥锁，而共享锁可以理解为乐观锁，它放宽了加锁的条件，允许多线程同时访问该资源。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>悲观锁和乐观锁，悲观锁的典型应用为 synchronized，它的特性为独占式互斥锁；而乐观锁相比于悲观锁而言，拥有更好的性能，但乐观锁可能会导致 ABA 的问题，常见的解决方案是添加版本号来防止 ABA 问题的发生。同时，还讲了可重入锁，在 Java 中，synchronized 和 ReentrantLock 都是可重入锁。最后，讲了独占锁和共享锁，其中独占锁可以理解为悲观锁，而共享锁可以理解为乐观锁。</p><p>我对共享锁和排它锁有不同理解共享锁，又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据。排他锁，又称为写锁、独占锁。获准排他锁后，既能读数据，又能修改数据.</p><p>有个问题不太明白，cas既然是原子操作，为什么在a线程取到期望值之后没有比较，而被b线程抢占了执行权，我理解的原子操作，在执行过程中不会受任何的干扰，不知道哪里理解不太对，还请老师指点</p><p><strong>答案</strong>： CAS 保证了原子性，但存在 ABA 的问题。可以理解为原子操作只能保证一个步骤执行的完整性，但ABA问题是组合操作，所以会存在问题。</p><h1 id="Java-Clone"><a href="#Java-Clone" class="headerlink" title="Java Clone"></a>Java Clone</h1><p>Java中的克隆存在两种 深克隆和浅克隆</p><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210105105310.png" alt="image-20210105105310861"></p><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210105105405.png" alt="image-20210105105405266"></p><p>在 Java 语言中要实现克隆则需要实现 Cloneable 接口，并重写 Object 类中的 clone() 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被赋值对象</span></span><br><span class="line">        People p1 = <span class="keyword">new</span> People();</span><br><span class="line">        p1.setId(<span class="number">1</span>);</span><br><span class="line">        p1.setName(<span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆 p1 对象</span></span><br><span class="line">        People p2 = (People) p1.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印名称</span></span><br><span class="line">        System.out.println(<span class="string">"p2:"</span> + p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性</span></span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2:Java</span><br></pre></td></tr></table></figure><h2 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h2><h3 id="在-java-lang-Object-中对-clone-方法的约定有哪些？"><a href="#在-java-lang-Object-中对-clone-方法的约定有哪些？" class="headerlink" title="在 java.lang.Object 中对 clone() 方法的约定有哪些？"></a>在 java.lang.Object 中对 clone() 方法的约定有哪些？</h3><p>要想真正的了解克隆，首先要从它的源码入手，代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns a copy of this object.  The precise meaning</span></span><br><span class="line"><span class="comment"> * of "copy" may depend on the class of the object. The general</span></span><br><span class="line"><span class="comment"> * intent is that, for any object &#123;<span class="doctag">@code</span> x&#125;, the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be true, and that the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment"> * While it is typically the case that:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the returned object should be obtained by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> super.clone&#125;.  If a class and all of its superclasses (except</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object&#125;) obey this convention, it will be the case that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> x.clone().getClass() == x.getClass()&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment"> * of this object (which is being cloned).  To achieve this independence,</span></span><br><span class="line"><span class="comment"> * it may be necessary to modify one or more fields of the object returned</span></span><br><span class="line"><span class="comment"> * by &#123;<span class="doctag">@code</span> super.clone&#125; before returning it.  Typically, this means</span></span><br><span class="line"><span class="comment"> * copying any mutable objects that comprise the internal "deep structure"</span></span><br><span class="line"><span class="comment"> * of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment"> * objects with references to the copies.  If a class contains only</span></span><br><span class="line"><span class="comment"> * primitive fields or references to immutable objects, then it is usually</span></span><br><span class="line"><span class="comment"> * the case that no fields in the object returned by &#123;<span class="doctag">@code</span> super.clone&#125;</span></span><br><span class="line"><span class="comment"> * need to be modified.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>从以上源码的注释信息中我们可以看出，Object 对 clone() 方法的约定有三条：</p><ul><li>对于所有对象来说，x.clone() !=x 应当返回 true，因为克隆对象与原对象不是同一个对象；</li><li>对于所有对象来说，x.clone().getClass() == x.getClass() 应当返回 true，因为克隆对象与原对象的类型是一样的；</li><li>对于所有对象来说，x.clone().equals(x) 应当返回 true，因为使用 equals 比较时，它们的值都是相同的。</li></ul><p>除了注释信息外，我们看 clone() 的实现方法，发现 clone() 是使用 native 修饰的本地方法，因此执行的性能会很高，并且它返回的类型为 Object，因此在调用克隆之后要把对象强转为目标类型才行。</p><h3 id="Arrays-copyOf-是深克隆还是浅克隆？"><a href="#Arrays-copyOf-是深克隆还是浅克隆？" class="headerlink" title="Arrays.copyOf() 是深克隆还是浅克隆？"></a>Arrays.copyOf() 是深克隆还是浅克隆？</h3><p>如果是数组类型，我们可以直接使用 Arrays.copyOf() 来实现克隆，实现代码如下：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">People[] o1 = &#123;new People(1, &quot;Java&quot;)&#125;;</span><br><span class="line">People[] o2 = Arrays.copyOf(o1, o1.length);</span><br><span class="line">// 修改原型对象的第一个元素的值</span><br><span class="line">o1[0].setName(&quot;Jdk&quot;);</span><br><span class="line">System.out.println(&quot;o1:&quot; + o1[0].getName());</span><br><span class="line">System.out.println(&quot;o2:&quot; + o2[0].getName());</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o1:Jdk</span><br><span class="line">o2:Jdk</span><br></pre></td></tr></table></figure><p>从结果可以看出，我们在修改克隆对象的第一个元素之后，原型对象的第一个元素也跟着被修改了，这说明 Arrays.copyOf() 其实是一个浅克隆。</p><p>因为数组比较特殊数组本身就是引用类型，因此在使用 Arrays.copyOf() 其实只是把引用地址复制了一份给克隆对象，如果修改了它的引用对象，那么指向它的（引用地址）所有对象都会发生改变，因此看到的结果是，修改了克隆对象的第一个元素，原型对象也跟着被修改了。</p><h3 id="深克隆的实现方式有几种？"><a href="#深克隆的实现方式有几种？" class="headerlink" title="深克隆的实现方式有几种？"></a>深克隆的实现方式有几种？</h3><p>深克隆的实现方式有很多种，大体可以分为以下几类：</p><ul><li>所有对象都实现克隆方法；</li><li>通过构造方法实现深克隆；</li><li>使用 JDK 自带的字节流实现深克隆；</li><li>使用第三方工具实现深克隆，比如 Apache Commons Lang；</li><li>使用 JSON 工具类实现深克隆，比如 Gson、FastJSON 等。</li></ul><p>接下来我们分别来实现以上这些方式，在开始之前先定义一个公共的用户类，代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address; <span class="comment">// 包含 Address 引用对象</span></span><br><span class="line">    <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出在 People 对象中包含了一个引用对象 Address。</p><p><strong>1.所有对象都实现克隆</strong></p><p>这种方式我们需要修改 People 和 Address 类，让它们都实现 Cloneable 的接口，让所有的引用对象都实现克隆，从而实现 People 类的深克隆，代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">          <span class="comment">// 创建被赋值对象</span></span><br><span class="line">          Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">          People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">          <span class="comment">// 克隆 p1 对象</span></span><br><span class="line">          People p2 = p1.clone();</span><br><span class="line">          <span class="comment">// 修改原型对象</span></span><br><span class="line">          p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">          <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">          System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                  <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> People <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            People people = (People) <span class="keyword">super</span>.clone();</span><br><span class="line">            people.setAddress(<span class="keyword">this</span>.address.clone()); <span class="comment">// 引用类型克隆赋值</span></span><br><span class="line">            <span class="keyword">return</span> people;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Address <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1:西安 p2:北京</span><br></pre></td></tr></table></figure><p>从结果可以看出，当我们修改了原型对象的引用属性之后，并没有影响克隆对象，这说明此对象已经实现了深克隆。</p><p><strong>2.通过构造方法实现深克隆</strong></p><p>《Effective Java》 中推荐使用构造器（Copy Constructor）来实现深克隆，如果构造器的参数为基本数据类型或字符串类型则直接赋值，如果是对象类型，则需要重新 new 一个对象，实现代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        <span class="comment">// 调用构造函数克隆对象</span></span><br><span class="line">        People p2 = <span class="keyword">new</span> People(p1.getId(), p1.getName(),</span><br><span class="line">                <span class="keyword">new</span> Address(p1.getAddress().getId(), p1.getAddress().getCity()));</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1:西安 p2:北京</span><br></pre></td></tr></table></figure><p>从结果可以看出，当我们修改了原型对象的引用属性之后，并没有影响克隆对象，这说明此对象已经实现了深克隆。</p><p><strong>3.通过字节流实现深克隆</strong></p><p>通过 JDK 自带的字节流实现深克隆的方式，是先将要原型对象写入到内存中的字节流，然后再从这个字节流中读出刚刚存储的信息，来作为一个新的对象返回，那么这个新对象和原型对象就不存在任何地址上的共享，这样就实现了深克隆，代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        <span class="comment">// 通过字节流实现克隆</span></span><br><span class="line">        People p2 = (People) StreamClone.clone(p1);</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过字节流实现克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamClone</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(People obj)</span> </span>&#123;</span><br><span class="line">            T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 写入字节流</span></span><br><span class="line">                ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">                oos.writeObject(obj);</span><br><span class="line">                oos.close();</span><br><span class="line">                <span class="comment">// 分配内存,写入原始对象,生成新对象</span></span><br><span class="line">                ByteArrayInputStream bi = <span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());<span class="comment">//获取上面的输出字节流</span></span><br><span class="line">                ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">                <span class="comment">// 返回生成的新对象</span></span><br><span class="line">                cloneObj = (T) oi.readObject();</span><br><span class="line">                oi.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cloneObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1:西安 p2:北京</span><br></pre></td></tr></table></figure><p>此方式需要注意的是，由于是通过字节流序列化实现的深克隆，因此每个对象必须能被序列化，必须实现 Serializable 接口，标识自己可以被序列化，否则会抛出异常 (java.io.NotSerializableException)。</p><p><strong>4.通过第三方工具实现深克隆</strong></p><p>本课时使用 Apache Commons Lang 来实现深克隆，实现代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.SerializationUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深克隆实现方式四：通过 apache.commons.lang 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FourthExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        <span class="comment">// 调用 apache.commons.lang 克隆对象</span></span><br><span class="line">        People p2 = (People) SerializationUtils.clone(p1);</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1:西安 p2:北京</span><br></pre></td></tr></table></figure><p>可以看出此方法和第三种实现方式类似，都需要实现 Serializable 接口，都是通过字节流的方式实现的，只不过这种实现方式是第三方提供了现成的方法，让我们可以直接调用。</p><p><strong>5.通过 JSON 工具类实现深克隆</strong></p><p>本课时我们使用 Google 提供的 JSON 转化工具 Gson 来实现，其他 JSON 转化工具类也是类似的，实现代码如下：</p><p>复制代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深克隆实现方式五：通过 JSON 工具实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FifthExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        <span class="comment">// 调用 Gson 克隆对象</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        People p2 = gson.fromJson(gson.toJson(p1), People.class);</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1:西安 p2:北京</span><br></pre></td></tr></table></figure><p>使用 JSON 工具类会先把对象转化成字符串，再从字符串转化成新的对象，因为新对象是从字符串转化而来的，因此不会和原型对象有任何的关联，这样就实现了深克隆，其他类似的 JSON 工具类实现方式也是一样的。</p><h3 id="Java-中的克隆为什么要设计成，既要实现空接口-Cloneable，还要重写-Object-的-clone-方法？"><a href="#Java-中的克隆为什么要设计成，既要实现空接口-Cloneable，还要重写-Object-的-clone-方法？" class="headerlink" title="Java 中的克隆为什么要设计成，既要实现空接口 Cloneable，还要重写 Object 的 clone() 方法？"></a>Java 中的克隆为什么要设计成，既要实现空接口 Cloneable，还要重写 Object 的 clone() 方法？</h3><p>从源码中可以看出 Cloneable 接口诞生的比较早，JDK 1.0 就已经存在了，因此从那个时候就已经有克隆方法了，那我们怎么来标识一个类级别对象拥有克隆方法呢？克隆虽然重要，但我们不能给每个类都默认加上克隆，这显然是不合适的，那我们能使用的手段就只有这几个了：</p><ul><li>在类上新增标识，此标识用于声明某个类拥有克隆的功能，像 final 关键字一样；</li><li>使用 Java 中的注解；</li><li>实现某个接口；</li><li>继承某个类。</li></ul><p>先说第一个，为了一个重要但不常用的克隆功能， 单独新增一个类标识，这显然不合适；再说第二个，因为克隆功能出现的比较早，那时候还没有注解功能，因此也不能使用；第三点基本满足我们的需求，第四点和第一点比较类似，为了一个克隆功能需要牺牲一个基类，并且 Java 只能单继承，因此这个方案也不合适。采用排除法，无疑使用实现接口的方式是那时最合理的方案了，而且在 Java 语言中一个类可以实现多个接口。</p><p>那为什么要在 Object 中添加一个 clone() 方法呢？</p><p>因为 clone() 方法语义的特殊性，因此最好能有 JVM 的直接支持，既然要 JVM 直接支持，就要找一个 API 来把这个方法暴露出来才行，最直接的做法就是把它放入到一个所有类的基类 Object 中，这样所有类就可以很方便地调用到了。</p><hr><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h2 id="普通类-抽象类-接口区别"><a href="#普通类-抽象类-接口区别" class="headerlink" title="普通类 抽象类 接口区别"></a>普通类 抽象类 接口区别</h2><p>1.普通类可以实例化,接口都不能被实例化（它没有构造方法）,抽象类如果要实例化,抽象类必须指向实现所有抽象方法的子类对象(抽象类可以直接实例化，直接重写自己的抽象方法),接口必须指向实现所有所有接口方法的类对象。</p><p>2.抽象类要被子类继承,接口要被子类实现。</p><p>3.接口只能做方法的声明,抽象类可以做方法的声明,也可以做方法的实现。</p><p>4.接口里定义的变量只能是公共的静态常量,抽象类中定义的变量是普通变量。</p><p>5.抽象类里的抽象方法必须全部被子类所实现,如果子类不能全部实现父类的抽象方法,那么该子类只能是抽象类。同样，一个实现接口的时候，如果不能全部实现接口方法，那么该类只能是抽象类。<br>6.抽象方法只能声明，不能实现。接口是设计的结果，抽象类是重构的结果。<br>7.抽象类里可以没有抽象方法。<br>8.如果一个类里有抽象方法，那么该类只能是抽象类。<br>9.抽象方法要被实现，所以不能是静态的，也不能是私有的。<br>10.接口可以继承接口，并可多继承接口，但类只能单继承。（重要啊）<br>11.接口中的常量：有固定的修饰符-publicstaticfinal（不能用private和protected修饰/本质上都<br>是static的而且是final类型的，不管加不加static修饰）。<br>12.接口中的抽象方法：有固定的修饰符-publicabstract。<br>注意：<br>①抽象类和接口都是用来抽象具体的对象的，但是接口的抽象级别更高。<br>②抽象类可以有具体的方法和属性，接口只能有抽象方法和静态常量。<br>③抽象类主要用来抽象级别，接口主要用来抽象功能。<br>④抽象类中，且不包含任何的实现，派生类必须覆盖它们。接口中所有方法都必须是未实现的。<br>⑤接口方法，访问权限必须是公共的public。<br>⑥接口内只能有公共方法，不能存在成员变量。<br>⑦接口内只能包含未被实现的方法，也叫抽象方法，但是不能用abstract关键字。<br>⑧抽象类的访问速度比接口要快，接口是稍微有点慢，因为它需要时间去寻找在类中实现的方法。<br>⑨抽象类，除了不能被实例化外，与普通java类没有任何区别。<br>⑩抽象类可以有main方法，接口没有main方法。<br>⑪抽象类可以用构造器，接口没有。<br>⑫抽象方法可以有public、protected和default这些修饰符，接口只能使用默认public。<br>⑬抽象类，添加新方法可以提供默认的实现，不需要改变原有代码。接口添加新方法，子类必须实现。<br>⑭抽象类的子类用extends关键字继承，接口用implements来实现。</p><h2 id="可以作为GCRoot的对象有哪些？"><a href="#可以作为GCRoot的对象有哪些？" class="headerlink" title="可以作为GCRoot的对象有哪些？"></a>可以作为GCRoot的对象有哪些？</h2><p>1.Systemclass<br>2.JNIclass<br>3.JNIglobal<br>4.ThreadBlock<br>5.Thread.（examplenewThread().start()）<br>6.Javalocal<br>7.NativeStack<br>8.JavastackFrame</p><h2 id="spring中Bean的作用域"><a href="#spring中Bean的作用域" class="headerlink" title="spring中Bean的作用域"></a>spring中Bean的作用域</h2><p>1.singleton：SpringIoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。Singleton作用域是Spring中的缺省作用域。<br>2.prototype：每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。<br>3.request：在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前HttpRequest内有效。<br>4.session：在一次HttpSession中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。<br>5.globalSession：在一个全局的HttpSession中，容器会返回该Bean的同一个实例，仅在使用portletcontext时有效。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gk8bz1ze11j20xc0m8gob.jpg&quot; alt=&quot;undefined&quot; style=&quot;zoom: 50%;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;JAVA 的随手PICK&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Tips4Java" scheme="http://yoursite.com/tags/Tips4Java/"/>
    
  </entry>
  
  <entry>
    <title>Flink Source Code</title>
    <link href="http://yoursite.com/2020/10/28/Flink%20Source%20Code/"/>
    <id>http://yoursite.com/2020/10/28/Flink%20Source%20Code/</id>
    <published>2020-10-27T20:47:54.000Z</published>
    <updated>2021-01-28T09:03:27.627Z</updated>
    
    <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk4kjbckk0j23342bc7wi.jpg" alt="42674d258e3ba907d1d288d8f3da38b.jpg" style="zoom: 15%;"><blockquote><p>菜逼的Apache源码阅读之路</p></blockquote><a id="more"></a> <h1 id="Flink-源码阅读"><a href="#Flink-源码阅读" class="headerlink" title="Flink 源码阅读"></a>Flink 源码阅读</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>很久之前我就在想怎么阅读源码，大佬的回答总是出奇的一致</p><p>“耐心”</p><p>哈哈，仿佛有了耐心就是万能的</p><p>于是菜逼那会去Github Clone了一份源码，结果在第一步就卡了好久，笑，在第一步学会了使用Git设置代理，学会了去官方文档寻找编译需要的环境（环境真的坑死人），需要合适的JDK版本，需要合适的Mvn版本，否则你是永远不可能编译成功的</p><p>涉及UI的Apache项目一般来说还会依赖很多东西，比如说Node Js之类的，他们会在POM中的自动脚本插件里面附上一些bash操作，对于不同的电脑环境来说未必是能成功的，里面涉及到一些Mvn项目的改动，那段时间确切得感受到了Mac的便利</p><p>终于把基本环境搞定了，接下来一个大型Apache项目中会有大量的代码，从哪阅读，怎么阅读也是个问题，首先要懂一点设计模式对吧，不然光看那些不知所以然的解耦就不知道写代码的人在做什么，满脸懵逼而已，核心的代码，看着26个英文字母都懂，组合在一起就不知道这些代码在干锤子了</p><p>后来又刷了一波LeeCode，终于明白了人和人的差距，连LeeCode这么简单的算法，都有各种巧妙的实现方式，有时候配上注释都要看半天，更别说各种精妙的算法在工程里面的实现了，释然了，这事情只能慢慢去补，如果是梳理框架，使用的话，先从架构层面，理解源码，每个东西在代码中的作用先了然，再谈实现方式，我尝试着尽量不在细节上面纠结，这样阅读代码的收获和成就感会强得多，才能支持自己读下去，书和博客都是梳理架构的好途径</p><p>只要能坚持，总能从优秀的Apache 代码里面学到越来越多的东西，理解应该也会越来越多，上面的是截止到目前为止，菜逼的一些简单感悟，后面如果有新的看法会过来更新<br>剩下需要的就是耐心和时间  :）</p></blockquote><h1 id="源码阅读入口"><a href="#源码阅读入口" class="headerlink" title="源码阅读入口"></a>源码阅读入口</h1><p>Flink提供了系列shell脚本用于flink集群管理、job提交等，通过分析这些脚本找到自己所关心的核心链路入口是比较合适的。</p><p>Flink提供了两个启动脚本：<code>bin/start-local.sh</code> 用于启动单机模式的Flink；<code>bin/start-cluster.sh</code> 用于启动集群模式的Flink。</p><p>（1）start-local.sh</p><ul><li>解析提取flink-yaml.xml中的配置项，各配置项的含义可参考<a href="https://ci.apache.org/projects/flink/flink-docs-master/ops/config.html%E3%80%82" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-master/ops/config.html。</a></li><li>以daemon模式启动jobmanager进程（并分出一个线程启动taskmanager）。</li></ul><p>（2）start-cluster.sh</p><ul><li>解析提取flink-yaml.xml中的配置项。</li><li>通过ssh远程启动各master机器上的jobmaster进程（需要在conf/masters中配置master机器的ip地址，默认是localhost:8081）。</li><li>启动taskmanager进程（需要在conf/slaves配置slave机器的ip地址，通常是localhost）。</li></ul><p>由flink-daemon.sh可知，Flink中各主要进程的入口对应关系如下：</p><table><thead><tr><th>jobmanager</th><th>org.apache.flink.runtime.jobmanager.JobManager</th></tr></thead><tbody><tr><td>taskmanager</td><td>org.apache.flink.runtime.taskmanager.TaskManager</td></tr><tr><td>内置zookeeper</td><td>org.apache.flink.runtime.zookeeper.FlinkZooKeeperQuorumPeer</td></tr><tr><td>historyserver</td><td>org.apache.flink.runtime.webmonitor.history.HistoryServer</td></tr></tbody></table><p>Flink提供的CLI脚本是bin/flink，可以通过该脚本提交Job、创建Savepoint等。</p><p>脚本的主要流程：</p><ul><li>解析提取flink-yaml.xml中的配置项。</li><li>通过Client入口org.apache.flink.client.CliFrontend连接到JobManager并发送消息。</li></ul><p>DUBUG主要流程：</p><p>将源码导入到IDE中（如IDEA），本地debug基本方法如下：</p><p>1、在jvm启动参数中添加远程调试参数</p><p>（1）如果是调试Client，可以将上述参数加到bin/flink脚本的最后一行中，形如：<br>JVM_REMOTE_DEBUG_ARGS=’-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005’<br>exec $JAVA_RUN $JVM_ARGS $JVM_REMOTE_DEBUG_ARGS “${log_setting[@]}” -classpath “<code>manglePathList &quot;$CC_CLASSPATH:$INTERNAL_HADOOP_CLASSPATHS&quot;</code>“ org.apache.flink.client.CliFrontend “$@”<br>（2）如果是调试JobManager或TaskManager，可以在conf/flink-conf.yaml中添加：</p><p>env.java.opts: -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5006</p><p>2、启动flink client或jobmanager或taskmanager，此时程序会suspend等待debuger连接（通过suspend=y来配置）。</p><p>3、配置IDEA中的remote：host配置为localhost，配置port（参考1中的配置的address端口）。</p><p>4、在Flink源码中设置断点，连接远程host，然后就可以开始debug跟踪了。</p><h1 id="Flink-Annotations"><a href="#Flink-Annotations" class="headerlink" title="Flink Annotations"></a>Flink Annotations</h1><p>flink-annotations模块定义了一些flink项目中需要用到的注解。Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。该模块主要包括的注解类型有：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk764ocwdcj20tr08xaah.jpg" alt="undefined"></p><p>flink annotations下包含了docs相关的三种注解：ConfigGroup，ConfigGroups和Documentation。然后还有其他5种注解：Experimental，Internal， Public，PublicEnvolving和VisableForTesting。下面分别简单地介绍下这些注解的作用。</p><h2 id="docs相关的三个注解"><a href="#docs相关的三个注解" class="headerlink" title="docs相关的三个注解"></a>docs相关的三个注解</h2><h3 id="ConfigGroup"><a href="#ConfigGroup" class="headerlink" title="ConfigGroup"></a>ConfigGroup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;&#125;)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigGroup &#123;</span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">keyPrefix</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解的作用是指定一组配置选项的类。该组的name将被用作生成的HTML文件的文件名。</p><h3 id="ConfigGroups"><a href="#ConfigGroups" class="headerlink" title="ConfigGroups"></a>ConfigGroups</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigGroups &#123;</span><br><span class="line">ConfigGroup[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解是提供了一种根据key的最大前缀来把配置选项拆分为不同的组。</p><h3 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h3><p>这个类主要是修改文档生成器的行为的注解集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Documentation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于配置选项字段的以重写已记录的默认值</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OverrideDefault &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 用于配置选项字段的注释，以便将它们包括在“公共选项”部分中。</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CommonOption &#123;</span><br><span class="line"><span class="keyword">int</span> POSITION_MEMORY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_PARALLELISM_SLOTS = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_FAULT_TOLERANCE = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_HIGH_AVAILABILITY = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_SECURITY = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> <span class="keyword">default</span> Integer.MAX_VALUE</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 在配置选项字段上使用的注释，以从文档中排除配置选项。</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExcludeFromDocumentation &#123;</span><br><span class="line"> </span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Documentation</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Experimental"><a href="#Experimental" class="headerlink" title="Experimental"></a>Experimental</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Experimental &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标注类为实验阶段。带有此注释的类既没有经过严格的测试，也还不稳定，并且可以更改或删除在未来版本中。</p><h2 id="Internal"><a href="#Internal" class="headerlink" title="Internal"></a>Internal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Internal &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解用于将稳定的公共API中的方法标记为内部开发人员API。开发人员API是稳定的，但仅仅是在Flink内部，但是在发布版本有可能有些变化。</p><h2 id="Public"><a href="#Public" class="headerlink" title="Public"></a>Public</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Public &#123;&#125;</span><br></pre></td></tr></table></figure><p>标注类为开放和稳定的。类，方法或者属性被这个这个注解修饰时，表示在小版本迭代中，都维持稳定。</p><h2 id="PublicEvolving"><a href="#PublicEvolving" class="headerlink" title="PublicEvolving"></a>PublicEvolving</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PublicEvolving &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解用来标注公共的但有不断发展的接口依赖的类或者方法。带有此注释的类和方法用于公共使用，并且具有稳定的行为。但是，它们的接口和签名不被认为是稳定的，并且当跨版本时可能会变化。</p><h2 id="VisibleForTesting"><a href="#VisibleForTesting" class="headerlink" title="VisibleForTesting"></a>VisibleForTesting</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> VisibleForTesting &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个注解申明有些函数，属性，构造函数或整个类型值是在test时才是可见的。当例如方法应该是编码阶段，通常附加这个注释（因为它不打算在外部调用），但不能声明为私有，因为一些测试需要访问它。</p><h1 id="ParameterTool"><a href="#ParameterTool" class="headerlink" title="ParameterTool"></a>ParameterTool</h1><p>先从简单的看起，这个是Flink自带的工具类, 位置：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk616mdhn7j20ix0roq4t.jpg" alt="73E97217-CF9B-4d73-A33A-5AD2140FA487.png"></p><p>结构：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk61j80jj3j20bc0bggru.jpg" alt="未命名1603941927.png"></p><p>ParameterTool 里面的可以从多种数据来源创建</p><p>比如方法：</p><p><code>fromPropertiesFile</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@link</span> ParameterTool&#125; for the given &#123;<span class="doctag">@link</span> Properties&#125; file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path Path to the properties file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> ParameterTool&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException If the file does not exist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Properties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterTool <span class="title">fromPropertiesFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File propertiesFile = <span class="keyword">new</span> File(path);</span><br><span class="line"><span class="keyword">return</span> fromPropertiesFile(propertiesFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到下面调用了工具类里面的另外一个函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@link</span> ParameterTool&#125; for the given &#123;<span class="doctag">@link</span> Properties&#125; file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file File object to the properties file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> ParameterTool&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException If the file does not exist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Properties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterTool <span class="title">fromPropertiesFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Properties file "</span> + file.getAbsolutePath() + <span class="string">" does not exist"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(file)) &#123;</span><br><span class="line"><span class="keyword">return</span> fromPropertiesFile(fis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续向下套娃</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@link</span> ParameterTool&#125; for the given InputStream from &#123;<span class="doctag">@link</span> Properties&#125; file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputStream InputStream from the properties file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> ParameterTool&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException If the file does not exist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Properties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterTool <span class="title">fromPropertiesFile</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(inputStream);</span><br><span class="line"><span class="keyword">return</span> fromMap((Map) props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@link</span> ParameterTool&#125; for the given map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map A map of arguments. Both Key and Value have to be Strings</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> ParameterTool&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterTool <span class="title">fromMap</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">Preconditions.checkNotNull(map, <span class="string">"Unable to initialize from empty map"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ParameterTool(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边调用了ParameterTool的构造器，然后窜入了参数 最终构造出了这个 ParameterTool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ParameterTool</span><span class="params">(Map&lt;String, String&gt; data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = Collections.unmodifiableMap(<span class="keyword">new</span> HashMap&lt;&gt;(data));</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.defaultData = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(data.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.unrequestedParameters = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(data.size()));</span><br><span class="line"></span><br><span class="line">unrequestedParameters.addAll(data.keySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程里面，<code>inputStream</code> 转化成了 <code>Map&lt;String,String&gt;</code>直到最后的传入。</p><p>工具类的源码比较简单，代码也比较工整，很容易看懂。</p><p>FromArgs用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ParameterTool parameters = ParameterTool.fromArgs(args);</span><br><span class="line">String local_path = parameters.get(<span class="string">"local_path"</span>,<span class="keyword">null</span>);  <span class="comment">//指定参数名：local_path</span></span><br><span class="line"><span class="comment">//读取配置文件</span></span><br><span class="line">ParameterTool paramFromProps = ParameterTool.fromPropertiesFile(local_path);</span><br></pre></td></tr></table></figure><p>代码打包完成jar，在服务器启动Flink任务时，需要添加自定义参数local_path，指定配置文件的绝对路径。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flink run flink.jar -local_path ./config.properties</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>开源发布的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Alpha、Beta、Gamma版本</span><br><span class="line"></span><br><span class="line">以下三者，在系统、架包、软件的开发过程中，使用。</span><br><span class="line">Alpha：内测版，BUG多，开发人员开发过程中使用，希腊字母α，第一，指最初版</span><br><span class="line">Beta：早期版本，有缺陷，无大BUG，可能加入新功能，进一步开发完善。</span><br><span class="line">Gamma: 经beta 版，完善修改，成为正式发布的候选版本（Release Candidate）</span><br><span class="line"></span><br><span class="line">RC、GA、R版本</span><br><span class="line">RC：(Release Candidate)：候选版本，几乎就是正式版了，</span><br><span class="line">GA：（Ggeneral Availability）：发行稳定版，官方推荐使用此版本。</span><br><span class="line">R，RELEASE：正式版，等价于GA</span><br><span class="line"></span><br><span class="line">SNAPSHOT版本</span><br><span class="line">SNAPSHOT：快照版，可以稳定使用，且仍在继续改进版本。</span><br><span class="line"></span><br><span class="line">snapshot多见于架包依赖中，使用Maven时，需要的架包回去仓库Nexus中找，，一个仓库一般分为RELEASE仓和SNAPSHOT仓快照版，前者理解，稳定正式版本，后者如何？Maven在构建项目时，会优先去远程仓库中查看是否有最新的example-1.0-SNAPSHOT.jar，如果有则下载下来使用。即使本地仓库中已经有了example-1.0-SNAPSHOT.jar，它也会尝试去远程仓库中查看同名的jar是否是最新的。</span><br><span class="line"></span><br><span class="line">有的人可能会问，这样不就不能充分利用本地仓库的缓存机制了吗？别着急，Maven比我们想象中的要聪明。在配置Maven的Repository的时候中有个配置项，可以配置对于SNAPSHOT版本向远程仓库中查找的频率。频率共有四种，分别是always、daily、interval、never。当本地仓库中存在需要的依赖项目时，always是每次都去远程仓库查看是否有更新，daily是只在第一次的时候查看是否有更新，当天的其它时候则不会查看；interval允许设置一个分钟为单位的间隔时间，在这个间隔时间内只会去远程仓库中查找一次，never是不会去远程仓库中查找（这种就和正式版本的行为一样了）。</span><br><span class="line"></span><br><span class="line">其他版本</span><br><span class="line">Alpha：内部测试版</span><br><span class="line">Beta：外部测试版</span><br><span class="line">Build：修正版</span><br><span class="line">Corporation或Enterprise：企业版</span><br><span class="line">Delux：豪华版</span><br><span class="line">DEMO：演示版，有功能限制</span><br><span class="line">Free：免费版</span><br><span class="line">Full：完全版</span><br><span class="line">Final：正式版</span><br><span class="line">Pro(professional)：专业版</span><br><span class="line">Plus：加强版</span><br><span class="line">Retail：零售版</span><br><span class="line">Release：发行版，有时间限制</span><br><span class="line">Shareware：共享版，虽然不会要求注册但是一般也有功能限制</span><br><span class="line">SR：修正版</span><br><span class="line">Trial：试用版（一般有时间或者功能限制）</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gk4kjbckk0j23342bc7wi.jpg&quot; alt=&quot;42674d258e3ba907d1d288d8f3da38b.jpg&quot; style=&quot;zoom: 15%;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;菜逼的Apache源码阅读之路&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Apache Flink" scheme="http://yoursite.com/tags/Apache-Flink/"/>
    
  </entry>
  
  <entry>
    <title>BookTool</title>
    <link href="http://yoursite.com/2020/10/24/BookTool/"/>
    <id>http://yoursite.com/2020/10/24/BookTool/</id>
    <published>2020-10-24T06:59:34.000Z</published>
    <updated>2021-01-28T08:55:31.081Z</updated>
    
    <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk0fpauus8j20sg0lcad5.jpg" alt="undefined" style="zoom: 50%;"><blockquote><p>读书笔记。</p></blockquote><a id="more"></a> <h1 id="设计数据密集型应用-Designing-Data-Intensive-Application"><a href="#设计数据密集型应用-Designing-Data-Intensive-Application" class="headerlink" title="设计数据密集型应用 Designing Data-Intensive Application"></a>设计数据密集型应用 Designing Data-Intensive Application</h1><h2 id="第一章：可靠性-可拓展性-可维护性"><a href="#第一章：可靠性-可拓展性-可维护性" class="headerlink" title="第一章：可靠性 可拓展性 可维护性"></a>第一章：可靠性 可拓展性 可维护性</h2><blockquote><p>Data System</p></blockquote><h3 id="可靠性-Reliability"><a href="#可靠性-Reliability" class="headerlink" title="可靠性 Reliability"></a>可靠性 Reliability</h3><p>系统在adversity中任然可以正常工作。</p><p>可靠性的总结：</p><ul><li>程序表现出用户所期望的功能</li><li>允许用户犯错，允许用户以出乎意料的方式使用软件</li><li>在预期的负载和数据量下，性能满足要求</li><li>系统能防止未经授权的访问和滥用</li></ul><p>故障（fault） 容错（fault-tolerant） 韧性（resilient）</p><p>硬件故障、软件错误、人为错误</p><h3 id="可拓展性-Scalability"><a href="#可拓展性-Scalability" class="headerlink" title="可拓展性 Scalability"></a>可拓展性 Scalability</h3><p>有合理的办法应对系统的增长（数据量 流量复杂性）</p><p><strong>描述负载</strong>    tw为例</p><p><strong>描述性能</strong>    </p><p>对于hadoop 关心吞吐（throughput） </p><p>对于在线系统，关心响应时间（response time）对响应时间的比较良好的数据：百分位点（percentiles）和中位数（median）而不是算术平均值（arithmetic mean） </p><p>尾部延迟（tail latecies）在某些场景下非常重要，比如亚马逊–用户掏钱了</p><p><strong>应对负载</strong></p><p>纵向拓展 scaling up 垂直拓展 vertival scaling 转向更强大的机器</p><p>横向拓展 scaling out 水平拓展 horizontal scaling 将负载分不到多台小机器上</p><p>有些系统是弹性的（elastic），但是会造成额外的复杂度，手动扩容会简单很多 如果系统是极难预测的，则弹性扩容可能会很有用（highly unpredictable）</p><p>跨多台机器部署无状态服务（stateless service）非常简单。</p><p>没有通用的可拓展框架（万金油 magic scaling sauce）</p><p>一个适配良好的可拓展框架，是围绕假设（assumption）建立的</p><h3 id="可维护性-Maintainability"><a href="#可维护性-Maintainability" class="headerlink" title="可维护性 Maintainability"></a>可维护性 Maintainability</h3><p>许多不同的人在不同的声明周期，都高效的在系统中工作</p><p>在设计软件指出就尽量考虑尽可能减少维护期间的痛苦，从而避免自己的软件系统编程遗留系统。</p><p>为此，我们将特别关注软件系统的三个设计原则：</p><p><strong>可操作性</strong></p><p>便于运维团队保持系统平稳运行</p><p><strong>简单性</strong></p><p>从系统中消除尽可能多的复杂度（complexity）</p><p><strong>可演化性</strong></p><p>可拓展性（extensibility） 可修改性（modifiability）可塑性（plasticity）</p><h2 id="数据模型与查询语言"><a href="#数据模型与查询语言" class="headerlink" title="数据模型与查询语言"></a>数据模型与查询语言</h2><p>数据模型不仅仅影响着软件编写方式，而且影响着我们的解题思路。</p><p>数据模型种类繁多，每个数据模型都带有如何使用的设想，有些用法很容易，有些则不支持如此。</p><p>掌握一个数据模型需要花费很多精力，所以选择一个适合的数据模型是非常重要的。</p><h3 id="关系模型与文档模型"><a href="#关系模型与文档模型" class="headerlink" title="关系模型与文档模型"></a>关系模型与文档模型</h3><p><strong>SQL</strong></p><p>现在最著名的数据模型可能是SQL，它基于Edgar Codd在1970年提出的关系模型：数据被组织称关系（SQL中称作表），每个关系是元组的无需集合。</p><p><strong>NoSQL</strong></p><p>NoSQL被追溯性的重新解释为不仅是SQL（Not Only SQL）</p><p>驱动NoSQL诞生的原因是：</p><ul><li>需要比关系型数据库更好的可拓展性，包括非常大的数据集或非常高的写入吞吐量</li><li>相比商业数据库产品，免费和开源更手滑你用</li><li>关系模型不能很好地支持一些特殊查询</li><li>受挫与关系模型的限制性，渴望一种更多动态性与表现力的数据模型</li></ul><p>在可预见的未来，关系型数据库似乎可能会继续与各种非关系型数据库一起使用，这种想法有时被称为混合持久化(polyglot persistence)</p><p><strong>对象关系不匹配</strong></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gk0fpauus8j20sg0lcad5.jpg&quot; alt=&quot;undefined&quot; style=&quot;zoom: 50%;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Paxos从入门到学会Raft</title>
    <link href="http://yoursite.com/2020/10/22/Paxos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AD%A6%E4%BC%9ARaft/"/>
    <id>http://yoursite.com/2020/10/22/Paxos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AD%A6%E4%BC%9ARaft/</id>
    <published>2020-10-22T12:18:11.000Z</published>
    <updated>2021-01-28T09:44:31.056Z</updated>
    
    <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210128174109.png" style="zoom: 20%;"><blockquote><p>分布式一致性协议把分布式的系统连接到了一起，就像蚁群有个统一的大脑一样，蚁群应该也有这种系统吧。</p><p>除了Paxos，类似的算法还有Bully 算法 Zab算法</p><p>文章来自网络，后续会补上自己的看法。</p></blockquote><a id="more"></a> <h1 id="Paxos从入门到学会Raft"><a href="#Paxos从入门到学会Raft" class="headerlink" title="Paxos从入门到学会Raft"></a>Paxos从入门到学会Raft</h1><p>我觉得学习Paxos/Raft的最大障碍并不是算法本身复杂，而是难以理解。就好像某些数学结论，证明过程不难，但是结论却很难从直观上去理解。本文就是希望能借助一个假想中的系统，逐步加强约束，引导到Paxos/Raft，希望能一定程度上解释“为啥要用共识算法”以及“不用共识算法会怎样”的问题。</p><p>本文结构在很大程度上参考了<a href="https://weibo.com/drdrxp" target="_blank" rel="noopener">drdrxp</a>阁下的一个PPT，他的微博主页上也有对应一篇很棒的<a href="https://weibo.com/ttarticle/p/show?id=2309404510981786042616" target="_blank" rel="noopener">关于Paxos的文章</a>，这里表示感谢及一并推荐给大家。不过因为理解角度不同，本文很多地方有诸多差异，例如关于半同步复制为什么不可行，本文给出了另一种解释，另外这里没有讲Fast Paxos，但是多了关于Raft的内容，希望读者可以进行比较阅读：）</p><h2 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h2><p>我们假想一个抢购手机的网络服务，因为这款手机的用户都比较发烧，所以一次只卖一个手机。在活动之前，系统会给每个用户分配一个E码作为唯一标识，抢购时间到达之后，所有用户通过客户端发送E码到服务器，服务器把手机分配给一个用户。</p><p>第一版设计我们使用单机服务器模式：搞一台主机作为服务器，当收到第一个请求后，保存这个用户的E码，并给客户端返回“抢购成功”，对于后续的所有请求，只要E码跟保存的不一样，一律返回“抢购失败”。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye19zpv1g20dw07iq3w.gif" alt="undefined"></p><p>单机模式的缺陷大家都耳熟能详了，就是不能容忍节点发生故障。仅有的一台服务一旦故障，整个服务就不能用了，这个指的是可用性。还有一个批判的角度是容灾性，如果这台服务器的数据损坏了，我们将无从判断这台手机是否已经被卖给了某个用户。</p><h2 id="备份（异步复制）"><a href="#备份（异步复制）" class="headerlink" title="备份（异步复制）"></a>备份（异步复制）</h2><p>大家都知道用户数据是非常重要的资产，万万不能丢，一定要备份。</p><p>所谓备份，就是定期把数据拷贝一份放在别的地方。还有一个概念叫异步复制，其实本质上差别不大，我们放在一起讨论。这里说异步，指的是最新的数据并不是与备份副本实时同步的。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye1mnmsug20dw07b755.gif" alt="undefined"></p><p>备份能解决一部分数据容灾的问题。这里限定说“一部分”，是因为异步模式存在一个不同步的时间窗口。如果Master在(3)OK返回给客户端之后故障了，E的值将不能被复制到Slave。之后如果使用Slave数据来恢复服务，手机将再次被卖给另外一个人，也就是一致性被破坏了。</p><h2 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h2><p>异步的不行，那同步的怎么样呢？</p><p>如图所示，Master收到请求后，先同步给Slave，Slave存盘后返回OK，然后Master再存盘并给客户端返回OK。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye1vol49g20dw07c3zi.gif" alt="undefined"></p><p>如果Slave故障了，我们把Master切换成单机模式继续提供服务。如果Master故障了，我们就把Slave切换成Master提供服务。因为是同步的，两种情况都不会产生数据丢失。</p><p>注意这里假设Slave在存完盘返回消息之前故障，也不算丢数据，因为此时Master并没有给客户端返回OK，所以手机是可以再卖给另一个人的，只需要在Slave恢复之后，Master再把新值同步过去就行了。</p><p>看上去就很完美了，可用性和一致性都能得到保证，只需要有一个负责任的工程师来盯着服务器，故障的时候切一下状态就行了。</p><p>问题就出在这个工程师身上。</p><p>我们必须要把工程师这个人也算成分布式系统的一部分，要考虑到人也会故障的（生病，意外，手机欠费失联，突然想去看看世界），而且通常管理员也是通过网络来运维管理，当服务器节点之前网络中断时，管理员也很可能无法访问某些节点。实际上我们完全可以把工程师看作集群里的一个故障检测程序来分析问题。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye267j7yj20dw0d6js9.jpg" alt="undefined"></p><p>如图(A)，假如Admin节点离Master比较近，那么当他们一起故障时，Slave无法被提升成Master。同理(图B)，Admin跟Slave一起故障时，Master也无法切换成单机模式。</p><p>那我多搞几个Admin，分别跟Master/Slave部署在一起行不行？也是不行的，这样看起来Master/Slave不管谁故障了，另一个没故障的总有Admin来操作。但是假如发生了网络隔离，如果Admin判断对面故障了，贸然切换状态，可能会出现两都是Master同时提供服务，一致性被破坏。</p><p>还有一种打补丁的思路，就是引入一个仲裁者(图D)的角色，Master和Slave不断心跳上报状态，发现对面失联想切换状态时，也要向Meta申请。这样一来，当Master和Slave断开时，取决于谁跟Meta是连着的，以及谁能更快地把状态切换请求发给Meta。</p><p>不过这里的问题在于，如何保证Meta的高可用和容灾性呢？（禁止套娃）</p><h2 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h2><p>回顾一下上面提到的各种方案，我们能发现一个有趣的现象：每次都是跪在系统中的特殊节点上面。比如仲裁者Meta，或者负责切换状态的Admin，还可以包括单机模式下的那个唯一单点。由于特殊节点的不可替代性，一旦故障了，牵一发动全身，整个系统就离挂掉不远了。</p><p>说明一下，这里从可用性来分析，我们不认为Master是特殊节点，因为Master和Slave是可以相互替代的。</p><p>从消除特殊节点的思路出发，我们把之前方案里的仲裁者Meta换成Slave，就得到了半同步复制模式。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye2f051wg20dw09qgn3.gif" alt="undefined"></p><p>具体来说，Master收到消息先本地持久化，然后同时同步给两个Slave，当其中任意一个Slave完成持久化并返回OK后，Master返回OK给客户端。</p><p>不难分析，任意一个Slave故障时，都不会影响服务。假如Master故障，则需要两个Slave挑一个出来当新的Master，此时可能只有一个Slave同步到数据，我们需要选择有数据的节点当Master。如果两个Slave都没数据，那任选一个就行。</p><p>这里的Slave其实同时承载了“仲裁节点”的角色，当Master和另一个Slave断连时，如果此Slave能连上Master，则支持Master继续提供服务，反之如果此Slave只能连到另一个Slave，那这两个Slave放弃旧Master选个新的出来。</p><p>如此这般，这个方案能很好地满足单节点故障时的可用性和一致性，而且规则简单，不需要人工介入就能自动完成。可惜它还是有缺陷的，前面我们其实只分析了单次故障的情形，如果连续多次故障，就不行了。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye2yvsexg20dw09hadn.gif" alt="undefined"></p><p>如图，Master本地写完E=1后故障了，Slave选出新的Master然后写入E=2，随后新Master也故障同时旧Master又活过来了，然后剩下的两个节点都有数据，还都不一样，你瞧瞧我，我瞧瞧你，不知道谁来当Master合适。</p><p>你可能想说，我们改下流程，写入时先在Slave持久化，OK返回给Master后再在Master持久化，这样是不是就行了？这样也是不行的，因为Slave可能在刚持久化之后就故障了，随后另外两个节点写入新值并再次故障，最后结果是一样的。</p><p>半同步复制还可以进一步打补丁，不过这里我们先放一放，来看一下另一个思路。</p><h2 id="多写"><a href="#多写" class="headerlink" title="多写"></a>多写</h2><p>如果我们进一步消除节点的特殊性，即不再区分Master和Slave，可以得到另一个方案：客户端把请求同时发向3个节点，当其中2个节点返回OK后，就认为写入成功。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye3bpzq4g20dw0bvtbr.gif" alt="undefined"></p><p>如图所示，Node1和Node2成功持久化了E=1并返回OK，之后Client2再尝试写入E=2时，最多只能写入Node3一个节点，因此无法成功写入，这样我们就保证了手机不可能被卖给2个人。</p><p>这里我们利用了“鸽巢原理”：client1和client2要想都写入成功，需要各收到2个OK，而每个节点都只会给第一个请求的客户端发送OK，也就是说总共只能发出去3个OK，因此只有一个客户端能写入成功。</p><p>这个规律也可以推广至更多数量的节点，只要规定要求写入的节点数大于一半，就只能写成功一个。</p><p>还有一种表述是，两个包含大多数成员的子集，一定至少有一个公共节点。这个性质十分重要，后面我们还会用到。</p><p>这个方案的问题在于，它能保证手机不被卖给多个人，但是保证不了手机一定能卖出去。比如3个节点收到的第一个请求分别来自不同的客户端，此时任何一个客户端都无法收集到足够数量的OK。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye3kmdsgg20dw0bo0ue.gif" alt="undefined"></p><p>此外的矛盾之处在于：一方面，节点应该避免先后被多次写入来确保手机不被卖给多人；另一方面，节点又需要能“擦除”已经写入的数据来使得手机最终一定能被卖出。</p><p>不难发现，能被安全擦除的值，一定是没有成功写入大多数节点的，一旦写入了大多数节点，客户端就认为写入成功，如果再允许其他客户端写入成功，手机也就被卖给多个人了。</p><p>在多写模式下，不存在Master那样的特殊节点，最后手机卖给谁了，不取决于某一个节点，而是由集群中的大多数节点决定。</p><h2 id="WRN"><a href="#WRN" class="headerlink" title="WRN"></a>WRN</h2><p>多写模式下应该如何去读取数据，DynamoDB和Cassandra所用的WRN模型给出了一个思路。所谓WRN，是指有N个节点的集群，写入时同时写入W个节点，读取时查询R个节点，当保证W+R&gt;N时，同样根据“鸽巢原理”，我们能知道W和R一定至少有一个公共节点，因此先写入的值一定会被后面的读取“看到”。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye3uptr8g20dw0bt776.gif" alt="undefined"></p><p>大家都知道，DynamoDB和Cassandra都是最终一致性的。它们的弱一致性，主要体现在写入进行的过程中进行多次读取，可能有时能读到写入的数据，有时又读不到，根据读取所查询的节点不同而得到不同的结果。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye4586zlg20dw0c6gp9.gif" alt="undefined"></p><p>此外，写入成功的值一定会被读到，不意味着读到的值一定写入成功或将要写入成功。假设客户端只写入了一个节点就故障了，数据仍然可能被其他客户端读取到。</p><p>WRN还给了我们一点提示，想要集群节点的两个子集有公共节点，不一定要取两个大多数节点，只需要加起一起数量大于N就行了。从高可用的角度来看，W和R分别取刚好超过一半节点通常是一个好选择，因为这样可以容忍最多不超过一半的节点故障。当然了，假如业务只关心写入请求的高可用，完全可以让W=1,R=N，此时只要连上一个节点就能写入，但是不同节点可能写入不同的值，需要在读的时候处理冲突，这就是典型的CAP理论中牺牲C来换取A了。</p><h2 id="多读-多写"><a href="#多读-多写" class="headerlink" title="多读+多写"></a>多读+多写</h2><p>基于此我们有了改进思路：服务器端总是允许用新值覆盖旧值；客户端使用一种两阶段的流程，在写入之前先进行一轮读取，如果发现已经有值被写入了大多数节点，就说明手机已经被卖出去了，否则可以尝试写入新值。</p><p>很显然，与WRN类似，这个方案也有并发问题。当client2发起读取时，client1的写入还没有开始或者进行到一半，此时client2认为没有旧值被成功写入，于是发起写入，而在client2写入成功之前，client1也写入成功了，这样，手机又被卖给了两个人。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye4e2woxg20dw0c7770.gif" alt="undefined"></p><p>这个方案不能成功的原因是，第一阶段的读取的结果不能保持到第二阶段的写入，写入请求到达服务器时，前置条件已经不成立了。</p><p>一种可能的改进方法是使用某种锁机制，第一阶段读取时，把读过的节点上锁，第二阶段写入时再解锁。只是这么做的副作用也很显然，一旦上完锁之后客户端崩溃，或者与某些节点的网络断开，某些节点将没有机会被解锁。</p><p>我们要做的是把这个锁换成一种“活锁”。</p><h2 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h2><p>在现实生活中有一个活锁的例子，就是拍卖。拍卖的时候，报价是不断上涨的，每当竞拍人给出一个报价时，之前所有更低的报价就失效了，同时产生了一个交易确认窗口期，如果没有人出更高报价，交易就会被确认。</p><p>Paxos的工作方式是类似的。每个客户端可以不断生成递增且互不重复的proposal id，写入分为读写两阶段，分别叫_prepare_和_accept_，如果两个阶段之间没有被更大的proposal id打断，写入就能成功。</p><p>Paxos把我们之前描述的抢手机的问题抽象为“多个节点共同确认一个值”的问题，把我们的服务器节点叫acceptor，客户端叫proposer，当一个proposer把值写入超过半数的acceptor后，这个值就被确认了。</p><p>Paxos的工作过程是，在读取阶段，需要写入数据的proposer向所有acceptor发送自己的proposal id，acceptor保证一旦返回自己的状态，便不再接受proposal id更小的请求了。</p><p>我们尝试站在proposer的视角，来推断其收到大多数acceptor回复后，可能遇到的3种情况：</p><ol><li>这些节点都没有value，说明此时没有value被确定，而且将来也不会有value被更小的proposal id确定（理由是大多数acceptor已经不再接受proposal id更小的请求了）。此时该proposer可以尝试发送accept消息来写入新值。</li><li>这些节点都返回了相同的value和proposal id，说明此时value已经被确定了。此时该proposer应该拒绝掉待写入的新值。</li><li>只有部分结果有value，或者这些节点返回的proposal id不完全一样。此时不确定是否有value已经或即将被更小的proposal id所确认，该proposer也不能写入新值。不过，能确定的是，如果已经有value已经或即将被提交，那么该value一定是所有acceptor返回的消息中proposal id最大的那一个（原因参考情况1，某个proposer写入了该value，意味着更小的proposal id都不可能成功）。此时为了得到确定的值，我们只能选择发送accept消息写入旧值。</li></ol><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye4mwucjj20dw0gj750.jpg" alt="undefined"></p><p>在第二阶段，proposer把待写入的新值或旧值放在accept消息中发给所有的acceptor，再一次，当收到大多acceptor的返回消息后，该值就被确定了。如果在两个阶段之间插入了proposal id更大的prepare消息，写入将不会成功。这时proposer需要选择更大的proposal id并再次尝试两阶段写入。</p><p>这就是Paxos的基本过程了，其实是很容易理解的。</p><p>它能保证一致性的关键之处在于，两个阶段都要求得到大多数节点的确认，对于任意两个有潜在冲突可能的二阶段过程，我们假设proposal id较小的是X，另一个是Y。在X的accept阶段与之交互的acceptor集合和在Y的prepare阶段与之交互的acceptor集合，一定至少有一个公共节点，如果这个节点先收到X的accept，那么Y的prepare将会读到X所写入的值，反之如果这个节点先收到Y的prepare，那么X的accept一定不会成功。</p><p>考虑高可用和容灾能力的话，两个阶段都只需要大多数节点参与，因此Paxos能半数以下的节点故障或数据丢失。</p><h2 id="Naive-Raft"><a href="#Naive-Raft" class="headerlink" title="Naive Raft"></a>Naive Raft</h2><p>之前我们介绍了，半同步复制模式还可以进一步优化，接下来就给出一个能真正解决问题的方案。</p><p>为了阐明Raft与Paxos之间的内在联系，这里我们引入一个简化版本的Raft算法，即只确定一个值的Raft，不妨叫Naive Raft。为了配合Raft中的术语，接下来我们把半同步复制中的Master改叫Leader，Slave改叫Follower。</p><p>回顾半同步复制不可行的场景，是在节点多次隔离或故障之后，剩余节点上存储的是不同的数据，无法判断谁的数据可能被确定了，也就无法决定谁去覆盖谁。</p><p>解决的方法也很简单，就是仿照Paxos，给不同的value定一个偏序的覆盖关系。由于半同步复制模型中，value总是由leader写入的，说白了就是要给不同的leader定一个覆盖顺序。</p><p>具体做法是这样的。每个节点存储一个整数term，表示选举轮次，初始时term都为0。当follower发现leader心跳超时，则会递增自己的term，并互相发消息投票选新leader。投票的限制条件是：</p><ol><li>节点只会给大于自己本地存储的term投票</li><li>节点给某个term投完票后，就不会再投给相同或更小的term投票，也不再接受term更小的数据同步</li><li>节点收到大多数节点的投票后，即成为leader，可以开始接受数据写入。如果超时没能选出leader，则会过一段时间再次递增term发起选举。</li></ol><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye4zpjqeg20dw0cigqq.gif" alt="undefined"></p><p>Naive Raft能保证一致性的关键，同样在于两个大多数节点集合有交集。其一是leader选举时所有给leader投票的节点集合，一个是数据复制是所有参与同步数据的节点集合。这二者有交集，意味着如果上一任leader确认了一个值，这个值必然会出现在下一任leader上，反之如果某一任leader选出时，节点上不存在一个value，那么上一任leader的数据复制将一定不能成功。</p><p>与Paxos类似，也是半数以上节点在线就能提供服务。</p><h2 id="Basic-Paxos和Naive-Raft的内在联系"><a href="#Basic-Paxos和Naive-Raft的内在联系" class="headerlink" title="Basic Paxos和Naive Raft的内在联系"></a>Basic Paxos和Naive Raft的内在联系</h2><p>不难发现，这两个算法有很大程度上的相似性。比如Paxos中“只响应proposal id更大的请求”和Raft中“只给大于本地term的节点投票”，比如Paxos中“选择proposal id最大的数据写入”和Raft中“选择term最大的节点当leader”，比如二者都利用了大多数节点子集相交的性质……</p><p>这两者的对应关系是这样的。Raft的term和Paxos的proposal id本质上是一个东西，Raft leader选举等效于Paxos的prepare，Raft leader相当于完成了第一阶段prepare的Paxos proposer，Raft的数据复制对应于Paxos的第二阶段accept。</p><p>其中最不明显的对应关系是Raft leader选举和Paxos的prepare。Paxos的prepare阶段通过收集大多数acceptor的状态，来判断是否可能有value已经被确定，如果有则该value一定会接下来被accept。在Raft中，leader选举本质上也是一个读取过程，通过数据交换来判断是否可能有value在更小的term被确定，如果有则保证该value一定出现在下一任leader上。</p><p>另外，Paxos的第一阶段跟要写入的value是没有任何关系的，所以理论上prepare完全可以像Raft一样提前做了，等什么时候要写入的值来了，再做第二阶段。当然实际上不可行，因为多个proposer会互相覆盖，可以找一个proposer做完prepare，再不断给其他proposer发心跳阻止被覆盖，如此一来就更像Raft了。</p><p>还有一点，在我们的Native Raft中，第一任leader一开始就可以直接写入的，不需要第一阶段选举（注意真正的Raft不是这样，因为不在初始配置区分Leader/Follower，启动时也是需要选举的）。这是因为term 0是初始化配置，不可能有比term 0更早的写入，因此可以省掉第一阶段。同理在Paxos中，假如我们规定proposal id最小是0，那么对应proposal id为0的proposer也不用走第一阶段，直接写入就行。</p><h2 id="Quorum"><a href="#Quorum" class="headerlink" title="Quorum"></a>Quorum</h2><p>不管是Paxos还是Raft，反复出现的一个要素是“大多数节点”，也就是所谓Quorum。Quorum的最重要的一个性质就是所有节点的两个Quorum一定至少有一个交集，共识算法就是在一个节点随时会挂或重启的极端不稳定的环境中，构建出这样一个稳定的交集来保证一致性。</p><p>实际上，关于Quorum的一切结论都来源于“两个Quorum必相交”这个性质。其实，“大多数”并不是Quorum的本质，“相交”才是。具体来说，共识算法两阶段所涉及的节点集合，必须要有交集。</p><p>基于这个认知，我们可以设置很多种不同的Quorum方案来适应不同场景，这里试举几例。</p><p>第一种是加权重。Quorum设置为Majority的一个重要理由是使得集群能承受最多数量的节点故障，不过假如因为某种原因节点故障的概率是不同的，我们就可以给节点赋予不同的权重，越是稳定的节点权重越大，Quorum则定义成超过总权重的一半，这么做同样可以保证相交。</p><p>第二种是考虑地理拓扑结构。比如6个节点分布在3个数据中心，如果使用Majority数据必须要复制到4个节点，需要跨数据中心。我们可以将两阶段的Quorum分别定义成“每个中心的至少一个节点”和“某个中心的全部节点”，也就是读取阶段必须读完每个中心，写入阶段必须写完单个中心的全部节点，写入时不用跨数据中心。</p><p>还有一种更泛化的方式是把所有节点放进一个矩阵，然后第一阶段要求完成任意一行，第二阶段要求完成任意一列。比如9个节点，按常规方法两阶段都需要完成5个节点，如果放入3x3的矩阵，那么两个阶段都是最少完成3节点就够了。</p><h2 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi-Paxos"></a>Multi-Paxos</h2><p>到目前为止，我们都只卖一台手机，也就是算法只用来确定一个值。实际场景中往往需要的是确定一系列的值，比如我们可能要卖100台手机。</p><p>最简单的做法就是同时运行100个Paxos实例，每个实例只卖一台手机。不过这也不符合现实场景的需要，比如100台手机一起卖，无法判断E码是不是被重复使用了。更常见的做法是顺序地依次运行100次，最后被确定的是一个连续的日志队列，记录每个手机的卖出记录。</p><p>如何保证“顺序依次运行”呢？我们可以把100台手机想象成100个待确定的“坑”，当proposer在尝试写入一条记录之前，需要找到第一个空闲的坑，并把这个坑之前待确认的坑都给确认了。</p><p>类似Basic Paxos，proposer准备写入一个value时，先生成proposal id放在prepare消息发送给所有acceptor，每个accetpor把自己本地100个坑位的情况回复给proposer。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjye5dp5v2j20dw07wq33.jpg" alt="undefined"></p><p>当proposer收到大多数acceptor的回复后，假如此时收到的回复中，有数据的最大的坑位编号是i，则我们应该把数据写入i+1号坑位。不过，此时i号坑位可能并没有被确认（除非所有acceptor返回的i号坑位的状态是一样的），我们需要先用Basic Paxos的方法把i号确认了（也就是挑选其中proposal id最大的，发送accept并确保收到大多数accepter回复的OK），然后再次使用Basic Paxos的方法把自己的数据填入i+1号坑位。</p><p>有一点需要说明一下，待确认的坑位最多只可能有最大的那一个，因为按照流程如果i之前有未被确认的坑位，i这个位置根本不可能有数据。</p><p>接下来我们来看一下Multi-Paxos一个十分关键的优化。前面介绍，在写入一条记录时，可能需要两次Paxos过程，一次用来确认潜在的未完成的最后一条记录，一次用来写入新记录。实际上，第二次Paxos过程不用做全套，只用做第二阶段就行了。</p><p>怎么做到呢？我们先对proposal id做点小手脚，把proposal id改成递增的proposal id和坑位号的组合，即&lt;proposal_id, index&gt;，比较大小的时候先比较proposal id，再比较index，这样确认完i号坑，准备写i+1号坑时，就不用递增proposal id了，因为index加了1，起到了组合变大的效果。此时如果另一个proposer发过来更大的proposal id，仍然可以打断当前proposer，即&lt;100,0&gt;大于&lt;99,42&gt;。</p><p>接下来我们思考一下，第二轮Paxos里prepare阶段的目的是什么？是为了确保没有更小的proposal id可能确认i+1号坑位，而我们在accept第i号坑位时，已经成功地保证了这一点。（因为我们知道大多数acceptor已经不再接受小于&lt;proposal_id, i+1&gt;的请求了）。</p><p>同样的道理，这个proposer写完i+1号坑之后，可以继续直接accept i+2号坑位，i+3号坑位……直到其他proposer生成出更大的proposal id将其打断。</p><p>因此，在Multi-Paxos中，只要保证同一时刻只有一个proposer，就能做到一次prepare，然后不断进行accept，宏观上来看，写入一个值平均只需要一个阶段。至于如何保证同一时刻只有一个proposer，可以使用类似raft的心跳机制，只要当前工作的proposer能不断发出心跳，其他proposer就不会尝试写入数据。</p><p>Multi-Paxos还有一个优化是pipeline。经过前面的优化，虽然每次写入只需要一阶段RPC，但是连续的写入中完全串行的，前一轮发送accept，收集到多数回复OK确认后，下一轮才开始，即流程是“写入index1 -&gt; 确认index1 -&gt; 写入index2 -&gt; 确认index2”，pipeline的过程就是前一条日志确认之前就开始下一条，即流程变成“写入index1 -&gt; 写入index2 -&gt; 确认index1 -&gt; 确认index2”。</p><p>不过pipeline时要求两条日志是没什么关系的，如果后面的操作依赖前面完成后的结果，就不行了。而且，下一任proposer写入之前，待确认的日志可能就不止最后一条了，处理起来麻烦一些，这里就不展开了。</p><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>最后为了不标题党简单讲一下Raft。个人觉得Raft其实并不比Paxos容易理解，但是肯定比Paxos要易于实现，大体上可以认为Raft就是工程化之后的Multi-Paxos，二者类似图灵机和冯诺尹曼机的关系。</p><p>为啥Paxos不好实现呢？Google Chubby论文里也讲了很多了，主要原因就是Paxos本来就是偏理论的，没太考虑实现上的事情，更倾向于怎么让它更好证明。举个例子，Basic Paxos中第一阶段发出的proposal id如果过小，acceptor会直接抛弃消息，proposer在超时后增加proposal id并重试，当然此时可能还是过小。从工程化的视角出发，为了避免不必要的重试，让acceptor返回自己见过的最大proposal id显然是个好主意。而Paxos不这么干的原因也很简单：反正发消息也可能会丢失，而且不论怎样最终总能递增到一个合适的值，本质上是没有区别的。</p><p>Raft的重要特色就是工程化。这不仅在于其算法本身考虑到了很多实现层面的现实问题，例如节点长时间断连后如何快速追上进度，还在于它在达成共识日志的基础上实现了更为实用的<a href="https://zh.wikipedia.org/wiki/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6" target="_blank" rel="noopener">复制状态机</a>，并提供了几乎等同于伪代码程度的数据结构及算法描述。</p><p>我们还是把注意力聚焦在Raft算法如何生成达成共识的日志队列（Raft Log）。算法核心主要分成两个部分，Leader Election和Log Replication。</p><p>Raft节点在初始化时不指定角色，而是通过投票选举选出Leader，与Naive Raft类似，节点只会给term更大且含有更多日志的节点投票。因此，Leader Election也隐含了读取数据的过程，体现就是leader一定会出现在包含有最新已确认的日志的节点上。与之相比，Multi-Paxos的leader则没有这个限制，选leader只是为了减少冲突，不影响正确性。</p><p>在Log Replication阶段，Leader先把要追加的数据写入本地，然后再通过RPC同步给所有Follower，当收到大多数Follower的回复后，数据就写入成功了。与Multi-Paxos类似，只要不发生leader切换，整体上写入都是一阶段的。</p><p>相比于Multi-Paxos最大的差异是，Raft保证<strong>在每个节点上</strong>，如果第i个坑位的值是被确认的，那么第i个坑位之前的所有坑位就一定都是被确认的。也就是说，不用为每个坑位单独维护状态了，并且节点间通信的消息也简化了，大多数情况下只需要关心最后一个坑位。</p><p>有一种常见的质疑是说这个优化使得Raft无法“并行提交”。比如3个节点，写第一条记录时一个follower卡了一下，写第二条记录时另一个follower也卡住了，此时leader需要等其中一个follower把两条记录都补上，才能继续推进。而在Multi-Paxos中，是可以允许日志出现空洞的，即某一个follower可以把第一条记录先空着，直接确认第二条记录。不过，支持并行提交带来的优势是否值得为此付出的复杂度代价，也是个问题。况且，现实业务往往需要拿到全部日志再做决定，就说卖手机吧，如果之前的日志有空洞，就没法判断当前这个人是不是已经买过手机了。</p><p>Raft有个细节很多人都不理解，就是Raft中新leader选出来后，需要写一条空记录。实际上对照Multi-Paxos就清楚了，这无非就是Multi-Paxos中写入之前确认最后一条记录的过程嘛，只不过Multi-Paxos中是使用当前的proposal id去写旧值，在Raft里面，旧日志的Term无法改成新的，所以就用新Term提交一条空日志，这样顺带就把旧日志一并提交了。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>本文就到此为止了，还有更多高级主题，比如config change什么的因为我也不懂就打住不讲了。啥时候搞懂了可以再写写，嘿嘿嘿。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210128174109.png&quot; style=&quot;zoom: 20%;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;分布式一致性协议把分布式的系统连接到了一起，就像蚁群有个统一的大脑一样，蚁群应该也有这种系统吧。&lt;/p&gt;
&lt;p&gt;除了Paxos，类似的算法还有Bully 算法 Zab算法&lt;/p&gt;
&lt;p&gt;文章来自网络，后续会补上自己的看法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="分布式一致性协议" scheme="http://yoursite.com/tags/分布式一致性协议/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://yoursite.com/2020/10/21/Docker/"/>
    <id>http://yoursite.com/2020/10/21/Docker/</id>
    <published>2020-10-21T12:05:07.000Z</published>
    <updated>2020-10-22T03:34:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjx7mchws6j20y10cv40y.jpg" alt="undefined"></p><blockquote><p>类比：</p><p>蓝色的大海： 宿主机系统（win mac linux）</p><p>鲸鱼：docker</p><p>集装箱：容器实例 from 我们的镜像模版</p></blockquote><a id="more"></a> <h1 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h1><h2 id="为什么会有docker出现"><a href="#为什么会有docker出现" class="headerlink" title="为什么会有docker出现"></a>为什么会有docker出现</h2><p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说吧，Java/Tomcat/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。 传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</p><blockquote><p>也就是 容器化部署环境，一个DockerFile，一次构建，四处部署。 和Java的虚拟机的思想有点类似。</p></blockquote><h2 id="Docker理念"><a href="#Docker理念" class="headerlink" title="Docker理念"></a>Docker理念</h2><p> Docker是基于Go语言实现的云开源项目。Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</p><blockquote><p>解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p></blockquote><h2 id="之前的虚拟机技术"><a href="#之前的虚拟机技术" class="headerlink" title="之前的虚拟机技术"></a>之前的虚拟机技术</h2><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。 虚拟机的缺点：</p><ol><li>资源占用多        </li><li>冗余步骤多         </li><li>启动慢</li></ol><h2 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h2><p> 由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。 比较了 Docker 和传统虚拟化方式的不同之处：<em>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</em>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。* 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p><h2 id="开发-运维"><a href="#开发-运维" class="headerlink" title="开发/运维"></a>开发/运维</h2><h3 id="一次构建、随处运行"><a href="#一次构建、随处运行" class="headerlink" title="一次构建、随处运行"></a>一次构建、随处运行</h3><h4 id="更快速的应用交付和部署"><a href="#更快速的应用交付和部署" class="headerlink" title="更快速的应用交付和部署"></a>更快速的应用交付和部署</h4><p>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</p><h4 id="更便捷的升级和扩缩容"><a href="#更便捷的升级和扩缩容" class="headerlink" title="更便捷的升级和扩缩容"></a>更便捷的升级和扩缩容</h4><p>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</p><h4 id="更简单的系统运维"><a href="#更简单的系统运维" class="headerlink" title="更简单的系统运维"></a>更简单的系统运维</h4><p>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</p><h4 id="更高效的计算资源利用"><a href="#更高效的计算资源利用" class="headerlink" title="更高效的计算资源利用"></a>更高效的计算资源利用</h4><p>Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p><h3 id="Docker官网"><a href="#Docker官网" class="headerlink" title="Docker官网"></a>Docker官网</h3><p>docker官网：<a href="http://www.docker.com/" target="_blank" rel="noopener">http://www.docker.com</a></p><p>docker中文网站：<a href="https://www.docker-cn.com/" target="_blank" rel="noopener">https://www.docker-cn.com/</a></p><p>Docker Hub官网: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h1 id="Docker怎么用"><a href="#Docker怎么用" class="headerlink" title="Docker怎么用"></a>Docker怎么用</h1><h2 id="基本环境说明"><a href="#基本环境说明" class="headerlink" title="基本环境说明"></a>基本环境说明</h2><p>CentOS Docker 安装Docker支持以下的CentOS版本：<code>CentOS 7 (64-bit) CentOS 6.5 (64-bit)</code> 或更高的版本 前提条件目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。 查看自己的内核uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。 查看已安装的CentOS版本信息（CentOS6.8有，CentOS7无该命令）</p><h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><h3 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像     Image"></a>镜像     Image</h3><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 </p><h3 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器     Container"></a>容器     Container</h3><p>Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。 它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><h3 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库     Repository"></a>仓库     Repository</h3><p>仓库（Repository）是集中存放镜像文件的场所。仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)%EF%BC%8C%E5%AD%98%E6%94%BE%E4%BA%86%E6%95%B0%E9%87%8F%E5%BA%9E%E5%A4%A7%E7%9A%84%E9%95%9C%E5%83%8F%E4%BE%9B%E7%94%A8%E6%88%B7%E4%B8%8B%E8%BD%BD%E3%80%82%E5%9B%BD%E5%86%85%E7%9A%84%E5%85%AC%E5%BC%80%E4%BB%93%E5%BA%93%E5%8C%85%E6%8B%AC%E9%98%BF%E9%87%8C%E4%BA%91" target="_blank" rel="noopener">https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云</a> 、网易云 等</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>TODO</p><p>Mac 直接下载安装，后续有别的系统需要安装会补充</p><h1 id="简单原理"><a href="#简单原理" class="headerlink" title="简单原理"></a>简单原理</h1><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjx8j6cq9sj20fe07ndg0.jpg" alt="undefined"></p><p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是常说的集装箱。</p><h2 id="为什么Docker比普通虚拟机要快"><a href="#为什么Docker比普通虚拟机要快" class="headerlink" title="为什么Docker比普通虚拟机要快"></a>为什么Docker比普通虚拟机要快</h2><p>(1) docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。 </p><p>(2) docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。</p><h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><blockquote><p>docker version</p></blockquote><blockquote><p>docker info</p></blockquote><blockquote><p>docker –help</p></blockquote><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><blockquote><p>docker images</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">各个选项说明:</span><br><span class="line">    REPOSITORY：表示镜像的仓库源</span><br><span class="line">    TAG：镜像的标签</span><br><span class="line">    IMAGE ID：镜像ID</span><br><span class="line">    CREATED：镜像创建时间</span><br><span class="line">    SIZE：镜像大小 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a :列出本地所有的镜像（含中间映像层）</span><br><span class="line">-q :只显示镜像ID。</span><br><span class="line">--digests :显示镜像的摘要信息</span><br><span class="line">--no-trunc :显示完整的镜像信息</span><br></pre></td></tr></table></figure><blockquote><p>docker search 某个XXX镜像名字</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不配置镜像的话，从 https://hub.docker.com 上面下载镜像</span><br><span class="line"></span><br><span class="line">docker search [OPTIONS] 镜像名字</span><br><span class="line">OPTIONS说明：</span><br><span class="line">--no-trunc : 显示完整的镜像描述</span><br><span class="line">-s : 列出收藏数不小于指定值的镜像。</span><br><span class="line">--automated : 只列出 automated build类型的镜像；</span><br></pre></td></tr></table></figure><blockquote><p>docker pull 某个XXX镜像名字</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名字[:TAG]</span><br></pre></td></tr></table></figure><blockquote><p>docker rmi 某个XXX镜像名字ID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi  -f 镜像ID</span><br><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG </span><br><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>有镜像才能创建容器，这是根本前提</strong></p><blockquote><p>docker pull centos</p></blockquote><p>新建并启动容器</p><blockquote><p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS说明（常用）：</span><br><span class="line">有些是一个减号，有些是两个减号 </span><br><span class="line">--name=&quot;容器新名字&quot;: 为容器指定一个名称；</span><br><span class="line">-d: 后台运行容器，并返回容器ID，也即启动守护式容器；</span><br><span class="line">-i：以交互模式运行容器，通常与 </span><br><span class="line">-t 同时使用；-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">-P: 随机端口映射；-p: 指定端口映射，有以下四种格式      ip:hostPort:containerPort      ip::containerPort      hostPort:containerPort      containerPort</span><br></pre></td></tr></table></figure><p>#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。docker run -it centos /bin/bash </p><p>列出当前所有正在运行的容器</p><blockquote><p>docker ps [OPTIONS]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS说明（常用）： </span><br><span class="line">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line">-n：显示最近n个创建的容器。</span><br><span class="line">-q :静默模式，只显示容器编号。</span><br><span class="line">--no-trunc :不截断输出。</span><br></pre></td></tr></table></figure><p>退出容器</p><blockquote><p>exit</p></blockquote><blockquote><p>ctrl+P+Q (容器不停止退出)</p></blockquote><p>启动容器</p><blockquote><p>docker start 容器ID或者容器名</p></blockquote><p>重启容器</p><blockquote><p>docker restart 容器ID或者容器名</p></blockquote><p>停止容器</p><blockquote><p>docker stop 容器ID或者容器名</p></blockquote><p>强制停止容器</p><blockquote><p>docker kill 容器ID或者容器名</p></blockquote><p>删除已停止的容器</p><blockquote><p>docker rm 容器ID</p></blockquote><p>一次性删除多个容器</p><blockquote><p>docker rm -f $(docker ps -a -q)</p></blockquote><blockquote><p>docker ps -a -q | xargs docker rm</p></blockquote><h3 id="重要容器命令"><a href="#重要容器命令" class="headerlink" title="重要容器命令"></a>重要容器命令</h3><p>启动守护式容器</p><blockquote><p>docker run -d 容器名</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#使用镜像centos:latest以后台模式启动一个容器docker run -d centos 问题：然后docker ps -a 进行查看, 会发现容器已经退出很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。 这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如service nginx start但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行</span><br></pre></td></tr></table></figure><p>查看容器日志</p><blockquote><p>docker logs -f -t –tail 容器ID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-t 是加入时间戳</span><br><span class="line"></span><br><span class="line">-f 跟随最新的日志打印</span><br><span class="line"></span><br><span class="line">--tail 数字 显示最后多少条</span><br></pre></td></tr></table></figure><p>查看容器内运行的进程</p><blockquote><p>docker top 容器ID</p></blockquote><p>查看容器内部细节, 生成一个非常长的容器字符串</p><blockquote><p>docker inspect 容器ID</p></blockquote><p>进入正在运行的容器并以命令行交互</p><blockquote><p>docker exec -it 容器ID bashShell</p></blockquote><p>exec 是在容器中打开新的终端，并且可以启动新的进程</p><blockquote><p>重新进入docker attach 容器ID</p></blockquote><p>attach 直接进入容器启动命令的终端，不会启动新的进程</p><p>从容器内拷贝文件到主机上</p><blockquote><p>docker cp  容器ID:容器内路径 目的主机路径</p></blockquote><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">attach   Attach to a running container         # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line"></span><br><span class="line">build   Build an image from a Dockerfile        # 通过 Dockerfile 定制镜像</span><br><span class="line"></span><br><span class="line">commit   Create a new image from a container changes  # 提交当前容器为新的镜像</span><br><span class="line"></span><br><span class="line">cp     Copy files/folders from the containers filesystem to the host path  #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line"></span><br><span class="line">create   Create a new container             # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line"></span><br><span class="line">diff    Inspect changes on a container&apos;s filesystem  # 查看 docker 容器变化</span><br><span class="line"></span><br><span class="line">events   Get real time events from the server      # 从 docker 服务获取容器实时事件</span><br><span class="line"></span><br><span class="line">exec    Run a command in an existing container     # 在已存在的容器上运行命令</span><br><span class="line"></span><br><span class="line">export   Stream the contents of a container as a tar archive  # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line"></span><br><span class="line">history  Show the history of an image          # 展示一个镜像形成历史</span><br><span class="line"></span><br><span class="line">images   List images                  # 列出系统当前镜像</span><br><span class="line"></span><br><span class="line">import   Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line"></span><br><span class="line">info    Display system-wide information        # 显示系统相关信息</span><br><span class="line"></span><br><span class="line">inspect  Return low-level information on a container  # 查看容器详细信息</span><br><span class="line"></span><br><span class="line">kill    Kill a running container            # kill 指定 docker 容器</span><br><span class="line"></span><br><span class="line">load    Load an image from a tar archive        # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line"></span><br><span class="line">login   Register or Login to the docker registry server   # 注册或者登陆一个 docker 源服务器</span><br><span class="line"></span><br><span class="line">logout   Log out from a Docker registry server      # 从当前 Docker registry 退出</span><br><span class="line"></span><br><span class="line">logs    Fetch the logs of a container         # 输出当前容器日志信息</span><br><span class="line"></span><br><span class="line">port    Lookup the public-facing port which is NAT-ed to PRIVATE_PORT   # 查看映射端口对应的容器内部源端口</span><br><span class="line"></span><br><span class="line">pause   Pause all processes within a container     # 暂停容器</span><br><span class="line"></span><br><span class="line">ps     List containers                # 列出容器列表</span><br><span class="line"></span><br><span class="line">pull    Pull an image or a repository from the docker registry server  # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line"></span><br><span class="line">push    Push an image or a repository to the docker registry server   # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line"></span><br><span class="line">restart  Restart a running container          # 重启运行的容器</span><br><span class="line"></span><br><span class="line">rm     Remove one or more containers         # 移除一个或者多个容器</span><br><span class="line"></span><br><span class="line">rmi    Remove one or more images       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line"></span><br><span class="line">run    Run a command in a new container        # 创建一个新的容器并运行一个命令</span><br><span class="line"></span><br><span class="line">save    Save an image to a tar archive         # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class="line"></span><br><span class="line">search   Search for an image on the Docker Hub     # 在 docker hub 中搜索镜像</span><br><span class="line"></span><br><span class="line">start   Start a stopped containers           # 启动容器</span><br><span class="line"></span><br><span class="line">stop    Stop a running containers           # 停止容器</span><br><span class="line"></span><br><span class="line">tag    Tag an image into a repository         # 给源中镜像打标签</span><br><span class="line"></span><br><span class="line">top    Lookup the running processes of a container  # 查看容器中运行的进程信息</span><br><span class="line"></span><br><span class="line">unpause  Unpause a paused container           # 取消暂停容器</span><br><span class="line"></span><br><span class="line">version  Show the docker version information      # 查看 docker 版本号</span><br><span class="line"></span><br><span class="line">wait    Block until a container stops, then print its exit code  # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gjx7mchws6j20y10cv40y.jpg&quot; alt=&quot;undefined&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类比：&lt;/p&gt;
&lt;p&gt;蓝色的大海： 宿主机系统（win mac linux）&lt;/p&gt;
&lt;p&gt;鲸鱼：docker&lt;/p&gt;
&lt;p&gt;集装箱：容器实例 from 我们的镜像模版&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Flink Advanced</title>
    <link href="http://yoursite.com/2020/10/21/Flink-Advanced/"/>
    <id>http://yoursite.com/2020/10/21/Flink-Advanced/</id>
    <published>2020-10-21T01:42:56.000Z</published>
    <updated>2021-01-28T09:04:02.846Z</updated>
    
    <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjy2m9uj9pj20zk0np77z.jpg" alt="undefined" style="zoom: 30%;"><blockquote><p>Flink进阶的知识点和文章整理</p></blockquote><a id="more"></a> <h1 id="Flink的应用场景"><a href="#Flink的应用场景" class="headerlink" title="Flink的应用场景"></a>Flink的应用场景</h1><p>前段时间被人问了一个很简单的问题，那就是Flink应该使用在什么应用场景下</p><p>乍一听很简单的问题，我却没法提供让我自己满意的回答，只是说需要用到实时计算的地方都刻意用Flink，表述的不够明确，OK，这边有空来用专业的术语和详细的例子总结一下</p><ul><li>事件驱动型应用</li><li>数据分析型应用</li><li>数据管道型应用</li></ul><h2 id="事件驱动型应用场景"><a href="#事件驱动型应用场景" class="headerlink" title="事件驱动型应用场景"></a>事件驱动型应用场景</h2><h3 id="社交领域"><a href="#社交领域" class="headerlink" title="社交领域"></a>社交领域</h3><p>比如在twitter上，我们点击关注某人，点击之后，点击作为一个事件，以数据的方式被接受计算，被关注者的粉丝数量+1，关注者的关注数量+1，两个数据收到了影响，这个就叫事件驱动型应用。</p><h3 id="电商"><a href="#电商" class="headerlink" title="电商"></a>电商</h3><p>当刷单者疯狂买东西然后每天给很多个好评，持续很多天的时候，这个事件作为一条数据被抛出警告，提醒淘宝平台这个账号有问题，可能在刷单，这也是事件驱动。</p><p>如果某个商家收到来自不同用户的大量投诉，那么可能是店出现了问题，同样提醒淘宝平台。</p><p>在淘宝的推荐系统中</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkoqzw3ghyj20u30guk85.jpg" alt="微信截图_20201114154629.png"></p><p>购买东西作为事件，可以看到会实时触发淘宝的推荐系统进行类似推荐。</p><h3 id="金融行业"><a href="#金融行业" class="headerlink" title="金融行业"></a>金融行业</h3><p>比如说，有人在银行ATM机里面通过摄像头被算法识别到遮挡面部或者遮挡摄像头等特征的时候，会触发一些事件，比如说通知安保人员等等。</p><blockquote><p>事件驱动型应用是一类具有<strong>状态</strong>的应用，该应用会根据事件流中的时间触发计算，更新状态或进行外部系统操作。事件驱动型应用常见于实时计算业务中，比如上面的：实时推荐系统，金融反欺诈系统，实时规则预警系统等。</p></blockquote><p>上述的这种场景毫无疑问是优先于Flink出现而出现的，那么我们来看一下原来我们是如何解决这些问题的</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkoyk15s9qj20zg0hst9j.jpg" alt="微信截图_20201114200806.png"></p><p>这个是我们最开始的解决此类问题的架构</p><p>对于一些数据规模是很大，实时性要求不是很高的场景来说，效果是很好的，但是随着数量的不断增加，尤其是数据爆炸时代背景下的海量数据，以关系型数据为例，这里我们需要使用分库分表的方式来支持海量数据，这种方式由于数据库的各种限制，比如说事务一致性的控制，数据备份机制，全局索引等等数据库的实际的架构方面的原因，随着数据量的增加，写入和查询的性能会受到很大的挑战，尤其在实时性要求更高的场景，我们需要更优秀的架构。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkozw4iza2j215l0g6q3y.jpg" alt="微信截图_20201114205428.png"></p><p>这个是引入了Flink之后的架构，在一个完整的时间驱动型架构中往往会涉及到已有数据实体的存储，实体之间关系的维护，统计报表的持久化等需求，所以我们在这个架构中仍然需要用到传统关系型数据库，那么在这个架构中，触发计算的部分，我们交给Apache Flink处理，计算结果既可以存储到支持海量数据的Hadoop生态中的HDFS上，我们也可以将计算结果和统计信息存储在传统数据库中供实时查询。</p><p>那么这种解决方案有什么优势呢？</p><p><strong>实时性</strong>。为了数据价值最大化，从上面的场景中，我们可以很明显的体会到数据实时反馈的重要性，Flink为了实时计算处理，进行了针对实时流计算的定制特性，比如丰富的状态支持，多窗口语义支持，灵活的Timer和Trigger机制，强大的CEP机制等等等，同时进行了大量的性能优化，这里限于篇幅不能一一列举，后面有机会会再介绍。</p><h2 id="数据分析型应用"><a href="#数据分析型应用" class="headerlink" title="数据分析型应用"></a>数据分析型应用</h2><p>So，怎样的应用才是数据分析型应用呢？</p><p>数据分析型应用是一个非常宽泛的范围，凡是数据分析型应用都是<strong>从原始数据中提取有价值的信息和指标</strong>。</p><p>传统的数据分析方案是一次查询，获得一次查询 获得一次结果，为了实现始终得到最新的结果，需要自己定义触发器（到了某个设定的条件，自动执行查询）也就是我们说的Batch方式的查询方式。</p><p>而得益于Timer和State的支持，Flink能够持续查询，Flink的Timer能够持续触发计算，State能够保存上次结果增加计算，一次查询能够源源不断的获得最新的结果。</p><p>为了体现Flink的优秀性能，我举一些特定例子</p><p>比如说，几乎要求零延迟的天猫/京东双十一大屏</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkp3n2m556j20d805qgtj.jpg" alt="微信截图_20201114230411.png"></p><p>这个统计结果几乎是要求零延迟展示给大家的，现在几家巨头电商的双十一计算逻辑都是在Flink中实现的，侧面验证了Flink在快和处理数据量巨大这两点上的可靠性。</p><p>实际上更多的业务可能既既是事件驱动型应用又是数据分析型应用，如果一定要定义这两种区别的话，我们可以从处理目的上来定义，事件驱动型应用是数据最后会直接派发新动作，比如上面的ATM应用检测到不正常动作就触发报警。而数据分析我们只是产生数据，让决策者根据结果数据为现实事件做决定。</p><h2 id="数据管道型应用"><a href="#数据管道型应用" class="headerlink" title="数据管道型应用"></a>数据管道型应用</h2><p>我们在采集数据的时候往往会根据数据的特性（数据量的大小，数据的结构）采用不同的数据库来存储数据，但是我们在使用数据的时候如果需要进行流处理，那么我们要针对不用的数据库开发的数据库开发上面所述的不同的触发器，大大增加开发成本。</p><p>现在Flink已经集成了CDC功能，正在完善对各个流行的数据库的解析模块，随着时间的推移，最后会成为一个完美的数据管道。</p><h2 id="流处理的历史"><a href="#流处理的历史" class="headerlink" title="流处理的历史"></a>流处理的历史</h2><p>这里把流处理的历史放在了第二部分，上面花了相当的篇幅来描述了什么是Flink(流处理)，先弄懂了这个，然后再介绍历史，应该会好一些。</p><p>为了同时获得准确性和低延迟，为了让当时的数据处理系统，可以同时提供快速和准确的结果，人们设计了所谓的lambda架构。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl83jzfn69j20l507utah.jpg" alt="undefined"></p><p>lambda架构增强了传统的批处理架构，其“快速层”（speed layer）由低延迟的流处理器来支持。数据到达之后由流处理器提取出来，并写入批处理存储。流处理器近乎实时地计算近似结果并将它们写入“快速表”（speed table）。批处理器定期处理批量存储中的数据，将准确的结果写入批处理表，并从速度表中删除相应的不准确结果。应用程序会合并快速表中的近似结果和批处理表中的准确结果，然后消费最终的结果。</p><p>lambda架构现在已经不再是最先进的，但仍在许多地方使用。该体系结构的最初目标是改善原始批处理分析体系结构的高延迟。但是，它有一些明显的缺点。首先，它需要对一个应用程序，做出两个语义上等效的逻辑实现，用于两个独立的、具有不同API的处理系统。其次，流处理器计算的结果只是近似的。第三，lambda架构很难建立和维护。</p><p>通过在第一代基础上进行改进，下一代分布式开源流处理器（2013）提供了更好的故障保证，并确保在发生故障时，每个输入记录仅对结果产生一次影响（exactly -once）。此外，编程API从相当低级的操作符接口演变为高级API。但是，一些改进（例如更高的吞吐量和更好的故障保证）是以将处理延迟从毫秒增加到几秒为代价的。此外，结果仍然取决于到达事件的时间和顺序。</p><p>第三代分布式开源流处理器（2015）解决了结果对到达事件的时间和顺序的依赖性。结合精确一次（exactly-once）的故障语义，这一代系统是第一个具有计算一致性和准确结果的开源流处理器。通过基于实际数据来计算结果（“重演”数据），这些系统还能够以与“实时”数据相同的方式处理历史数据。另一个改进是解决了延迟/吞吐量无法同时保证的问题。先前的流处理器仅能提供高吞吐量或者低延迟（其中之一），而第三代系统能够同时提供这两个特性。这一代的流处理器使得lambda架构过时了。当然，这一代流处理以flink为代表。</p><p>除了目前讨论的特性，例如容错、性能和结果准确性之外，流处理器还不断添加新的操作功能，例如高可用性设置，与资源管理器（如YARN或Kubernetes）的紧密集成，以及能够动态扩展流应用程序。其他功能包括：支持升级应用程序代码，或将作业迁移到其他群集或新版本的流处理器，而不会丢失当前状态。</p><h1 id="Flink基础：流处理基础"><a href="#Flink基础：流处理基础" class="headerlink" title="Flink基础：流处理基础"></a>Flink基础：流处理基础</h1><h2 id="数据流编程简介"><a href="#数据流编程简介" class="headerlink" title="数据流编程简介"></a>数据流编程简介</h2><h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><p>之前做了一个纯Java分析项目，大大加深了我对流处理的认识，只要是流处理，总是会包含的一些特性 ==&gt; 我们把这些特性称之为流处理特性。</p><p>顾名思义，<strong>数据流程序</strong>描述了数据如何在算子之间流动。数据流程序通常表示为有向图，其中<strong>节点称为算子</strong>，<strong>用来表示计算，边表示数据之间的依赖性</strong>。算子是数据流程序的基本功能单元。他们从输入消耗数据，对它们执行计算，并生成数据输出用于进一步处理。一个数据流图必须至少有一个数据源和一个数据接收器。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl83x00h4bj20l904ign3.jpg" alt="undefined"></p><p>上面的图只能叫逻辑流图，没有考虑在实际执行过程中的物理机的问题，下面是物理数据流图</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl840jvc7zj20l6080di4.jpg" alt="undefined"></p><p>在物理数据流图中，节点是任务。“Extract hashtags”和“Count”算子有两个并行算子任务，每个算子任务对输入数据的子集执行计算。</p><h3 id="数据并行与任务并行"><a href="#数据并行与任务并行" class="headerlink" title="数据并行与任务并行"></a>数据并行与任务并行</h3><p>我们可以以不同方式利用数据流图中的并行性。第一，我们可以<strong>对输入数据进行分区，并在数据的子集上并行执行具有相同算子的任务并行</strong>。这种类型的并行性被称为<strong>数据并行性</strong>。数据并行是有用的，因为它允许处理大量数据，并将计算分散到不同的计算节点上。第二，<strong>我们可以将不同的算子在相同或不同的数据上并行执行</strong>。这种并行性称为任务并行性。使用<strong>任务并行性</strong>，我们可以更好地利用计算资源。</p><h3 id="数据交换策略"><a href="#数据交换策略" class="headerlink" title="数据交换策略"></a>数据交换策略</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl84e3gozaj20lg0dfwhb.jpg" alt="undefined"></p><ul><li><strong>前向策略</strong>将数据从一个任务发送到接收任务。如果两个任务都位于同一台物理计算机上（这通常由任务调度器确保），这种交换策略可以避免网络通信。</li><li><strong>广播策略</strong>将所有数据发送到算子的所有的并行任务上面去。因为这种策略会复制数据和涉及网络通信，所以代价相当昂贵。</li><li><strong>基于键控的策略</strong>通过Key值(键)对数据进行分区保证具有相同Key的数据将由同一任务处理。在图2-2中，输出“Extract hashtags”算子使用键来分区（hashtag），以便count算子的任务可以正确计算每个#标签的出现次数。</li><li><strong>随机策略</strong>统一将数据分配到算子的任务中去，以便均匀地将负载分配到不同的计算任务。</li></ul><h2 id="并行处理流数据"><a href="#并行处理流数据" class="headerlink" title="并行处理流数据"></a>并行处理流数据</h2><p>首先，让我们定义术语数据流：<strong>数据流是一个可能无限的事件序列。</strong></p><p>数据流中的事件可以表示监控数据，传感器测量数据，信用卡交易数据，气象站观测数据，在线用户交互数据，网络搜索数据等。在本节中，我们将学习如何并行处理无限流，使用数据流编程范式。</p><h3 id="延迟和吞吐量"><a href="#延迟和吞吐量" class="headerlink" title="延迟和吞吐量"></a>延迟和吞吐量</h3><p>流处理程序不同与批处理程序。在评估性能时，要求也有所不同。对于批处理程序，我们通常关心一个作业的总的执行时间，或我们的处理引擎读取输入所需的时间，执行计算，并回写结果。由于流处理程序是连续运行的，输入可能是无界的，所以数据流处理中没有总执行时间的概念。 相反，流处理程序必须尽可能快的提供输入ew数据的计算结果。我们使用延迟和吞吐量来表征流处理的性能要求。</p><h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><p><strong>延迟表示处理事件所需的时间</strong>。</p><p>在数据流中，延迟是以时间为单位测量的，例如毫秒。根据应用程序，我们可能会关心平均延迟，最大延迟或百分位延迟。例如，平均延迟值为10ms意味着处理事件的平均时间在10毫秒内。或者，延迟值为95%，10ms表示95%的事件在10ms内处理完毕。平均值隐藏了处理延迟的真实分布，可能会让人难以发现问题。</p><p>确保低延迟对于许多流应用程序来说至关重要，例如欺诈检测，系统警报，网络监控和提供具有严格服务水平协议的服务。低延迟是流处理的关键特性，它实现了我们所谓的实时应用程序。像Apache Flink这样的现代流处理器可以提供低至几毫秒的延迟。</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p><strong>吞吐量是衡量系统处理能力的指标，也就是处理速率。</strong></p><h2 id="数据流上的操作"><a href="#数据流上的操作" class="headerlink" title="数据流上的操作"></a>数据流上的操作</h2><p>流处理引擎通畅提供的一组内置操作：                                                                                                                                                                                                                                                           </p><p><strong>摄取(ingest)，转换(transform)和输出流(output)</strong></p><p>操作可以是无状态的或有状态的。无状态操作不保持任何内部状态。也就是说，事件的处理不依赖于过去看到的任何事件，也没有保留历史。 无状态操作很容易并行化，因为事件可以彼此独立地处理，也独立于事件到达的顺序(和事件到达顺序没有关系)。 而且，在失败的情况下，无状态操作可以是简单的重新启动并从中断处继续处理。相反， 有状态操作可能会维护之前收到的事件的信息。此状态可以通过传入事件更新，也可以用于未来事件的处理逻辑。有状态的流 处理应用程序更难以并行化和以容错的方式来运行，因为状态需要有效的进行分区和在发生故障的情况下可靠地恢复。</p><h3 id="数据摄入和数据吞吐量"><a href="#数据摄入和数据吞吐量" class="headerlink" title="数据摄入和数据吞吐量"></a>数据摄入和数据吞吐量</h3><p>数据摄取和数据出口操作允许流处理程序与外部系统通信。数据摄取是操作从外部源获取原始数据并将其转换为其他格式(ETL)。实现数据提取逻辑的运算符被称为数据源。数据源可以从TCP Socket，文件，Kafka Topic或传感器数据接口中提取数据。数据出口是以适合消费的形式产出到外部系统。执行数据出口的运算符称为数据接收器，包括文件，数据库，消息队列和监控接口。</p><h3 id="转换算子"><a href="#转换算子" class="headerlink" title="转换算子"></a>转换算子</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl84so9twij20sv05a74j.jpg" alt="undefined"></p><p>转换算子是单遍处理算子，碰到一个事件处理一个事件。这些操作在使用后会消费一个事件，然后对事件数据做一些转换，产生一个新的输出流。转换逻辑可以集成在 操作符中或由UDF函数提供。</p><p>操作符可以接受多个输入流并产生多个输出流。他们还可以通过修改数据流图的结构要么将流分成多个流，要么将流合并为一条流。</p><h3 id="滚动聚合"><a href="#滚动聚合" class="headerlink" title="滚动聚合"></a>滚动聚合</h3><p>滚动聚合是一种聚合，例如sum，minimum和maximum，为每个输入事件不断更新。 聚合操作是有状态的，并将当前状态与传入事件一起计算以产生更新的聚合值。请注意能够有效地将当前状态与事件相结合 产生单个值，聚合函数必须是关联的和可交换的。否则，操作符必须存储完整的流数据历史。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl84v84umrj20jt0cgq3o.jpg" alt="undefined"></p><h3 id="窗口操作符"><a href="#窗口操作符" class="headerlink" title="窗口操作符"></a>窗口操作符</h3><p>转换和滚动聚合一次处理一个事件产生输出事件并可能更新状态。但是，有些操作必须收集并缓冲数据以计算其结果。 例如，考虑不同流之间的连接或整体聚合这样的操作，例如中值函数。为了在无界流上高效运行这些操作符，我们需要限制 这些操作维护的数据量。在本节中，我们将讨论窗口操作，提供此服务。</p><p>窗口还可以在语义上实现关于流的比较复杂的查询。我们已经看到了滚动聚合的方式，以聚合值编码整个流的历史数据来为每个事件提供低延迟的结果。 但如果我们只对最近的数据感兴趣的话会怎样？考虑给司机提供实时交通信息的应用程序。这个程序可以使他们避免拥挤的路线。在这种场景下，你想知道某个位置在最近几分钟内是否有事故发生。 另一方面，了解所有发生过的事故在这个应用场景下并没有什么卵用。更重要的是，通过将流历史缩减为单一聚合值，我们将丢失这段时间内数据的变化。例如，我们可能想知道每5分钟有多少车辆穿过 某个路口。</p><p><strong>窗口操作不断从无限事件流中创建有限的事件集</strong>，好让我们执行有限集的计算。通常会基于数据属性或基于时间的窗口来分配事件。 要正确定义窗口运算符语义，我们需要确定如何给窗口分配事件以及对窗口中的元素进行求值的频率是什么样的。 窗口的行为由一组策略定义。窗口策略决定何时创建新的窗口以及要分配的事件属于哪个窗口，以及何时对窗口中的元素进行求值。 而窗口的求值基于触发条件。一旦触发条件得到满足，窗口的内容将会被发送到求值函数，求值函数会将计算逻辑应用于窗口中的元素。 求值函数可以是sum或minimal或自定义的聚合函数。 求值策略可以根据时间或者数据属性计算(例如，在过去五秒内收到的事件或者最近的一百个事件等等)。 接下来，我们描述常见窗口类型的语义。</p><ul><li>滚动窗口是将事件分配到固定大小的不重叠的窗口中。当通过窗口的结尾时，全部事件被发送到求值函数进行处理。基于计数的滚动窗口定义了在触发求值之前需要收集多少事件。下图显示了一个基于计数的翻滚窗口，每四个元素一个窗口。基于时间的滚动窗口定义一个时间间隔，包含在此时间间隔内的事件。下下图显示了基于时间的滚动窗口，将事件收集到窗口中每10分钟触发一次计算。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl853ixg14j20xl06v3yq.jpg" alt="undefined"></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl853p56uoj20z007yjrn.jpg" alt="undefined"></p><ul><li>滑动窗口将事件分配到固定大小的重叠的窗口中去。因此，事件可能属于多个桶。我们通过提供窗口的长度和滑动距离来定义滑动窗口。滑动距离定义了创建新窗口的间隔。基于滑动计数的窗口，下图长度为四个事件，三个为滑动距离。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl855xhdfdj20vz08h0st.jpg" alt="undefined"></p><ul><li>会话窗口在常见的真实场景中很有用，一些场景既不能使用滚动窗口也不能使用滑动窗口。考虑一个分析在线用户行为的应用程序。在应用程序里，我们想把源自同一时期的用户活动或会话事件分组在一起。会话由一系列相邻时间发生的事件组成，接下来有一段时间没有活动。例如，用户在App上浏览一系列的新闻，然后关掉App，那么浏览新闻这段时间的浏览事件就是一个会话。会话窗口事先没有定义窗口的长度，而是取决于数据的实际情况，滚动窗口和滑动窗口无法应用于这个场景。相反，我们需要将同一会话中的事件分配到同一个窗口中去，而不同的会话可能窗口长度不一样。会话窗口会定义一个间隙值来区分不同的会话。间隙值的意思是：用户一段时间内不活动，就认为用户的会话结束了。下图显示了一个会话窗口。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl856ykspxj20zb06zdg1.jpg" alt="undefined"></p><p>到目前为止，所有窗口类型都是在整条流上去做窗口操作。但实际上你可能想要将一条流分流成多个逻辑流并定义并行窗口。 例如，如果我们正在接收来自不同传感器的测量结果，那么可能想要在做窗口计算之前按传感器ID对流进行分流操作。 在并行窗口中，每条流都独立于其他流，然后应用了窗口逻辑。下图显示了一个基于计数的长度为2的并行滚动窗口，根据事件颜色分流。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl858l5xs9j20to0c80t6.jpg" alt="undefined"></p><p>在流处理中，窗口操作与两个主要概念密切相关：时间语义和状态管理。时间也许是流处理最重要的方面。即使低延迟是流处理的一个有吸引力的特性，它的真正价值不仅仅是快速分析。真实世界的系统，网络和通信渠道远非完美，流数据经常被推迟或无序(乱序)到达。理解如何在这种条件下提供准确和确定的结果是至关重要的。 更重要的是，流处理程序可以按原样处理事件制作的也应该能够处理相同的历史事件方式，从而实现离线分析甚至时间旅行分析。 当然，前提是我们的系统可以保存状态，因为可能有故障发生。到目前为止，我们看到的所有窗口类型在产生结果前都需要保存之前的数据。实际上，如果我们想计算任何指标，即使是简单的计数，我们也需要保存状态。考虑到流处理程序可能会运行几天，几个月甚至几年，我们需要确保状态可以在发生故障的情况下可靠地恢复。 并且即使程序崩溃，我们的系统也能保证计算出准确的结果。本章，我们将在流处理应用可能发生故障的语境下，深入探讨时间和状态的概念。</p><h2 id="时间语义"><a href="#时间语义" class="headerlink" title="时间语义"></a>时间语义</h2><h3 id="在流处理中一分钟代表什么？"><a href="#在流处理中一分钟代表什么？" class="headerlink" title="在流处理中一分钟代表什么？"></a>在流处理中一分钟代表什么？</h3><p>在处理可能是无限的事件流（包含了连续到达的事件），时间成为流处理程序的核心方面。假设我们想要连续的计算结果，可能每分钟就要计算一次。在我们的流处理程序上下文中，一分钟的意思是什么？</p><p>考虑一个程序需要分析一款移动端的在线游戏的用户所产生的事件流。游戏中的用户分了组，而应用程序将收集每个小组的活动数据，基于小组中的成员多快达到了游戏设定的目标，然后在游戏中提供奖励。例如额外的生命和用户升级。例如，如果一个小组中的所有用户在一分钟之内都弹出了500个泡泡，他们将升一级。Alice是一个勤奋的玩家，她在每天早晨的通勤时间玩游戏。问题在于Alice住在柏林，并且乘地铁去上班。而柏林的地铁手机信号很差。我们设想一个这样的场景，Alice当她的手机连上网时，开始弹泡泡，然后游戏会将数据发送到我们编写的应用程序中，这时地铁突然进入了隧道，她的手机也断网了。Alice还在玩这个游戏，而产生的事件将会缓存在手机中。当地铁离开隧道，Alice的手机又在线了，而手机中缓存的游戏事件将发送到应用程序。我们的应用程序应该如何处理这些数据？在这个场景中一分钟的意思是什么？这个一分钟应该包含Alice离线的那段时间吗？下图展示了这个问题。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl85ano45xj20pr0fbjsg.jpg" alt="undefined"></p><p>在线手游是一个简单的场景，展示了应用程序的运算应该取决于事件实际发生的时间，而不是应用程序收到事件的时间。如果我们按照应用程序收到事件的时间来进行处理的话，最糟糕的后果就是，Alice和她的朋友们再也不玩这个游戏了。但是还有很多时间语义非常关键的应用程序，我们需要保证时间语义的正确性。如果我们只考虑我们在一分钟之内收到了多少数据，我们的结果会变化，因为结果取决于网络连接的速度或处理的速度。相反，定义一分钟之内的事件数量，这个一分钟应该是数据本身的时间。</p><p>在Alice的这个例子中，流处理程序可能会碰到两个不同的时间概念：处理时间和事件时间。我们将在接下来的部分，讨论这两个概念。</p><h3 id="处理时间"><a href="#处理时间" class="headerlink" title="处理时间"></a>处理时间</h3><p>处理时间是处理流的应用程序的机器的本地时钟的时间（墙上时钟）。处理时间的窗口包含了一个时间段内来到机器的所有事件。这个时间段指的是机器的墙上时钟。如下图所示，在Alice的这个例子中，处理时间窗口在Alice的手机离线的情况下，时间将会继续行走。但这个处理时间窗口将不会收集Alice的手机离线时产生的事件。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl85e0dlv9j20pq0g8jsi.jpg" alt="undefined"></p><h3 id="事件时间"><a href="#事件时间" class="headerlink" title="事件时间"></a>事件时间</h3><p>　　事件时间是流中的事件实际发生的时间。事件时间基于流中的事件所包含的时间戳。通常情况下，在事件进入流处理程序前，事件数据就已经包含了时间戳。下图展示了事件时间窗口将会正确的将事件分发到窗口中去。可以如实反应事情是怎么发生的。即使事件可能存在延迟。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl85efcaw7j20pq0g80tu.jpg" alt="undefined"></p><p>​        事件时间使得计算结果的过程不需要依赖处理数据的速度。基于事件时间的操作是可以预测的，而计算结果也是确定的。无论流处理程序处理流数据的速度快或是慢，无论事件到达流处理程序的速度快或是慢，事件时间窗口的计算结果都是一样的。</p><p>　　可以处理迟到的事件只是我们使用事件时间所克服的一个挑战而已。普遍存在的事件乱序问题可以使用事件时间得到解决。考虑和Alice玩同样游戏的Bob，他恰好和Alice在同一趟地铁上。Alice和Bob虽然玩的游戏一样，但他们的手机信号是不同的运营商提供的。当Alice的手机没信号时，Bob的手机依然有信号，游戏数据可以正常发送出去。</p><p>　　如果使用事件时间，即使碰到了事件乱序到达的情况，我们也可以保证结果的正确性。还有，当我们在处理可以重播的流数据时，由于时间戳的确定性，我们可以快进过去。也就是说，我们可以重播一条流，然后分析历史数据，就好像流中的事件是实时发生一样。另外，我们可以快进历史数据来使我们的应用程序追上现在的事件，然后应用程序仍然是一个实时处理程序，而且业务逻辑不需要改变。</p><h3 id="水位线"><a href="#水位线" class="headerlink" title="水位线"></a>水位线</h3><p>　　在我们对事件时间窗口的讨论中，我们忽略了一个很重要的方面：<strong>我们应该怎样去决定何时触发事件时间窗口的计算</strong>？也就是说，在我们可以确定一个时间点之前的所有事件都已经到达之前，我们需要等待多久？我们如何知道事件是迟到的？在分布式系统无法准确预测行为的现实条件下，以及外部组件所引发的事件的延迟，以上问题并没有准确的答案。在本小节中，我们将会看到如何使用水位线来设置事件时间窗口的行为。</p><p>　　水位线是全局进度的度量标准。系统可以确信在一个时间点之后，不会有早于这个时间点发生的事件到来了。本质上，水位线提供了一个逻辑时钟，这个逻辑时钟告诉系统当前的事件时间。当一个运算符接收到含有时间T的水位线时，这个运算符会认为早于时间T的发生的事件已经全部都到达了。对于事件时间窗口和乱序事件的处理，水位线非常重要。运算符一旦接收到水位线，运算符会认为一段时间内发生的所有事件都已经观察到，可以触发针对这段时间内所有事件的计算了。</p><p>　　水位线提供了一种结果可信度和延时之间的妥协。激进的水位线设置可以保证低延迟，但结果的准确性不够。在这种情况下，迟到的事件有可能晚于水位线到达，我们需要编写一些代码来处理迟到事件。另一方面，如果水位线设置的过于宽松，计算的结果准确性会很高，但可能会增加流处理程序不必要的延时。</p><p>　　在很多真实世界的场景里面，系统无法获得足够的知识来完美的确定水位线。在手游这个场景中，我们无法得知一个用户离线时间会有多长，他们可能正在穿越一条隧道，可能正在乘飞机，可能永远不会再玩儿了。水位线无论是用户自定义的或者是自动生成的，在一个分布式系统中追踪全局的时间进度都不是很容易。所以仅仅依靠水位线可能并不是一个很好的主意。流处理系统还需要提供一些机制来处理迟到的元素（在水位线之后到达的事件）。根据应用场景，我们可能需要把迟到事件丢弃掉，或者写到日志里，或者使用迟到事件来更新之前已经计算好的结果。</p><h3 id="处理时间和事件时间"><a href="#处理时间和事件时间" class="headerlink" title="处理时间和事件时间"></a>处理时间和事件时间</h3><p>　　大家可能会有疑问，既然事件时间已经可以解决我们的所有问题，为什么我们还要对比这两个时间概念？真相是，处理时间在很多情况下依然很有用。处理时间窗口将会带来理论上最低的延迟。因为我们不需要考虑迟到事件以及乱序事件，所以一个窗口只需要简单的缓存窗口内的数据即可，一旦机器时间超过指定的处理时间窗口的结束时间，就会触发窗口的计算。所以对于一些处理速度比结果准确性更重要的流处理程序，处理时间就派上用场了。另一个应用场景是，当我们需要在真实的时间场景下，周期性的报告结果时，同时不考虑结果的准确性。一个例子就是一个实时监控的仪表盘，负责显示当事件到达时立即聚合的结果。最后，处理时间窗口可以提供流本身数据的忠实表达，对于一些案例可能是很必要的特性。例如我们可能对观察流和对每分钟事件的计数（检测可能存在的停电状况）很感兴趣。简单的说，处理时间提供了低延迟，同时结果也取决于处理速度，并且也不能保证确定性。另一方面，事件时间保证了结果的确定性，同时还可以使我们能够处理迟到的或者乱序的事件流。</p><h2 id="状态和持久化模型"><a href="#状态和持久化模型" class="headerlink" title="状态和持久化模型"></a>状态和持久化模型</h2><p>我们现在转向另一个对于流处理程序非常重要的话题：状态。在数据处理中，状态是普遍存在的。任何稍微复杂一点的计算，都涉及到状态。为了产生计算结果，一个函数在一段时间内的一定数量的事件上来累加状态（例如，聚合计算或者模式匹配）。有状态的运算符使用输入的事件以及内部保存的状态来计算得到输出。例如，一个滚动聚合运算符需要输出这个运算符所观察到的所有事件的累加和。这个运算符将会在内部保存当前观察到的所有事件的累加和，同时每输入一个事件就更新一次累加和的计算结果。相似的，当一个运算符检测到一个“高温”事件紧接着十分钟以内检测到一个“烟雾”事件时，将会报警。直到运算符观察到一个“烟雾”事件或者十分钟的时间段已经过去，这个运算符需要在内部状态中一直保存着“高温”事件。</p><p>当我们考虑一下使用批处理系统来分析一个无界数据集时，会发现状态的重要性显而易见。在现代流处理器兴起之前，处理无界数据集的一个通常做法是将输入的事件攒成微批，然后交由批处理器来处理。当一个任务结束时，计算结果将被持久化，而所有的运算符状态就丢失了。一旦一个任务在计算下一个微批次的数据时，这个任务是无法访问上一个任务的状态的（都丢掉了）。这个问题通常使用将状态代理到外部系统（例如数据库）的方法来解决。相反，在一个连续不间断运行的流处理任务中，事件的状态是一直存在的，我们可以将状态暴露出来作为编程模型中的一等公民。当然，我们的确可以使用外部系统来管理流的状态，即使这个解决方案会带来额外的延迟。</p><p>由于流处理运算符默认处理的是无界数据流。所以我们必须要注意不要让内部状态无限的增长。为了限制状态的大小，运算符通常情况下会保存一些之前所观察到的事件流的总结或者概要。这个总结可能是一个计数值，一个累加和，或者事件流的采样，窗口的缓存操作，或者是一个自定义的数据结构，这个数据结构用来保存数据流中感兴趣的一些特性。</p><p>我们可以想象的到，支持有状态的运算符可能会碰到一些实现上的挑战：</p><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>系统需要高效的管理状态，并保证针对状态的并发更新，不会产生竞争条件（race condition）。</p><h3 id="状态分区"><a href="#状态分区" class="headerlink" title="状态分区"></a>状态分区</h3><p>并行会带来复杂性。因为计算结果同时取决于已经保存的状态和输入的事件流。幸运的是，大多数情况下，我们可以使用Key来对状态进行分区，然后独立的管理每一个分区。例如，当我们处理一组传感器的测量事件流时，我们可以使用分区的运算符状态来针对不同的传感器独立的保存状态。</p><h3 id="状态恢复"><a href="#状态恢复" class="headerlink" title="状态恢复"></a>状态恢复</h3><p>第三个挑战是有状态的运算符如何保证状态可以恢复，即使出现任务失败的情况，计算也是正确的。</p><h3 id="任务失败"><a href="#任务失败" class="headerlink" title="任务失败"></a>任务失败</h3><p>流任务中的运算符状态是很宝贵的，也需要抵御任务失败带来的问题。如果在任务失败的情况下，状态丢失的话，在任务恢复以后计算的结果将是不正确的。流任务会连续不断的运行很长时间，而状态可能已经收集了几天甚至几个月。在失败的情况下，重新处理所有的输入并重新生成一个丢失的状态，将会很浪费时间，开销也很大。</p><h4 id="什么是任务失败？"><a href="#什么是任务失败？" class="headerlink" title="什么是任务失败？"></a>什么是任务失败？</h4><p>　　对于流中的每一个事件，一个处理任务分为以下步骤：</p><p>　　（1）接收事件，并将事件存储在本地的缓存中；</p><p>　　（2）可能会更新内部状态；</p><p>　　（3）产生输出记录。这些步骤都能失败，而系统必须对于在失败的场景下如何处理有清晰的定义。如果任务在第一步就失败了，事件会丢失吗？如果当更新内部状态的时候任务失败，那么内部状态会在任务恢复以后更新吗？在以上这些场景中，输出是确定性的吗？</p><p>　　在批处理场景下，所有的问题都不是问题。因为我们可以很方便的重新计算。所以不会有事件丢失，状态也可以得到完全恢复。在流的世界里，处理失败不是一个小问题。流系统在失败的情况下需要保证结果的准确性。接下来，我们需要看一下现代流处理系统所提供的一些保障，以及实现这些保障的机制。</p><h4 id="结果的保证"><a href="#结果的保证" class="headerlink" title="结果的保证"></a>结果的保证</h4><p>当我们讨论保证计算的结果时，我们的意思是流处理器的内部状态需要保证一致性。也就是说我们关心的是应用程序的代码在故障恢复以后看到的状态值是什么。要注意保证应用程序状态的一致性并不是保证应用程序的输出结果的一致性。一旦输出结果被持久化，结果的准确性就很难保证了。除非持久化系统支持事务。</p><p><strong>AT-MOST-ONCE</strong></p><p>　　当任务故障时，最简单的做法是什么都不干，既不恢复丢失的状态，也不重播丢失的事件。At-most-once语义的含义是最多处理一次事件。换句话说，事件可以被丢弃掉，也没有任何操作来保证结果的准确性。这种类型的保证也叫“没有保证”，因为一个丢弃掉所有事件的系统其实也提供了这样的保障。没有保障听起来是一个糟糕的主意，但如果我们能接受近似的结果，并且希望尽可能低的延迟，那么这样也挺好。</p><p><strong>AT-LEAST-ONCE</strong></p><p>　　在大多数的真实应用场景，我们希望不丢失事件。这种类型的保障成为at-least-once，意思是所有的事件都得到了处理，而且一些事件还可能被处理多次。如果结果的正确性仅仅依赖于数据的完整性，那么重复处理是可以接受的。例如，判断一个事件是否在流中出现过，at-least-once这样的保证完全可以正确的实现。在最坏的情况下，我们多次遇到了这个事件。而如果我们要对一个特定的事件进行计数，计算结果就可能是错误的了。</p><p>　　为了保证在at-least-once语义的保证下，计算结果也能正确。我们还需要另一套系统来从数据源或者缓存中重新播放数据。持久化的事件日志系统将会把所有的事件写入到持久化存储中。所以如果任务发生故障，这些数据可以重新播放。还有一种方法可以获得同等的效果，就是使用结果承认机制。这种方法将会把每一条数据都保存在缓存中，直到数据的处理等到所有的任务的承认。一旦得到所有任务的承认，数据将被丢弃。</p><p><strong>EXACTLY-ONCE</strong></p><p>　　恰好处理一次是最严格的保证，也是最难实现的。恰好处理一次语义不仅仅意味着没有事件丢失，还意味着针对每一个数据，内部状态仅仅更新一次。本质上，恰好处理一次语义意味着我们的应用程序可以提供准确的结果，就好像从未发生过故障。</p><p>　　提供恰好处理一次语义的保证必须有至少处理一次语义的保证才行，同时还需要数据重放机制。另外，流处理器还需要保证内部状态的一致性。也就是说，在故障恢复以后，流处理器应该知道一个事件有没有在状态中更新。事务更新是达到这个目标的一种方法，但可能引入很大的性能问题。Flink使用了一种轻量级快照机制来保证恰好处理一次语义。</p><p><strong>端到端恰好处理一次</strong></p><p>　　目前我们看到的一致性保证都是由流处理器实现的，也就是说都是在Flink流处理器内部保证的。而在真实世界中，流处理应用除了流处理器以外还包含了数据源（例如Kafka）和持久化系统。端到端的一致性保证意味着结果的正确性贯穿了整个流处理应用的始终。每一个组件都保证了它自己的一致性。而整个端到端的一致性级别取决于所有组件中一致性最弱的组件。要注意的是，我们可以通过弱一致性来实现更强的一致性语义。例如，当任务的操作具有幂等性时，比如流的最大值或者最小值的计算。在这种场景下，我们可以通过最少处理一次这样的一致性来实现恰好处理一次这样的最高级别的一致性。</p><h1 id="Flink基础：Flink运行架构"><a href="#Flink基础：Flink运行架构" class="headerlink" title="Flink基础：Flink运行架构"></a>Flink基础：Flink运行架构</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>　　Flink是一个用于有状态的并行数据流处理的分布式系统。它由多个进程构成，这些进程一般会分布运行在不同的机器上。对于分布式系统来说，面对的常见问题有：集群中资源的分配和管理、进程协调调度、持久化和高可用的数据存储，以及故障恢复。</p><p>　　对于这些分布式系统的经典问题，业内已有比较成熟的解决方案和服务。所以Flink并不会自己去处理所有的问题，而是利用了现有的集群架构和服务，这样它就可以把精力集中在核心工作——<font color="red"><strong>分布式数据流处理</strong></font>上了。Flink与一些集群资源管理工具有很好的集成，比如Apache Mesos、YARN和Kubernetes；同时，也可以配置为独立（stand-alone）集群运行。Flink自己并不提供持久化的分布式存储，而是直接利用了已有的分布式文件系统（比如HDFS）或者对象存储（比如S3）。对于高可用的配置，Flink需要依靠Apache ZooKeeper来完成。</p><p>　　在本节中，我们将介绍Flink的不同组件，以及在运行程序时它们如何相互作用。我们会讨论部署Flink应用程序的两种模式，并且了解每种模式下分发和执行任务的方式。最后，我们还会解释一下Flink的高可用性模式是如何工作的。</p><h3 id="Flink运行时组件"><a href="#Flink运行时组件" class="headerlink" title="Flink运行时组件"></a>Flink运行时组件</h3><p>　　Flink运行时架构主要包括四个不同的组件，它们会在运行流处理应用程序时协同工作：作业管理器（JobManager）、资源管理器（ResourceManager）、任务管理器（TaskManager），以及分发器（Dispatcher）。因为Flink是用Java和Scala实现的，所以所有组件都会运行在Java虚拟机（JVMs）上。每个组件的职责如下：</p><ul><li><strong>作业管理器（JobManager）</strong>是控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的作业管理器所控制执行。作业管理器会先接收到要执行的应用程序。这个应用程序会包括：作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库和其它资源的JAR包。作业管理器会把JobGraph转换成一个物理层面的数据流图，这个图被叫做“执行图”（ExecutionGraph），包含了所有可以并发执行的任务。作业管理器会向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（slot）。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的TaskManager上。而在运行过程中，作业管理器会负责所有需要中央协调的操作，比如说检查点（checkpoints）的协调。</li><li><strong>ResourceManager</strong>主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManger插槽是Flink中定义的处理资源单元。Flink为不同的环境和资源管理工具提供了不同资源管理器（ResourceManager），比如YARN、Mesos、K8s，以及standalone部署。当作业管理器申请插槽资源时，ResourceManager会将有空闲插槽的TaskManager分配给作业管理器。如果ResourceManager没有足够的插槽来满足作业管理器的请求，它还可以向资源提供平台发起会话，以提供启动TaskManager进程的容器。另外，ResourceManager还负责终止空闲的TaskManager，释放计算资源。</li><li><strong>任务管理器（TaskManager）</strong>是Flink中的工作进程。通常在Flink中会有多个TaskManager运行，每一个TaskManager都包含了一定数量的插槽（slots）。插槽的数量限制了TaskManager能够执行的任务数量。启动之后，TaskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给作业管理器调用。作业管理器就可以向插槽分配任务（tasks）来执行了。在执行过程中，一个TaskManager可以跟其它运行同一应用程序的TaskManager交换数据。任务的执行和插槽的概念会在“任务执行”一节做具体讨论。</li><li><strong>分发器（Dispatcher）</strong>可以跨作业运行，它为应用提交提供了REST接口。当一个应用被提交执行时，分发器就会启动并将应用移交给一个作业管理器。由于是REST接口，所以Dispatcher可以作为集群的一个HTTP接入点，这样就能够不受防火墙阻挡。Dispatcher也会启动一个Web UI，用来方便地展示和监控作业执行的信息。Dispatcher在架构中可能并不是必需的，这取决于应用提交运行的方式。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl87wvvwclj20zc0bpwfq.jpg" alt="undefined"></p><blockquote><p>上图是从一个较为高层级的视角，来看应用中各组件的交互协作。如果部署的集群环境不同（例如YARN，Mesos，Kubernetes，standalone等），其中一些步骤可以被省略，或是有些组件会运行在同一个JVM进程中。</p></blockquote><h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><p>Flink应用程序可以用以下两种不同的方式部署：</p><p><strong>框架（Framework）方式</strong></p><p>　　在这个模式下，Flink应用被打包成一个Jar文件，并由客户端提交给一个运行服务（running service）。这个服务可以是一个Flink的Dispatcher，也可以是一个Flink的作业管理器，或是Yarn的ResourceManager。如果application被提交给一个作业管理器，则它会立即开始执行这个application。如果application被提交给了一个Dispatcher，或是Yarn ResourceManager，则它会启动一个作业管理器，然后将application交给它，再由作业管理器开始执行此应用。</p><p>**库（Library）方式                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           **</p><p>在这个模式下，Flink Application 会被打包在一个容器（container） 镜像里，例如一个Docker 镜像。此镜像包含了运行作业管理器和ResourceManager的代码。当一个容器从镜像启动后，它会自动启动ResourceManager和作业管理器，并提交打包好的应用。另一种方法是：将应用打包到镜像后，只用于部署TaskManager容器。从镜像启动的容器会自动启动一个TaskManager，然后连接ResourceManager并注册它的slots。这些镜像的启动以及失败重启，通常都会由一个外部的资源管理器管理（比如Kubernetes）。</p><p>框架模式遵循了传统的任务提交方式，从客户端提交到Flink运行服务。而在库模式下，没有运行的Flink服务。它是将Flink作为一个库，与应用程序一同打包到了一个容器镜像。这种部署方式在微服务架构中较为常见。我们会在“运行管理流式应用程序”一节对这个话题做详细讨论。</p><h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><p>一个TaskManager可以同时执行多个<strong>任务（tasks）</strong>。这些任务可以是同一个<strong>算子（operator）</strong>的<strong>子任务</strong>（数据并行）<strong>，也可以是来自不同算子的</strong>（任务并行），甚至可以是另一个不同应用程序的（作业并行）。TaskManager提供了一定数量的处理插槽（processing slots），用于控制可以并行执行的任务数。一个slot可以执行应用的一个分片，也就是应用中每一个算子的一个并行任务。下图展示了TaskManagers，slots，tasks以及operators之间的关系：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl8i2lx179j21170g1mzk.jpg" alt="undefined"></p><p>最左边是一个“作业图”（JobGraph），包含了5个算子——它是应用程序的非并行表示。其中算子A和C是数据源（source），E是输出端（sink）。C和E并行度为2，而其他的算子并行度为4。因为最高的并行度是4，所以应用需要至少四个slot来执行任务。现在有两个TaskManager，每个又各有两个slot，所以我们的需求是满足的。作业管理器将JobGraph转化为“执行图”（ExecutionGraph），并将任务分配到四个可用的slot上。<strong>对于有4个并行任务的算子，它的task会分配到每个slot上</strong>。而对于并行度为2的operator C和E，它们的任务被分配到slot 1.1、2.1 以及 slot 1.2、2.2。将tasks调度到slots上，可以让多个tasks跑在同一个TaskManager内，也就可以是的tasks之间的数据交换更高效。然而将太多任务调度到同一个TaskManager上会导致TaskManager过载，继而影响效率。之后我们会在“控制任务调度”一节继续讨论如何控制任务的调度。</p><p>TaskManager在同一个JVM中以多线程的方式执行任务。线程较进程会更轻量级，但是线程之间并没有对任务进行严格隔离。所以，单个任务的异常行为有可能会导致整个TaskManager进程挂掉，当然也同时包括运行在此进程上的所有任务。通过为每个TaskManager配置单独的slot，就可以将应用在TaskManager上相互隔离开来。TaskManager内部有多线程并行的机制，而且在一台主机上可以部署多个TaskManager，所以Flink在资源配置上非常灵活，在部署应用时可以充分权衡性能和资源的隔离。我们将会在第九章对Flink集群的配置和搭建继续做详细讨论。</p><h3 id="高可用配置"><a href="#高可用配置" class="headerlink" title="高可用配置"></a>高可用配置</h3><p>流式应用程序一般被设计为7 x 24小时运行。所以很重要的一点是：即使出现了进程挂掉的情况，应用仍需要继续保持运行。为了从故障恢复，系统首先需要重启进程、然后重启应用并恢复它的状态。接下来，我们就来了解Flink如何重启失败的进程。</p><p><strong>TaskManager故障</strong></p><p>　　如前所述，Flink需要足够数目的slot，来执行一个应用的所有任务。假设一个Flink环境有4个TaskManager，每个提供2个插槽，那么流应用程序执行的最高并行度为8。如果其中一个TaskManager挂掉了，那么可用的slots会降到6。在这种情况下，作业管理器会请求ResourceManager提供更多的slots。如果此请求无法满足——例如应用跑在一个独立集群——那么作业管理器在有足够的slots之前，无法重启应用。应用的重启策略决定了作业管理器的重启频率，以及两次重启尝试之间的时间间隔。</p><p><strong>作业管理器故障</strong></p><p>　　比TaskManager故障更严重的问题是作业管理器故障。作业管理器控制整个流应用程序的执行，并维护执行中的元数据——例如指向已完成检查点的指针。若是对应的作业管理器挂掉，则流程序无法继续运行。所以这就导致在Flink应用中，作业管理器是单点故障。为了解决这个问题，Flink提供了高可用模式。在原先的作业管理器挂掉后，可以将一个作业的状态和元数据迁移到另一个作业管理器，并继续执行。</p><p>　　Flink的高可用模式基于Apache ZooKeeper，我们知道，ZooKeeper是用来管理需要协调和共识的分布式服务的系统。Flink主要利用ZooKeeper来进行领导者（leader）的选举，并把它作为一个高可用和持久化的数据存储。当在高可用模式下运行时，作业管理器会将JobGraph以及所有需要的元数据（例如应用程序的jar文件），写入到一个远程的持久化存储系统中。而且，作业管理器会将指向存储位置的指针，写入到ZooKeeper的数据存储中。在执行一个应用的过程中，作业管理器会接收每个独立任务检查点的状态句柄（也就是存储位置）。当一个检查点完成时（所有任务已经成功地将它们的状态写入到远程存储）， 作业管理器把状态句柄写入远程存储，并将指向这个远程存储的指针写入ZooKeeper。这样，一个作业管理器挂掉之后再恢复，所需要的所有数据信息已经都保存在了远程存储，而ZooKeeper里存有指向此存储位置的指针。下图描述了这个设计：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gl98e1vx16j20t10gogna.jpg" alt="undefined"></p><p>当一个作业管理器失败，所有属于这个应用的任务都会自动取消。一个新的作业管理器接管工作，会执行以下操作：</p><ul><li>从ZooKeeper请求存储位置（storage location），从远端存储获取JobGraph，Jar文件，以及应用最近一次检查点（checkpoint）的状态句柄（state handles）</li><li>从ResourceManager请求slots，用来继续运行应用</li><li>重启应用，并将所有任务的状态，重设为最近一次已完成的检查点</li></ul><p>　　如果我们是在容器环境里运行应用（如Kubernetes），故障的作业管理器或TaskManager 容器通常会由容器服务自动重启。当运行在YARN或Mesos之上时，作业管理器或TaskManager进程会由Flink的保留进程自动触发重启。而在standalone模式下，Flink并未提供重启故障进程的工具。所以，此模式下我们可以增加备用（standby）的 作业管理器和TaskManager，用于接管故障的进程。我们将会在“高可用配置”一节中做进一步讨论。</p><h2 id="Flink中的数据传输"><a href="#Flink中的数据传输" class="headerlink" title="Flink中的数据传输"></a>Flink中的数据传输</h2><h3 id="基于信任度的流控制"><a href="#基于信任度的流控制" class="headerlink" title="基于信任度的流控制"></a>基于信任度的流控制</h3><p>通过网络连接来发送每条数据的效率很低，会导致很大的开销。为了充分利用网络连接的带宽，就需要进行缓冲了。在流处理的上下文中，缓冲的一个缺点是会增加延迟，因为数据需要在缓冲区中进行收集，而不是立即发送。</p><p>　　Flink实现了一个基于信任度的流量控制机制，其工作原理如下。接收任务授予发送任务一些“信任度”（credit），也就是为了接收其数据而保留的网络缓冲区数。当发送者收到一个信任度通知，它就会按照被授予的信任度，发送尽可能多的缓冲数据，并且同时发送目前积压数据的大小——也就是已填满并准备发送的网络缓冲的数量。接收者用保留的缓冲区处理发来的数据，并对发送者传来的积压量进行综合考量，为其所有连接的发送者确定下一个信用度授权的优先级。</p><p>　　基于信用度的流控制可以减少延迟，因为发送者可以在接收者有足够的资源接受数据时立即发送数据。此外，在数据倾斜的情况下，这样分配网络资源是一种很有效的机制，因为信用度是根据发送者积压数据量的规模授予的。因此，基于信用的流量控制是Flink实现高吞吐量和低延迟的重要组成部分。</p><h4 id="任务链"><a href="#任务链" class="headerlink" title="任务链"></a>任务链</h4><p>Flink采用了一种称为任务链的优化技术，可以在特定条件下减少本地通信的开销。为了满足任务链的要求，必须将两个或多个算子设为相同的并行度，并通过本地转发（local forward）的方式进行连接。下图所示的算子管道满足这些要求。它由三个算子组成，这些算子的任务并行度都被设为2，并且通过本地转发方式相连接。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9hf5p4qj20wh06yjrs.jpg" alt="undefined"></p><p>下图展示了管道以任务链方式运行的过程。算子的函数被融合成了一个单一的任务，由一个线程执行。由函数生成的数据通过一个简单的方法调用移交给下一个函数；这样在函数之间直接传递数据，基本上没有序列化和通信成本。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9i2ut13j20nk0cmdgi.jpg" alt="undefined"></p><p>任务链可以显著降低本地任务之间的通信成本，但也有一些场景，在没有链接的情况下运行管道操作是有意义的。例如，如果任务链中某个函数执行的开销巨大，那就可以将一条长的任务链管道断开，或者将一条链断开为两个任务，从而可以将这个开销大的函数调度到不同的槽（slots）中。下图显示了在没有任务链的情况下相同管道操作的执行情况。所有函数都由独立的单个任务来评估，每个任务都在专有的线程中运行。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9imstamj20wg0d1gmk.jpg" alt="undefined"></p><p><strong>任务链在Flink中默认会启用</strong>。在“控制任务链”一节中，我们展示了如何禁用应用程序的任务链，以及如何控制各个算子的链接行为。</p><h2 id="事件时间处理"><a href="#事件时间处理" class="headerlink" title="事件时间处理"></a>事件时间处理</h2><p>​        在“时间语义”一节，我们重点强调了时间语义在流处理应用中的重要性，并且解释了处理时间（processing time）和事件时间（event time）的不同。处理时间比较好理解，因为它是基于处理器本地时间的；但同时，它会带来比较混乱、不一致、并且不可重现的结果。相比之下，事件时间语义能够产生可重现且一致的结果，这也是许多流处理场景希望解决的一大难题。但是，与处理时间应用程序相比，事件时间应用程序会更复杂，需要额外的配置。另外，支持事件时间的流处理器，也比纯粹在处理时间中运行的系统内部更为复杂。</p><p>　　Flink为常见的事件时间处理操作提供了直观且易于使用的原语，同时暴露了表达性很强的API，用户可以使用自定义算子实现更高级的事件时间应用程序。很好地理解Flink的内部时间处理，对于实现这样的高级应用程序会有很大帮助，有时也是必需的。上一章介绍了Flink利用两个概念来支持事件时间语义：记录时间戳（timestamps）和水位线（watermarks）。接下来，我们将描述Flink如何在内部实现并处理时间戳和水位线，进而支持具有事件时间语义的流式应用程序。</p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>　　由Flink事件时间流应用程序处理的所有记录都必须伴有时间戳。时间戳将数据与特定时间点相关联，通常就是数据所表示的事件发生的时间点。而只要时间戳大致跟数据流保持一致，基本上随着数据流的前进而增大，应用程序就可以自由选择时间戳的含义。不过正如“时间语义”一节中所讨论的，在现实场景中，时间戳基本上都是乱序的，所以采用“事件时间”而非“处理事件”往往会显得更为重要。</p><p>　　当Flink以事件时间模式处理数据流时，它会根据数据记录的时间戳来处理基于时间的算子。例如，时间窗口算子根据相关时间戳将数据分配给不同的时间窗口。Flink将时间戳编码为16字节的长整型值，并将其作为元数据附加到数据记录中。它的内置运算符会将这个长整型值解释为一个具有毫秒精度的Unix时间戳，也就是1970-01-01-00:00:00.000以来的毫秒数。当然，如果用户进行了自定义，那么运算符可以有自己的解释，例如，可以将精度调整到微秒。</p><h3 id="水位线-1"><a href="#水位线-1" class="headerlink" title="水位线"></a>水位线</h3><p>　　除了时间戳，基于事件时间的Flink应用程序还必须支持水位线（watermark）。在基于事件时间的应用中，水位线用于生成每个任务的当前事件时间。基于时间的算子使用这个“当前事件时间”来触发计算和处理操作。例如，一个时间窗口任务（time-window task）会在任务的事件时间超出窗口的关闭边界时，完成窗口计算，并输出计算结果。</p><p>在Flink中，水位线被实现为一条特殊的数据记录，它里面以长整型值保存了一个时间戳。水位线在带有时间戳的数据流中，跟随着其它数据一起流动，如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9pspnzfj20ss07g753.jpg" alt="undefined"></p><p><strong>水位线有两个基本属性</strong>：</p><ul><li>必须单调递增，以确保任务的事件时间时钟在向前推进，而不是在后退。</li><li>它们与数据的时间戳相关。带有时间戳T的水位线表示，所有后续数据的时间戳都应该大于T。</li></ul><p>　　上面的第二个属性用于处理带有乱序时间戳的数据流，比如图中时间戳3和5的数据。基于时间的算子任务会收集和处理数据（这些数据可能具有乱序的时间戳），并在事件时间时钟到达某个时刻时完成计算。这个时刻就表示数据收集的截止，具有之前时间戳的数据应该都已经到达、不再需要了；而其中的事件时间时钟，正是由当前接收到的水位线来指示的。如果任务再接收到的数据违反了watermark的这一属性，也就是时间戳小于以前接收到的水位线时，它所属的那部分计算可能已经完成了。这种数据被称为延迟数据（late records）。Flink提供了处理延迟数据的不同方式，我们会在“处理延迟数据”一节中讨论。</p><p>　　水位线还有一个很有趣的特性，它允许应用程序自己来平衡结果的完整性和延迟。如果水位线与数据的时间戳非常接近，那么我们可以得到较低的处理延迟，因为任务在完成计算之前只会短暂地等待更多数据到达。而同时，结果的完整性可能会受到影响，因为相关数据可能因为迟到而被视为“延迟数据”，这样就不会包含在结果中。相反，非常保守的水位线提供了足够的时间去等待所有数据到达，这样会增加处理延迟，但提高了结果的完整性。</p><h3 id="watermark的传递和事件时间"><a href="#watermark的传递和事件时间" class="headerlink" title="watermark的传递和事件时间"></a>watermark的传递和事件时间</h3><p>在本节中，我们将讨论算子如何处理水位线。Flink把watermark作为一条特殊的数据来实现，它也会由算子任务接收和发送。任务会有一个内部的时间服务，它会维护定时器，并在收到watermark时触发。<strong>任务可以在计时器服务中注册定时器，以便在将来特定的时间点执行计算。例如，窗口算子为每个活动窗口注册一个定时器，当事件时间超过窗口的结束时间时，该计时器将清除窗口的状态。</strong></p><p>当任务收到watermark时，将执行以下操作：</p><ul><li>任务根据watermark的时间戳更新其内部事件时钟。</li><li>任务的时间服务会将所有过期的计时器标识出来，它们的时间小于当前的事件时间。对于每个过期的计时器，任务调用一个回调函数，该函数可以执行计算并发送结果。</li><li>任务会发出一个带有更新后的事件时间的watermark。</li></ul><blockquote><p>Flink限制通过DataStream API访问时间戳和watermark。函数不能读取或修改数据的时间戳和watermark，但底层的“处理函数”（process functions）除外，它们可以读取当前处理数据的时间戳、请求算子的当前事件时间，还可以注册定时器。通常的函数都不会暴露这些可以设置时间戳、操作任务事件时间时钟、或者发出水位线的API。而基于时间的数据流算子任务则会配置发送出的数据的时间戳，以确保它们能够与已到达的水位线平齐。例如，窗口计算完成后，时间窗口的算子任务会将窗口的结束时间作为时间戳附加到将要发送出的结果数据上，然后再使用触发窗口计算的时间戳发出watermark。</p></blockquote><p>　　现在，让我们更详细地解释一下任务在接收到新的watermark时，如何继续发送watermark并更新其事件时钟。正如我们在“数据并发和任务并发”中所了解的，Flink将数据流拆分为多个分区，并通过单独的算子任务并行地处理每个分区。每个分区都是一个流，里面包含了带着时间戳的数据和watermark。一个算子与它前置或后续算子的连接方式有多种情况，所以它对应的任务可以从一个或多个“输入分区”接收数据和watermark，同时也可以将数据和watermark发送到一个或多个“输出分区”。接下来，我们将详细描述一个任务如何向多个输出任务发送watermark，以及如何通过接收到的watermark来驱动事件时间时钟前进。</p><p>　　任务为每个输入分区维护一个分区水位线（watermark）。当从一个分区接收到watermark时，它会比较新接收到的值和当前水位值，然后将相应的分区watermark更新为两者的最大值。然后，任务会比较所有分区watermark的大小，将其事件时钟更新为所有分区watermark的最小值。如果事件时间时钟前进了，任务就将处理所有被触发的定时器操作，并向所有连接的输出分区发送出相应的watermark，最终将新的事件时间广播给所有下游任务。</p><p>下图显示了具有四个输入分区和三个输出分区的任务如何接收watermark、更新分区watermark和事件时间时钟，以及向下游发出watermark。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9rpx0enj213p0n641h.jpg" alt="undefined"></p><p>具有两个或多个输入流（如Union或CoFlatMap）的算子任务（参见“多流转换”一节）也会以所有分区watermark的最小值作为事件时间时钟。它们并不区分不同输入流的分区watermark，所以两个输入流的数据都是基于相同的事件时间时钟进行处理的。当然我们可以想到，如果应用程序的各个输入流的事件时间不一致，那么这种处理方式可能会导致问题。</p><p>　　Flink的水位处理和传递算法，确保了算子任务发出的时间戳和watermark是“对齐”的。不过它依赖一个条件，那就是所有分区都会提供不断增长的watermark。一旦一个分区不再推进水位线的上升，或者完全处于空闲状态、不再发送任何数据和watermark，任务的事件时间时钟就将停滞不前，任务的定时器也就无法触发了。对于基于时间的算子来说，它们需要依赖时钟的推进来执行计算和清除状态，这种情况显然就会有问题。如果任务没有定期从所有输入任务接收到新的watermark，那么基于时间的算子的处理延迟和状态空间的大小都会显著增加。</p><p>　　对于具有两个输入流而且watermark明显不同的算子，也会出现类似的情况。具有两个输入流的任务的事件时间时钟，将会同较慢的那条流的watermark保持一致，而通常较快流的数据或者中间结果会在state中缓冲，直到事件时间时钟达到这条流的watermark，才会允许处理它们。</p><h3 id="时间戳的分配和水位线的产生"><a href="#时间戳的分配和水位线的产生" class="headerlink" title="时间戳的分配和水位线的产生"></a>时间戳的分配和水位线的产生</h3><p>我们已经解释了什么是时间戳和水位线，以及它们是如何由Flink内部处理的；然而我们还没有讨论它们的产生。流应用程序接收到数据流时，通常就会先分配时间戳并生成水位线（watermark）。因为时间戳的选择是由不同的应用程序决定的，而且watermark取决于时间戳和流的特性，所以应用程序必须首先显式地分配时间戳并生成watermark。Flink流应用程序可以通过三种方式分配时间戳和生成watermark：</p><ul><li>在数据源（source）处分配：当数据流被摄入到应用程序中时，可以由“源函数”SourceFunction分配和生成时间戳和watermark。SourceFunction可以产生并发送一个数据流；数据会与相关的时间戳一起发送出去，而watermark可以作为一条特殊数据在任何时间点发出。如果SourceFunction（暂时）不再发出watermark，它可以声明自己处于“空闲”（idle）状态。Flink会在后续算子的水位计算中，把空闲的SourceFunction产生的流分区排除掉。source的这一空闲机制，可以用来解决前面提到的水位不再上升的问题。源函数（Source Function）在“实现自定义源函数”一节中进行了更详细的讨论。</li><li>定期分配：在Flink中，DataStream API提供一个名为AssignerWithPeriodicWatermarks的用户定义函数，它可以从每个数据中提取时间戳，并被定期调用以生成当前watermark。提取出的时间戳被分配给相应的数据，而生成的watermark也会添加到流中。这个函数将在“分配时间戳和生成水位线”一节中讨论。</li><li>间断分配：AssignerWithPunctuatedWatermarks是另一个用户定义的函数，它同样会从每个数据中提取一个时间戳。它可以用于生成特殊输入数据中的watermark。与AssignerWithPeriodicWatermarks相比，此函数可以（但不是必须）从每个记录中提取watermark。我们在“分配时间戳和生成水位线”一节中同样讨论了该函数。</li></ul><p>　　用户定义的时间戳分配函数并没有严格的限制，通常会放在尽可能靠近source算子的位置，因为当经过一些算子处理后，数据及其时间戳的顺序就更加难以解释了。所以尽管我们可以在流应用程序的中段覆盖已有的时间戳和watermark——Flink通过用户定义的函数提供了这种灵活性，但这显然并不是推荐的做法。</p><h2 id="状态管理-1"><a href="#状态管理-1" class="headerlink" title="状态管理"></a>状态管理</h2><p>​        我们已经知道大多数流应用程序都是有状态的。许多算子会不断地读取和更新状态，例如在窗口中收集的数据、读取输入源的位置，或者像机器学习模型那样的用户定制化的算子状态。 Flink用同样的方式处理所有的状态，无论是内置的还是用户自定义的算子。本节我们将会讨论Flink支持的不同类型的状态，并解释“状态后端”是如何存储和维护状态的。</p><p>​        一般来说，由一个任务维护，并且用来计算某个结果的所有数据，都属于这个任务的状态。你可以认为状态就是一个本地变量，可以被任务的业务逻辑访问。下图显示了任务与其状态之间的交互。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glf9ypa4y7j20hj09omxs.jpg" alt="undefined"></p><p>　　任务会接收一些输入数据。在处理数据时，任务可以读取和更新状态，并根据输入数据和状态计算结果。最简单的例子，就是统计接收到多少条数据的任务。当任务收到新数据时，它会访问状态以获取当前的计数，然后让计数递增，更新状态并发送出新的计数。</p><p>　　应用程序里，读取和写入状态的逻辑一般都很简单直接，而有效可靠的状态管理会复杂一些。这包括如何处理很大的状态——可能会超过内存，并且保证在发生故障时不会丢失任何状态。幸运的是，Flink会帮我们处理这相关的所有问题，包括状态一致性、故障处理以及高效存储和访问，以便开发人员可以专注于应用程序的逻辑。</p><p>　　在Flink中，状态始终与特定算子相关联。为了使运行时的Flink了解算子的状态，算子需要预先注册其状态。总的说来，有两种类型的状态：算子状态（operator state）和键控状态（keyed state），它们有着不同的范围访问，我们将在下面展开讨论。</p><h3 id="算子状态"><a href="#算子状态" class="headerlink" title="算子状态"></a>算子状态</h3><p>算子状态的作用范围限定为算子任务。这意味着由同一并行任务所处理的所有数据都可以访问到相同的状态，状态对于同一任务而言是共享的。算子状态不能由相同或不同算子的另一个任务访问。下图显示了任务如何访问算子状态。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfa2mwpxjj20gi0f1754.jpg" alt="undefined"></p><p>Flink为算子状态提供三种基本数据结构：</p><p><strong>列表状态</strong></p><p>将状态表示为一组数据的列表。</p><p><strong>联合列表状态</strong></p><p>也将状态表示为数据的列表。它与常规列表状态的区别在于，在发生故障时，或者从保存点（savepoint）启动应用程序时如何恢复。我们将在后面继续讨论。</p><p><strong>广播状态</strong></p><p>如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态。在保存检查点和重新调整算子并行度时，会用到这个特性。这两部分内容将在本章后面讨论。</p><h3 id="键控状态"><a href="#键控状态" class="headerlink" title="键控状态"></a>键控状态</h3><p>顾名思义，键控状态是根据输入数据流中定义的键（key）来维护和访问的。Flink为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个key对应的状态。当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的key。因此，具有相同key的所有数据都会访问相同的状态。下图显示了任务如何与键控状态进行交互。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfaifkmeij20kt0h9zlj.jpg" alt="undefined"></p><p>我们可以将键控状态看成是在算子所有并行任务上，对键进行分区（或分片）之后的一个键值映射（key-value map）。 Flink为键控状态提供不同的数据结构，用于确定map中每个key存储的值的类型。我们简单了解一下最常见的键控状态。</p><h4 id="值状态"><a href="#值状态" class="headerlink" title="值状态"></a>值状态</h4><p>为每个键存储一个任意类型的单个值。复杂数据结构也可以存储为值状态。</p><h4 id="列表状态"><a href="#列表状态" class="headerlink" title="列表状态"></a>列表状态</h4><p>为每个键存储一个值的列表。列表里的每个数据可以是任意类型。</p><h4 id="映射状态"><a href="#映射状态" class="headerlink" title="映射状态"></a>映射状态</h4><p>为每个键存储一个键值映射（map）。map的key和value可以是任意类型。</p><p>状态的数据结构可以让Flink实现更有效的状态访问。我们将在“在运行时上下文（RuntimeContext）中声明键控状态”中做进一步讨论。</p><h3 id="状态后端"><a href="#状态后端" class="headerlink" title="状态后端"></a>状态后端</h3><p>　　每传入一条数据，有状态的算子任务都会读取和更新状态。由于有效的状态访问对于处理数据的低延迟至关重要，因此每个并行任务都会在本地维护其状态，以确保快速的状态访问。状态到底是如何被存储、访问以及维护的？这件事由一个可插入的组件决定，这个组件就叫做状态后端（state backend）。状态后端主要负责两件事：本地的状态管理，以及将检查点（checkpoint）状态写入远程存储。</p><p>　　对于本地状态管理，状态后端会存储所有键控状态，并确保所有的访问都被正确地限定在当前键范围。 Flink提供了默认的状态后端，会将键控状态作为内存中的对象进行管理，将它们存储在JVM堆上。另一种状态后端则会把状态对象进行序列化，并将它们放入RocksDB中，然后写入本地硬盘。第一种方式可以提供非常快速的状态访问，但它受内存大小的限制；而访问RocksDB状态后端存储的状态速度会较慢，但其状态可以增长到非常大。</p><p>　　状态检查点的写入也非常重要，这是因为Flink是一个分布式系统，而状态只能在本地维护。 TaskManager进程（所有任务在其上运行）可能在任何时间点挂掉。因此，它的本地存储只能被认为是不稳定的。状态后端负责将任务的状态检查点写入远程的持久存储。写入检查点的远程存储可以是分布式文件系统，也可以是数据库。不同的状态后端在状态检查点的写入机制方面有所不同。例如，RocksDB状态后端支持增量的检查点，这对于非常大的状态来说，可以显著减少状态检查点写入的开销。</p><p>我们将在“选择状态后端”一节中更详细地讨论不同的状态后端及其优缺点。</p><h4 id="调整有状态算子的并行度"><a href="#调整有状态算子的并行度" class="headerlink" title="调整有状态算子的并行度"></a>调整有状态算子的并行度</h4><p>　　流应用程序的一个常见要求是，为了增大或较小输入数据的速率，需要灵活地调整算子的并行度。对于无状态算子而言，并行度的调整没有任何问题，但更改有状态算子的并行度显然就没那么简单了，因为它们的状态需要重新分区并分配给更多或更少的并行任务。 Flink支持四种模式来调整不同类型的状态。</p><p>　　具有键控状态的算子通过将键重新分区为更少或更多任务来缩放并行度。不过，并行度调整时任务之间会有一些必要的状态转移。为了提高效率，Flink并不会对单独的key做重新分配，而是用所谓的“键组”（key group）把键管理起来。键组是key的分区形式，同时也是Flink为任务分配key的方式。图3-13显示了如何在键组中重新分配键控状态。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfawq49exj20sv0jitc6.jpg" alt="undefined"></p><p>　　具有算子列表状态的算子，会通过重新分配列表中的数据项目来进行并行度缩放。从概念上讲，所有并行算子任务的列表项目会被收集起来，并将其均匀地重新分配给更少或更多的任务。如果列表条目少于算子的新并行度，则某些任务将以空状态开始。下图显示了算子列表状态的重新分配。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfax3sj46j20x80ceq4a.jpg" alt="undefined"></p><p>　　具有算子联合列表状态的算子，会通过向每个任务广播状态的完整列表，来进行并行度的缩放。然后，任务可以选择要使用的状态项和要丢弃的状态项。下图显示了如何重新分配算子联合列表状态。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfaxicg8hj20vw0f575r.jpg" alt="undefined"></p><p>　　具有算子广播状态的算子，通过将状态复制到新任务，来增大任务的并行度。这是没问题的，因为广播状态保证了所有任务都具有相同的状态。而对于缩小并行度的情况，我们可以直接取消剩余任务，因为状态是相同的，已经被复制并且不会丢失。下图显示了算子广播状态的重新分配。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfaxwogz6j20oo0bb74y.jpg" alt="undefined"></p><h2 id="检查点，保存点和状态恢复"><a href="#检查点，保存点和状态恢复" class="headerlink" title="检查点，保存点和状态恢复"></a>检查点，保存点和状态恢复</h2><p>　　Flink是一个分布式数据处理系统，因此必须有一套机制处理各种故障，比如被杀掉的进程，故障的机器和中断的网络连接。任务都是在本地维护状态的，所以Flink必须确保状态不会丢失，并且在发生故障时能够保持一致。</p><p>　　在本节中，我们将介绍Flink的检查点（checkpoint）和恢复机制，这保证了“精确一次”（exactly-once）的状态一致性。我们还会讨论Flink独特的保存点（savepoint）功能，这是一个“瑞士军刀”式的工具，可以解决许多操作数据流时面对的问题。</p><h3 id="一致的检查点"><a href="#一致的检查点" class="headerlink" title="一致的检查点"></a>一致的检查点</h3><p>　　Flink的恢复机制的核心，就是应用状态的一致检查点。有状态流应用的一致检查点，其实就是所有任务状态在某个时间点的一份拷贝，而这个时间点应该是所有任务都恰好处理完一个相同的输入数据的时候。这个过程可以通过一致检查点的一个简单算法步骤来解释。这个算法的步骤是：</p><ul><li>暂停所有输入流的摄取，也就是不再接收新数据的输入。</li><li>等待所有正在处理的数据计算完毕，这意味着结束时，所有任务都已经处理了所有输入数据。</li><li>通过将每个任务的状态复制到远程持久存储，来得到一个检查点。所有任务完成拷贝操作后，检查点就完成了。</li><li>恢复所有输入流的摄取。</li></ul><p>　　需要注意，Flink实现的并不是这种简单的机制。我们将在本节后面介绍Flink更精妙的检查点算法。</p><p>下图显示了一个简单应用中的一致检查点。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfayxbpf9j20nu0hrabk.jpg" alt="undefined"></p><p>　　上面的应用程序中具有单一的输入源（source）任务，输入数据就是一组不断增长的数字的流——1,2,3等。数字流被划分为偶数流和奇数流。求和算子（sum）的两个任务会分别实时计算当前所有偶数和奇数的总和。源任务会将其输入流的当前偏移量存储为状态，而求和任务则将当前的总和值存储为状态。在图3-17中，Flink在输入偏移量为5时，将检查点写入了远程存储，当前的总和为6和9</p><h3 id="从一致检查点中恢复状态"><a href="#从一致检查点中恢复状态" class="headerlink" title="从一致检查点中恢复状态"></a>从一致检查点中恢复状态</h3><p>在执行流应用程序期间，Flink会定期检查状态的一致检查点。如果发生故障，Flink将会使用最近的检查点来一致恢复应用程序的状态，并重新启动处理流程。下图显示了恢复过程。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfazjk3kjj20q318x42f.jpg" alt="undefined"></p><p>应用程序从检查点的恢复分为三步：</p><ul><li>重新启动整个应用程序。</li><li>将所有的有状态任务的状态重置为最近一次的检查点。</li><li>恢复所有任务的处理。</li></ul><p>　　这种检查点的保存和恢复机制可以为应用程序状态提供“精确一次”（exactly-once）的一致性，因为所有算子都会保存检查点并恢复其所有状态，这样一来所有的输入流就都会被重置到检查点完成时的位置。至于数据源是否可以重置它的输入流，这取决于其实现方式和消费流数据的外部接口。例如，像Apache Kafka这样的事件日志系统可以提供流上之前偏移位置的数据，所以我们可以将源重置到之前的偏移量，重新消费数据。而从套接字（socket）消费数据的流就不能被重置了，因为套接字的数据一旦被消费就会丢弃掉。因此，对于应用程序而言，只有当所有的输入流消费的都是可重置的数据源时，才能确保在“精确一次”的状态一致性下运行。</p><p>　　从检查点重新启动应用程序后，其内部状态与检查点完成时的状态完全相同。然后它就会开始消费并处理检查点和发生故障之间的所有数据。尽管这意味着Flink会对一些数据处理两次（在故障之前和之后），我们仍然可以说这个机制实现了精确一次的一致性语义，因为所有算子的状态都已被重置，而重置后的状态下还不曾看到这些数据。</p><p>　　我们必须指出，Flink的检查点保存和恢复机制仅仅可以重置流应用程序的内部状态。对于应用中的一些的输出（sink）算子，在恢复期间，某些结果数据可能会多次发送到下游系统，比如事件日志、文件系统或数据库。对于某些存储系统，Flink提供了具有精确一次输出功能的sink函数，比如，可以在检查点完成时提交发出的记录。另一种适用于许多存储系统的方法是幂等更新。在“应用程序一致性保证”一节中，我们还会详细讨论如何解决应用程序端到端的精确一次一致性问题。</p><h3 id="Flink的检查点算法"><a href="#Flink的检查点算法" class="headerlink" title="Flink的检查点算法"></a>Flink的检查点算法</h3><p>　　Flink的恢复机制，基于它的一致性检查点。前面我们已经了解了从流应用中创建检查点的简单方法——先暂停应用，保存检查点，然后再恢复应用程序，这种方法很好理解，但它的理念是“停止一切”，这对于即使是中等延迟要求的应用程序而言也是不实用的。所以Flink没有这么简单粗暴，而是基于Chandy-Lamport算法实现了分布式快照的检查点保存。该算法并不会暂停整个应用程序，而是将检查点的保存与数据处理分离，这样就可以实现在其它任务做检查点状态保存状态时，让某些任务继续进行而不受影响。接下来我们将解释此算法的工作原理。</p><p>　　Flink的检查点算法用到了一种称为“检查点分界线”（checkpoint barrier）的特殊数据形式。与水位线（watermark）类似，检查点分界线由source算子注入到常规的数据流中，它的位置是限定好的，不能超过其他数据，也不能被后面的数据超过。检查点分界线带有检查点ID，用来标识它所属的检查点；这样，这个分界线就将一条流逻辑上分成了两部分。分界线之前到来的数据导致的状态更改，都会被包含在当前分界线所属的检查点中；而基于分界线之后的数据导致的所有更改，就会被包含在之后的检查点中。</p><p>　　我们用一个简单的流应用程序作为示例，来一步一步解释这个算法。该应用程序有两个源（source）任务，每个任务都消费一个增长的数字流。源任务的输出被划分为两部分：偶数和奇数的流。每个分区由一个任务处理，该任务计算所有收到的数字的总和，并将更新的总和转发给输出（sink）任务。这个应用程序的结构如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb0fcof8j20uy0e8myi.jpg" alt="undefined"></p><p>作业管理器会向每个数据源（source）任务发送一条带有新检查点ID的消息，通过这种方式来启动检查点，如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb0s7gl2j20uy0e0jst.jpg" alt="undefined"></p><p>　　当source任务收到消息时，它会暂停发出新的数据，在状态后端触发本地状态的检查点保存，并向所有传出的流分区广播带着检查点ID的分界线（barriers）。状态后端在状态检查点完成后会通知任务，而任务会向作业管理器确认检查点完成。在发出所有分界线后，source任务就可以继续常规操作，发出新的数据了。通过将分界线注入到输出流中，源函数（source function）定义了检查点在流中所处的位置。下图显示了两个源任务将本地状态保存到检查点，并发出检查点分界线之后的流应用程序。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb16kvayj20y70jgwgk.jpg" alt="undefined"></p><p>　　源任务发出的检查点分界线（barrier），将被传递给所连接的任务。与水位线（watermark）类似，barrier会被广播到所有连接的并行任务，以确保每个任务从它的每个输入流中都能接收到。当任务收到一个新检查点的barrier时，它会等待这个检查点的所有输入分区的barrier到达。在等待的过程中，任务并不会闲着，而是会继续处理尚未提供barrier的流分区中的数据。对于那些barrier已经到达的分区，如果继续有新的数据到达，它们就不会被立即处理，而是先缓存起来。这个等待所有分界线到达的过程，称为“分界线对齐”（barrier alignment），如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb1j5vy1j20uy0hrmz1.jpg" alt="undefined"></p><p>当任务从所有输入分区都收到barrier时，它就会在状态后端启动一个检查点的保存，并继续向所有下游连接的任务广播检查点分界线，如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb1y7d78j20w40ed0un.jpg" alt="undefined"></p><p>所有的检查点barrier都发出后，任务就开始处理之前缓冲的数据。在处理并发出所有缓冲数据之后，任务就可以继续正常处理输入流了。下图显示了此时的应用程序。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb2aooe1j20yf0edtae.jpg" alt="undefined"></p><p>　　最终，检查点分界线会到达输出（sink）任务。当sink任务接收到barrier时，它也会先执行“分界线对齐”，然后将自己的状态保存到检查点，并向作业管理器确认已接收到barrier。一旦从应用程序的所有任务收到一个检查点的确认信息，作业管理器就会将这个检查点记录为已完成。下图显示了检查点算法的最后一步。这样，当发生故障时，我们就可以用已完成的检查点恢复应用程序了。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glfb2ul73nj20yf0frtao.jpg" alt="undefined"></p><h3 id="检查点的性能影响"><a href="#检查点的性能影响" class="headerlink" title="检查点的性能影响"></a>检查点的性能影响</h3><p>　　Flink的检查点算法可以在不停止整个应用程序的情况下，生成一致的分布式检查点。但是，它可能会增加应用程序的处理延迟。Flink对此有一些调整措施，可以在某些场景下显得对性能的影响没那么大。</p><p>　　当任务将其状态保存到检查点时，它其实处于一个阻塞状态，而此时新的输入会被缓存起来。由于状态可能变得非常大，而且检查点需要通过网络将数据写入远程存储系统，检查点的写入很容易就会花费几秒到几分钟的时间——这对于要求低延迟的应用程序而言，显然是不可接受的。在Flink的设计中，真正负责执行检查点写入的，其实是状态后端。具体怎样复制任务的状态，取决于状态后端的实现方式。例如，文件系统（FileSystem）状态后端和RocksDB状态后端都支持了异步（asynchronous）检查点。触发检查点操作时，状态后端会先创建状态的本地副本。本地拷贝完成后，任务就将继续常规的数据处理，这往往并不会花费太多时间。一个后台线程会将本地快照异步复制到远程存储，并在完成检查点后再回来通知任务。异步检查点的机制，显著减少了任务继续处理数据之前的等待时间。此外，RocksDB状态后端还实现了增量的检查点，这样可以大大减少要传输的数据量。</p><p>　　为了减少检查点算法对处理延迟的影响，另一种技术是调整分界线对齐的步骤。对于需要非常低的延迟、并且可以容忍“至少一次”（at-least-once）状态保证的应用程序，Flink可以将检查点算法配置为，在等待barrier对齐期间处理所有到达的数据，而不是把barrier已经到达的那些分区的数据缓存起来。当检查点的所有barrier到达，算子任务就会将状态写入检查点——当然，现在的状态中，就可能包括了一些“提前”的更改，这些更改由本该属于下一个检查点的数据到来时触发。如果发生故障，从检查点恢复时，就将再次处理这些数据：这意味着检查点现在提供的是“至少一次”（at-least-once）而不是“精确一次”（exactly-once）的一致性保证。</p><h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>　　Flink的恢复算法是基于状态检查点的。Flink根据可配置的策略，定期保存并自动丢弃检查点。检查点的目的是确保在发生故障时可以重新启动应用程序，所以当应用程序被显式地撤销（cancel）时，检查点会被删除掉。除此之外，应用程序状态的一致性快照还可用于除故障恢复之外的更多功能。</p><p>Flink中一个最有价值，也是最独特的功能是保存点（savepoints）。原则上，创建保存点使用的算法与检查点完全相同，因此保存点可以认为就是具有一些额外元数据的检查点。 Flink不会自动创建保存点，因此用户（或者外部调度程序）必须明确地触发创建操作。同样，Flink也不会自动清理保存点。第10章将会具体介绍如何触发和处理保存点。</p><h4 id="使用保存点"><a href="#使用保存点" class="headerlink" title="使用保存点"></a>使用保存点</h4><p>　　有了应用程序和与之兼容的保存点，我们就可以从保存点启动应用程序了。这会将应用程序的状态初始化为保存点的状态，并从保存点创建时的状态开始运行应用程序。虽然看起来这种行为似乎与用检查点从故障中恢复应用程序完全相同，但实际上故障恢复只是一种特殊情况，它只是在相同的集群上以相同的配置启动相同的应用程序。而从保存点启动应用程序会更加灵活，这就可以让我们做更多事情了。</p><ul><li>可以从保存点启动不同但兼容的应用程序。这样一来，我们就可以及时修复应用程序中的逻辑bug，并让流式应用的源尽可能多地提供之前发生的事件，然后重新处理，以便修复之前的计算结果。修改后的应用程序还可用于运行A / B测试，或者具有不同业务逻辑的假设场景。这里要注意，应用程序和保存点必须兼容才可以这么做——也就是说，应用程序必须能够加载保存点的状态。</li><li>可以使用不同的并行度来启动相同的应用程序，可以将应用程序的并行度增大或减小。</li><li>可以在不同的集群上启动同样的应用程序。这非常有意义，意味着我们可以将应用程序迁移到较新的Flink版本或不同的集群上去。</li><li>可以使用保存点暂停应用程序，稍后再恢复。这样做的意义在于，可以为更高优先级的应用程序释放集群资源，或者在输入数据不连续生成时释放集群资源。</li><li>还可以将保存点设置为某一版本，并归档（archive）存储应用程序的状态。</li></ul><p>保存点是非常强大的功能，所以许多用户会定期创建保存点以便能够及时退回之前的状态。我们见到的各种场景中，保存点一个最有趣的应用是不断将流应用程序迁移到更便宜的数据中心上去。</p><h4 id="从保存点启动应用程序"><a href="#从保存点启动应用程序" class="headerlink" title="从保存点启动应用程序"></a>从保存点启动应用程序</h4><p>　　前面提到的保存点的所有用例，都遵循相同的模式。那就是首先创建正在运行的应用程序的保存点，然后在一个新启动的应用程序中用它来恢复状态。之前我们已经知道，保存点的创建和检查点非常相似，而接下来我们就将介绍对于一个从保存点启动的应用程序，Flink如何初始化其状态。</p><p>　　应用程序由多个算子组成。每个算子可以定义一个或多个键控状态和算子状态。算子由一个或多个算子任务并行执行。因此，一个典型的应用程序会包含多个状态，这些状态分布在多个算子任务中，这些任务可以运行在不同的TaskManager进程上。</p><p>　　图3-26显示了一个具有三个算子的应用程序，每个算子执行两个算子任务。一个算子（OP-1）具有单一的算子状态（OS-1），而另一个算子（OP-2）具有两个键控状态（KS-1和KS-2）。当保存点创建时，会将所有任务的状态复制到持久化的存储位置。</p><p>　　保存点中的状态拷贝会以算子标识符（operator ID）和状态名称（state name）组织起来。算子ID和状态名称必须能够将保存点的状态数据，映射到一个正在启动的应用程序的算子状态。从保存点启动应用程序时，Flink会将保存点的数据重新分配给相应的算子任务。</p><blockquote><p>请注意，保存点不包含有关算子任务的信息。这是因为当应用程序以不同的并行度启动时，任务数量可能会更改。</p></blockquote><p>　　如果我们要从保存点启动一个修改过的应用程序，那么保存点中的状态只能映射到符合标准的应用程序——它里面的算子必须具有相应的ID和状态名称。默认情况下，Flink会自动分配唯一的算子ID。然而，一个算子的ID，是基于它之前算子的ID确定性地生成的。因此，算子的ID会在其前序算子改变时改变，比如，当我们添加了新的或移除掉一个算子时，前序算子ID改变，当前算子ID就会变化。所以对于具有默认算子ID的应用程序而言，如果想在不丢失状态的前提下升级，就会受到极大的限制。因此，我们强烈建议在程序中为算子手动分配唯一ID，而不是依靠Flink的默认分配。我们将在“指定唯一的算子标识符”一节中详细说明如何分配算子标识符。</p><h1 id="Flink维表关联方式"><a href="#Flink维表关联方式" class="headerlink" title="Flink维表关联方式"></a>Flink维表关联方式</h1><p>从维表加载方式可以分为：</p><ul><li>实时数据库查找关联</li><li>预加载维表关联</li><li>维表变更日志关联</li><li>灵活组合衍生其他关联方式</li></ul><p>从维表在Flink内部的使用方式可以分为：</p><ul><li>预加载维表</li><li>热存储维表</li><li>广播维表</li><li>Temporal Table Function Join (仅SQL可用)</li></ul><p>一般我们习惯性把这个操作叫做Data Enrichment(数据扩充)</p><p>从处理思路又可以分为四种：</p><ul><li>全量预加载+定时刷新</li><li>实时查询+缓存刷新</li><li>纯实时查询</li><li>流式化纬度</li></ul><p><strong>TODO</strong> 后面我会针对这些纬度表的处理方式进行进一步的整理和补充</p><p>整体维表关联设计的指标：</p><ol><li>实现简单性：设计是否足够简单，易于迭代和维护</li><li>吞吐量：性能是否足够好</li><li>维表数据的实时性：维度表的更新是否可以立即对作业可见</li><li>数据库的负载</li><li>内存资源占用</li><li>可拓展性</li><li>结果确定性</li></ol><h1 id="Flink-原理与实现：内存管理"><a href="#Flink-原理与实现：内存管理" class="headerlink" title="Flink 原理与实现：内存管理"></a>Flink 原理与实现：内存管理</h1><p>如今，大数据领域的开源框架（Hadoop，Spark，Storm）都使用的 JVM，当然也包括 Flink。基于 JVM 的数据分析引擎都需要面对将大量数据存到内存中，这就不得不面对 JVM 存在的几个问题：</p><ol><li>Java 对象存储密度低。一个只包含 boolean 属性的对象占用了16个字节内存：对象头占了8个，boolean 属性占了1个，对齐填充占了7个。而实际上只需要一个bit（1/8字节）就够了。</li><li>Full GC 会极大地影响性能，尤其是为了处理更大数据而开了很大内存空间的JVM来说，GC 会达到秒级甚至分钟级。</li><li>OOM 问题影响稳定性。OutOfMemoryError是分布式计算框架经常会遇到的问题，当JVM中所有对象大小超过分配给JVM的内存大小时，就会发生OutOfMemoryError错误，导致JVM崩溃，分布式框架的健壮性和性能都会受到影响。</li></ol><p>所以目前，越来越多的大数据项目开始自己管理JVM内存了，像 Spark、Flink、HBase，为的就是获得像 C 一样的性能以及避免 OOM 的发生。本文将会讨论 Flink 是如何解决上面的问题的，主要内容包括内存管理、定制的序列化工具、缓存友好的数据结构和算法、堆外内存、JIT编译优化（Just In Time Compiler 即时编译器）等。</p><h2 id="积极的内存管理"><a href="#积极的内存管理" class="headerlink" title="积极的内存管理"></a>积极的内存管理</h2><p>Flink 并不是将大量对象存在堆上，而是将对象都序列化到一个预分配的内存块上，这个内存块叫做 <code>MemorySegment</code>，它代表了一段固定长度的内存（默认大小为 32KB），也是 Flink 中最小的内存分配单元，并且提供了非常高效的读写方法。你可以把 MemorySegment 想象成是为 Flink 定制的 <code>java.nio.ByteBuffer</code>。它的底层可以是一个普通的 Java 字节数组（<code>byte[]</code>），也可以是一个申请在堆外的 <code>ByteBuffer</code>。每条记录都会以序列化的形式存储在一个或多个<code>MemorySegment</code>中。</p><p>Flink 中的 Worker 名叫 TaskManager，是用来运行用户代码的 JVM 进程。TaskManager 的堆内存主要被分成了三个部分：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjwqeh9dfkj20k40l9ab4.jpg" alt="undefined"></p><ul><li><strong>Network Buffers:</strong> 一定数量的32KB大小的 buffer，主要用于数据的网络传输。在 TaskManager 启动的时候就会分配。默认数量是 2048 个，可以通过 <code>taskmanager.network.numberOfBuffers</code> 来配置。（阅读<a href="http://wuchong.me/blog/2016/04/26/flink-internals-how-to-handle-backpressure/?spm=a2c6h.12873639.0.0.506a2e39Kl3K9L" target="_blank" rel="noopener">这篇文章</a>了解更多Network Buffer的管理）</li><li><strong>Memory Manager Pool:</strong> 这是一个由 <code>MemoryManager</code> 管理的，由众多<code>MemorySegment</code>组成的超大集合。Flink 中的算法（如 sort/shuffle/join）会向这个内存池申请 MemorySegment，将序列化后的数据存于其中，使用完后释放回内存池。默认情况下，池子占了堆内存的 70% 的大小。</li><li><strong>Remaining (Free) Heap:</strong> 这部分的内存是留给用户代码以及 TaskManager 的数据结构使用的。因为这些数据结构一般都很小，所以基本上这些内存都是给用户代码使用的。从GC的角度来看，可以把这里看成的新生代，也就是说这里主要都是由用户代码生成的短期对象。</li></ul><p><em>注意：Memory Manager Pool 主要在Batch模式下使用。在Steaming模式下，该池子不会预分配内存，也不会向该池子请求内存块。也就是说该部分的内存都是可以给用户代码使用的。不过社区是打算在 Streaming 模式下也能将该池子利用起来。</em></p><p>Flink 采用类似 DBMS 的 sort 和 join 算法，直接操作二进制数据，从而使序列化/反序列化带来的开销达到最小。所以 Flink 的内部实现更像 C/C++ 而非 Java。如果需要处理的数据超出了内存限制，则会将部分数据存储到硬盘上。如果要操作多块MemorySegment就像操作一块大的连续内存一样，Flink会使用逻辑视图（<code>AbstractPagedInputView</code>）来方便操作。下图描述了 Flink 如何存储序列化后的数据到内存块中，以及在需要的时候如何将数据存储到磁盘上。</p><p>从上面我们能够得出 Flink 积极的内存管理以及直接操作二进制数据有以下几点好处：</p><ol><li><strong>减少GC压力。</strong>显而易见，因为所有常驻型数据都以二进制的形式存在 Flink 的<code>MemoryManager</code>中，这些<code>MemorySegment</code>一直呆在老年代而不会被GC回收。其他的数据对象基本上是由用户代码生成的短生命周期对象，这部分对象可以被 Minor GC 快速回收。只要用户不去创建大量类似缓存的常驻型对象，那么老年代的大小是不会变的，Major GC也就永远不会发生。从而有效地降低了垃圾回收的压力。另外，这里的内存块还可以是堆外内存，这可以使得 JVM 内存更小，从而加速垃圾回收。</li><li><strong>避免了OOM。</strong>所有的运行时数据结构和算法只能通过内存池申请内存，保证了其使用的内存大小是固定的，不会因为运行时数据结构和算法而发生OOM。在内存吃紧的情况下，算法（sort/join等）会高效地将一大批内存块写到磁盘，之后再读回来。因此，<code>OutOfMemoryErrors</code>可以有效地被避免。</li><li><strong>节省内存空间。</strong>Java 对象在存储上有很多额外的消耗（如上一节所谈）。如果只存储实际数据的二进制内容，就可以避免这部分消耗。</li><li><strong>高效的二进制操作 &amp; 缓存友好的计算。</strong>二进制数据以定义好的格式存储，可以高效地比较与操作。另外，该二进制形式可以把相关的值，以及hash值，键值和指针等相邻地放进内存中。这使得数据结构可以对高速缓存更友好，可以从 L1/L2/L3 缓存获得性能的提升（下文会详细解释）。</li></ol><h2 id="为-Flink-量身定制的序列化框架"><a href="#为-Flink-量身定制的序列化框架" class="headerlink" title="为 Flink 量身定制的序列化框架"></a>为 Flink 量身定制的序列化框架</h2><p>目前 Java 生态圈提供了众多的序列化框架：Java serialization, Kryo, Apache Avro 等等。但是 Flink 实现了自己的序列化框架。因为在 Flink 中处理的数据流通常是同一类型，由于数据集对象的类型固定，对于数据集可以只保存一份对象Schema信息，节省大量的存储空间。同时，对于固定大小的类型，也可通过固定的偏移位置存取。当我们需要访问某个对象成员变量的时候，通过定制的序列化工具，并不需要反序列化整个Java对象，而是可以直接通过偏移量，只是反序列化特定的对象成员变量。如果对象的成员变量较多时，能够大大减少Java对象的创建开销，以及内存数据的拷贝大小。</p><p>Flink支持任意的Java或是Scala类型。Flink 在数据类型上有很大的进步，不需要实现一个特定的接口（像Hadoop中的<code>org.apache.hadoop.io.Writable</code>），Flink 能够自动识别数据类型。Flink 通过 Java Reflection 框架分析基于 Java 的 Flink 程序 UDF (User Define Function)的返回类型的类型信息，通过 Scala Compiler 分析基于 Scala 的 Flink 程序 UDF 的返回类型的类型信息。类型信息由 <code>TypeInformation</code> 类表示，TypeInformation 支持以下几种类型：</p><ul><li><code>BasicTypeInfo</code>: 任意Java 基本类型（装箱的）或 String 类型。</li><li><code>BasicArrayTypeInfo</code>: 任意Java基本类型数组（装箱的）或 String 数组。</li><li><code>WritableTypeInfo</code>: 任意 Hadoop Writable 接口的实现类。</li><li><code>TupleTypeInfo</code>: 任意的 Flink Tuple 类型(支持Tuple1 to Tuple25)。Flink tuples 是固定长度固定类型的Java Tuple实现。</li><li><code>CaseClassTypeInfo</code>: 任意的 Scala CaseClass(包括 Scala tuples)。</li><li><code>PojoTypeInfo</code>: 任意的 POJO (Java or Scala)，例如，Java对象的所有成员变量，要么是 public 修饰符定义，要么有 getter/setter 方法。</li><li><code>GenericTypeInfo</code>: 任意无法匹配之前几种类型的类。</li></ul><p>前六种数据类型基本上可以满足绝大部分的Flink程序，针对前六种类型数据集，Flink皆可以自动生成对应的TypeSerializer，能非常高效地对数据集进行序列化和反序列化。对于最后一种数据类型，Flink会使用Kryo进行序列化和反序列化。每个TypeInformation中，都包含了serializer，类型会自动通过serializer进行序列化，然后用Java Unsafe接口写入MemorySegments。对于可以用作key的数据类型，Flink还同时自动生成TypeComparator，用来辅助直接对序列化后的二进制数据进行compare、hash等操作。对于 Tuple、CaseClass、POJO 等组合类型，其TypeSerializer和TypeComparator也是组合的，序列化和比较时会委托给对应的serializers和comparators。如下图展示 一个内嵌型的Tuple3 对象的序列化过程。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjwrvcz2rjj20pf0d70tf.jpg" alt="undefined"></p><p>可以看出这种序列化方式存储密度是相当紧凑的。其中 int 占4字节，double 占8字节，POJO多个一个字节的header，PojoSerializer只负责将header序列化进去，并委托每个字段对应的serializer对字段进行序列化。</p><p>Flink 的类型系统可以很轻松地扩展出自定义的TypeInformation、Serializer以及Comparator，来提升数据类型在序列化和比较时的性能。</p><h2 id="Flink-如何直接操作二进制数据"><a href="#Flink-如何直接操作二进制数据" class="headerlink" title="Flink 如何直接操作二进制数据"></a>Flink 如何直接操作二进制数据</h2><p>Flink 提供了如 group、sort、join 等操作，这些操作都需要访问海量数据。这里，我们以sort为例，这是一个在 Flink 中使用非常频繁的操作。</p><p>首先，Flink 会从 MemoryManager 中申请一批 MemorySegment，我们把这批 MemorySegment 称作 sort buffer，用来存放排序的数据。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjws4z21vij20jv0b2wev.jpg" alt="undefined"></p><p>我们会把 sort buffer 分成两块区域。一个区域是用来存放所有对象完整的二进制数据。另一个区域用来存放指向完整二进制数据的指针以及定长的序列化后的key（key+pointer）。如果需要序列化的key是个变长类型，如String，则会取其前缀序列化。如上图所示，当一个对象要加到 sort buffer 中时，它的二进制数据会被加到第一个区域，指针（可能还有key）会被加到第二个区域。</p><p>将实际的数据和指针加定长key分开存放有两个目的。第一，交换定长块（key+pointer）更高效，不用交换真实的数据也不用移动其他key和pointer。第二，这样做是缓存友好的，因为key都是连续存储在内存中的，可以大大减少 cache miss（后面会详细解释）。</p><p>排序的关键是比大小和交换。Flink 中，会先用 key 比大小，这样就可以直接用二进制的key比较而不需要反序列化出整个对象。因为key是定长的，所以如果key相同（或者没有提供二进制key），那就必须将真实的二进制数据反序列化出来，然后再做比较。之后，只需要交换key+pointer就可以达到排序的效果，真实的数据不用移动。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjwsnd19ebj20li0bkaak.jpg" alt="undefined"></p><p>最后，访问排序后的数据，可以沿着排好序的key+pointer区域顺序访问，通过pointer找到对应的真实数据，并写到内存或外部（更多细节可以看这篇文章 <a href="http://flink.apache.org/news/2015/03/13/peeking-into-Apache-Flinks-Engine-Room.html" target="_blank" rel="noopener">Joins in Flink</a>）。</p><h2 id="缓存友好的数据结构和算法"><a href="#缓存友好的数据结构和算法" class="headerlink" title="缓存友好的数据结构和算法"></a>缓存友好的数据结构和算法</h2><p>随着磁盘IO和网络IO越来越快，CPU逐渐成为了大数据领域的瓶颈。从 L1/L2/L3 缓存读取数据的速度比从主内存读取数据的速度快好几个量级。通过性能分析可以发现，CPU时间中的很大一部分都是浪费在等待数据从主内存过来上。如果这些数据可以从 L1/L2/L3 缓存过来，那么这些等待时间可以极大地降低，并且所有的算法会因此而受益。</p><p>在上面讨论中我们谈到的，Flink 通过定制的序列化框架将算法中需要操作的数据（如sort中的key）连续存储，而完整数据存储在其他地方。因为对于完整的数据来说，key+pointer更容易装进缓存，这大大提高了缓存命中率，从而提高了基础算法的效率。这对于上层应用是完全透明的，可以充分享受缓存友好带来的性能提升。</p><h2 id="走向堆外内存"><a href="#走向堆外内存" class="headerlink" title="走向堆外内存"></a>走向堆外内存</h2><p>Flink 基于堆内存的内存管理机制已经可以解决很多JVM现存问题了，为什么还要引入堆外内存？</p><ol><li>启动超大内存（上百GB）的JVM需要很长时间，GC停留时间也会很长（分钟级）。使用堆外内存的话，可以极大地减小堆内存（只需要分配Remaining Heap那一块），使得 TaskManager 扩展到上百GB内存不是问题。</li><li>高效的 IO 操作。堆外内存在写磁盘或网络传输时是 <code>zero-copy</code>，而堆内存的话，至少需要 copy 一次。</li><li>堆外内存是进程间共享的。也就是说，即使JVM进程崩溃也不会丢失数据。这可以用来做故障恢复（Flink暂时没有利用起这个，不过未来很可能会去做）。</li></ol><p>但是强大的东西总是会有其负面的一面，不然为何大家不都用堆外内存呢。</p><ol><li>堆内存的使用、监控、调试都要简单很多。堆外内存意味着更复杂更麻烦。</li><li>Flink 有时需要分配短生命周期的 <code>MemorySegment</code>，这个申请在堆上会更廉价。</li><li>有些操作在堆内存上会快一点点。</li></ol><p>Flink用通过<code>ByteBuffer.allocateDirect(numBytes)</code>来申请堆外内存，用 <code>sun.misc.Unsafe</code> 来操作堆外内存。</p><p>基于 Flink 优秀的设计，实现堆外内存是很方便的。Flink 将原来的 <code>MemorySegment</code> 变成了抽象类，并生成了两个子类。<code>HeapMemorySegment</code> 和 <code>HybridMemorySegment</code>。从字面意思上也很容易理解，前者是用来分配堆内存的，后者是用来分配堆外内存<strong>和堆内存</strong>的。是的，你没有看错，后者既可以分配堆外内存又可以分配堆内存。为什么要这样设计呢？</p><p>首先假设<code>HybridMemorySegment</code>只提供分配堆外内存。在上述堆外内存的不足中的第二点谈到，Flink 有时需要分配短生命周期的 buffer，这些buffer用<code>HeapMemorySegment</code>会更高效。那么当使用堆外内存时，为了也满足堆内存的需求，我们需要同时加载两个子类。这就涉及到了 JIT 编译优化的问题。因为以前 <code>MemorySegment</code> 是一个单独的 final 类，没有子类。JIT 编译时，所有要调用的方法都是确定的，所有的方法调用都可以被去虚化（de-virtualized）和内联（inlined），这可以极大地提高性能（MemroySegment的使用相当频繁）。然而如果同时加载两个子类，那么 JIT 编译器就只能在真正运行到的时候才知道是哪个子类，这样就无法提前做优化。实际测试的性能差距在 2.7 倍左右。</p><p>Flink 使用了两种方案：</p><p><strong>方案1：只能有一种 MemorySegment 实现被加载</strong></p><p>代码中所有的短生命周期和长生命周期的MemorySegment都实例化其中一个子类，另一个子类根本没有实例化过（使用工厂模式来控制）。那么运行一段时间后，JIT 会意识到所有调用的方法都是确定的，然后会做优化。</p><p><strong>方案2：提供一种实现能同时处理堆内存和堆外内存</strong></p><p>这就是 <code>HybridMemorySegment</code> 了，能同时处理堆与堆外内存，这样就不需要子类了。这里 Flink 优雅地实现了一份代码能同时操作堆和堆外内存。这主要归功于 <code>sun.misc.Unsafe</code>提供的一系列方法，如getLong方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Unsafe.getLong(Object reference, long offset)</span><br></pre></td></tr></table></figure><ul><li>如果reference不为空，则会取该对象的地址，加上后面的offset，从相对地址处取出8字节并得到 long。这对应了堆内存的场景。</li><li>如果reference为空，则offset就是要操作的绝对地址，从该地址处取出数据。这对应了堆外内存的场景。</li></ul><p>这里我们看下 <code>MemorySegment</code> 及其子类的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MemorySegment</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 堆内存引用</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] heapMemory;</span><br><span class="line">  <span class="comment">// 堆外内存地址</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> address;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//堆内存的初始化</span></span><br><span class="line">  MemorySegment(<span class="keyword">byte</span>[] buffer, Object owner) &#123;</span><br><span class="line">    <span class="comment">//一些先验检查</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.heapMemory = buffer;</span><br><span class="line">    <span class="keyword">this</span>.address = BYTE_ARRAY_BASE_OFFSET;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//堆外内存的初始化</span></span><br><span class="line">  MemorySegment(<span class="keyword">long</span> offHeapAddress, <span class="keyword">int</span> size, Object owner) &#123;</span><br><span class="line">    <span class="comment">//一些先验检查</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.heapMemory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.address = offHeapAddress;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> pos = address + index;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; pos &lt;= addressLimit - <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="comment">// 这是我们关注的地方，使用 Unsafe 来操作 on-heap &amp; off-heap</span></span><br><span class="line">      <span class="keyword">return</span> UNSAFE.getLong(heapMemory, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (address &gt; addressLimit) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"segment has been freed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// index is in fact invalid</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapMemorySegment</span> <span class="keyword">extends</span> <span class="title">MemorySegment</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指向heapMemory的额外引用，用来如数组越界的检查</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] memory;</span><br><span class="line">  <span class="comment">// 只能初始化堆内存</span></span><br><span class="line">  HeapMemorySegment(<span class="keyword">byte</span>[] memory, Object owner) &#123;</span><br><span class="line">    <span class="keyword">super</span>(Objects.requireNonNull(memory), owner);</span><br><span class="line">    <span class="keyword">this</span>.memory = memory;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HybridMemorySegment</span> <span class="keyword">extends</span> <span class="title">MemorySegment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer offHeapBuffer;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 堆外内存初始化</span></span><br><span class="line">  HybridMemorySegment(ByteBuffer buffer, Object owner) &#123;</span><br><span class="line">    <span class="keyword">super</span>(checkBufferAndGetAddress(buffer), buffer.capacity(), owner);</span><br><span class="line">    <span class="keyword">this</span>.offHeapBuffer = buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 堆内存初始化</span></span><br><span class="line">  HybridMemorySegment(<span class="keyword">byte</span>[] buffer, Object owner) &#123;</span><br><span class="line">    <span class="keyword">super</span>(buffer, owner);</span><br><span class="line">    <span class="keyword">this</span>.offHeapBuffer = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，HybridMemorySegment 中的很多方法其实都下沉到了父类去实现。包括堆内堆外内存的初始化。<code>MemorySegment</code> 中的 <code>getXXX</code>/<code>putXXX</code> 方法都是调用了 unsafe 方法，可以说<code>MemorySegment</code>已经具有了些 Hybrid 的意思了。<code>HeapMemorySegment</code>只调用了父类的<code>MemorySegment(byte[] buffer, Object owner)</code>方法，也就只能申请堆内存。另外，阅读代码你会发现，许多方法（大量的 getXXX/putXXX）都被标记成了 final，两个子类也是 final 类型，为的也是优化 JIT 编译器，会提醒 JIT 这个方法是可以被去虚化和内联的。</p><p>对于堆外内存，使用 <code>HybridMemorySegment</code> 能同时用来代表堆和堆外内存。这样只需要一个类就能代表长生命周期的堆外内存和短生命周期的堆内存。既然<code>HybridMemorySegment</code>已经这么全能，为什么还要方案1呢？因为我们需要工厂模式来保证只有一个子类被加载（为了更高的性能），而且HeapMemorySegment比heap模式的HybridMemorySegment要快。</p><p>下方是一些性能测试数据，更详细的数据请参考<a href="http://flink.apache.org/news/2015/09/16/off-heap-memory.html#appendix-detailed-micro-benchmarks" target="_blank" rel="noopener">这篇文章</a>。</p><table><thead><tr><th align="left">Segment</th><th align="left">Time</th></tr></thead><tbody><tr><td align="left">HeapMemorySegment, exclusive</td><td align="left">1,441 msecs</td></tr><tr><td align="left">HeapMemorySegment, mixed</td><td align="left">3,841 msecs</td></tr><tr><td align="left">HybridMemorySegment, heap, exclusive</td><td align="left">1,626 msecs</td></tr><tr><td align="left">HybridMemorySegment, off-heap, exclusive</td><td align="left">1,628 msecs</td></tr><tr><td align="left">HybridMemorySegment, heap, mixed</td><td align="left">3,848 msecs</td></tr><tr><td align="left">HybridMemorySegment, off-heap, mixed</td><td align="left">3,847 msecs</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要总结了 Flink 面对 JVM 存在的问题，而在内存管理的道路上越走越深。从自己管理内存，到序列化框架，再到堆外内存。其实纵观大数据生态圈，其实会发现各个开源项目都有同样的趋势。比如最近炒的很火热的 Spark Tungsten 项目，与 Flink 在内存管理上的思想是及其相似的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://flink.apache.org/news/2015/09/16/off-heap-memory.html" target="_blank" rel="noopener">Off-heap Memory in Apache Flink and the curious JIT compiler</a></li><li><a href="https://flink.apache.org/news/2015/05/11/Juggling-with-Bits-and-Bytes.html" target="_blank" rel="noopener">Juggling with Bits and Bytes</a></li><li><a href="https://flink.apache.org/news/2015/03/13/peeking-into-Apache-Flinks-Engine-Room.html" target="_blank" rel="noopener">Peeking into Apache Flink’s Engine Room</a></li><li><a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=53741525" target="_blank" rel="noopener">Flink: Memory Management</a></li><li><a href="http://www.bigsynapse.com/addressing-big-data-performance" target="_blank" rel="noopener">Big Data Performance Engineering</a></li><li><a href="http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/" target="_blank" rel="noopener">sun.misc.misc.Unsafe usage for C style memory management</a></li><li><a href="http://howtodoinjava.com/core-java/related-concepts/usage-of-class-sun-misc-unsafe/" target="_blank" rel="noopener">sun.misc.misc.Unsafe usage for C style memory management - How to do it.</a></li><li><a href="http://www.javamex.com/tutorials/memory/object_memory_usage.shtml" target="_blank" rel="noopener">Memory usage of Java objects: general guide</a></li><li><a href="http://www.36dsj.com/archives/33650" target="_blank" rel="noopener">脱离JVM？ Hadoop生态圈的挣扎与演化</a></li></ul><h1 id="Flink-内存设置思路"><a href="#Flink-内存设置思路" class="headerlink" title="Flink 内存设置思路"></a>Flink 内存设置思路</h1><p>Flink内存设置思路分为两个版本</p><p>分别是1.9之前和之后的</p><h2 id="Flink-lt-1-9"><a href="#Flink-lt-1-9" class="headerlink" title="Flink &lt;= 1.9"></a>Flink &lt;= 1.9</h2><p>这里用Flink1.8为例，计算内存的代码位于<code>org.apache.flink.runtime.clusterframework.ContaineredTaskManagerParameters</code>类的<code>create</code>方法。</p><p>按照计算步骤，以<code>taskmanager.heap.size=6g</code>为例子，其他参数保持不动，最终得到的参数如下：</p><p>​                        -Xms4148m -Xmx4148m  -XX:MaxDirectMemorySize=1996m</p><p>两块内存加起来是6144m = 6g jvm的设置符合参数。</p><p>Flink Dashboard上面显示的是：</p><p>​        JVM Heap Size：3.95 GB  Flink Managed Memory：2.74 GB</p><p>​        JVM (Heap/Non-Heap) Commit： Heap：3.95 GB Non-Heap：141 MB Total：4.09 GB</p><p>​        Outside JVM：Capacity：457 MB</p><p>​        NetWork: count: xxxxx</p><h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p>设容器内存总大小是x</p><p>详细看create方法：</p><pre><code>1.  cutoff：容器超过3g, 简单可以记成 0.25x. flink为了防止内存溢出，计算的时候先切了一块内存下来不参与后续计算，这块就是cutoff</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cutoff = Math.max(containerized.heap-cutoff-min, taskmanager.heap.size * containerized.heap-cutoff-ratio)</span><br></pre></td></tr></table></figure><p>默认值是600和0.25，所以6g的时候=Math.max(600, 6144*0.25) = 1536m</p><p>剩余大小 0.75x6g = 4608m</p><ol start="2"><li>networkBufMB：简单记成 0.75*0.1x，最大1g</li></ol><p>网络buffer使用内存分成新旧版，这里只关注新版，涉及参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">taskmanager.memory.segment-size：32kb</span><br><span class="line">taskmanager.network.memory.fraction：0.1</span><br><span class="line">taskmanager.network.memory.min：64mb</span><br><span class="line">taskmanager.network.memory.max：1g</span><br></pre></td></tr></table></figure><p>计算参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.min(taskmanager.network.memory.max，Math.max(taskmanager.network.memory.min, taskmanager.network.memory.fraction * (x - cutoff))</span><br></pre></td></tr></table></figure><p>这里的结果就是：Math.min(1g, Math.max(64mb, 0.1 * 4608m) = 460.8m</p><ol start="3"><li>heapSizeMB：0.75 * 0.9x</li></ol><p>taskmanager.memory.off-heap默认为false，主要指的是Flink Managed Memory使用Heap还是Non-heap，默认使用Heap，如果开启使用Non-heap将再减少一部分资源。</p><p>计算公式：<code>x - cutoff - networkBufMB</code></p><p>这里就是：4147.2　　　　（注意：这个就是-xmx 4148m）</p><p>​    4. offHeapSizeMB： x - heapSizeMB</p><p>就是1996m　　　　　　　(注意：这个就是XX:MaxDirectMemorySize: 1996m)</p><p>后续：上面只是一个jvm的参数预估设置，实际设置还与运行中环境有关，TaskManagerServices.fromConfiguration</p><p>会计算一个 freeHeapMemoryWithDefrag，计算之前会手动触发gc，然后用Jvm最大内存 - 总内存 + 空闲内存。</p><p>这个值可以认为是一个空运行的flink任务剩余的堆内存了。</p><p>后面将计算Flink管理的内存，这个指的是Flink Managed Memory Segment: taskmanager.memory.fraction默认是0.7，</p><p>被Flink管理的内存就是：freeHeapMemoryWithDefrag * 0.7</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk54bjvcx9j20ee0nkjvz.jpg" alt="undefined"></p><p>所以虽然6g内存计算出来后，heap是4148，但是在dashbord中显示不足4148, 为3.95G=4044.8, Flink managed内存小于 0.75<em>0.9</em>0.7 = 2903.04 , dashboard上显示2.74g = 2805.76m</p><p>框架运行需要：4148 - 4044.8 = 103.2m，3.95 * 0.7 = 2.765 &gt; 2.74。没有相等，其他的内存使用暂时没有探究了。</p><p>Flink Managed内存一般用于批处理作业，流处理作业可以调整 taskmanager.memory.fraction，使得这部分内存用于用户代码。</p><p>Non - heap空间一般用于 JVM 的栈空间、方法区等堆外开销外，还包括网络 buffer、batch 缓存、RocksDB</p><h2 id="Flink-gt-1-10"><a href="#Flink-gt-1-10" class="headerlink" title="Flink &gt;= 1.10"></a>Flink &gt;= 1.10</h2><p>Flink后面内存进行了较大的变动，也就是说之前上面云邪写的内存管理已经过时了</p><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/zh/ops/memory/mem_migration.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.10/zh/ops/memory/mem_migration.html</a></p><p>这里设置单个taskmanager为14g，taskmanager.memory.managed.fraction为0.5，将会得到以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xmx5721030656  = 5456MB = 5.328g</span><br><span class="line">-=1207959552  = 1152MB = 1.125g</span><br><span class="line">-XX:MaxMetaspaceSize=100663296 = 96MB</span><br></pre></td></tr></table></figure><p>可以发现，上面的加起来等于6704MB，远远不足14g，和1.8版本有很大的不同。</p><p>再看dashboard：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JVM Heap Size：5.19 GB   Flink Managed Memory：6.45 GB</span><br><span class="line">JVM (Heap/Non-Heap) ： Heap：5.19 GB  Non-Heap：1.33 GB  Total：6.52 GB</span><br><span class="line">Outside JVM：Capacity：1.01GB</span><br><span class="line">NetWork: count:  xxxxx</span><br></pre></td></tr></table></figure><p>可以计算得到6.45+6.52+1.01 = 13.98 等于14</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">taskmanager.memory.process.size 设置的是容器的内存大小，等于之前的 taskmanager.heap.size</span><br><span class="line"></span><br><span class="line">计算过程在org.apache.flink.runtime.clusterframework.TaskExecutorProcessUtils中processSpecFromConfig方法，TaskExecutorProcessSpec类展示了1.10版本整个内存的组成。</span><br><span class="line"></span><br><span class="line">计算方法分成3种：</span><br><span class="line">1.指定了taskmanager.memory.task.heap.size和taskmanager.memory.managed.size   </span><br><span class="line">见方法：deriveProcessSpecWithExplicitTaskAndManagedMemory</span><br><span class="line">2.指定了taskmanager.memory.flink.size  </span><br><span class="line">见方法：deriveProcessSpecWithTotalFlinkMemory</span><br><span class="line">3.指定了taskmanager.memory.process.size（容器环境一般指定这个，决定全局容量）</span><br><span class="line">totalProcessMemorySize = 设置的值 14g,   jvmMetaspaceSize = taskmanager.memory.jvm-metaspace.size,默认96m,这个对应参数-XX:MaxMetaspaceSize=100663296。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jvmOverheadSize：</span><br><span class="line"></span><br><span class="line">taskmanager.memory.jvm-overhead.min  192m</span><br><span class="line">taskmanager.memory.jvm-overhead.max 1g</span><br><span class="line">taskmanager.memory.jvm-overhead.fraction 0.1</span><br></pre></td></tr></table></figure><p>公式 14g * 0.1 = 1.4g 必须在[192m, 1g]之间，所以jvmOverheadSize的大小是1g</p><p>totalFlinkMemorySize = 14g - 1g - 96m = 13216m</p><p>frameworkHeapMemorySize：taskmanager.memory.framework.heap.size 默认128m</p><p>frameworkOffHeapMemorySize：taskmanager.memory.framework.off-heap.size 默认128m</p><p>taskOffHeapMemorySize：taskmanager.memory.task.off-heap.size 默认0</p><p>确定好上面这些参数后，就是最重要的三个指标的计算了：</p><p>taskHeapMemorySize，networkMemorySize，managedMemorySize</p><p>计算分成确定了：taskmanager.memory.task.heap.size还是没确定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">确定了taskmanager.memory.task.heap.size</span><br><span class="line">taskHeapMemorySize = 设置值</span><br><span class="line">managedMemorySize = 设置了使用设置值，否则使用 0.4 * totalFlinkMemorySize</span><br><span class="line">如果 taskHeapMemorySize + taskOffHeapMemorySize + frameworkHeapMemorySize + frameworkOffHeapMemorySize + managedMemorySize &gt; totalFlinkMemorySize异常</span><br><span class="line">networkMemorySize 等于剩余的大小，之后还会check这块内存是否充足，可以自己查看对应代码</span><br><span class="line">未设置heap大小</span><br><span class="line">先确定 managedMemorySize = 设置了使用设置值，否则使用 0.4 * totalFlinkMemorySize，这里就是 0.5 * 13216m = 6608 = 6.45g (这里就是dashboard的显示内容)</span><br><span class="line">再确定network buffer大小，这个也是有两种情况，不细说。 [64mb, 1g] 0.1 * totalFlinkMemorySize = 1321.6, 所以是1g</span><br><span class="line">最后剩余的就是taskHeapMemorySize,不能为负数，这里等于  13216 - 6608 - 1024 - 128 - 128 = 5328 = 5.2g (这里约等于dashboard的显示heap大小)</span><br><span class="line">最后jvm的参数的计算过程：</span><br><span class="line">jvmHeapSize = frameworkHeapSize + taskHeapSize = 5328 + 128 = 5456</span><br><span class="line">jvmDirectSize = frameworkOffHeapMemorySize + taskOffHeapSize + networkMemSize = 128 + 1024 = 1152</span><br><span class="line">jvmMetaspaceSize = 96m</span><br></pre></td></tr></table></figure><h3 id="全新内存划分"><a href="#全新内存划分" class="headerlink" title="全新内存划分"></a>全新内存划分</h3><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/ops/memory/mem_detail.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.10/ops/memory/mem_detail.html</a></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gk54yygegpj20iw0yota9.jpg" alt="undefined"></p><p>从计算过程，结合上图可以看出Flink 1.10中的一个内存划分了。</p><p>总内存 = Flink 内存 + JVM Metaspace （96m）+ JVM Overhead （计算为0.1 * 全局大小，结果必须在[192m, 1g]之间）</p><p>Flink内存被划分成6部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">框架运行需要的Heap和Non Heap，默认都是128m</span><br><span class="line">任务需要的Heap和Non Heap(默认0), Heap是通过计算其他5部分内存，Flink内存剩余得到</span><br><span class="line">网络缓冲 (0.1 * Flink内存，结果必须在[64mb, 1g]之间）</span><br><span class="line">Flink管理内存：0.4 * Flink内存</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Flink 1.10之前对内存的划分比较简单，主要就是Heap + Non-Heap，之后对内存做了更细致的切分。</p><p>Flink 1.8可以调整taskmanager.memory.fraction 减少Heap中的管理的内存，增大用户代码的内存使用，调整containerized.heap-cutoff-ratio，控制Non-heap空间，这个影响rocksdb。</p><p>Flink 1.10可以调整taskmanager.memory.managed.fraction 控制managed内存，这个影响rocksdb，也会影响taskHeap大小，需要衡量。</p><p>也可以看到Flink内存模型的变化managed内存位置也发生了变化，作用也有了些许变化。</p><p>JVM 主要划分 Heap 和 Non-Heap，Non-Heap又划分为Direct和Native等。</p><p>1.8的Non-Heap都是通过XX:MaxDirectMemorySize设置的</p><p>1.10的Network buffer在Direct里面，另一部分是Native(包括Managed Memory)，主要用于rocksdb，如果使用的是Heap状态后台，可以设置小点，也用于Batch。</p><h1 id="多流合并"><a href="#多流合并" class="headerlink" title="多流合并"></a>多流合并</h1><p>遇到了一个多流合并的问题，目前给出的方案是：</p><ol><li><p>分析业务数据源，很多需要多个流的join的场景 是伪命题，用union即可。</p></li><li><p>union + group by ，在基于key的流中可以取代join。优势： 在join 发生数据倾斜或者反压，很难 checkpoint时，用union可以回避这个问题。</p></li><li><p>例如三个流join，可以 tempstream = stream1.join(stream2)  ResultStream = tempstream.join(stream3)。语法支持，看了下生成的图，不确定是不是想要的效果。</p></li><li><p>将第三点的 join 换成 cogroup操作。这个是社区直播中，提问多流join后  得到的回复</p></li><li><p>基于blink引擎，多表join 直接用sql表达出来。select * from table1 a left join table2 b on a.id = b.id left join table3 c on b.id = c.id 这个方案也是在社区直播，提问多流join后 得到的回复。</p></li></ol><p>SQL暂时是不用的，那么只剩下了第一种。</p><p>我尝试拆分一下逻辑。</p><h1 id="Flink-的算子链机制"><a href="#Flink-的算子链机制" class="headerlink" title="Flink 的算子链机制"></a>Flink 的算子链机制</h1><p>“为什么我的 Flink 作业 Web UI 中只显示出了一个框，并且 Records Sent 和Records Received 指标都是 0 ？是我的程序写得有问题吗？”</p><p>在 Flink 社区群里经常能看到类似这样的疑问。这种情况几乎都不是程序有问题，而是因为 Flink 的 operator chain ——即算子链机制导致的，即提交的作业的执行计划中，所有算子的并发实例（即 sub-task ）都因为满足特定条件而串成了整体来执行，自然就观察不到算子之间的数据流量了。</p><p>当然上述是一种特殊情况。我们更常见到的是只有部分算子得到了算子链机制的优化，如官方文档中出现过多次的下图所示，注意 Source 和 map() 算子。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkmcz3c92rj20u00ki0z9.jpg" alt="undefined"></p><p>算子链机制的好处是显而易见的：<strong>所有 chain 在一起的 sub-task 都会在同一个线程（即 TaskManager 的 slot）中执行，能够减少不必要的数据交换、序列化和上下文切换，从而提高作业的执行效率。</strong></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gkmd1v7t1nj20u009rjua.jpg" alt="undefined"></p><h2 id="逻辑计划中的算子链"><a href="#逻辑计划中的算子链" class="headerlink" title="逻辑计划中的算子链"></a>逻辑计划中的算子链</h2><p>对 Flink Runtime 稍有了解的看官应该知道，Flink 作业的执行计划会用三层图结构来表示，即：</p><ul><li>StreamGraph —— 原始逻辑执行计划</li><li>JobGraph —— 优化的逻辑执行计划（Web UI 中看到的就是这个）</li><li>ExecutionGraph —— 物理执行计划</li></ul><p>算子链是在优化逻辑计划时加入的，也就是由 StreamGraph 生成 JobGraph 的过程中。那么我们来到负责生成 JobGraph 的 o.a.f.streaming.api.graph.StreamingJobGraphGenerator 类，查看其核心方法 createJobGraph() 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> JobGraph <span class="title">createJobGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// make sure that all vertices start immediately</span></span><br><span class="line">    jobGraph.setScheduleMode(streamGraph.getScheduleMode());</span><br><span class="line">    <span class="comment">// Generate deterministic hashes for the nodes in order to identify them across</span></span><br><span class="line">    <span class="comment">// submission iff they didn't change.</span></span><br><span class="line">    Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes = defaultStreamGraphHasher.traverseStreamGraphAndGenerateHashes(streamGraph);</span><br><span class="line">    <span class="comment">// Generate legacy version hashes for backwards compatibility</span></span><br><span class="line">    List&lt;Map&lt;Integer, <span class="keyword">byte</span>[]&gt;&gt; legacyHashes = <span class="keyword">new</span> ArrayList&lt;&gt;(legacyStreamGraphHashers.size());</span><br><span class="line">    <span class="keyword">for</span> (StreamGraphHasher hasher : legacyStreamGraphHashers) &#123;</span><br><span class="line">        legacyHashes.add(hasher.traverseStreamGraphAndGenerateHashes(streamGraph));</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; chainedOperatorHashes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    setChaining(hashes, legacyHashes, chainedOperatorHashes);</span><br><span class="line"></span><br><span class="line">    setPhysicalEdges();</span><br><span class="line">    <span class="comment">// 略......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jobGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，该方法会先计算出 StreamGraph 中各个节点的哈希码作为唯一标识，并创建一个空的 Map 结构保存即将被链在一起的算子的哈希码，然后调用 setChaining() 方法，如下源码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChaining</span><span class="params">(Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes, List&lt;Map&lt;Integer, <span class="keyword">byte</span>[]&gt;&gt; legacyHashes, Map&lt;Integer, List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; chainedOperatorHashes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer sourceNodeId : streamGraph.getSourceIDs()) &#123;</span><br><span class="line">        createChain(sourceNodeId, sourceNodeId, hashes, legacyHashes, <span class="number">0</span>, chainedOperatorHashes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见是逐个遍历 StreamGraph 中的 Source 节点，并调用 createChain() 方法。createChain() 是逻辑计划层创建算子链的核心方法，完整源码如下，有点长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;StreamEdge&gt; <span class="title">createChain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Integer startNodeId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Integer currentNodeId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;Map&lt;Integer, <span class="keyword">byte</span>[]&gt;&gt; legacyHashes,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> chainIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;Integer, List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; chainedOperatorHashes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!builtVertices.contains(startNodeId)) &#123;</span><br><span class="line">        List&lt;StreamEdge&gt; transitiveOutEdges = <span class="keyword">new</span> ArrayList&lt;StreamEdge&gt;();</span><br><span class="line">        List&lt;StreamEdge&gt; chainableOutputs = <span class="keyword">new</span> ArrayList&lt;StreamEdge&gt;();</span><br><span class="line">        List&lt;StreamEdge&gt; nonChainableOutputs = <span class="keyword">new</span> ArrayList&lt;StreamEdge&gt;();</span><br><span class="line"></span><br><span class="line">        StreamNode currentNode = streamGraph.getStreamNode(currentNodeId);</span><br><span class="line">        <span class="keyword">for</span> (StreamEdge outEdge : currentNode.getOutEdges()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isChainable(outEdge, streamGraph)) &#123;</span><br><span class="line">                chainableOutputs.add(outEdge);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nonChainableOutputs.add(outEdge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (StreamEdge chainable : chainableOutputs) &#123;</span><br><span class="line">            transitiveOutEdges.addAll(</span><br><span class="line">                    createChain(startNodeId, chainable.getTargetId(), hashes, legacyHashes, chainIndex + <span class="number">1</span>, chainedOperatorHashes));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (StreamEdge nonChainable : nonChainableOutputs) &#123;</span><br><span class="line">            transitiveOutEdges.add(nonChainable);</span><br><span class="line">            createChain(nonChainable.getTargetId(), nonChainable.getTargetId(), hashes, legacyHashes, <span class="number">0</span>, chainedOperatorHashes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt; operatorHashes =</span><br><span class="line">            chainedOperatorHashes.computeIfAbsent(startNodeId, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] primaryHashBytes = hashes.get(currentNodeId);</span><br><span class="line">        OperatorID currentOperatorId = <span class="keyword">new</span> OperatorID(primaryHashBytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map&lt;Integer, <span class="keyword">byte</span>[]&gt; legacyHash : legacyHashes) &#123;</span><br><span class="line">            operatorHashes.add(<span class="keyword">new</span> Tuple2&lt;&gt;(primaryHashBytes, legacyHash.get(currentNodeId)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chainedNames.put(currentNodeId, createChainedName(currentNodeId, chainableOutputs));</span><br><span class="line">        chainedMinResources.put(currentNodeId, createChainedMinResources(currentNodeId, chainableOutputs));</span><br><span class="line">        chainedPreferredResources.put(currentNodeId, createChainedPreferredResources(currentNodeId, chainableOutputs));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode.getInputFormat() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getOrCreateFormatContainer(startNodeId).addInputFormat(currentOperatorId, currentNode.getInputFormat());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.getOutputFormat() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getOrCreateFormatContainer(startNodeId).addOutputFormat(currentOperatorId, currentNode.getOutputFormat());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StreamConfig config = currentNodeId.equals(startNodeId)</span><br><span class="line">                ? createJobVertex(startNodeId, hashes, legacyHashes, chainedOperatorHashes)</span><br><span class="line">                : <span class="keyword">new</span> StreamConfig(<span class="keyword">new</span> Configuration());</span><br><span class="line"></span><br><span class="line">        setVertexConfig(currentNodeId, config, chainableOutputs, nonChainableOutputs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNodeId.equals(startNodeId)) &#123;</span><br><span class="line">            config.setChainStart();</span><br><span class="line">            config.setChainIndex(<span class="number">0</span>);</span><br><span class="line">            config.setOperatorName(streamGraph.getStreamNode(currentNodeId).getOperatorName());</span><br><span class="line">            config.setOutEdgesInOrder(transitiveOutEdges);</span><br><span class="line">            config.setOutEdges(streamGraph.getStreamNode(currentNodeId).getOutEdges());</span><br><span class="line">            <span class="keyword">for</span> (StreamEdge edge : transitiveOutEdges) &#123;</span><br><span class="line">                connect(startNodeId, edge);</span><br><span class="line">            &#125;</span><br><span class="line">            config.setTransitiveChainedTaskConfigs(chainedConfigs.get(startNodeId));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chainedConfigs.computeIfAbsent(startNodeId, k -&gt; <span class="keyword">new</span> HashMap&lt;Integer, StreamConfig&gt;());</span><br><span class="line">            config.setChainIndex(chainIndex);</span><br><span class="line">            StreamNode node = streamGraph.getStreamNode(currentNodeId);</span><br><span class="line">            config.setOperatorName(node.getOperatorName());</span><br><span class="line">            chainedConfigs.get(startNodeId).put(currentNodeId, config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        config.setOperatorID(currentOperatorId);</span><br><span class="line">        <span class="keyword">if</span> (chainableOutputs.isEmpty()) &#123;</span><br><span class="line">            config.setChainEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transitiveOutEdges;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先解释一下方法开头创建的 3 个 List 结构：</p><ul><li>transitiveOutEdges：当前算子链在 JobGraph 中的出边列表，同时也是 createChain() 方法的最终返回值；</li><li>chainableOutputs：当前能够链在一起的 StreamGraph 边列表；</li><li>nonChainableOutputs：当前不能够链在一起的 StreamGraph 边列表。</li></ul><p>接下来，从 Source 开始遍历 StreamGraph 中当前节点的所有出边，调用 isChainable() 方法判断是否可以被链在一起（这个判断逻辑稍后会讲到）。可以链接的出边被放入 chainableOutputs 列表，否则放入 nonChainableOutputs 列表。</p><p>对于 chainableOutputs 中的边，就会以这些边的直接下游为起点，继续递归调用createChain() 方法延展算子链。对于 nonChainableOutputs 中的边，由于当前算子链的延展已经到头，就会以这些“断点”为起点，继续递归调用 createChain() 方法试图创建新的算子链。也就是说，逻辑计划中整个创建算子链的过程都是递归的，亦即实际返回时，是从 Sink 端开始返回的。</p><p>然后要判断当前节点是不是算子链的起始节点。如果是，则调用 createJobVertex()方法为算子链创建一个 JobVertex（ 即 JobGraph 中的节点），也就形成了我们在Web UI 中看到的 JobGraph 效果：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1gkmd8wroh7j20u00ezgp1.jpg" alt="undefined"></p><p>最后，还需要将各个节点的算子链数据写入各自的 StreamConfig 中，算子链的起始节点要额外保存下 transitiveOutEdges。StreamConfig 在后文的物理执行阶段会再次用到。</p><h2 id="形成算子链的条件"><a href="#形成算子链的条件" class="headerlink" title="形成算子链的条件"></a>形成算子链的条件</h2><p>来看看 isChainable() 方法的代码。 由此可得，上下游算子能够 chain 在一起的条件还是非常苛刻的（老生常谈了），列举如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChainable</span><span class="params">(StreamEdge edge, StreamGraph streamGraph)</span> </span>&#123;</span><br><span class="line">    StreamNode upStreamVertex = streamGraph.getSourceVertex(edge);</span><br><span class="line">    StreamNode downStreamVertex = streamGraph.getTargetVertex(edge);</span><br><span class="line"></span><br><span class="line">    StreamOperatorFactory&lt;?&gt; headOperator = upStreamVertex.getOperatorFactory();</span><br><span class="line">    StreamOperatorFactory&lt;?&gt; outOperator = downStreamVertex.getOperatorFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> downStreamVertex.getInEdges().size() == <span class="number">1</span></span><br><span class="line">            &amp;&amp; outOperator != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; headOperator != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; upStreamVertex.isSameSlotSharingGroup(downStreamVertex)</span><br><span class="line">            &amp;&amp; outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS</span><br><span class="line">            &amp;&amp; (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||</span><br><span class="line">                headOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)</span><br><span class="line">            &amp;&amp; (edge.getPartitioner() <span class="keyword">instanceof</span> ForwardPartitioner)</span><br><span class="line">            &amp;&amp; edge.getShuffleMode() != ShuffleMode.BATCH</span><br><span class="line">            &amp;&amp; upStreamVertex.getParallelism() == downStreamVertex.getParallelism()</span><br><span class="line">            &amp;&amp; streamGraph.isChainingEnabled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上下游算子实例处于同一个 SlotSharingGroup 中（之后再提）；</p></li><li><p>下游算子的链接策略（ChainingStrategy）为 ALWAYS ——既可以与上游链接，也可以与下游链接。我们常见的 map()、filter() 等都属此类；</p></li><li><p>上游算子的链接策略为 HEAD 或 ALWAYS。HEAD 策略表示只能与下游链接，这在正常情况下是 Source 算子的专属；</p></li><li><p>两个算子间的物理分区逻辑是 ForwardPartitioner ，可参见之前写过的《聊聊Flink DataStream 的八种物理分区逻辑》；</p></li><li><p>两个算子间的 shuffle 方式不是批处理模式；</p></li><li><p>上下游算子实例的并行度相同；</p></li><li><p>没有禁用算子链。</p></li></ul><h2 id="禁用算子链"><a href="#禁用算子链" class="headerlink" title="禁用算子链"></a>禁用算子链</h2><p>用户可以在一个算子上调用 startNewChain() 方法强制开始一个新的算子链，或者调用 disableOperatorChaining() 方法指定它不参与算子链。代码位于 SingleOutputStreamOperator 类中，都是通过改变算子的链接策略实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@PublicEvolving</span><br><span class="line">public SingleOutputStreamOperator&lt;T&gt; disableChaining() &#123;</span><br><span class="line">    return setChainingStrategy(ChainingStrategy.NEVER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@PublicEvolving</span><br><span class="line">public SingleOutputStreamOperator&lt;T&gt; startNewChain() &#123;</span><br><span class="line">    return setChainingStrategy(ChainingStrategy.HEAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要在整个运行时环境中禁用算子链，调用 StreamExecutionEnvironment.disableOperatorChaining() 方法即可。</p><h2 id="物理计划中的算子链"><a href="#物理计划中的算子链" class="headerlink" title="物理计划中的算子链"></a>物理计划中的算子链</h2><p>在 JobGraph 转换成 ExecutionGraph 并交由 TaskManager 执行之后，会生成调度执行的基本任务单元 ——StreamTask，负责执行具体的 StreamOperator 逻辑。在StreamTask.invoke() 方法中，初始化了状态后端、checkpoint 存储和定时器服务之后，可以发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">operatorChain = new OperatorChain&lt;&gt;(this, recordWriters);</span><br><span class="line">headOperator = operatorChain.getHeadOperator();</span><br></pre></td></tr></table></figure><p>构造出了一个 OperatorChain 实例，这就是算子链在实际执行时的形态。解释一下OperatorChain 中的几个主要属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final StreamOperator&lt;?&gt;[] allOperators;</span><br><span class="line">private final RecordWriterOutput&lt;?&gt;[] streamOutputs;</span><br><span class="line">private final WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; chainEntryPoint;</span><br><span class="line">private final OP headOperator;</span><br></pre></td></tr></table></figure><ul><li>headOperator：算子链的第一个算子，对应 JobGraph 中的算子链起始节点；</li><li>allOperators：算子链中的所有算子，倒序排列，即 headOperator 位于该数组的末尾；</li><li>streamOutputs：算子链的输出，可以有多个；</li><li>chainEntryPoint：算子链的“入口点”，它的含义将在后文说明。</li></ul><p>由上可知，所有 StreamTask 都会创建 OperatorChain。如果一个算子无法进入算子链，也会形成一个只有 headOperator 的单个算子的 OperatorChain。</p><p>OperatorChain 构造方法中的核心代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; outEdgesInOrder.size(); i++) &#123;</span><br><span class="line">    StreamEdge outEdge = outEdgesInOrder.get(i);</span><br><span class="line">    RecordWriterOutput&lt;?&gt; streamOutput = createStreamOutput(</span><br><span class="line">        recordWriters.get(i),</span><br><span class="line">        outEdge,</span><br><span class="line">        chainedConfigs.get(outEdge.getSourceId()),</span><br><span class="line">        containingTask.getEnvironment());</span><br><span class="line">    this.streamOutputs[i] = streamOutput;</span><br><span class="line">    streamOutputMap.put(outEdge, streamOutput);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// we create the chain of operators and grab the collector that leads into the chain</span><br><span class="line">List&lt;StreamOperator&lt;?&gt;&gt; allOps = new ArrayList&lt;&gt;(chainedConfigs.size());</span><br><span class="line">this.chainEntryPoint = createOutputCollector(</span><br><span class="line">    containingTask,</span><br><span class="line">    configuration,</span><br><span class="line">    chainedConfigs,</span><br><span class="line">    userCodeClassloader,</span><br><span class="line">    streamOutputMap,</span><br><span class="line">    allOps);</span><br><span class="line"></span><br><span class="line">if (operatorFactory != null) &#123;</span><br><span class="line">    WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; output = getChainEntryPoint();</span><br><span class="line">    headOperator = operatorFactory.createStreamOperator(containingTask, configuration, output);</span><br><span class="line">    headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_OUTPUT_WATERMARK, output.getWatermarkGauge());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    headOperator = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// add head operator to end of chain</span><br><span class="line">allOps.add(headOperator);</span><br><span class="line">this.allOperators = allOps.toArray(new StreamOperator&lt;?&gt;[allOps.size()]);</span><br></pre></td></tr></table></figure><p>首先会遍历算子链整体的所有出边，并调用 createStreamOutput() 方法创建对应的下游输出 RecordWriterOutput。然后就会调用 createOutputCollector() 方法创建物理的算子链，并返回 chainEntryPoint，这个方法比较重要，部分代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt; createOutputCollector(</span><br><span class="line">        StreamTask&lt;?, ?&gt; containingTask,</span><br><span class="line">        StreamConfig operatorConfig,</span><br><span class="line">        Map&lt;Integer, StreamConfig&gt; chainedConfigs,</span><br><span class="line">        ClassLoader userCodeClassloader,</span><br><span class="line">        Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputs,</span><br><span class="line">        List&lt;StreamOperator&lt;?&gt;&gt; allOperators) &#123;</span><br><span class="line">    List&lt;Tuple2&lt;WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt;, StreamEdge&gt;&gt; allOutputs = new ArrayList&lt;&gt;(4);</span><br><span class="line"></span><br><span class="line">    // create collectors for the network outputs</span><br><span class="line">    for (StreamEdge outputEdge : operatorConfig.getNonChainedOutputs(userCodeClassloader)) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        RecordWriterOutput&lt;T&gt; output = (RecordWriterOutput&lt;T&gt;) streamOutputs.get(outputEdge);</span><br><span class="line">        allOutputs.add(new Tuple2&lt;&gt;(output, outputEdge));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Create collectors for the chained outputs</span><br><span class="line">    for (StreamEdge outputEdge : operatorConfig.getChainedOutputs(userCodeClassloader)) &#123;</span><br><span class="line">        int outputId = outputEdge.getTargetId();</span><br><span class="line">        StreamConfig chainedOpConfig = chainedConfigs.get(outputId);</span><br><span class="line">        WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt; output = createChainedOperator(</span><br><span class="line">            containingTask,</span><br><span class="line">            chainedOpConfig,</span><br><span class="line">            chainedConfigs,</span><br><span class="line">            userCodeClassloader,</span><br><span class="line">            streamOutputs,</span><br><span class="line">            allOperators,</span><br><span class="line">            outputEdge.getOutputTag());</span><br><span class="line">        allOutputs.add(new Tuple2&lt;&gt;(output, outputEdge));</span><br><span class="line">    &#125;</span><br><span class="line">    // 以下略......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法从上一节提到的 StreamConfig 中分别取出出边和链接边的数据，并创建各自的 Output。出边的 Output 就是将数据发往算子链之外下游的 RecordWriterOutput，而链接边的输出要靠 createChainedOperator() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private &lt;IN, OUT&gt; WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; createChainedOperator(</span><br><span class="line">        StreamTask&lt;?, ?&gt; containingTask,</span><br><span class="line">        StreamConfig operatorConfig,</span><br><span class="line">        Map&lt;Integer, StreamConfig&gt; chainedConfigs,</span><br><span class="line">        ClassLoader userCodeClassloader,</span><br><span class="line">        Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputs,</span><br><span class="line">        List&lt;StreamOperator&lt;?&gt;&gt; allOperators,</span><br><span class="line">        OutputTag&lt;IN&gt; outputTag) &#123;</span><br><span class="line">    // create the output that the operator writes to first. this may recursively create more operators</span><br><span class="line">    WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; chainedOperatorOutput = createOutputCollector(</span><br><span class="line">        containingTask,</span><br><span class="line">        operatorConfig,</span><br><span class="line">        chainedConfigs,</span><br><span class="line">        userCodeClassloader,</span><br><span class="line">        streamOutputs,</span><br><span class="line">        allOperators);</span><br><span class="line"></span><br><span class="line">    // now create the operator and give it the output collector to write its output to</span><br><span class="line">    StreamOperatorFactory&lt;OUT&gt; chainedOperatorFactory = operatorConfig.getStreamOperatorFactory(userCodeClassloader);</span><br><span class="line">    OneInputStreamOperator&lt;IN, OUT&gt; chainedOperator = chainedOperatorFactory.createStreamOperator(</span><br><span class="line">            containingTask, operatorConfig, chainedOperatorOutput);</span><br><span class="line"></span><br><span class="line">    allOperators.add(chainedOperator);</span><br><span class="line"></span><br><span class="line">    WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; currentOperatorOutput;</span><br><span class="line">    if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">        currentOperatorOutput = new ChainingOutput&lt;&gt;(chainedOperator, this, outputTag);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        TypeSerializer&lt;IN&gt; inSerializer = operatorConfig.getTypeSerializerIn1(userCodeClassloader);</span><br><span class="line">        currentOperatorOutput = new CopyingChainingOutput&lt;&gt;(chainedOperator, inSerializer, outputTag, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // wrap watermark gauges since registered metrics must be unique</span><br><span class="line">    chainedOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, currentOperatorOutput.getWatermarkGauge()::getValue);</span><br><span class="line">    chainedOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_OUTPUT_WATERMARK, chainedOperatorOutput.getWatermarkGauge()::getValue);</span><br><span class="line">    return currentOperatorOutput;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一眼就可以看到，这个方法递归调用了上述 createOutputCollector() 方法，与逻辑计划阶段类似，通过不断延伸 Output 来产生 chainedOperator（即算子链中除了headOperator 之外的算子），并逆序返回，这也是 allOperators 数组中的算子顺序为倒序的原因。</p><p>chainedOperator 产生之后，将它们通过 ChainingOutput 连接起来，形成如下图所示的结构。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1gkmdb2gkhoj20u00fjwgy.jpg" alt="undefined"></p><p>最后来看看 ChainingOutput.collect() 方法是如何输出数据流的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void collect(StreamRecord&lt;T&gt; record) &#123;</span><br><span class="line">    if (this.outputTag != null) &#123;</span><br><span class="line">        // we are only responsible for emitting to the main input</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    pushToOperator(record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;X&gt; void collect(OutputTag&lt;X&gt; outputTag, StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">    if (this.outputTag == null || !this.outputTag.equals(outputTag)) &#123;</span><br><span class="line">        // we are only responsible for emitting to the side-output specified by our</span><br><span class="line">        // OutputTag.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    pushToOperator(record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // we know that the given outputTag matches our OutputTag so the record</span><br><span class="line">        // must be of the type that our operator expects.</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        StreamRecord&lt;T&gt; castRecord = (StreamRecord&lt;T&gt;) record;</span><br><span class="line">        numRecordsIn.inc();</span><br><span class="line">        operator.setKeyContextElement1(castRecord);</span><br><span class="line">        operator.processElement(castRecord);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e) &#123;</span><br><span class="line">        throw new ExceptionInChainedOperatorException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见是通过调用链接算子的 processElement() 方法，直接将数据推给下游处理了。也就是说，OperatorChain 完全可以看做一个由 headOperator 和 streamOutputs组成的单个算子，其内部的 chainedOperator 和 ChainingOutput 都像是被黑盒遮蔽，同时没有引入任何 overhead。</p><p>打通了算子链在执行层的逻辑，看官应该会明白 chainEntryPoint 的含义了。由于它位于递归返回的终点，所以它就是流入算子链的起始 Output，即上图中指向 headOperator 的 RecordWriterOutput。</p><h1 id="Flink-Stream-类型转换"><a href="#Flink-Stream-类型转换" class="headerlink" title="Flink Stream 类型转换"></a>Flink Stream 类型转换</h1><blockquote><p>1.Map[DataStream -&gt; DataStream]<br>调用用户定义的MapFunction对DataStream[T]数据进行处理，形成新的DataStream[T]，其中<strong>数据格式可能会发生变化</strong>,常用作对数据集内数据的清洗和转换。</p></blockquote><blockquote><p>2.FlatMap[DataStream -&gt; DataStream]<br>主要对输入的元素处理之后生成一个或者多个元素</p></blockquote><blockquote><p> 3.Filter[DataStream -&gt; DataStream]<br>该算子将按照条件对输入数据集进行筛选操作，将符合条件的数据集输出，将不符合条件的数据过滤掉</p></blockquote><blockquote><p>4.KeyBy[DataStream -&gt; KeyedStream]<br>该算子根据指定的key将输入的DataStream[T]数据格式转换为KeyedStream[T]，也就是在数据集中执行Partition操作，将相同的key值的数据放置在相同的分区中。简单来说，就是sql里面的group by</p></blockquote><blockquote><p>5.Reduce[KeyedStream -&gt; DataStream]<br>该算子和MapReduce的Reduce原理基本一致，主要目的是将输入的KeyedStream通过传入的用户自定义的ReduceFunction滚动的进行数据聚合处理，其中定义的ReduceFunction必须满足运算结合律和交换律</p></blockquote><blockquote><p>6.Union[DataStream -&gt; DataStream]<br>将两个或者多个输入的数据集合并成一个数据集，需要保证两个数据集的格式一致，输出的数据集的格式和输入的数据集格式保持一致</p></blockquote><blockquote><p>7.Connect, CoMap, CoFlatMap[DataStream -&gt; DataStream]<br>Connect算子主要是为了合并两种后者多种不同数据类型的数据集，合并后悔保留原来的数据集的数据类型。连接操作允许共享状态数据，也就是说在多个数据集之间可以操作和查看对方数据集的状态。</p></blockquote><blockquote><p>8.Split[DataStream -&gt; SplitStream]<br>Split是将一个DataStream数据集按照条件进行拆分，形成两个数据集的过程</p><p>split stream要打印，需要转换成DataStream，使用select方法</p></blockquote><h2 id="Flink-WindowStream-amp-AllWindowedStream"><a href="#Flink-WindowStream-amp-AllWindowedStream" class="headerlink" title="Flink WindowStream &amp; AllWindowedStream"></a>Flink WindowStream &amp; AllWindowedStream</h2><p><code>WindowedStream</code>代表了根据key分组，并且基于<code>WindowAssigner</code>切分窗口的数据流。所以<code>WindowedStream</code>都是从<code>KeyedStream</code>衍生而来的。</p><p>而在<u><code>WindowedStream</code>上进行任何transformation也都将转变回<code>DataStream</code>。</u></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataStream</span>[<span class="type">MyType</span>] stream = ...</span><br><span class="line"><span class="type">WindowedDataStream</span>[<span class="type">MyType</span>] windowed = stream</span><br><span class="line">        .keyBy(<span class="string">"userId"</span>)</span><br><span class="line">        .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">5</span>))) <span class="comment">// Last 5 seconds of data</span></span><br><span class="line"><span class="type">DataStream</span>[<span class="type">ResultType</span>] result = windowed.reduce(myReducer)</span><br></pre></td></tr></table></figure><p>在key分组的流上进行窗口切分是比较常用的场景，也能够很好地并行化（不同的key上的窗口聚合可以分配到不同的task去处理）。不过当我们需要在普通流上进行窗口操作时，就要用到 <code>AllWindowedStream</code>。<code>AllWindowedStream</code>是直接在<code>DataStream</code>上进行<code>windowAll(...)</code>操作。AllWindowedStream 的实现是基于 WindowedStream 的。Flink 不推荐使用<code>AllWindowedStream</code>，因为在普通流上进行窗口操作，就势必需要将所有分区的流都汇集到单个的Task中，而这个单个的Task很显然就会成为整个Job的瓶颈。</p><p>Flink windowStream 进行操作，要使用apply函数，传入windowFunction，不能在使用Process。</p><h2 id="join，coGroup，connect，union"><a href="#join，coGroup，connect，union" class="headerlink" title="join，coGroup，connect，union"></a>join，coGroup，connect，union</h2><p><strong>join</strong></p><p>1 可用于DataStream和DataSet。只能2个DataStream一起join，或者2个DataSet一起join</p><p>2 用于DataStream时返回是JoinedStreams ,用于DataSet时返回是JoinOperatorSets </p><p>3 用于DataStream时需要与窗口同时使用，语法是：join where equalTo window apply ，用于DataSet时的语法是：join where equalTo with （where是指定第一个输入的分区字段，equalTo是指定第二个输入的分区字段，这2个字段类型需要一致）</p><p>4 与SQL中的inner join同义，只输出2个实时窗口内或2个数据集合内能匹配上的笛卡尔积，不能匹配上的不输出。</p><p>5 apply方法中或with方法中均可以使用JoinFunction或 FlatJoinFunction处理匹配上的数据对（用于DataStream和DataSet时均可）</p><p>6 侧重对2个输入里的 数据对 进行处理，join方法的入参是单个数据</p><p>7 可以join2个类型不同的流或join2个类型不同的数据集（比如Tuple2&lt;String, Long&gt; join Tuple2&lt;Long,String&gt;）,但是匹配的key或field类型要一致，不然报错（比如where中的String与equalTo中的String匹配才行）</p><p><strong>coGroup</strong></p><p>1 可用于DataStream和DataSet。只能2个DataStream一起coGroup，或者2个DataSet一起coGroup</p><p>2 用于DataStream时返回是CoGroupedStreams，用于DataSet时返回是CoGroupOperatorSets</p><p>3 用于DataStream时需要与窗口同时使用，语法是：coGroup where equalTo window apply ，用于DataSet时的语法是：coGroup where equalTo with,</p><p>4 把2个实时窗口内或2个数据集合内key相同的数据分组同一个分区，key不能匹配上的数据（只在一个窗口或集合内存在的数据）也分组到另一个分区上。</p><p>5 apply方法中或with方法中均可以使用CoGroupFunction对数据分组（用于DataStream和DataSet时均可，无FlatCoGroupFunction）</p><p>6 侧重对2个输入的 集合 进行处理，coGroup方法的入参是Iterable类型</p><p>7 可以coGroup2个类型不同的流或coGroup2个类型不同的数据集（比如Tuple2&lt;String, Long&gt; join Tuple2&lt;Long,String&gt;）,但是匹配的key或field类型要一致，不然报错（比如where中的String与equalTo中的String匹配才行）</p><p><strong>connect</strong></p><p>1 只能用于DataStream,返回是ConnectedStreams。不能用于DataSet.</p><p>2 只能2个流一起connect（stream1.connect(stream2)）</p><p>3 connect后可以对2个流分别处理（使用CoMapFunction或CoFlatMapFunction）</p><p>4 可以connect2个类型不同的流（比如Tuple2&lt;String, Long&gt; connect Tuple2&lt;Long,String&gt;）</p><p><strong>union</strong></p><p>1 用于DataStream时,返回是Datastream;用于DataSet时,返回是DataSet;</p><p>2 可以多个流一起合并（stream1.union(stream2,stream3,stream4)），合并结果是一个新Datastream；只能2个DataSet一起合并，合并结果是一个新DataSet</p><p>3 无论是合并Datastream还是合并DataSet，都不去重，2个源的消息或记录都保存。</p><p>4 不可以union 2个类型不同的流或union 2个类型不同的数据集</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1glyqex8e4cj20fe06g0sz.jpg" alt="undefined"></p><p><a href="https://blog.csdn.net/u010002184/article/details/106800819" target="_blank" rel="noopener">更多细节</a></p><h1 id="Flink-TimerService-Timers"><a href="#Flink-TimerService-Timers" class="headerlink" title="Flink TimerService Timers"></a>Flink TimerService Timers</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong><code>currentProcessingTime()</code></strong>: Long 返回当前处理时间<br>**<code>currentWatermark()</code><strong>: Long 返回当前 watermark 的时间戳<br>**<code>registerProcessingTimeTimer(timestamp: Long)</code></strong>: Unit 会注册当前 key 的processing time 的定时器。当 processing time 到达定时时间时，触发 timer。<br>**<code>registerEventTimeTimer(timestamp: Long)</code><strong>: Unit 会注册当前 key 的 event time 定时器。当 水位线大于等于定时器注册的时间时，触发定时器执行回调函数。<br>**<code>deleteProcessingTimeTimer(timestamp: Long)</code></strong>: Unit 删除之前注册处理时间定时器。如果没有这个时间戳的定时器，则不执行。<br>**<code>deleteEventTimeTimer(timestamp: Long)</code>**: Unit 删除之前注册的事件时间定时器，如果没有此时间戳的定时器，则不执行。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gjy2m9uj9pj20zk0np77z.jpg&quot; alt=&quot;undefined&quot; style=&quot;zoom: 30%;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;Flink进阶的知识点和文章整理&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Apache Flink" scheme="http://yoursite.com/tags/Apache-Flink/"/>
    
  </entry>
  
  <entry>
    <title>Drools</title>
    <link href="http://yoursite.com/2020/10/13/Drools/"/>
    <id>http://yoursite.com/2020/10/13/Drools/</id>
    <published>2020-10-13T04:54:59.000Z</published>
    <updated>2021-01-28T09:45:30.956Z</updated>
    
    <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnlz4pysij20hc068wev.jpg" alt="WX20201013-124607@2x.png" style="zoom:67%;"><p>Drools的复杂度非常高，本文前面Base Component出处是网络上流传的黑马教学文档。</p><p>后面复杂的部分晚些我会补上。</p><p>笑，maybe</p><a id="more"></a> <h1 id="规则引擎Drools-base-component"><a href="#规则引擎Drools-base-component" class="headerlink" title="规则引擎Drools [base component]"></a>规则引擎Drools [base component]</h1><h2 id="1-什么是规则引擎"><a href="#1-什么是规则引擎" class="headerlink" title="1. 什么是规则引擎"></a>1. 什么是规则引擎</h2><p><strong>规则引擎</strong>，全称为<strong>业务规则管理系统</strong>，英文名为BRMS(即Business Rule Management System)。规则引擎的主要思想是将应用程序中的业务决策部分分离出来，并使用预定义的语义模块编写业务决策（业务规则），由用户或开发者在需要时进行配置、管理。</p><p>需要注意的是规则引擎并不是一个具体的技术框架，而是指的一类系统，即业务规则管理系统。目前市面上具体的规则引擎产品有：drools、VisualRules、iLog等。</p><p>规则引擎实现了将业务决策从应用程序代码中分离出来，接收数据输入，解释业务规则，并根据业务规则做出业务决策。规则引擎其实就是一个输入输出平台。</p><p>系统中引入规则引擎后，业务规则不再以程序代码的形式驻留在系统中，取而代之的是处理规则的规则引擎，业务规则存储在规则库中，完全独立于程序。业务人员可以像管理数据一样对业务规则进行管理，比如查询、添加、更新、统计、提交业务规则等。业务规则被加载到规则引擎中供应用系统调用。</p><h2 id="2-使用规则引擎的优势"><a href="#2-使用规则引擎的优势" class="headerlink" title="2. 使用规则引擎的优势"></a>2. 使用规则引擎的优势</h2><p>使用规则引擎的优势如下：</p><p>1、业务规则与系统代码分离，实现业务规则的集中管理</p><p>2、在不重启服务的情况下可随时对业务规则进行扩展和维护</p><p>3、可以动态修改业务规则，从而快速响应需求变更</p><p>4、规则引擎是相对独立的，只关心业务规则，使得业务分析人员也可以参与编辑、维护系统的业务规则</p><p>5、减少了硬编码业务规则的成本和风险</p><p>6、使用规则引擎提供的规则编辑工具，使复杂的业务规则实现变得的简单</p><h2 id="3-规则引擎应用场景"><a href="#3-规则引擎应用场景" class="headerlink" title="3. 规则引擎应用场景"></a>3. 规则引擎应用场景</h2><p>对于一些存在比较复杂的业务规则并且业务规则会频繁变动的系统比较适合使用规则引擎，如下：</p><p>1、风险控制系统—-风险贷款、风险评估</p><p>2、反欺诈项目—-银行贷款、征信验证</p><p>3、决策平台系统—-财务计算</p><p>4、促销平台系统—-满减、打折、加价购</p><h2 id="4-Drools介绍"><a href="#4-Drools介绍" class="headerlink" title="4. Drools介绍"></a>4. Drools介绍</h2><p>drools是一款由JBoss组织提供的基于Java语言开发的开源规则引擎，可以将复杂且多变的业务规则从硬编码中解放出来，以规则脚本的形式存放在文件或特定的存储介质中(例如存放在数据库中)，使得业务规则的变更不需要修改项目代码、重启服务器就可以在线上环境立即生效。</p><p>drools官网地址：<a href="https://drools.org/" target="_blank" rel="noopener">https://drools.org/</a></p><p>drools源码下载地址：<a href="https://github.com/kiegroup/drools" target="_blank" rel="noopener">https://github.com/kiegroup/drools</a></p><p>在项目中使用drools时，即可以单独使用也可以整合spring使用。如果单独使用只需要导入如下maven坐标即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>drools API开发步骤如下：<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmhstmhbj21fg0gw428.jpg" alt="5.png"></p><h2 id="5-Drools入门案例"><a href="#5-Drools入门案例" class="headerlink" title="5. Drools入门案例"></a>5. Drools入门案例</h2><p>本小节通过一个Drools入门案例来让大家初步了解Drools的使用方式、对Drools有一个整体概念。</p><h3 id="5-1-业务场景说明"><a href="#5-1-业务场景说明" class="headerlink" title="5.1 业务场景说明"></a>5.1 业务场景说明</h3><p>业务场景：消费者在图书商城购买图书，下单后需要在支付页面显示订单优惠后的价格。具体优惠规则如下：</p><table><thead><tr><th align="left">规则编号</th><th align="left">规则名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">规则一</td><td align="left">所购图书总价在100元以下的没有优惠</td></tr><tr><td align="left">2</td><td align="left">规则二</td><td align="left">所购图书总价在100到200元的优惠20元</td></tr><tr><td align="left">3</td><td align="left">规则三</td><td align="left">所购图书总价在200到300元的优惠50元</td></tr><tr><td align="left">4</td><td align="left">规则四</td><td align="left">所购图书总价在300元以上的优惠100元</td></tr></tbody></table><h3 id="5-2-开发实现"><a href="#5-2-开发实现" class="headerlink" title="5.2 开发实现"></a>5.2 开发实现</h3><p>第一步：创建maven工程drools_quickstart并导入drools相关maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：根据drools要求创建resources/META-INF/kmodule.xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kmodule</span> <span class="attr">xmlns</span>=<span class="string">"http://www.drools.org/xsd/kmodule"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        name:指定kbase的名称，可以任意，但是需要唯一</span></span><br><span class="line"><span class="comment">        packages:指定规则文件的目录，需要根据实际情况填写，否则无法加载到规则文件</span></span><br><span class="line"><span class="comment">        default:指定当前kbase是否为默认</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kbase</span> <span class="attr">name</span>=<span class="string">"myKbase1"</span> <span class="attr">packages</span>=<span class="string">"rules"</span> <span class="attr">default</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            name:指定ksession名称，可以任意，但是需要唯一</span></span><br><span class="line"><span class="comment">            default:指定当前session是否为默认</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ksession</span> <span class="attr">name</span>=<span class="string">"ksession-rule"</span> <span class="attr">default</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kbase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">kmodule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：上面配置文件的名称和位置都是固定写法，不能更改</p><p>第三步：创建实体类Order</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Double originalPrice;<span class="comment">//订单原始价格，即优惠前价格</span></span><br><span class="line">    <span class="keyword">private</span> Double realPrice;<span class="comment">//订单真实价格，即优惠后价格</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Order&#123;"</span> +</span><br><span class="line">                <span class="string">"originalPrice="</span> + originalPrice +</span><br><span class="line">                <span class="string">", realPrice="</span> + realPrice +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getOriginalPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOriginalPrice</span><span class="params">(Double originalPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.originalPrice = originalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getRealPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> realPrice;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRealPrice</span><span class="params">(Double realPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realPrice = realPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：创建规则文件resources/rules/bookDiscount.drl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图书优惠规则</span></span><br><span class="line"><span class="keyword">package</span> book.discount</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Order</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则一：所购图书总价在100元以下的没有优惠</span></span><br><span class="line">rule <span class="string">"book_discount_1"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(originalPrice &lt; <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice());</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则一：所购图书总价在100元以下的没有优惠"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则二：所购图书总价在100到200元的优惠20元</span></span><br><span class="line">rule <span class="string">"book_discount_2"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(originalPrice &lt; <span class="number">200</span> &amp;&amp; originalPrice &gt;= <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则二：所购图书总价在100到200元的优惠20元"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则三：所购图书总价在200到300元的优惠50元</span></span><br><span class="line">rule <span class="string">"book_discount_3"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(originalPrice &lt;= <span class="number">300</span> &amp;&amp; originalPrice &gt;= <span class="number">200</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则三：所购图书总价在200到300元的优惠50元"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则四：所购图书总价在300元以上的优惠100元</span></span><br><span class="line">rule <span class="string">"book_discount_4"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(originalPrice &gt;= <span class="number">300</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则四：所购图书总价在300元以上的优惠100元"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第五步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">    <span class="comment">//会话对象，用于和规则引擎交互</span></span><br><span class="line">    KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格</span></span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.setOriginalPrice(<span class="number">210</span>D);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配</span></span><br><span class="line">    kieSession.insert(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//激活规则引擎，如果规则匹配成功则执行规则</span></span><br><span class="line">    kieSession.fireAllRules();</span><br><span class="line">    <span class="comment">//关闭会话</span></span><br><span class="line">    kieSession.dispose();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"优惠前原始价格："</span> + order.getOriginalPrice() +</span><br><span class="line">                       <span class="string">"，优惠后价格："</span> + order.getRealPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的入门案例我们可以发现，使用drools规则引擎主要工作就是编写规则文件，在规则文件中定义跟业务相关的业务规则，例如本案例定义的就是图书优惠规则。规则定义好后就需要调用drools提供的API将数据提供给规则引擎进行规则模式匹配，规则引擎会执行匹配成功的规则并将计算的结果返回给我们。</p><p>可能大家会有疑问，就是我们虽然没有在代码中编写规则的判断逻辑，但是我们还是在规则文件中编写了业务规则，这跟在代码中编写规则有什么本质的区别呢？</p><p>我们前面其实已经提到，使用规则引擎时业务规则可以做到动态管理。业务人员可以像管理数据一样对业务规则进行管理，比如查询、添加、更新、统计、提交业务规则等。这样就可以做到在不重启服务的情况下调整业务规则。</p><h3 id="5-3-小结"><a href="#5-3-小结" class="headerlink" title="5.3 小结"></a>5.3 小结</h3><h4 id="5-3-1-规则引擎构成"><a href="#5-3-1-规则引擎构成" class="headerlink" title="5.3.1 规则引擎构成"></a>5.3.1 规则引擎构成</h4><p>drools规则引擎由以下三部分构成：</p><ul><li>Working Memory（工作内存）</li><li>Rule Base（规则库）</li><li>Inference Engine（推理引擎）</li></ul><p>其中Inference Engine（推理引擎）又包括：</p><ul><li>Pattern Matcher（匹配器）     具体匹配哪一个规则，由这个完成</li><li>Agenda(议程)</li><li>Execution Engine（执行引擎）</li></ul><p>如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmkpkhnuj20sj060gml.jpg" alt="8.png"></p><h4 id="5-3-2-相关概念说明"><a href="#5-3-2-相关概念说明" class="headerlink" title="5.3.2 相关概念说明"></a>5.3.2 相关概念说明</h4><p><strong>Working Memory</strong>：工作内存，drools规则引擎会从Working Memory中获取数据并和规则文件中定义的规则进行模式匹配，所以我们开发的应用程序只需要将我们的数据插入到Working Memory中即可，例如本案例中我们调用kieSession.insert(order)就是将order对象插入到了工作内存中。</p><p><strong>Fact</strong>：事实，是指在drools 规则应用当中，将一个<strong>普通的JavaBean插入到Working Memory后的对象</strong>就是Fact对象，例如本案例中的Order对象就属于Fact对象。Fact对象是我们的应用和规则引擎进行数据交互的桥梁或通道。</p><p><strong>Rule Base</strong>：规则库，我们在规则文件中定义的规则都会被加载到规则库中。</p><p><strong>Pattern Matcher</strong>：匹配器，将Rule Base中的所有规则与Working Memory中的Fact对象进行模式匹配，匹配成功的规则将被激活并放入Agenda中。</p><p><strong>Agenda</strong>：议程，用于存放通过匹配器进行模式匹配后被激活的规则。</p><p><strong>Execution Engine</strong>：执行引擎，执行Agenda中被激活的规则。</p><h4 id="5-3-3-规则引擎执行过程"><a href="#5-3-3-规则引擎执行过程" class="headerlink" title="5.3.3 规则引擎执行过程"></a>5.3.3 规则引擎执行过程</h4><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmlg1debj20sk097myn.jpg" alt="10.png"></p><h4 id="5-3-4-KIE介绍"><a href="#5-3-4-KIE介绍" class="headerlink" title="5.3.4 KIE介绍"></a>5.3.4 KIE介绍</h4><p>我们在操作Drools时经常使用的API以及它们之间的关系如下图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmlyh6xnj20o0065mxr.jpg" alt="9.png"></p><p>通过上面的核心API可以发现，大部分类名都是以Kie开头。<strong>Kie全称为Knowledge Is Everything</strong>，即”知识就是一切”的缩写，是Jboss一系列项目的总称。如下图所示，Kie的主要模块有OptaPlanner、Drools、UberFire、jBPM。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmm9g0pqj21f40ggmyt.jpg" alt="11.png"></p><p>通过上图可以看到，Drools是整个KIE项目中的一个组件，Drools中还包括一个Drools-WB的模块，它是一个可视化的规则编辑器。</p><h2 id="6-Drools基础语法"><a href="#6-Drools基础语法" class="headerlink" title="6. Drools基础语法"></a>6. Drools基础语法</h2><h3 id="6-1-规则文件构成"><a href="#6-1-规则文件构成" class="headerlink" title="6.1 规则文件构成"></a>6.1 规则文件构成</h3><p>在使用Drools时非常重要的一个工作就是编写规则文件，通常规则文件的后缀为.drl。</p><p><strong>drl是Drools Rule Language的缩写</strong>。在规则文件中编写具体的规则内容。</p><p>一套完整的规则文件内容构成如下：</p><table><thead><tr><th align="left">关键字</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">package</td><td align="left">包名，只限于逻辑上的管理，同一个包名下的查询或者函数可以直接调用</td></tr><tr><td align="left">import</td><td align="left">用于导入类或者静态方法</td></tr><tr><td align="left">global</td><td align="left">全局变量</td></tr><tr><td align="left">function</td><td align="left">自定义函数</td></tr><tr><td align="left">query</td><td align="left">查询</td></tr><tr><td align="left">rule end</td><td align="left">规则体</td></tr></tbody></table><p>Drools支持的规则文件，除了drl形式，还有Excel文件类型的。</p><h3 id="6-2-规则体语法结构"><a href="#6-2-规则体语法结构" class="headerlink" title="6.2 规则体语法结构"></a>6.2 规则体语法结构</h3><p>规则体是规则文件内容中的重要组成部分，是进行业务规则判断、处理业务结果的部分。</p><p>规则体语法结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">"ruleName"</span></span><br><span class="line">    attributes</span><br><span class="line">    when</span><br><span class="line">        LHS </span><br><span class="line">    then</span><br><span class="line">        RHS</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>rule</strong>：关键字，表示规则开始，参数为规则的唯一名称。</p><p><strong>attributes</strong>：规则属性，是rule与when之间的参数，为可选项。</p><p><strong>when</strong>：关键字，后面跟规则的条件部分。</p><p><strong>LHS</strong>(Left Hand Side)：是规则的条件部分的通用名称。它由零个或多个条件元素组成。<strong>如果LHS为空，则它将被视为始终为true的条件元素</strong>。  （左手边）</p><p><strong>then</strong>：关键字，后面跟规则的结果部分。</p><p><strong>RHS</strong>(Right Hand Side)：是规则的后果或行动部分的通用名称。 （右手边）</p><p><strong>end</strong>：关键字，表示一个规则结束。</p><h3 id="6-3-注释"><a href="#6-3-注释" class="headerlink" title="6.3 注释"></a>6.3 注释</h3><p>在drl形式的规则文件中使用注释和Java类中使用注释一致，分为单行注释和多行注释。</p><p>单行注释用”//“进行标记，多行注释以”/<em>“开始，以”</em>/“结束。如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//规则rule1的注释，这是一个单行注释</span><br><span class="line">rule &quot;rule1&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;rule1触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">规则rule2的注释，</span><br><span class="line">这是一个多行注释</span><br><span class="line">*/</span><br><span class="line">rule &quot;rule2&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;rule2触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="6-4-Pattern模式匹配"><a href="#6-4-Pattern模式匹配" class="headerlink" title="6.4 Pattern模式匹配"></a>6.4 Pattern模式匹配</h3><p>前面我们已经知道了Drools中的匹配器可以将Rule Base中的所有规则与Working Memory中的Fact对象进行模式匹配，那么我们就需要在规则体的LHS部分定义规则并进行模式匹配。LHS部分由一个或者多个条件组成，条件又称为pattern。</p><p><strong>pattern的语法结构为：绑定变量名:Object(Field约束)</strong></p><p>其中绑定变量名可以省略，通常绑定变量名的命名一般建议以$开始。如果定义了绑定变量名，就可以在规则体的RHS部分使用此绑定变量名来操作相应的Fact对象。Field约束部分是需要返回true或者false的0个或多个表达式。</p><p>例如我们的入门案例中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规则二：所购图书总价在100到200元的优惠20元</span></span><br><span class="line">rule <span class="string">"book_discount_2"</span></span><br><span class="line">    when</span><br><span class="line">        <span class="comment">//Order为类型约束，originalPrice为属性约束</span></span><br><span class="line">        $order:Order(originalPrice &lt; <span class="number">200</span> &amp;&amp; originalPrice &gt;= <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则二：所购图书总价在100到200元的优惠20元"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以知道，匹配的条件为：</p><p>1、工作内存中必须存在Order这种类型的Fact对象—–类型约束</p><p>2、Fact对象的originalPrice属性值必须小于200——属性约束</p><p>3、Fact对象的originalPrice属性值必须大于等于100——属性约束</p><p>以上条件必须同时满足当前规则才有可能被激活。</p><p><strong>绑定变量既可以用在对象上，也可以用在对象的属性上</strong>。例如上面的例子可以改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规则二：所购图书总价在100到200元的优惠20元</span></span><br><span class="line">rule <span class="string">"book_discount_2"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order($op:originalPrice &lt; <span class="number">200</span> &amp;&amp; originalPrice &gt;= <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"$op="</span> + $op);</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则二：所购图书总价在100到200元的优惠20元"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>LHS部分还可以定义多个pattern，多个pattern之间可以使用and或者or进行连接，也可以不写，默认连接为and。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规则二：所购图书总价在100到200元的优惠20元</span></span><br><span class="line">rule <span class="string">"book_discount_2"</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order($op:originalPrice &lt; <span class="number">200</span> &amp;&amp; originalPrice &gt;= <span class="number">100</span>) and</span><br><span class="line">        $customer:Customer(age &gt; <span class="number">20</span> &amp;&amp; gender==<span class="string">'male'</span>)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"$op="</span> + $op);</span><br><span class="line">        $order.setRealPrice($order.getOriginalPrice() - <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"成功匹配到规则二：所购图书总价在100到200元的优惠20元"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="6-5-比较操作符"><a href="#6-5-比较操作符" class="headerlink" title="6.5 比较操作符"></a>6.5 比较操作符</h3><p>Drools提供的比较操作符，如下表：</p><table><thead><tr><th align="left">符号</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于</td></tr><tr><td align="left">==</td><td align="left">等于</td></tr><tr><td align="left">!=</td><td align="left">不等于</td></tr><tr><td align="left">contains</td><td align="left">检查一个Fact对象的某个属性值是否包含一个指定的对象值</td></tr><tr><td align="left">not contains</td><td align="left">检查一个Fact对象的某个属性值是否不包含一个指定的对象值</td></tr><tr><td align="left">memberOf</td><td align="left">判断一个Fact对象的某个属性是否在一个或多个集合中</td></tr><tr><td align="left">not memberOf</td><td align="left">判断一个Fact对象的某个属性是否不在一个或多个集合中</td></tr><tr><td align="left">matches</td><td align="left">判断一个Fact对象的属性是否与提供的标准的Java正则表达式进行匹配</td></tr><tr><td align="left">not matches</td><td align="left">判断一个Fact对象的属性是否不与提供的标准的Java正则表达式进行匹配</td></tr></tbody></table><p>前6个比较操作符和Java中的完全相同，下面我们重点学习后6个比较操作符。</p><h4 id="6-5-1-语法"><a href="#6-5-1-语法" class="headerlink" title="6.5.1 语法"></a>6.5.1 语法</h4><ul><li><p><strong>contains | not contains语法结构</strong></p><p>Object(Field[Collection/Array] contains value)</p><p>Object(Field[Collection/Array] not contains value)</p></li><li><p><strong>memberOf | not memberOf语法结构</strong></p><p>Object(field memberOf value[Collection/Array])</p><p>Object(field not memberOf value[Collection/Array])</p></li><li><p><strong>matches | not matches语法结构</strong></p><p>Object(field matches “正则表达式”)</p><p>Object(field not matches “正则表达式”)</p></li></ul><p>contain是前面包含后面，memberOf是后面包含前面。</p><h4 id="6-5-2-操作步骤"><a href="#6-5-2-操作步骤" class="headerlink" title="6.5.2 操作步骤"></a>6.5.2 操作步骤</h4><p>第一步：创建实体类，用于测试比较操作符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实体类</span></span><br><span class="line"><span class="comment"> * 用于测试比较操作符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparisonOperatorEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String names;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNames</span><span class="params">(String names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：在/resources/rules下创建规则文件comparisonOperator.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package comparisonOperator</span><br><span class="line">import com.itheima.drools.entity.ComparisonOperatorEntity</span><br><span class="line">/*</span><br><span class="line"> 当前规则文件用于测试Drools提供的比较操作符</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//测试比较操作符contains</span><br><span class="line">rule &quot;rule_comparison_contains&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names contains &quot;张三&quot;)</span><br><span class="line">        ComparisonOperatorEntity(list contains names)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_contains触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//测试比较操作符not contains</span><br><span class="line">rule &quot;rule_comparison_notContains&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names not contains &quot;张三&quot;)</span><br><span class="line">        ComparisonOperatorEntity(list not contains names)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_notContains触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//测试比较操作符memberOf</span><br><span class="line">rule &quot;rule_comparison_memberOf&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names memberOf list)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_memberOf触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//测试比较操作符not memberOf</span><br><span class="line">rule &quot;rule_comparison_notMemberOf&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names not memberOf list)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_notMemberOf触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//测试比较操作符matches</span><br><span class="line">rule &quot;rule_comparison_matches&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names matches &quot;张.*&quot;)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_matches触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//测试比较操作符not matches</span><br><span class="line">rule &quot;rule_comparison_notMatches&quot;</span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names not matches &quot;张.*&quot;)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_comparison_notMatches触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第三步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试比较操作符</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">    KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">    ComparisonOperatorEntity comparisonOperatorEntity = <span class="keyword">new</span> ComparisonOperatorEntity();</span><br><span class="line">    comparisonOperatorEntity.setNames(<span class="string">"张三"</span>);</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"张三"</span>);</span><br><span class="line">    list.add(<span class="string">"李四"</span>);</span><br><span class="line">    comparisonOperatorEntity.setList(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配，如果规则匹配成功则执行规则</span></span><br><span class="line">    kieSession.insert(comparisonOperatorEntity);</span><br><span class="line"></span><br><span class="line">    kieSession.fireAllRules();</span><br><span class="line">    kieSession.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-执行指定规则"><a href="#6-6-执行指定规则" class="headerlink" title="6.6 执行指定规则"></a>6.6 执行指定规则</h3><p>通过前面的案例可以看到，我们在调用规则代码时，满足条件的规则都会被执行。那么如果我们只想执行其中的某个规则如何实现呢？</p><p>Drools给我们提供的方式是通过规则过滤器来实现执行指定规则。对于规则文件不用做任何修改，只需要修改Java代码即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">ComparisonOperatorEntity comparisonOperatorEntity = <span class="keyword">new</span> ComparisonOperatorEntity();</span><br><span class="line">comparisonOperatorEntity.setNames(<span class="string">"张三"</span>);</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"张三"</span>);</span><br><span class="line">list.add(<span class="string">"李四"</span>);</span><br><span class="line">comparisonOperatorEntity.setList(list);</span><br><span class="line">kieSession.insert(comparisonOperatorEntity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过规则过滤器实现只执行指定规则</span></span><br><span class="line">kieSession.fireAllRules(<span class="keyword">new</span> RuleNameEqualsAgendaFilter(<span class="string">"rule_comparison_memberOf"</span>));</span><br><span class="line"></span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><h3 id="6-7-关键字"><a href="#6-7-关键字" class="headerlink" title="6.7 关键字"></a>6.7 关键字</h3><p>Drools的关键字分为：硬关键字(Hard keywords)和软关键字(Soft keywords)。</p><p><strong>硬关键字是我们在规则文件中定义包名或者规则名时明确不能使用的，否则程序会报错</strong>。软关键字虽然可以使用，但是不建议使用。</p><p>硬关键字包括：true false null</p><p>软关键字包括：lock-on-active date-effective date-expires no-loop auto-focus activation-group agenda-group ruleflow-group entry-point duration package import dialect salience enabled attributes rule extend when then template query declare function global eval not in or and exists forall accumulate collect from action reverse result end over init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">rule true  //不可以</span><br><span class="line">rule &quot;true&quot;  //可以</span><br></pre></td></tr></table></figure><h3 id="6-8-Drools内置方法"><a href="#6-8-Drools内置方法" class="headerlink" title="6.8 Drools内置方法"></a>6.8 Drools内置方法</h3><p>规则文件的<code>RHS</code>部分的主要作用是通过<strong>插入，删除或修改工作内存中的Fact数据</strong>，来达到控制规则引擎执行的目的。Drools提供了一些方法可以用来操作工作内存中的数据，<strong>操作完成后规则引擎会重新进行相关规则的匹配，</strong>原来没有匹配成功的规则在我们修改数据完成后有可能就会匹配成功了。</p><p>创建如下实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-8-1-update方法"><a href="#6-8-1-update方法" class="headerlink" title="6.8.1 update方法"></a>6.8.1 update方法</h4><p><strong>update方法的作用是更新工作内存中的数据，并让相关的规则重新匹配。</strong>   （要避免死循环）</p><p>第一步：编写规则文件/resources/rules/student.drl，文件内容如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> student</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Student</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 当前规则文件用于测试Drools提供的内置方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age小于10岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(<span class="number">15</span>);</span><br><span class="line">        update($s);<span class="comment">//更新数据，导致相关的规则会重新匹配</span></span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age小于10岁触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age小于20岁同时大于10岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; <span class="number">20</span> &amp;&amp; age &gt; <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(<span class="number">25</span>);</span><br><span class="line">        update($s);<span class="comment">//更新数据，导致相关的规则会重新匹配</span></span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age小于20岁同时大于10岁触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age大于20岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &gt; <span class="number">20</span>)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age大于20岁触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student = new Student();</span><br><span class="line">student.setAge(5);</span><br><span class="line"></span><br><span class="line">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配，如果规则匹配成功则执行规则</span><br><span class="line">kieSession.insert(student);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台的输出可以看到规则文件中定义的三个规则都触发了。</p><p>在更新数据时需要注意防止发生死循环。</p><h4 id="6-8-2-insert方法"><a href="#6-8-2-insert方法" class="headerlink" title="6.8.2 insert方法"></a>6.8.2 insert方法</h4><p>insert方法的作用是向工作内存中插入数据，并让相关的规则重新匹配。</p><p>第一步：修改student.drl文件内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package student</span><br><span class="line">import com.itheima.drools.entity.Student</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 当前规则文件用于测试Drools提供的内置方法</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">rule &quot;rule_student_age等于10岁&quot;</span><br><span class="line">    when</span><br><span class="line">        $s:Student(age == 10)</span><br><span class="line">    then</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student.setAge(5);</span><br><span class="line">        insert(student);//插入数据，导致相关的规则会重新匹配</span><br><span class="line">        System.out.println(&quot;规则rule_student_age等于10岁触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_student_age小于10岁&quot;</span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; 10)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(15);</span><br><span class="line">        update($s);</span><br><span class="line">        System.out.println(&quot;规则rule_student_age小于10岁触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_student_age小于20岁同时大于10岁&quot;</span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; 20 &amp;&amp; age &gt; 10)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(25);</span><br><span class="line">        update($s);</span><br><span class="line">        System.out.println(&quot;规则rule_student_age小于20岁同时大于10岁触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_student_age大于20岁&quot;</span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &gt; 20)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_student_age大于20岁触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setAge(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配，如果规则匹配成功则执行规则</span></span><br><span class="line">kieSession.insert(student);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台输出可以发现，四个规则都触发了，这是因为首先进行规则匹配时只有第一个规则可以匹配成功，但是在第一个规则中向工作内存中插入了一个数据导致重新进行规则匹配，此时第二个规则可以匹配成功。在第二个规则中进行了数据修改导致第三个规则也可以匹配成功，以此类推最终四个规则都匹配成功并执行了。</p><h4 id="6-8-3-retract方法"><a href="#6-8-3-retract方法" class="headerlink" title="6.8.3 retract方法"></a>6.8.3 retract方法</h4><p><strong>retract方法的作用是删除工作内存中的数据，并让相关的规则重新匹配。</strong></p><p>第一步：修改student.drl文件内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> student</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Student</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 当前规则文件用于测试Drools提供的内置方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age等于10岁时删除数据"</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    salience：设置当前规则的执行优先级，数值越大越优先执行，默认值为0.</span></span><br><span class="line"><span class="comment">    因为当前规则的匹配条件和下面规则的匹配条件相同，为了保证先执行当前规则，需要设置优先级</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    salience <span class="number">100</span> </span><br><span class="line">    when</span><br><span class="line">        $s:Student(age == <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        retract($s);<span class="comment">//retract方法的作用是删除工作内存中的数据，并让相关的规则重新匹配。</span></span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age等于10岁时删除数据触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age等于10岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age == <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setAge(<span class="number">5</span>);</span><br><span class="line">        insert(student);</span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age等于10岁触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age小于10岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(<span class="number">15</span>);</span><br><span class="line">        update($s);</span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age小于10岁触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age小于20岁同时大于10岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &lt; <span class="number">20</span> &amp;&amp; age &gt; <span class="number">10</span>)</span><br><span class="line">    then</span><br><span class="line">        $s.setAge(<span class="number">25</span>);</span><br><span class="line">        update($s);</span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age小于20岁同时大于10岁触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_student_age大于20岁"</span></span><br><span class="line">    when</span><br><span class="line">        $s:Student(age &gt; <span class="number">20</span>)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_student_age大于20岁触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setAge(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配，如果规则匹配成功则执行规则</span></span><br><span class="line">kieSession.insert(student);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台输出可以发现，只有第一个规则触发了，因为在第一个规则中将工作内存中的数据删除了导致第二个规则并没有匹配成功。</p><h2 id="7-规则属性-attributes"><a href="#7-规则属性-attributes" class="headerlink" title="7. 规则属性  attributes"></a>7. 规则属性  attributes</h2><p>前面我们已经知道了规则体的构成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">"ruleName"</span></span><br><span class="line">    attributes</span><br><span class="line">    when</span><br><span class="line">        LHS</span><br><span class="line">    then</span><br><span class="line">        RHS</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>本章节就是针对规则体的<strong>attributes</strong>属性部分进行讲解。Drools中提供的属性如下表(部分属性)：</p><table><thead><tr><th align="left">属性名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">salience</td><td align="left">指定规则执行优先级</td></tr><tr><td align="left">dialect</td><td align="left">指定规则使用的语言类型，取值为java和mvel</td></tr><tr><td align="left">enabled</td><td align="left">指定规则是否启用</td></tr><tr><td align="left">date-effective</td><td align="left">指定规则生效时间</td></tr><tr><td align="left">date-expires</td><td align="left">指定规则失效时间</td></tr><tr><td align="left">activation-group</td><td align="left">激活分组，具有相同分组名称的规则只能有一个规则触发</td></tr><tr><td align="left">agenda-group</td><td align="left">议程分组，只有获取焦点的组中的规则才有可能触发</td></tr><tr><td align="left">timer</td><td align="left">定时器，指定规则触发的时间</td></tr><tr><td align="left">auto-focus</td><td align="left">自动获取焦点，一般结合agenda-group一起使用</td></tr><tr><td align="left">no-loop</td><td align="left">防止死循环</td></tr></tbody></table><h3 id="7-1-enabled属性"><a href="#7-1-enabled属性" class="headerlink" title="7.1 enabled属性"></a>7.1 enabled属性</h3><p>enabled属性对应的取值为true和false，默认值为true。</p><p>用于指定当前规则是否启用，如果设置的值为false则当前规则无论是否匹配成功都不会触发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">"rule_comparison_notMemberOf"</span></span><br><span class="line">    <span class="comment">//指定当前规则不可用，当前规则无论是否匹配成功都不会执行</span></span><br><span class="line">    enabled <span class="keyword">false</span></span><br><span class="line">    when</span><br><span class="line">        ComparisonOperatorEntity(names not memberOf list)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_comparison_notMemberOf触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="7-2-dialect属性"><a href="#7-2-dialect属性" class="headerlink" title="7.2 dialect属性"></a>7.2 dialect属性</h3><p>dialect属性用于指定当前规则使用的语言类型，取值为java和mvel，默认值为java。</p><p>注：mvel是一种基于java语法的表达式语言。</p><p>mvel像正则表达式一样，有直接支持集合、数组和字符串匹配的操作符。</p><p>mvel还提供了用来配置和构造字符串的模板语言。</p><p>mvel表达式内容包括属性表达式，布尔表达式，方法调用，变量赋值，函数定义等。</p><h3 id="7-3-salience属性"><a href="#7-3-salience属性" class="headerlink" title="7.3 salience属性"></a>7.3 salience属性</h3><p>salience属性用于指定规则的执行优先级，<strong>取值类型为Integer</strong>。<strong>数值越大越优先执行</strong>。每个规则都有一个默认的执行顺序，如果不设置salience属性，规则体的执行顺序为由上到下。</p><p>可以通过创建规则文件salience.drl来测试salience属性，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package test.salience</span><br><span class="line"></span><br><span class="line">rule &quot;rule_1&quot;</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_1触发&quot;);</span><br><span class="line">end</span><br><span class="line">    </span><br><span class="line">rule &quot;rule_2&quot;</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_2触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_3&quot;</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_3触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>通过控制台可以看到，由于以上三个规则没有设置salience属性，所以执行的顺序是按照规则文件中规则的顺序由上到下执行的。接下来我们修改一下文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package testsalience</span><br><span class="line"></span><br><span class="line">rule &quot;rule_1&quot;</span><br><span class="line">    salience 9</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_1触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_2&quot;</span><br><span class="line">    salience 10</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_2触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_3&quot;</span><br><span class="line">    salience 8</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_3触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>通过控制台可以看到，规则文件执行的顺序是按照我们设置的salience值由大到小顺序执行的。</p><p>建议在编写规则时使用salience属性明确指定执行优先级。</p><h3 id="7-4-no-loop属性"><a href="#7-4-no-loop属性" class="headerlink" title="7.4 no-loop属性"></a>7.4 no-loop属性</h3><p>no-loop属性用于防止死循环，当规则通过update之类的函数修改了Fact对象时，可能使当前规则再次被激活从而导致死循环。取值类型为Boolean，默认值为false。测试步骤如下：</p><p>第一步：编写规则文件/resource/rules/noloop.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package testnoloop</span><br><span class="line">import com.itheima.drools.entity.Student</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试no-loop属性</span><br><span class="line">*/</span><br><span class="line">rule &quot;rule_noloop&quot;</span><br><span class="line">    when</span><br><span class="line">        // no-loop true</span><br><span class="line">        $student:Student(age == 25)</span><br><span class="line">    then</span><br><span class="line">        update($student);//注意此处执行update会导致当前规则重新被激活</span><br><span class="line">        System.out.println(&quot;规则rule_noloop触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student = new Student();</span><br><span class="line">student.setAge(25);</span><br><span class="line"></span><br><span class="line">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配，如果规则匹配成功则执行规则</span><br><span class="line">kieSession.insert(student);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台可以看到，由于我们没有设置no-loop属性的值，所以发生了死循环。接下来设置no-loop的值为true再次测试则不会发生死循环。</p><h3 id="7-5-activation-group属性"><a href="#7-5-activation-group属性" class="headerlink" title="7.5 activation-group属性"></a>7.5 activation-group属性</h3><p>activation-group属性是指<strong>激活分组</strong>，取值为String类型。具有相同分组名称的规则只能有一个规则被触发。</p><p>第一步：编写规则文件/resources/rules/activationgroup.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package testactivationgroup</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试activation-group属性</span><br><span class="line">*/</span><br><span class="line">    </span><br><span class="line">rule &quot;rule_activationgroup_1&quot;</span><br><span class="line">    activation-group &quot;mygroup&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_activationgroup_1触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_activationgroup_2&quot;</span><br><span class="line">    activation-group &quot;mygroup&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_activationgroup_2触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台可以发现，上面的两个规则因为属于同一个分组，所以只有一个触发了。同一个分组中的多个规则如果都能够匹配成功，具体哪一个最终能够被触发可以通过salience属性确定。</p><h3 id="7-6-agenda-group属性"><a href="#7-6-agenda-group属性" class="headerlink" title="7.6 agenda-group属性"></a>7.6 agenda-group属性</h3><p>agenda-group属性为<strong>议程分组</strong>，属于另一种可控的规则执行方式。用户可以通过设置agenda-group来控制规则的执行，只有获取焦点的组中的规则才会被触发。</p><p>第一步：创建规则文件/resources/rules/agendagroup.drl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testagendagroup</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    此规则文件用于测试agenda-group属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">rule <span class="string">"rule_agendagroup_1"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_1"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_1触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_agendagroup_2"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_1"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_2触发"</span>);</span><br><span class="line">end</span><br><span class="line"><span class="comment">//========================================================</span></span><br><span class="line">rule <span class="string">"rule_agendagroup_3"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_2"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_3触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_agendagroup_4"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_2"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_4触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置焦点，对应agenda-group分组中的规则才可能被触发</span></span><br><span class="line">kieSession.getAgenda().getAgendaGroup(<span class="string">"myagendagroup_1"</span>).setFocus();</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台可以看到，只有获取焦点的分组中的规则才会触发。与activation-group不同的是，activation-group定义的分组中只能够有一个规则可以被触发，而agenda-group分组中的多个规则都可以被触发。</p><h3 id="7-7-auto-focus属性"><a href="#7-7-auto-focus属性" class="headerlink" title="7.7 auto-focus属性"></a>7.7 auto-focus属性</h3><p>auto-focus属性为<strong>自动获取焦点</strong>，取值类型为Boolean，默认值为false。一般结合agenda-group属性使用，当一个议程分组未获取焦点时，可以设置auto-focus属性来控制。</p><p>第一步：修改/resources/rules/agendagroup.drl文件内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testagendagroup</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_agendagroup_1"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_1"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_1触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_agendagroup_2"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_1"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_2触发"</span>);</span><br><span class="line">end</span><br><span class="line"><span class="comment">//========================================================</span></span><br><span class="line">rule <span class="string">"rule_agendagroup_3"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_2"</span></span><br><span class="line">    auto-focus <span class="keyword">true</span> <span class="comment">//自动获取焦点</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_3触发"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_agendagroup_4"</span></span><br><span class="line">    agenda-group <span class="string">"myagendagroup_2"</span></span><br><span class="line">    auto-focus <span class="keyword">true</span> <span class="comment">//自动获取焦点</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则rule_agendagroup_4触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>通过控制台可以看到，设置auto-focus属性为true的规则都触发了。</p><p>注意：同一个组，只要有个设置auto-focus true 其他的设置不设置都无所谓啦。都会起作用的。</p><h3 id="7-8-timer属性"><a href="#7-8-timer属性" class="headerlink" title="7.8 timer属性"></a>7.8 timer属性</h3><p>timer属性可以通过定时器的方式指定规则执行的时间，使用方式有两种：</p><p><strong>方式一</strong>：timer (int: <initial delay> <repeat interval>?)</repeat></initial></p><p>此种方式遵循java.util.Timer对象的使用方式，第一个参数表示几秒后执行，第二个参数表示每隔几秒执行一次，第二个参数为可选。</p><p><strong>方式二</strong>：timer(cron: <cron expression>) </cron></p><p>此种方式使用标准的unix cron表达式的使用方式来定义规则执行的时间。</p><p>第一步：创建规则文件/resources/rules/timer.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package testtimer</span><br><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.util.Date</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试timer属性</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">rule &quot;rule_timer_1&quot;</span><br><span class="line">    timer (5s 2s) //含义：5秒后触发，然后每隔2秒触发一次</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_timer_1触发，触发时间为：&quot; + </span><br><span class="line">                         new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_timer_2&quot;</span><br><span class="line">    timer (cron:0/1 * * * * ?) //含义：每隔1秒触发一次</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_timer_2触发，触发时间为：&quot; + </span><br><span class="line">                         new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line"><span class="keyword">final</span> KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动规则引擎进行规则匹配，直到调用halt方法才结束规则引擎</span></span><br><span class="line">        kieSession.fireUntilHalt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"><span class="comment">//结束规则引擎</span></span><br><span class="line">kieSession.halt();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>注意：单元测试的代码和以前的有所不同，因为我们规则文件中使用到了timer进行定时执行，需要程序能够持续一段时间才能够看到定时器触发的效果。</p><h3 id="7-9-date-effective属性"><a href="#7-9-date-effective属性" class="headerlink" title="7.9 date-effective属性"></a>7.9 date-effective属性</h3><p>date-effective属性<strong>用于指定规则的生效时间</strong>，即只有当前系统时间大于等于设置的时间或者日期规则才有可能触发。默认日期格式为：dd-MMM-yyyy。用户也可以自定义日期格式。</p><p>第一步：编写规则文件/resources/rules/dateeffective.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package testdateeffective</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试date-effective属性</span><br><span class="line">*/</span><br><span class="line">rule &quot;rule_dateeffective_1&quot;</span><br><span class="line">    date-effective &quot;2020-10-01 10:00&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_dateeffective_1触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置日期格式</span></span><br><span class="line">System.setProperty(<span class="string">"drools.dateformat"</span>,<span class="string">"yyyy-MM-dd HH:mm"</span>);</span><br><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>注意：上面的代码需要设置日期格式，否则我们在规则文件中写的日期格式和默认的日期格式不匹配程序会报错。</p><h3 id="7-10-date-expires属性"><a href="#7-10-date-expires属性" class="headerlink" title="7.10 date-expires属性"></a>7.10 date-expires属性</h3><p>date-expires属性用于指定规则的<strong>失效时间</strong>，即只有当前系统时间小于设置的时间或者日期规则才有可能触发。默认日期格式为：dd-MMM-yyyy。用户也可以自定义日期格式。</p><p>第一步：编写规则文件/resource/rules/dateexpires.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package testdateexpires</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试date-expires属性</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">rule &quot;rule_dateexpires_1&quot;</span><br><span class="line">    date-expires &quot;2019-10-01 10:00&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则rule_dateexpires_1触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置日期格式</span></span><br><span class="line">System.setProperty(<span class="string">"drools.dateformat"</span>,<span class="string">"yyyy-MM-dd HH:mm"</span>);</span><br><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><p>注意：上面的代码需要设置日期格式，否则我们在规则文件中写的日期格式和默认的日期格式不匹配程序会报错。</p><h2 id="8-Drools高级语法"><a href="#8-Drools高级语法" class="headerlink" title="8. Drools高级语法"></a>8. Drools高级语法</h2><p>前面章节我们已经知道了一套完整的规则文件内容构成如下：</p><table><thead><tr><th align="left">关键字</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">package</td><td align="left">包名，只限于逻辑上的管理，同一个包名下的查询或者函数可以直接调用</td></tr><tr><td align="left">import</td><td align="left">用于导入类或者静态方法</td></tr><tr><td align="left">global</td><td align="left">全局变量</td></tr><tr><td align="left">function</td><td align="left">自定义函数</td></tr><tr><td align="left">query</td><td align="left">查询</td></tr><tr><td align="left">rule end</td><td align="left">规则体</td></tr></tbody></table><p>本章节我们就来学习其中的几个关键字。</p><h3 id="8-1-global全局变量"><a href="#8-1-global全局变量" class="headerlink" title="8.1 global全局变量"></a>8.1 global全局变量</h3><p>global关键字用于在规则文件中<strong>定义全局变量</strong>，它可以让应用程序的对象在规则文件中能够被访问。可以用来为规则文件提供数据或服务。</p><p>语法结构为：<strong>global 对象类型 对象名称</strong></p><p>在使用global定义的全局变量时有两点需要注意：</p><p>1、如果对象类型为<strong>包装类型</strong>时，在一个规则中改变了global的值，那么<strong>只针对当前规则有效</strong>，对其他规则中的global不会有影响。可以理解为它是当前规则代码中的global副本，规则内部修改不会影响全局的使用。</p><p>2、如果对象类型为<strong>集合类型或JavaBean</strong>时，在一个规则中改变了global的值，对java代码和所有规则都有效。</p><p>下面我们通过代码进行验证：</p><p>第一步：创建UserService类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools.service;</span><br><span class="line"></span><br><span class="line">public class UserService &#123;</span><br><span class="line">    public void save()&#123;</span><br><span class="line">        System.out.println(&quot;UserService.save()...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：编写规则文件/resources/rules/global.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package testglobal</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试global全局变量</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">global java.lang.Integer count //定义一个包装类型的全局变量</span><br><span class="line">global com.itheima.drools.service.UserService userService //定义一个JavaBean类型的全局变量</span><br><span class="line">global java.util.List gList //定义一个集合类型的全局变量</span><br><span class="line"></span><br><span class="line">rule &quot;rule_global_1&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        count += 10; //全局变量计算，只对当前规则有效，其他规则不受影响</span><br><span class="line">        userService.save();//调用全局变量的方法</span><br><span class="line">        gList.add(&quot;itcast&quot;);//向集合类型的全局变量中添加元素，Java代码和所有规则都受影响</span><br><span class="line">        gList.add(&quot;itheima&quot;);</span><br><span class="line">        System.out.println(&quot;count=&quot; + count);</span><br><span class="line">        System.out.println(&quot;gList.size=&quot; + gList.size());</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_global_2&quot;</span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        userService.save();</span><br><span class="line">        System.out.println(&quot;count=&quot; + count);</span><br><span class="line">        System.out.println(&quot;gList.size=&quot; + gList.size());</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第三步：编写单元测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">//设置全局变量，名称和类型必须和规则文件中定义的全局变量名称对应</span><br><span class="line">kieSession.setGlobal(&quot;userService&quot;,new UserService());</span><br><span class="line">kieSession.setGlobal(&quot;count&quot;,5);</span><br><span class="line">List list = new ArrayList();//size为0</span><br><span class="line">kieSession.setGlobal(&quot;gList&quot;,list);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br><span class="line"></span><br><span class="line">//因为在规则中为全局变量添加了两个元素，所以现在的size为2</span><br><span class="line">System.out.println(list.size());</span><br></pre></td></tr></table></figure><p>注意：</p><p>后面的代码中定义了全局变量以后，前面的test都需要加，不然会出错。</p><h3 id="8-2-query查询"><a href="#8-2-query查询" class="headerlink" title="8.2 query查询"></a>8.2 query查询</h3><p>query查询提供了一种<strong>查询working memory中符合约束条件的Fact对象</strong>的简单方法。它仅包含规则文件中的LHS部分，不用指定“when”和“then”部分并且以end结束。具体语法结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query 查询的名称(可选参数)</span><br><span class="line">    LHS</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>具体操作步骤：</p><p>第一步：编写规则文件/resources/rules/query.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package testquery</span><br><span class="line">import com.itheima.drools.entity.Student</span><br><span class="line">/*</span><br><span class="line">    此规则文件用于测试query查询</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//不带参数的查询</span><br><span class="line">//当前query用于查询Working Memory中age&gt;10的Student对象</span><br><span class="line">query &quot;query_1&quot;</span><br><span class="line">    $student:Student(age &gt; 10)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//带有参数的查询</span><br><span class="line">//当前query用于查询Working Memory中age&gt;10同时name需要和传递的参数name相同的Student对象</span><br><span class="line">query &quot;query_2&quot;(String sname)</span><br><span class="line">    $student:Student(age &gt; 20 &amp;&amp; name == sname)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student1 = new Student();</span><br><span class="line">student1.setName(&quot;张三&quot;);</span><br><span class="line">student1.setAge(12);</span><br><span class="line"></span><br><span class="line">Student student2 = new Student();</span><br><span class="line">student2.setName(&quot;李四&quot;);</span><br><span class="line">student2.setAge(8);</span><br><span class="line"></span><br><span class="line">Student student3 = new Student();</span><br><span class="line">student3.setName(&quot;王五&quot;);</span><br><span class="line">student3.setAge(22);</span><br><span class="line"></span><br><span class="line">//将对象插入Working Memory中</span><br><span class="line">kieSession.insert(student1);</span><br><span class="line">kieSession.insert(student2);</span><br><span class="line">kieSession.insert(student3);</span><br><span class="line"></span><br><span class="line">//调用规则文件中的查询</span><br><span class="line">QueryResults results1 = kieSession.getQueryResults(&quot;query_1&quot;);</span><br><span class="line">int size = results1.size();</span><br><span class="line">System.out.println(&quot;size=&quot; + size);</span><br><span class="line">for (QueryResultsRow row : results1) &#123;</span><br><span class="line">    Student student = (Student) row.get(&quot;$student&quot;);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用规则文件中的查询</span><br><span class="line">QueryResults results2 = kieSession.getQueryResults(&quot;query_2&quot;,&quot;王五&quot;);</span><br><span class="line">size = results2.size();</span><br><span class="line">System.out.println(&quot;size=&quot; + size);</span><br><span class="line">for (QueryResultsRow row : results2) &#123;</span><br><span class="line">    Student student = (Student) row.get(&quot;$student&quot;);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br><span class="line">//kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><h3 id="8-3-function函数"><a href="#8-3-function函数" class="headerlink" title="8.3 function函数"></a>8.3 function函数</h3><p>function关键字用于在规则文件中定义函数，就相当于java类中的方法一样。可以在规则体中调用定义的函数。使用函数的好处是可以将业务逻辑集中放置在一个地方，根据需要可以对函数进行修改。</p><p>函数定义的语法结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 返回值类型 函数名(可选参数)&#123;</span><br><span class="line">    <span class="comment">//逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体操作步骤：</p><p>第一步：编写规则文件/resources/rules/function.drl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testfunction</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Student</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    此规则文件用于测试function函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数</span></span><br><span class="line"><span class="function">function String <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_function_1"</span></span><br><span class="line">    when</span><br><span class="line">        $student:Student(name != <span class="keyword">null</span>)</span><br><span class="line">    then</span><br><span class="line">        <span class="comment">//调用上面定义的函数</span></span><br><span class="line">        String ret = sayHello($student.getName());</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第二步：编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">KieSession kieSession = kieClasspathContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setName(<span class="string">"小明"</span>);</span><br><span class="line"></span><br><span class="line">kieSession.insert(student);</span><br><span class="line"></span><br><span class="line">kieSession.fireAllRules();</span><br><span class="line">kieSession.dispose();</span><br></pre></td></tr></table></figure><h3 id="8-4-LHS加强"><a href="#8-4-LHS加强" class="headerlink" title="8.4 LHS加强"></a>8.4 LHS加强</h3><p>前面我们已经知道了在规则体中的LHS部分是<strong>介于when和then之间的部分</strong>，主要用于模式匹配，只有匹配结果为true时，才会触发RHS部分的执行。本章节我们会针对LHS部分学习几个新的用法。</p><h4 id="8-4-1-复合值限制in-not-in"><a href="#8-4-1-复合值限制in-not-in" class="headerlink" title="8.4.1 复合值限制in/not in"></a>8.4.1 复合值限制in/not in</h4><p>复合值限制是指超过一种匹配值的限制条件，类似于SQL语句中的in关键字。Drools规则体中的LHS部分可以使用in或者not in进行复合值的匹配。具体语法结构如下：</p><p><strong>Object(field in (比较值1,比较值2…))</strong></p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$s:Student(name in (&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;))</span><br><span class="line">$s:Student(name not in (&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;))</span><br></pre></td></tr></table></figure><h4 id="8-4-2-条件元素eval"><a href="#8-4-2-条件元素eval" class="headerlink" title="8.4.2 条件元素eval"></a>8.4.2 条件元素eval</h4><p>eval用于规则体的LHS部分，并返回一个Boolean类型的值。语法结构如下：</p><p><strong>eval(表达式)</strong></p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval(true)</span><br><span class="line">eval(false)</span><br><span class="line">eval(1 == 1)</span><br></pre></td></tr></table></figure><h4 id="8-4-3-条件元素not"><a href="#8-4-3-条件元素not" class="headerlink" title="8.4.3 条件元素not"></a>8.4.3 条件元素not</h4><p>not用于判断Working Memory中是否存在某个Fact对象，如果不存在则返回true，如果存在则返回false。语法结构如下：</p><p><strong>not Object(可选属性约束)</strong></p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">not Student()</span><br><span class="line">not Student(age &lt; 10)</span><br></pre></td></tr></table></figure><h4 id="8-4-4-条件元素exists"><a href="#8-4-4-条件元素exists" class="headerlink" title="8.4.4 条件元素exists"></a>8.4.4 条件元素exists</h4><p>exists的作用与not相反，用于判断Working Memory中是否存在某个Fact对象，如果存在则返回true，不存在则返回false。语法结构如下：</p><p><strong>exists Object(可选属性约束)</strong></p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exists Student()</span><br><span class="line">exists Student(age &lt; 10 &amp;&amp; name != null)</span><br></pre></td></tr></table></figure><p>可能有人会有疑问，我们前面在LHS部分进行条件编写时并没有使用exists也可以达到判断Working Memory中是否存在某个符合条件的Fact元素的目的，那么我们使用exists还有什么意义？</p><p>两者的区别：当向Working Memory中加入多个满足条件的Fact对象时，使用了exists的规则执行一次，不使用exists的规则会执行多次。</p><p>例如：</p><p>规则文件(只有规则体)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rule &quot;使用exists的规则&quot;</span><br><span class="line">    when</span><br><span class="line">        exists Student()</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：使用exists的规则触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;没有使用exists的规则&quot;</span><br><span class="line">    when</span><br><span class="line">        Student()</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：没有使用exists的规则触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Java代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kieSession.insert(new Student());</span><br><span class="line">kieSession.insert(new Student());</span><br><span class="line">kieSession.fireAllRules();</span><br></pre></td></tr></table></figure><p>上面第一个规则只会执行一次，因为Working Memory中存在两个满足条件的Fact对象，第二个规则会执行两次。</p><h4 id="8-4-5-规则继承"><a href="#8-4-5-规则继承" class="headerlink" title="8.4.5 规则继承"></a>8.4.5 规则继承</h4><p>规则之间可以使用extends关键字进行规则条件部分的继承，类似于java类之间的继承。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rule &quot;rule_1&quot;</span><br><span class="line">    when</span><br><span class="line">        Student(age &gt; 10)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：rule_1触发&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;rule_2&quot; extends &quot;rule_1&quot; //继承上面的规则</span><br><span class="line">    when</span><br><span class="line">        /*</span><br><span class="line">        此处的条件虽然只写了一个，但是从上面的规则继承了一个条件，</span><br><span class="line">        所以当前规则存在两个条件，即Student(age &lt; 20)和Student(age &gt; 10)</span><br><span class="line">        */</span><br><span class="line">        Student(age &lt; 20) </span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：rule_2触发&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="8-5-RHS加强"><a href="#8-5-RHS加强" class="headerlink" title="8.5 RHS加强"></a>8.5 RHS加强</h3><p>RHS部分是规则体的重要组成部分，当LHS部分的条件匹配成功后，对应的RHS部分就会触发执行。一般在RHS部分中需要进行业务处理。</p><p>在RHS部分Drools为我们提供了一个内置对象，名称就是drools。本小节我们来介绍几个drools对象提供的方法。</p><h4 id="8-5-1-halt"><a href="#8-5-1-halt" class="headerlink" title="8.5.1 halt"></a>8.5.1 halt</h4><p>halt方法的作用是<strong>立即终止后面所有规则的执行</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testhalt</span><br><span class="line">rule <span class="string">"rule_halt_1"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则：rule_halt_1触发"</span>);</span><br><span class="line">        drools.halt();<span class="comment">//立即终止后面所有规则执行</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前规则并不会触发，因为上面的规则调用了halt方法导致后面所有规则都不会执行</span></span><br><span class="line">rule <span class="string">"rule_halt_2"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则：rule_halt_2触发"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="8-5-2-getWorkingMemory"><a href="#8-5-2-getWorkingMemory" class="headerlink" title="8.5.2 getWorkingMemory"></a>8.5.2 getWorkingMemory</h4><p>getWorkingMemory方法的作用是返回工作内存对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testgetWorkingMemory</span><br><span class="line">rule <span class="string">"rule_getWorkingMemory"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(drools.getWorkingMemory());</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="8-5-3-getRule"><a href="#8-5-3-getRule" class="headerlink" title="8.5.3 getRule"></a>8.5.3 getRule</h4><p>getRule方法的作用是返回规则对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testgetRule</span><br><span class="line">rule <span class="string">"rule_getRule"</span></span><br><span class="line">    when</span><br><span class="line">    then</span><br><span class="line">        System.out.println(drools.getRule());</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="8-6-规则文件编码规范（重要）"><a href="#8-6-规则文件编码规范（重要）" class="headerlink" title="8.6 规则文件编码规范（重要）"></a>8.6 规则文件编码规范（重要）</h3><p>我们在进行drl类型的规则文件编写时尽量遵循如下规范：</p><ul><li>所有的规则文件(.drl)应统一放在一个规定的文件夹中，如：/rules文件夹</li><li>书写的每个规则应尽量加上注释。注释要清晰明了，言简意赅</li><li>同一类型的对象尽量放在一个规则文件中，如所有Student类型的对象尽量放在一个规则文件中</li><li>规则结果部分(RHS)尽量不要有条件语句，如if(…)，尽量不要有复杂的逻辑和深层次的嵌套语句</li><li>每个规则最好都加上salience属性，明确执行顺序</li><li>Drools默认dialect为”Java”，尽量避免使用dialect “mvel”</li></ul><h2 id="9-Spring整合Drools"><a href="#9-Spring整合Drools" class="headerlink" title="9. Spring整合Drools"></a>9. Spring整合Drools</h2><h3 id="9-1-Spring简单整合Drools"><a href="#9-1-Spring简单整合Drools" class="headerlink" title="9.1 Spring简单整合Drools"></a>9.1 Spring简单整合Drools</h3><p>在项目中使用Drools时往往会跟Spring整合来使用。具体整合步骤如下：</p><p>第一步：创建maven工程drools_spring并配置pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools_spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">drools.version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">drools.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--注意：此处必须排除传递过来的依赖，否则会跟我们自己导入的Spring jar包产生冲突--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：创建规则目录/resources/rules，中rules目录中创建规则文件helloworld.drl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld</span><br><span class="line"></span><br><span class="line">rule <span class="string">"rule_helloworld"</span></span><br><span class="line">    when</span><br><span class="line">        eval(<span class="keyword">true</span>)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">"规则：rule_helloworld触发..."</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第三步：创建Spring配置文件/resources/spring.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:kie</span>=<span class="string">"http://drools.org/schema/kie-spring"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://drools.org/schema/kie-spring</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://drools.org/schema/kie-spring.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kie:kmodule</span> <span class="attr">id</span>=<span class="string">"kmodule"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">kie:kbase</span> <span class="attr">name</span>=<span class="string">"kbase"</span> <span class="attr">packages</span>=<span class="string">"rules"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">kie:ksession</span> <span class="attr">name</span>=<span class="string">"ksession"</span>&gt;</span><span class="tag">&lt;/<span class="name">kie:ksession</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">kie:kbase</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kie:kmodule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.kie.spring.annotations.KModuleAnnotationPostProcessor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第四步：编写单元测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.test;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.kie.api.KieBase;</span><br><span class="line">import org.kie.api.cdi.KBase;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &quot;classpath:spring.xml&quot;)</span><br><span class="line">public class DroolsSpringTest &#123;</span><br><span class="line">    @KBase(&quot;kbase&quot;)</span><br><span class="line">    private KieBase kieBase;//注入KieBase对象</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        KieSession kieSession = kieBase.newKieSession();</span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        kieSession.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-Spring整合Drools-web"><a href="#9-2-Spring整合Drools-web" class="headerlink" title="9.2 Spring整合Drools+web"></a>9.2 Spring整合Drools+web</h3><p>本小节我们来进行Drools和Spring Web的整合。具体操作步骤如下：</p><p>第一步：创建maven的war工程drools_springweb并在pom.xml文件中导入相关maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools_springweb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">drools.version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">drools.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--注意：此处必须排除传递过来的依赖，否则会跟我们自己导入的Spring jar包产生冲突--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   自己加的版本号，不加的话，会报错</span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 指定端口 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 请求路径 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：配置web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE web-app PUBLIC</span></span><br><span class="line"><span class="meta"> "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"><span class="meta"> "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三步：创建/resources/springmvc.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:kie</span>=<span class="string">"http://drools.org/schema/kie-spring"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://drools.org/schema/kie-spring</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://drools.org/schema/kie-spring.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">kie:kmodule</span> <span class="attr">id</span>=<span class="string">"kmodule"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">kie:kbase</span> <span class="attr">name</span>=<span class="string">"kbase"</span> <span class="attr">packages</span>=<span class="string">"rules"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">kie:ksession</span> <span class="attr">name</span>=<span class="string">"ksession"</span>&gt;</span><span class="tag">&lt;/<span class="name">kie:ksession</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">kie:kbase</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kie:kmodule</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.kie.spring.annotations.KModuleAnnotationPostProcessor"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring批量扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.itheima"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--springMVC注解驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第四步：创建规则文件/resources/rules/helloworld.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package helloworld</span><br><span class="line"></span><br><span class="line">rule &quot;rule_helloworld&quot;</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：rule_helloworld触发...&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第五步：创建RuleService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.cdi.KBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@KBase</span>(<span class="string">"kbase"</span>)</span><br><span class="line">    <span class="keyword">private</span> KieBase kieBase;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        KieSession kieSession = kieBase.newKieSession();</span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        kieSession.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步：创建HelloController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.service.RuleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RuleService ruleService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/rule"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ruleService.rule();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-Spring-Boot整合Drools"><a href="#9-3-Spring-Boot整合Drools" class="headerlink" title="9.3 Spring Boot整合Drools"></a>9.3 Spring Boot整合Drools</h3><p>目前在企业开发中Spring Boot已经成为主流，本小节我们来进行Spring Boot整合Drools。具体操作步骤：</p><p>第一步：创建maven工程drools_springboot并配置pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools_springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--drools规则引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-templates<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：创建/resources/application.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: drools_springboot</span><br></pre></td></tr></table></figure><p>第三步：创建规则文件/resources/rules/helloworld.drl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package helloworld</span><br><span class="line">rule &quot;rule_helloworld&quot;</span><br><span class="line">    when</span><br><span class="line">        eval(true)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;规则：rule_helloworld触发...&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>第四步：编写配置类DroolsConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.config;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieServices;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieBuilder;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieFileSystem;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieRepository;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieContainer;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.kie.internal.io.ResourceFactory;</span><br><span class="line"><span class="keyword">import</span> org.kie.spring.KModuleBeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则引擎配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroolsConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定规则文件存放的目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RULES_PATH = <span class="string">"rules/"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieFileSystem <span class="title">kieFileSystem</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();</span><br><span class="line">        ResourcePatternResolver resourcePatternResolver = </span><br><span class="line">            <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">        Resource[] files = </span><br><span class="line">            resourcePatternResolver.getResources(<span class="string">"classpath*:"</span> + RULES_PATH + <span class="string">"*.*"</span>);</span><br><span class="line">        String path = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Resource file : files) &#123;</span><br><span class="line">            path = RULES_PATH + file.getFilename();</span><br><span class="line">            kieFileSystem.write(ResourceFactory.newClassPathResource(path, <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kieFileSystem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieContainer <span class="title">kieContainer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KieRepository kieRepository = kieServices.getRepository();</span><br><span class="line">        kieRepository.addKieModule(kieRepository::getDefaultReleaseId);</span><br><span class="line">        KieBuilder kieBuilder = kieServices.newKieBuilder(kieFileSystem());</span><br><span class="line">        kieBuilder.buildAll();</span><br><span class="line">        <span class="keyword">return</span> kieServices.newKieContainer(kieRepository.getDefaultReleaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieBase <span class="title">kieBase</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kieContainer().getKieBase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KModuleBeanFactoryPostProcessor <span class="title">kiePostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KModuleBeanFactoryPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步：创建RuleService类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools.service;</span><br><span class="line"></span><br><span class="line">import org.kie.api.KieBase;</span><br><span class="line">import org.kie.api.runtime.KieSession;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RuleService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private KieBase kieBase;</span><br><span class="line">    public void rule()&#123;</span><br><span class="line">        KieSession kieSession = kieBase.newKieSession();</span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        kieSession.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步：创建HelloController类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.drools.service.RuleService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RuleService ruleService;</span><br><span class="line">    @RequestMapping(&quot;/rule&quot;)</span><br><span class="line">    public String rule()&#123;</span><br><span class="line">        ruleService.rule();</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第七步：创建启动类DroolsApplication</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class DroolsApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DroolsApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第八步：启动服务，访问<a href="http://localhost:8080/hello/rule" target="_blank" rel="noopener">http://localhost:8080/hello/rule</a></p><h2 id="10-WorkBench"><a href="#10-WorkBench" class="headerlink" title="10. WorkBench"></a>10. WorkBench</h2><h3 id="10-1-WorkBench简介"><a href="#10-1-WorkBench简介" class="headerlink" title="10.1 WorkBench简介"></a>10.1 WorkBench简介</h3><p>WorkBench是KIE组件中的元素，也称为KIE-WB，是Drools-WB与JBPM-WB的结合体。它是一个<strong>可视化的规则编辑器</strong>。WorkBench其实就是一个war包，安装到tomcat中就可以运行。使用WorkBench可以在浏览器中创建数据对象、创建规则文件、创建测试场景并将规则部署到maven仓库供其他应用使用。</p><p>下载地址：<a href="https://download.jboss.org/drools/release/7.6.0.Final/kie-drools-wb-7.6.0.Final-tomcat8.war" target="_blank" rel="noopener">https://download.jboss.org/drools/release/7.6.0.Final/kie-drools-wb-7.6.0.Final-tomcat8.war</a></p><p>注意：下载的war包需要安装到tomcat8中。</p><h3 id="10-2-安装方式"><a href="#10-2-安装方式" class="headerlink" title="10.2 安装方式"></a>10.2 安装方式</h3><p>软件安装时经常会涉及到软件版本兼容性的问题，所以需要明确各个软件的使用版本。</p><p>本课程使用的软件环境如下：</p><ul><li>操作系统：Windows 10 64位</li><li>JDK版本：1.8</li><li>maven版本：3.5.4</li><li>Tomcat版本：8.5</li></ul><p>具体安装步骤：</p><p>第一步：配置Tomcat的环境变量CATALINA_HOME，对应的值为Tomcat安装目录</p><p>第二步：在Tomcat的bin目录下创建setenv.bat文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CATALINA_OPTS=&quot;-Xmx512M \</span><br><span class="line">    -Djava.security.auth.login.config=$CATALINA_HOME/webapps/kie-drools-wb/WEB-INF/classes/login.config \</span><br><span class="line">    -Dorg.jboss.logging.provider=jdk&quot;</span><br></pre></td></tr></table></figure><p>第三步：将下载的WorkBench的war包改名为kie-drools-wb.war并复制到Tomcat的webapps目录下</p><p>第四步：修改Tomcat下conf/tomcat-users.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tomcat-users</span> <span class="attr">xmlns</span>=<span class="string">"http://tomcat.apache.org/xml"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://tomcat.apache.org/xml tomcat-users.xsd"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--定义admin角色--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--定义一个用户，用户名为kie，密码为kie，对应的角色为admin角色--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"kie"</span> <span class="attr">password</span>=<span class="string">"kie"</span> <span class="attr">roles</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第五步：下载以下三个jar包并复制到Tomcat的lib目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kie-tomcat-integration-7.10.0.Final.jar</span><br><span class="line">javax.security.jacc-api-1.5.jar</span><br><span class="line">slf4j-api-1.7.25.jar</span><br></pre></td></tr></table></figure><p>第六步：修改Tomcat的conf/server.xml文件，添加Valve标签，内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.kie.integration.tomcat.JACCValve"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>第七步：启动Tomcat并访问<a href="http://localhost:8080/kie-drools-wb%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0WorkBench%E7%9A%84%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E3%80%82%E4%BD%BF%E7%94%A8%E5%89%8D%E9%9D%A2%E5%9C%A8tomcat-users.xml%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95%E5%8D%B3%E5%8F%AF" target="_blank" rel="noopener">http://localhost:8080/kie-drools-wb，可以看到WorkBench的登录页面。使用前面在tomcat-users.xml文件中定义的用户进行登录即可</a></p><p>注意：这里我自己的是80端口，<a href="http://localhost/kie-drools-wb" target="_blank" rel="noopener">http://localhost/kie-drools-wb</a></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmwxxjf3j20zs0hcgot.jpg" alt="12.png"></p><p>登录成功后进入系统首页：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmx7fhlej211x0gagsu.jpg" alt="13.png"></p><h3 id="10-3-使用方式"><a href="#10-3-使用方式" class="headerlink" title="10.3 使用方式"></a>10.3 使用方式</h3><h4 id="10-3-1-创建空间、项目"><a href="#10-3-1-创建空间、项目" class="headerlink" title="10.3.1 创建空间、项目"></a>10.3.1 创建空间、项目</h4><p>WorkBench中存在空间和项目的概念。我们在使用WorkBench时首先需要创建空间（Space），在空间中创建项目，在项目中创建数据对象、规则文件等。</p><ul><li><p>创建空间</p><p>第一步：登录WorkBench后进行系统首页，点击首页中的Design区域进入项目列表页面：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmxmiw8sj211o0dvwf8.jpg" alt="14.png"></p><p>如果是第一次登录还没有创建项目则无法看到项目</p><p>第二步：点击左上角Spaces导航链接进入空间列表页面</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmycnfllj211w0b40ta.jpg" alt="15.png"></p><p>第三步：点击右上角Add Space按钮弹出创建添加空间窗口</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmyor1bhj211x0d4js4.jpg" alt="16.png"></p><p>录入空间名称，点击Save按钮则完成空间的创建，如下图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnmyzidd0j211y0arjrz.jpg" alt="17.png"></p><p>创建项目</p><p>前面已经提到，我们在WorkBench中需要先创建空间，在空间中才能创建项目。上面我们已经创建了一个空间itheima，现在需要住此空间中创建项目。</p><p>第一步：点击itheima空间，进入此空间</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn09r42gj211y0gkmy1.jpg" alt="18.png"></p><p>可以看到当前空间中还没有项目</p><p>第二步：点击Add Project按钮弹出添加项目窗口</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn0wnfabj211w0fuab3.jpg" alt="19.png"></p><p>第三步：在添加项目窗口中录入项目名称（例如项目名称为pro1），点击Add按钮完成操作</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn156plbj211x0g9wfi.jpg" alt="20.png"></p><p>可以看到在完成项目创建后，系统直接跳转到了项目页面。要查看当前itheima空间中的所有项目，可以点击左上角itheima链接：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn1mtjqij211w0chdge.jpg" alt="21.png"></p></li></ul><h4 id="10-3-2-创建数据对象"><a href="#10-3-2-创建数据对象" class="headerlink" title="10.3.2 创建数据对象"></a>10.3.2 创建数据对象</h4><p>  数据对象其实就是JavaBean，一般都是在drl规则文件中使用进行规则匹配。</p><p>  第一步：在itheima空间中点击pro1项目，进入此项目页面</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn6bgiglj211v0i00tt.jpg" alt="22.png"></p><p>  第二步：点击Create New Asset按钮选择“数据对象”</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn6p6cs3j211y0hv0u1.jpg" alt="23.png"></p><p>  第三步：在弹出的创建数据对象窗口中输入数据对象的名称，点击确定按钮完成操作</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn73brn6j211y0ex0tn.jpg" alt="24.png"></p><p>  操作完成后可以看到如下：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn7btncuj211y0f8ab8.jpg" alt="25.png"></p><p>  第四步：点击“添加字段”按钮弹出新建字段窗口</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn7r6f6nj211y0dijsk.jpg" alt="26.png"></p><p>  第五步：在新建字段窗口中录入字段Id（其实就是属性名），选择类型，点击创建按钮完成操作</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn83m32qj211y0f0gmp.jpg" alt="27.png"></p><p>  完成操作后可以看到刚才创建的字段：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn8d62p5j211y0ex75c.jpg" alt="28.png"></p><p>  可以点击添加字段按钮继续创建其他字段：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn8mu2z2j211y0ecq43.jpg" alt="29.png"></p><p>  注意添加完字段后需要点击右上角保存按钮完成保存操作：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnn9wzsg5j211y0fimyb.jpg" alt="32.png"></p><p>  点击源代码按钮可以查看刚才创建的Person对象源码：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnabnhwaj211y0hd3zx.jpg" alt="30.png"></p><p>  点击左上角pro1项目链接，可以看到当前pro1项目中已经创建的各种类型的对象：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnakrvfaj211w0ea754.jpg" alt="31.png"></p><h4 id="10-3-3-创建DRL规则文件"><a href="#10-3-3-创建DRL规则文件" class="headerlink" title="10.3.3 创建DRL规则文件"></a>10.3.3 创建DRL规则文件</h4><p>  第一步：在pro1项目页面点击右上角Create New Asset按钮，选择“DRL文件”，弹出创建DRL文件窗口</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnauejywj211v0f1gms.jpg" alt="33.png"></p><p>  第二步：在添加DRL文件窗口录入DRL文件名称，点击确定按钮完成操作</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnb29fhgj211y0fowfh.jpg" alt="34.png"></p><p>  第三步：上面点击确定按钮完成创建DRL文件后，页面会跳转到编辑DRL文件页面</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnbba37dj211y0fmt9k.jpg" alt="35.png"></p><p>  可以看到DRL规则文件页面分为两个部分：左侧为项目浏览视图、右侧为编辑区域，需要注意的是左侧默认展示的不是项目浏览视图，需要点击上面设置按钮，选择“资料库视图”和“显示为文件夹”，如下图所示：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnbkqzyfj211y0gp75o.jpg" alt="36.png"></p><p>  第四步：在编辑DRL文件页面右侧区域进行DRL文件的编写，点击右上角保存按钮完成保存操作，点击检验按钮进行规则文件语法检查</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnby5iv8j211y0erjsq.jpg" alt="37.png"></p><p>  点击左上角pro1项目回到项目页面，可以看到此项目下已经存在两个对象，即person.drl规则文件和Person类：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnc8i1g9j211y0d60th.jpg" alt="38.png"></p><h4 id="10-3-4-创建测试场景"><a href="#10-3-4-创建测试场景" class="headerlink" title="10.3.4 创建测试场景"></a>10.3.4 创建测试场景</h4><p>  前面我们已经创建了Person数据对象和person规则文件，现在我们需要测试一下规则文件中的规则，可以通过创建测试场景来进行测试。</p><p>  第一步：在项目页面点击Create New Asset按钮选择“测试场景”，弹出创建测试场景窗口</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnncj3vq1j211y0eoab4.jpg" alt="39.png"></p><p>  第二步：在弹出的创建测试场景窗口中录入测试场景的名称，点击确定完成操作</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnncr39vzj211y0cedgt.jpg" alt="40.png"></p><p>  完成测试场景的创建后，页面会跳转到测试场景编辑页面，如下图：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnncy249rj211y0br75b.jpg" alt="41.png"></p><p>  第三步：因为我们编写的规则文件中需要从工作内存中获取Person对象进行规则匹配，所以在测试场景中需要准备Person对象给工作内存，点击“GIVEN”按钮弹出新建数据录入窗口，选择Person类，输入框中输入事实名称（名称任意），如下图</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnd648wpj211y0dawfr.jpg" alt="42.png"></p><p>  第四步：录入事实名称后点击后面的添加按钮，可以看到Person对象已经添加成功</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnndll1vtj211y0b8gmp.jpg" alt="43.png"></p><p>  第五步：我们给工作内存提供的Person对象还需要设置age属性的值，点击“添加字段”按钮弹出窗口，选择age属性</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnndutq8mj211y0dsjsp.jpg" alt="44.png"></p><p>  点击确定按钮后可以看到字段已经添加成功：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnne5h6csj211x0czgms.jpg" alt="45.png"></p><p>  第六步：点击age属性后面的编辑按钮，弹出字段值窗口</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnedo5kkj211y0dxabk.jpg" alt="image-20200113154817582.png"></p><p>  第七步：在弹出的窗口中点击字面值按钮，重新回到测试场景页面，可以看到age后面出现输入框，可以为age属性设置值</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnenrrcdj211y0cn0u4.jpg" alt="image-20200113155136957.png"></p><p>  设置好age属性的值后点击保存按钮保存测试场景</p><p>  第八步：点击右上角“运行测试场景”按钮进行测试</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnezucrjj211u0f2myp.jpg" alt="image-20200113155332666.png"></p><p>  测试成功后可以查看WorkBench部署的Tomcat控制台：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnfa8byuj20qn09ujrr.jpg" alt="image-20200113155819517.png"></p><h4 id="10-3-5-设置KieBase和KieSession"><a href="#10-3-5-设置KieBase和KieSession" class="headerlink" title="10.3.5 设置KieBase和KieSession"></a>10.3.5 设置KieBase和KieSession</h4><p>  第一步：在pro1项目页面点击右上角Settings按钮进入设置页面</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnfjo7ccj211y0ce756.jpg" alt="image-20200113162923877.png"></p><p>  第二步：在设置页面选择“知识库和会话”选项</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnfrfocjj211y0dx75c.jpg" alt="image-20200113163005061.png"></p><p>  第三步：在弹出的知识库和会话页面点击“添加”按钮进行设置</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnfzmshrj211t0gggmc.jpg" alt="image-20200113163313305.png"></p><p>  第四步：设置完成后点击右上角保存按钮完成设置操作，可以通过左侧浏览视图点击kmodule.xml，查看文件内容</p><p>  注意：出不来的话，要刷新一下。</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnngb49mgj211y0e275g.jpg" alt="image-20200113163539676.png"></p><h4 id="10-3-6-编译、构建、部署"><a href="#10-3-6-编译、构建、部署" class="headerlink" title="10.3.6 编译、构建、部署"></a>10.3.6 编译、构建、部署</h4><p>  前面我们已经在WorkBench中创建了一个空间itheima，并且在此空间中创建了一个项目pro1，在此项目中创建了数据文件、规则文件和测试场景，如下图：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnngljshdj211y0csmy2.jpg" alt="image-20200113160102668.png"></p><p>  点击右上角“Compile”按钮可以对项目进行编译，点击“Bulid&amp;Deploy”按钮进行构建和部署。</p><p>  部署成功后可以在本地maven仓库中看到当前项目已经被打成jar包：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnngtbntlj20dd04474b.jpg" alt="image-20200113160728259.png"></p><p>  将上面的jar包进行解压，可以看到我们创建的数据对象Person和规则文件person以及kmodule.xml都已经打到jar包中了。</p><h4 id="10-3-7-在项目中使用部署的规则"><a href="#10-3-7-在项目中使用部署的规则" class="headerlink" title="10.3.7 在项目中使用部署的规则"></a>10.3.7 在项目中使用部署的规则</h4><p>  前面我们已经在WorkBench中创建了pro1项目，并且在pro1项目中创建了数据文件、规则文件等。最后我们将此项目打成jar包部署到了maven仓库中。本小节就需要在外部项目中使用我们定义的规则。</p><p>  第一步：在IDEA中创建一个maven项目并在pom.xml文件中导入相关坐标</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.drools&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.10.0.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>  第二步：在项目中创建一个数据对象Person，需要和WorkBench中创建的Person包名、类名完全相同，属性也需要对应</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.pro1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> java.lang.String id;</span><br><span class="line">    <span class="keyword">private</span> java.lang.String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(java.lang.String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(java.lang.String id, java.lang.String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第三步：编写单元测试，远程加载maven仓库中的jar包最终完成规则调用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//通过此URL可以访问到maven仓库中的jar包</span></span><br><span class="line">    <span class="comment">//URL地址构成：http://ip地址:Tomcat端口号/WorkBench工程名/maven2/坐标/版本号/xxx.jar</span></span><br><span class="line">    String url = </span><br><span class="line">    <span class="string">"http://localhost:8080/kie-drools-wb/maven2/com/itheima/pro1/1.0.0/pro1-1.0.0.jar"</span>;</span><br><span class="line">    </span><br><span class="line">    KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过Resource资源对象加载jar包</span></span><br><span class="line">    UrlResource resource = (UrlResource) kieServices.getResources().newUrlResource(url);</span><br><span class="line">    <span class="comment">//通过Workbench提供的服务来访问maven仓库中的jar包资源，需要先进行Workbench的认证</span></span><br><span class="line">    resource.setUsername(<span class="string">"kie"</span>);</span><br><span class="line">    resource.setPassword(<span class="string">"kie"</span>);</span><br><span class="line">    resource.setBasicAuthentication(<span class="string">"enabled"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将资源转换为输入流，通过此输入流可以读取jar包数据</span></span><br><span class="line">    InputStream inputStream = resource.getInputStream();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建仓库对象，仓库对象中保存Drools的规则信息</span></span><br><span class="line">    KieRepository repository = kieServices.getRepository();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过输入流读取maven仓库中的jar包数据，包装成KieModule模块添加到仓库中</span></span><br><span class="line">    KieModule kieModule = </span><br><span class="line">    repository.</span><br><span class="line">        addKieModule(kieServices.getResources().newInputStreamResource(inputStream));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//基于KieModule模块创建容器对象，从容器中可以获取session会话</span></span><br><span class="line">    KieContainer kieContainer = kieServices.newKieContainer(kieModule.getReleaseId());</span><br><span class="line">    KieSession session = kieContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.setAge(<span class="number">10</span>);</span><br><span class="line">    session.insert(person);</span><br><span class="line"></span><br><span class="line">    session.fireAllRules();</span><br><span class="line">    session.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  执行单元测试可以发现控制台已经输出了相关内容。通过WorkBench修改规则输出内容并发布，再次执行单元测试可以发现控制台输出的内容也发生了变化。</p><p>  <strong>通过上面的案例可以发现，我们在IEDA中开发的项目中并没有编写规则文件，规则文件是我们通过WorkBench开发并安装部署到maven仓库中，我们自己开发的项目只需要远程加载maven仓库中的jar包就可以完成规则的调用。这种开发方式的好处是我们的应用可以和业务规则完全分离，同时通过WorkBench修改规则后我们的应用不需要任何修改就可以加载到最新的规则从而实现规则的动态变更。</strong></p><h2 id="11-Drools实战"><a href="#11-Drools实战" class="headerlink" title="11. Drools实战"></a>11. Drools实战</h2><h3 id="11-1-个人所得税计算器"><a href="#11-1-个人所得税计算器" class="headerlink" title="11.1 个人所得税计算器"></a>11.1 个人所得税计算器</h3><p>  本小节我们需要通过Drools规则引擎来根据规则计算个人所得税，最终页面效果如下：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnh76474j20c908et8v.jpg" alt="image-20200214132448956.png"></p><h4 id="11-1-1-名词解释"><a href="#11-1-1-名词解释" class="headerlink" title="11.1.1 名词解释"></a>11.1.1 名词解释</h4><p>  税前月收入：即税前工资，指交纳个人所得税之前的总工资</p><p>  应纳税所得额：指按照税法规定确定纳税人在一定期间所获得的所有应税收入减除在该纳税期间依法允许减除的各种支出后的余额</p><p>  税率：是对征税对象的征收比例或征收额度</p><p>  速算扣除数：指为解决超额累进税率分级计算税额的复杂技术问题，而预先计算出的一个数据，可以简化计算过程</p><p>  扣税额：是指实际缴纳的税额</p><p>  税后工资：是指扣完税后实际到手的工资收入</p><h4 id="11-1-2-计算规则"><a href="#11-1-2-计算规则" class="headerlink" title="11.1.2 计算规则"></a>11.1.2 计算规则</h4><p>  要实现个人所得税计算器，需要了解如下计算规则：（2011）</p><table><thead><tr><th align="left">规则编号</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">计算应纳税所得额</td><td align="left">应纳税所得额为税前工资减去3500</td></tr><tr><td align="left">2</td><td align="left">设置税率，应纳税所得额&lt;=1500</td><td align="left">税率为0.03，速算扣除数为0</td></tr><tr><td align="left">3</td><td align="left">设置税率，应纳税所得额在1500至4500之间</td><td align="left">税率为0.1，速算扣除数为105</td></tr><tr><td align="left">4</td><td align="left">设置税率，应纳税所得额在4500志9000之间</td><td align="left">税率为0.2，速算扣除数为555</td></tr><tr><td align="left">5</td><td align="left">设置税率，应纳税所得额在9000志35000之间</td><td align="left">税率为0.25，速算扣除数为1005</td></tr><tr><td align="left">6</td><td align="left">设置税率，应纳税所得额在35000至55000之间</td><td align="left">税率为0.3，速算扣除数为2755</td></tr><tr><td align="left">7</td><td align="left">设置税率，应纳税所得额在55000至80000之间</td><td align="left">税率为0.35，速算扣除数为5505</td></tr><tr><td align="left">8</td><td align="left">设置税率，应纳税所得额在80000以上</td><td align="left">税率为0.45，速算扣除数为13505</td></tr><tr><td align="left">9</td><td align="left">计算税后工资</td><td align="left">扣税额=应纳税所得额*税率-速算扣除数 税后工资=税前工资-扣税额</td></tr></tbody></table><p>  税前工资：10000</p><p>  应缴纳所得税：10000-3500 = 6500</p><p>  税率：0.2</p><p>  速算扣除数：555</p><p>  扣税额：6500 * 0.2 - 555 = 745</p><p>  税后工资：10000 - 745 = 9255</p><h4 id="11-1-3-实现步骤"><a href="#11-1-3-实现步骤" class="headerlink" title="11.1.3 实现步骤"></a>11.1.3 实现步骤</h4><p>  本实战案例我们基于Spring Boot整合Drools的方式来实现。</p><p>  第一步：创建maven工程calculation并配置pom.xml文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--drools规则引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-templates<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  第二步：创建/resources/application.yml文件</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">calculation</span></span><br></pre></td></tr></table></figure><p>  第三步：编写配置类DroolsConfig</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.config;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieServices;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieBuilder;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieFileSystem;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieRepository;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieContainer;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.kie.internal.io.ResourceFactory;</span><br><span class="line"><span class="keyword">import</span> org.kie.spring.KModuleBeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则引擎配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroolsConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定规则文件存放的目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RULES_PATH = <span class="string">"rules/"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieFileSystem <span class="title">kieFileSystem</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"drools.dateformat"</span>,<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();</span><br><span class="line">        ResourcePatternResolver resourcePatternResolver = </span><br><span class="line">            <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">        Resource[] files = </span><br><span class="line">            resourcePatternResolver.getResources(<span class="string">"classpath*:"</span> + RULES_PATH + <span class="string">"*.*"</span>);</span><br><span class="line">        String path = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Resource file : files) &#123;</span><br><span class="line">            path = RULES_PATH + file.getFilename();</span><br><span class="line">            kieFileSystem.write(ResourceFactory.newClassPathResource(path, <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kieFileSystem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieContainer <span class="title">kieContainer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KieRepository kieRepository = kieServices.getRepository();</span><br><span class="line">        kieRepository.addKieModule(kieRepository::getDefaultReleaseId);</span><br><span class="line">        KieBuilder kieBuilder = kieServices.newKieBuilder(kieFileSystem());</span><br><span class="line">        kieBuilder.buildAll();</span><br><span class="line">        <span class="keyword">return</span> kieServices.newKieContainer(kieRepository.getDefaultReleaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieBase <span class="title">kieBase</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kieContainer().getKieBase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KModuleBeanFactoryPostProcessor <span class="title">kiePostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KModuleBeanFactoryPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第四步：编写实体类Calculation</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> wage;<span class="comment">//税前工资</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> wagemore;<span class="comment">//应纳税所得额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> cess;<span class="comment">//税率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> preminus;<span class="comment">//速算扣除数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> wageminus;<span class="comment">//扣税额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> actualwage;<span class="comment">//税后工资</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWage</span><span class="params">(<span class="keyword">double</span> wage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wage = wage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getActualwage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> actualwage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActualwage</span><span class="params">(<span class="keyword">double</span> actualwage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actualwage = actualwage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWagemore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wagemore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWagemore</span><span class="params">(<span class="keyword">double</span> wagemore)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wagemore = wagemore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCess</span><span class="params">(<span class="keyword">double</span> cess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cess = cess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPreminus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preminus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPreminus</span><span class="params">(<span class="keyword">double</span> preminus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preminus = preminus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWageminus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wageminus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWageminus</span><span class="params">(<span class="keyword">double</span> wageminus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wageminus = wageminus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Calculation&#123;"</span> +</span><br><span class="line">                <span class="string">"wage="</span> + wage +</span><br><span class="line">                <span class="string">", actualwage="</span> + actualwage +</span><br><span class="line">                <span class="string">", wagemore="</span> + wagemore +</span><br><span class="line">                <span class="string">", cess="</span> + cess +</span><br><span class="line">                <span class="string">", preminus="</span> + preminus +</span><br><span class="line">                <span class="string">", wageminus="</span> + wageminus +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第五步：在resources/rules下创建规则文件calculation.drl文件</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calculation</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Calculation</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：计算应纳税所得额"</span></span><br><span class="line">    enabled <span class="keyword">true</span></span><br><span class="line">    salience <span class="number">3</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    date-effective <span class="string">"2011-09-01"</span> <span class="comment">//生效日期</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wage&gt;<span class="number">0</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setWagemore($cal.getWage()-<span class="number">3500</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额&lt;=1500"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &lt;= <span class="number">1500</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.03</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">0</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在1500至4500之间"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">1500</span> &amp;&amp; wagemore &lt;= <span class="number">4500</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.1</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">105</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在4500志9000之间"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">4500</span> &amp;&amp; wagemore &lt;= <span class="number">9000</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.2</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">555</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在9000志35000之间"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">9000</span> &amp;&amp; wagemore &lt;= <span class="number">35000</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.25</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">1005</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在35000至55000之间"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">35000</span> &amp;&amp; wagemore &lt;= <span class="number">55000</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.3</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">2755</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在55000至80000之间"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">55000</span> &amp;&amp; wagemore &lt;= <span class="number">80000</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.35</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">5505</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：设置税率--&gt;&gt;应纳税所得额在80000以上"</span></span><br><span class="line">    salience <span class="number">2</span></span><br><span class="line">    no-loop <span class="keyword">true</span></span><br><span class="line">    activation-group <span class="string">"SETCess_Group"</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wagemore &gt; <span class="number">80000</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setCess(<span class="number">0.45</span>);</span><br><span class="line">        $cal.setPreminus(<span class="number">13505</span>);</span><br><span class="line">        update($cal);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"个人所得税：计算税后工资"</span></span><br><span class="line">    salience <span class="number">1</span></span><br><span class="line">    when</span><br><span class="line">        $cal : Calculation(wage &gt; <span class="number">0</span> &amp;&amp; wagemore &gt; <span class="number">0</span> &amp;&amp; wagemore &gt; <span class="number">0</span> &amp;&amp; cess &gt; <span class="number">0</span>)</span><br><span class="line">    then</span><br><span class="line">        $cal.setWageminus($cal.getWagemore()*$cal.getCess()-$cal.getPreminus());</span><br><span class="line">        $cal.setActualwage($cal.getWage()-$cal.getWageminus());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----税前工资："</span>+$cal.getWage());</span><br><span class="line">        System.out.println(<span class="string">"-----应纳税所得额："</span>+$cal.getWagemore());</span><br><span class="line">        System.out.println(<span class="string">"-----税率："</span> + $cal.getCess());</span><br><span class="line">        System.out.println(<span class="string">"-----速算扣除数："</span> + $cal.getPreminus());</span><br><span class="line">        System.out.println(<span class="string">"-----扣税额："</span> + $cal.getWageminus());</span><br><span class="line">        System.out.println(<span class="string">"-----税后工资："</span> + $cal.getActualwage());</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>  第六步：创建RuleService</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Calculation;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用规则引擎，执行规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KieBase kieBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//个人所得税计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculation <span class="title">calculate</span><span class="params">(Calculation calculation)</span></span>&#123;</span><br><span class="line">        KieSession kieSession = kieBase.newKieSession();</span><br><span class="line">        kieSession.insert(calculation);</span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        kieSession.dispose();</span><br><span class="line">        <span class="keyword">return</span> calculation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第七步：创建RuleController</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.Calculation;</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.service.RuleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rule"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RuleService ruleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/calculate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculation <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> wage)</span></span>&#123;</span><br><span class="line">        Calculation calculation = <span class="keyword">new</span> Calculation();</span><br><span class="line">        calculation.setWage(wage);</span><br><span class="line">        calculation = ruleService.calculate(calculation);</span><br><span class="line">        System.out.println(calculation);</span><br><span class="line">        <span class="keyword">return</span> calculation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第八步：创建启动类DroolsApplication</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroolsApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DroolsApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第九步：导入静态资源文件到resources/static目录下</p><h3 id="11-2-信用卡申请"><a href="#11-2-信用卡申请" class="headerlink" title="11.2 信用卡申请"></a>11.2 信用卡申请</h3><p>  本小节我们需要通过Drools规则引擎来根据规则进行申请人的合法性检查，检查通过后再根据规则确定信用卡额度，最终页面效果如下：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnid4a6xj20ki081mxb.jpg" alt="image-20200214202525859.png"></p><h4 id="9-2-1-计算规则"><a href="#9-2-1-计算规则" class="headerlink" title="9.2.1 计算规则"></a>9.2.1 计算规则</h4><p>  合法性检查规则如下：</p><table><thead><tr><th align="left">规则编号</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">检查学历与薪水1</td><td align="left">如果申请人既没房也没车，同时学历为大专以下，并且月薪少于5000，那么不通过</td></tr><tr><td align="left">2</td><td align="left">检查学历与薪水2</td><td align="left">如果申请人既没房也没车，同时学历为大专或本科，并且月薪少于3000，那么不通过</td></tr><tr><td align="left">3</td><td align="left">检查学历与薪水3</td><td align="left">如果申请人既没房也没车，同时学历为本科以上，并且月薪少于2000，同时之前没有信用卡的，那么不通过</td></tr><tr><td align="left">4</td><td align="left">检查申请人已有的信用卡数量</td><td align="left">如果申请人现有的信用卡数量大于10，那么不通过</td></tr></tbody></table><p>  信用卡额度确定规则：</p><table><thead><tr><th align="left">规则编号</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">规则1</td><td align="left">如果申请人有房有车，或者月收入在20000以上，那么发放的信用卡额度为15000</td></tr><tr><td align="left">2</td><td align="left">规则2</td><td align="left">如果申请人没房没车，但月收入在10000~20000之间，那么发放的信用卡额度为6000</td></tr><tr><td align="left">3</td><td align="left">规则3</td><td align="left">如果申请人没房没车，月收入在10000以下，那么发放的信用卡额度为3000</td></tr><tr><td align="left">4</td><td align="left">规则4</td><td align="left">如果申请人有房没车或者没房但有车，月收入在10000以下，那么发放的信用卡额度为5000</td></tr><tr><td align="left">5</td><td align="left">规则5</td><td align="left">如果申请人有房没车或者是没房但有车，月收入在10000~20000之间，那么发放的信用卡额度为8000</td></tr></tbody></table><h4 id="11-2-2-实现步骤"><a href="#11-2-2-实现步骤" class="headerlink" title="11.2.2 实现步骤"></a>11.2.2 实现步骤</h4><p>  第一步：创建maven工程creditCardApply并配置pom.xml文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>creditCardApply<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--drools规则引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-templates<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  第二步：创建/resources/application.yml文件</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">creditCardApply</span></span><br></pre></td></tr></table></figure><p>  第三步：编写配置类DroolsConfig</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.config;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieBase;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieServices;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieBuilder;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieFileSystem;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.KieRepository;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieContainer;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.kie.internal.io.ResourceFactory;</span><br><span class="line"><span class="keyword">import</span> org.kie.spring.KModuleBeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则引擎配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroolsConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定规则文件存放的目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RULES_PATH = <span class="string">"rules/"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieFileSystem <span class="title">kieFileSystem</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();</span><br><span class="line">        ResourcePatternResolver resourcePatternResolver =</span><br><span class="line">                <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">        Resource[] files =</span><br><span class="line">                resourcePatternResolver.getResources(<span class="string">"classpath*:"</span> + RULES_PATH + <span class="string">"*.*"</span>);</span><br><span class="line">        String path = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Resource file : files) &#123;</span><br><span class="line">            path = RULES_PATH + file.getFilename();</span><br><span class="line">            kieFileSystem.write(ResourceFactory.newClassPathResource(path, <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kieFileSystem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieContainer <span class="title">kieContainer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KieRepository kieRepository = kieServices.getRepository();</span><br><span class="line">        kieRepository.addKieModule(kieRepository::getDefaultReleaseId);</span><br><span class="line">        KieBuilder kieBuilder = kieServices.newKieBuilder(kieFileSystem());</span><br><span class="line">        kieBuilder.buildAll();</span><br><span class="line">        <span class="keyword">return</span> kieServices.newKieContainer(kieRepository.getDefaultReleaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieBase <span class="title">kieBase</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kieContainer().getKieBase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KModuleBeanFactoryPostProcessor <span class="title">kiePostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KModuleBeanFactoryPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第四步：编写实体类CreditCardApplyInfo</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信用卡申请信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreditCardApplyInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EDUCATION_1 = <span class="string">"专科以下"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EDUCATION_2 = <span class="string">"专科"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EDUCATION_3 = <span class="string">"本科"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EDUCATION_4 = <span class="string">"本科以上"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String education;</span><br><span class="line">    <span class="keyword">private</span> String telephone;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> monthlyIncome = <span class="number">0</span>;<span class="comment">//月收入</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasHouse = <span class="keyword">false</span>;<span class="comment">//是否有房</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasCar = <span class="keyword">false</span>;<span class="comment">//是否有车</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hasCreditCardCount = <span class="number">0</span>;<span class="comment">//现持有信用卡数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> checkResult = <span class="keyword">true</span>;<span class="comment">//审核是否通过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> quota = <span class="number">0</span>;<span class="comment">//额度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEducation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> education;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEducation</span><span class="params">(String education)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.education = education;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTelephone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> telephone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTelephone</span><span class="params">(String telephone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.telephone = telephone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMonthlyIncome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> monthlyIncome;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMonthlyIncome</span><span class="params">(<span class="keyword">double</span> monthlyIncome)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.monthlyIncome = monthlyIncome;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasHouse</span><span class="params">(<span class="keyword">boolean</span> hasHouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasHouse = hasHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasCar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasCar</span><span class="params">(<span class="keyword">boolean</span> hasCar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasCar = hasCar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHasCreditCardCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasCreditCardCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasCreditCardCount</span><span class="params">(<span class="keyword">int</span> hasCreditCardCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasCreditCardCount = hasCreditCardCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCheckResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCheckResult</span><span class="params">(<span class="keyword">boolean</span> checkResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.checkResult = checkResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getQuota</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quota;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuota</span><span class="params">(<span class="keyword">double</span> quota)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quota = quota;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(checkResult)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"审核通过，信用卡额度为："</span> + quota;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"审核不通过"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第五步：在resources/rules下创建规则文件creditCardApply.drl文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.creditCardApply</span><br><span class="line">import com.itheima.drools.entity.CreditCardApplyInfo</span><br><span class="line"></span><br><span class="line">//合法性检查</span><br><span class="line">rule &quot;如果申请人既没房也没车，同时学历为大专以下，并且月薪少于5000，那么不通过&quot;</span><br><span class="line">    salience 10</span><br><span class="line">    no-loop true</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(hasCar == false &amp;&amp;</span><br><span class="line">                                hasHouse == false &amp;&amp;</span><br><span class="line">                                education == CreditCardApplyInfo.EDUCATION_1 &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt; 5000)</span><br><span class="line">    then</span><br><span class="line">        $c.setCheckResult(false);</span><br><span class="line">        drools.halt();</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人既没房也没车，同时学历为大专或本科，并且月薪少于3000，那么不通过&quot;</span><br><span class="line">    salience 10</span><br><span class="line">    no-loop true</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(hasCar == false &amp;&amp;</span><br><span class="line">                                hasHouse == false &amp;&amp;</span><br><span class="line">                                (education == CreditCardApplyInfo.EDUCATION_2  ||</span><br><span class="line">                                education == CreditCardApplyInfo.EDUCATION_3) &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt; 3000)</span><br><span class="line">    then</span><br><span class="line">        $c.setCheckResult(false);</span><br><span class="line">        drools.halt();</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人既没房也没车，同时学历为本科以上，并且月薪少于2000，同时之前没有信用卡的，那么不通过&quot;</span><br><span class="line">    salience 10</span><br><span class="line">    no-loop true</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(hasCar == false &amp;&amp;</span><br><span class="line">                                hasHouse == false &amp;&amp;</span><br><span class="line">                                education == CreditCardApplyInfo.EDUCATION_4 &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt; 2000 &amp;&amp;</span><br><span class="line">                                hasCreditCardCount == 0)</span><br><span class="line">    then</span><br><span class="line">        $c.setCheckResult(false);</span><br><span class="line">        drools.halt();</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人现有的信用卡数量大于10，那么不通过&quot;</span><br><span class="line">    salience 10</span><br><span class="line">    no-loop true</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(hasCreditCardCount &gt; 10)</span><br><span class="line">    then</span><br><span class="line">        $c.setCheckResult(false);</span><br><span class="line">        drools.halt();</span><br><span class="line">end</span><br><span class="line">//--------------------------------------------------------------------------</span><br><span class="line">//确定额度</span><br><span class="line">rule &quot;如果申请人有房有车，或者月收入在20000以上，那么发放的信用卡额度为15000&quot;</span><br><span class="line">    salience 1</span><br><span class="line">    no-loop true</span><br><span class="line">    activation-group &quot;quota_group&quot;</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(checkResult == true &amp;&amp;</span><br><span class="line">                                ((hasHouse == true &amp;&amp; hasCar == true) ||</span><br><span class="line">                                (monthlyIncome &gt; 20000)))</span><br><span class="line">    then</span><br><span class="line">        $c.setQuota(15000);</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人没房没车，但月收入在10000~20000之间，那么发放的信用卡额度为6000&quot;</span><br><span class="line">    salience 1</span><br><span class="line">    no-loop true</span><br><span class="line">    activation-group &quot;quota_group&quot;</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(checkResult == true &amp;&amp;</span><br><span class="line">                                hasHouse == false &amp;&amp;</span><br><span class="line">                                hasCar == false &amp;&amp;</span><br><span class="line">                                monthlyIncome &gt;= 10000 &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt;= 20000)</span><br><span class="line">    then</span><br><span class="line">        $c.setQuota(6000);</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人没房没车，月收入在10000以下，那么发放的信用卡额度为3000&quot;</span><br><span class="line">    salience 1</span><br><span class="line">    no-loop true</span><br><span class="line">    activation-group &quot;quota_group&quot;</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(checkResult == true &amp;&amp;</span><br><span class="line">                                        hasHouse == false &amp;&amp;</span><br><span class="line">                                        hasCar == false &amp;&amp;</span><br><span class="line">                                        monthlyIncome &lt; 10000)</span><br><span class="line">    then</span><br><span class="line">        $c.setQuota(3000);</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人有房没车或者没房但有车，月收入在10000以下，那么发放的信用卡额度为5000&quot;</span><br><span class="line">    salience 1</span><br><span class="line">    no-loop true</span><br><span class="line">    activation-group &quot;quota_group&quot;</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(checkResult == true &amp;&amp;</span><br><span class="line">                                ((hasHouse == true &amp;&amp; hasCar == false) ||</span><br><span class="line">                                (hasHouse == false &amp;&amp; hasCar == true)) &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt; 10000)</span><br><span class="line">    then</span><br><span class="line">        $c.setQuota(5000);</span><br><span class="line">end</span><br><span class="line">rule &quot;如果申请人有房没车或者是没房但有车，月收入在10000~20000之间，那么发放的信用卡额度为8000&quot;</span><br><span class="line">    salience 1</span><br><span class="line">    no-loop true</span><br><span class="line">    activation-group &quot;quota_group&quot;</span><br><span class="line">    when</span><br><span class="line">        $c:CreditCardApplyInfo(checkResult == true &amp;&amp;</span><br><span class="line">                                ((hasHouse == true &amp;&amp; hasCar == false) ||</span><br><span class="line">                                (hasHouse == false &amp;&amp; hasCar == true)) &amp;&amp;</span><br><span class="line">                                monthlyIncome &gt;= 10000 &amp;&amp;</span><br><span class="line">                                monthlyIncome &lt;= 20000)</span><br><span class="line">    then</span><br><span class="line">        $c.setQuota(8000);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>  第六步：创建RuleService</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools.service;</span><br><span class="line"></span><br><span class="line">import com.itheima.drools.entity.CreditCardApplyInfo;</span><br><span class="line">import org.kie.api.KieBase;</span><br><span class="line">import org.kie.api.runtime.KieSession;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RuleService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private KieBase kieBase;</span><br><span class="line"></span><br><span class="line">    //调用Drools规则引擎实现信用卡申请</span><br><span class="line">    public CreditCardApplyInfo creditCardApply(CreditCardApplyInfo creditCardApplyInfo)&#123;</span><br><span class="line">        KieSession session = kieBase.newKieSession();</span><br><span class="line">        session.insert(creditCardApplyInfo);</span><br><span class="line">        session.fireAllRules();</span><br><span class="line">        session.dispose();</span><br><span class="line">        return creditCardApplyInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第七步：创建RuleController</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.drools.entity.CreditCardApplyInfo;</span><br><span class="line">import com.itheima.drools.service.RuleService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/rule&quot;)</span><br><span class="line">public class RuleController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RuleService ruleService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/creditCardApply&quot;)</span><br><span class="line">    public CreditCardApplyInfo creditCardApply(@RequestBody </span><br><span class="line">        CreditCardApplyInfo creditCardApplyInfo)&#123;</span><br><span class="line">        creditCardApplyInfo = ruleService.creditCardApply(creditCardApplyInfo);</span><br><span class="line">        return creditCardApplyInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第八步：创建启动类DroolsApplication</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.drools;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class DroolsApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DroolsApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第九步：导入静态资源文件到resources/static目录下</p><h3 id="11-3-保险产品准入规则-学到决策表这里-高级部分跳过"><a href="#11-3-保险产品准入规则-学到决策表这里-高级部分跳过" class="headerlink" title="11.3 保险产品准入规则  (学到决策表这里 高级部分跳过)"></a>11.3 保险产品准入规则  (学到决策表这里 高级部分跳过)</h3><h4 id="11-3-1-决策表"><a href="#11-3-1-决策表" class="headerlink" title="11.3.1 决策表"></a>11.3.1 决策表</h4><p>  前面的课程中我们编写的规则文件都是drl形式的文件，Drools除了支持drl形式的文件外还支持xls格式的文件（即Excel文件）。这种xls格式的文件通常称为决策表（decision table）。</p><p>  决策表（decision table）是一个“精确而紧凑的”表示条件逻辑的方式，非常适合商业级别的规则。决策表与现有的drl文件可以无缝替换。Drools提供了相应的API可以将xls文件编译为drl格式的字符串。</p><p>  一个决策表的例子如下：</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnj1ywwmj20zf0bumxh.jpg" alt="image-20200217160930138.png"></p><p>  决策表语法：</p><table><thead><tr><th align="left">关键字</th><th align="left">说明</th><th align="left">是否必须</th></tr></thead><tbody><tr><td align="left">RuleSet</td><td align="left">相当于drl文件中的package</td><td align="left">必须，只能有一个。如果没有设置RuleSet对应的值则使用默认值rule_table</td></tr><tr><td align="left">Sequential</td><td align="left">取值为Boolean类型。true表示规则按照表格自上到下的顺序执行，false表示乱序</td><td align="left">可选</td></tr><tr><td align="left">Import</td><td align="left">相当于drl文件中的import，如果引入多个类则类之间用逗号分隔</td><td align="left">可选</td></tr><tr><td align="left">Variables</td><td align="left">相当于drl文件中的global，用于定义全局变量，如果有多个全局变量则中间用逗号分隔</td><td align="left">可选</td></tr><tr><td align="left">RuleTable</td><td align="left">它指示了后面将会有一批rule，RuleTable的名称将会作为以后生成rule的前缀</td><td align="left">必须</td></tr><tr><td align="left">CONDITION</td><td align="left">规则条件关键字，相当于drl文件中的when。下面两行则表示 LHS 部分，第三行则为注释行，不计为规则部分，从第四行开始，每一行表示一条规则</td><td align="left">每个规则表至少有一个</td></tr><tr><td align="left">ACTION</td><td align="left">规则结果关键字，相当于drl文件中的then</td><td align="left">每个规则表至少有一个</td></tr><tr><td align="left">NO-LOOP</td><td align="left">相当于drl文件中的no-loop</td><td align="left">可选</td></tr><tr><td align="left">AGENDA-GROUP</td><td align="left">相当于drl文件中的agenda-group</td><td align="left">可选</td></tr></tbody></table><p>  在决策表中还经常使用到占位符，语法为$后面加数字，用于替换每条规则中设置的具体值。</p><p>  上面的决策表例子转换为drl格式的规则文件内容如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.PersonInfoEntity;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">global java.util.List listRules;</span><br><span class="line"></span><br><span class="line">rule <span class="string">"personCheck_10"</span></span><br><span class="line">    salience <span class="number">65535</span></span><br><span class="line">    agenda-group <span class="string">"sign"</span></span><br><span class="line">    when</span><br><span class="line">        $person : PersonInfoEntity(sex != <span class="string">"男"</span>)</span><br><span class="line">    then</span><br><span class="line">        listRules.add(<span class="string">"性别不对"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"personCheck_11"</span></span><br><span class="line">    salience <span class="number">65534</span></span><br><span class="line">    agenda-group <span class="string">"sign"</span></span><br><span class="line">    when</span><br><span class="line">        $person : PersonInfoEntity(age &lt; <span class="number">22</span> || age &gt; <span class="number">25</span>)</span><br><span class="line">    then</span><br><span class="line">        listRules.add(<span class="string">"年龄不合适"</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">"personCheck_12"</span></span><br><span class="line">    salience <span class="number">65533</span></span><br><span class="line">    agenda-group <span class="string">"sign"</span></span><br><span class="line">    when</span><br><span class="line">        $person : PersonInfoEntity(salary &lt; <span class="number">10000</span>)</span><br><span class="line">    then</span><br><span class="line">        listRules.add(<span class="string">"工资太低了"</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>  要进行决策表相关操作，需要导入如下maven坐标：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-decisiontables<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  通过下图可以发现，由于maven的依赖传递特性在导入drools-decisiontables坐标后，drools-core和drools-compiler等坐标也被传递了过来</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnjdtdguj20m904yt8x.jpg" alt="image-20200218105819932.png"></p><p>  Drools提供的将xls文件编译为drl格式字符串的API如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String realPath = <span class="string">"C:\\testRule.xls"</span>;<span class="comment">//指定决策表xls文件的磁盘路径</span></span><br><span class="line">File file = <span class="keyword">new</span> File(realPath);</span><br><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">SpreadsheetCompiler compiler = <span class="keyword">new</span> SpreadsheetCompiler();</span><br><span class="line">String drl = compiler.compile(is, InputType.XLS);</span><br></pre></td></tr></table></figure><p>  Drools还提供了基于drl格式字符串创建KieSession的API：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KieHelper kieHelper = <span class="keyword">new</span> KieHelper();</span><br><span class="line">kieHelper.addContent(drl, ResourceType.DRL);</span><br><span class="line">KieSession session = kieHelper.build().newKieSession();</span><br></pre></td></tr></table></figure><p>  基于决策表的入门案例：</p><p>  第一步：创建maven工程drools_decisiontable_demo并配置pom.xml文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-decisiontables<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  第二步：创建实体类PersonInfoEntity</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInfoEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第三步：创建xls规则文件（可以直接使用资料中提供的testRule.xls文件）</p><p>  第四步：创建单元测试</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String realPath = <span class="string">"d:\\testRule.xls"</span>;<span class="comment">//指定决策表xls文件的磁盘路径</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(realPath);</span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    SpreadsheetCompiler compiler = <span class="keyword">new</span> SpreadsheetCompiler();</span><br><span class="line">    String drl = compiler.compile(is, InputType.XLS);</span><br><span class="line"></span><br><span class="line">    System.out.println(drl);</span><br><span class="line">    KieHelper kieHelper = <span class="keyword">new</span> KieHelper();</span><br><span class="line">    kieHelper.addContent(drl, ResourceType.DRL);</span><br><span class="line">    KieSession session = kieHelper.build().newKieSession();</span><br><span class="line"></span><br><span class="line">    PersonInfoEntity personInfoEntity = <span class="keyword">new</span> PersonInfoEntity();</span><br><span class="line">    personInfoEntity.setSex(<span class="string">"男"</span>);</span><br><span class="line">    personInfoEntity.setAge(<span class="number">35</span>);</span><br><span class="line">    personInfoEntity.setSalary(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    session.setGlobal(<span class="string">"listRules"</span>,list);</span><br><span class="line"></span><br><span class="line">    session.insert(personInfoEntity);</span><br><span class="line">    </span><br><span class="line">    session.getAgenda().getAgendaGroup(<span class="string">"sign"</span>).setFocus();</span><br><span class="line">    </span><br><span class="line">    session.fireAllRules();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    session.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-2-规则介绍"><a href="#11-3-2-规则介绍" class="headerlink" title="11.3.2 规则介绍"></a>11.3.2 规则介绍</h4><p>  各保险公司针对人身、财产推出了不同的保险产品，作为商业保险公司，筛选出符合公司利益最大化的客户是非常重要的，即各保险产品的准入人群是不同的，也就是说保险公司会针对不同的人群特征，制定不同的产品缴费和赔付规则。</p><p>  我们来看一下某保险产品准入规则的简化版，当不满足以下规则时，系统模块需要返回准入失败标识和失败原因</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">规则1：  保险公司是：PICC</span><br><span class="line">规则2：  销售区域是：北京、天津</span><br><span class="line">规则3：  投保人年龄：0 ~ 17岁</span><br><span class="line">规则4：  保险期间是：20年、25年、30年</span><br><span class="line">规则5：  缴费方式是：趸交（一次性交清）或年交</span><br><span class="line">规则6：  保险期与交费期规则一：保险期间为20年期交费期间最长10年交且不能选择[趸交]</span><br><span class="line">规则7：  保险期与交费期规则二：保险期间为25年期交费期间最长15年交且不能选择[趸交]</span><br><span class="line">规则8：  保险期与交费期规则三：保险期间为30年期交费期间最长20年交且不能选择[趸交]</span><br><span class="line">规则9：  被保人要求：（投保年龄+保险期间）不得大于40周岁</span><br><span class="line">规则10： 保险金额规则：投保时约定，最低为5万元，超过部分必须为1000元的整数倍</span><br><span class="line">规则11： 出单基本保额限额规则：线上出单基本保额限额62.5万元，超62.5万元需配合契调转线下出单</span><br></pre></td></tr></table></figure><p>  在本案例中规则文件是一个Excel文件，业务人员可以直接更改这个文件中指标的值，系统不需要做任何变更。</p><h4 id="11-3-3-实现步骤"><a href="#11-3-3-实现步骤" class="headerlink" title="11.3.3 实现步骤"></a>11.3.3 实现步骤</h4><p>  本案例还是基于Spring Boot整合Drools的架构来实现。</p><p>  第一步：创建maven工程insuranceInfoCheck并配置pom.xml文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="tag"><span class="string">                             http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>insuranceInfoCheck<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--drools规则引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-templates<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kie-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  第二步：创建/resources/application.yml文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: insuranceInfoCheck</span><br></pre></td></tr></table></figure><p>  第三步：创建实体类InsuranceInfo</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.entity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保险信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsuranceInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String param1;<span class="comment">//保险公司</span></span><br><span class="line">    <span class="keyword">private</span> String param2;<span class="comment">//方案代码</span></span><br><span class="line">    <span class="keyword">private</span> String param3;<span class="comment">//渠道号</span></span><br><span class="line">    <span class="keyword">private</span> String param4;<span class="comment">//销售区域</span></span><br><span class="line">    <span class="keyword">private</span> String param5;<span class="comment">//投保年龄</span></span><br><span class="line">    <span class="keyword">private</span> String param6;<span class="comment">//保险期间</span></span><br><span class="line">    <span class="keyword">private</span> String param7;<span class="comment">//缴费期间</span></span><br><span class="line">    <span class="keyword">private</span> String param8;<span class="comment">//缴费方式</span></span><br><span class="line">    <span class="keyword">private</span> String param9;<span class="comment">//保障类型</span></span><br><span class="line">    <span class="keyword">private</span> String param10;<span class="comment">//等待期</span></span><br><span class="line">    <span class="keyword">private</span> String param11;<span class="comment">//犹豫期</span></span><br><span class="line">    <span class="keyword">private</span> String param12;<span class="comment">//职业类型</span></span><br><span class="line">    <span class="keyword">private</span> String param13;<span class="comment">//保额限制</span></span><br><span class="line">    <span class="keyword">private</span> String param14;<span class="comment">//免赔额</span></span><br><span class="line">    <span class="keyword">private</span> String param15;<span class="comment">//主险保额</span></span><br><span class="line">    <span class="keyword">private</span> String param16;<span class="comment">//主险保费</span></span><br><span class="line">    <span class="keyword">private</span> String param17;<span class="comment">//附加险保额</span></span><br><span class="line">    <span class="keyword">private</span> String param18;<span class="comment">//附加险保费</span></span><br><span class="line">    <span class="keyword">private</span> String param19;<span class="comment">//与投保人关系</span></span><br><span class="line">    <span class="keyword">private</span> String param20;<span class="comment">//与被保人关系</span></span><br><span class="line">    <span class="keyword">private</span> String param21;<span class="comment">//性别</span></span><br><span class="line">    <span class="keyword">private</span> String param22;<span class="comment">//证件</span></span><br><span class="line">    <span class="keyword">private</span> String param23;<span class="comment">//保费</span></span><br><span class="line">    <span class="keyword">private</span> String param24;<span class="comment">//保额</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第四步：创建决策表文件（也可以直接使用实战资料中提供的insuranceInfoCheck.xls文件）</p><p>  <img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gjnnjpsulfj20yu0d7aa8.jpg" alt="image-20200218120618384.png"></p><p>  第五步：封装工具类KieSessionUtils</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.InsuranceInfo;</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.PersonInfoEntity;</span><br><span class="line"><span class="keyword">import</span> org.drools.decisiontable.InputType;</span><br><span class="line"><span class="keyword">import</span> org.drools.decisiontable.SpreadsheetCompiler;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.Message;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.builder.Results;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.io.ResourceType;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.kie.internal.utils.KieHelper;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KieSessionUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">KieSessionUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把xls文件解析为String</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDRL</span> <span class="params">(String realPath)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(realPath); <span class="comment">// 例如：C:\\abc.xls</span></span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        SpreadsheetCompiler compiler = <span class="keyword">new</span> SpreadsheetCompiler();</span><br><span class="line">        String drl = compiler.compile(is, InputType.XLS);</span><br><span class="line">        System.out.println(drl);</span><br><span class="line">        <span class="keyword">return</span> drl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// drl为含有内容的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KieSession <span class="title">createKieSessionFromDRL</span><span class="params">(String drl)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        KieHelper kieHelper = <span class="keyword">new</span> KieHelper();</span><br><span class="line">        kieHelper.addContent(drl, ResourceType.DRL);</span><br><span class="line">        Results results = kieHelper.verify();</span><br><span class="line">        <span class="keyword">if</span> (results.hasMessages(Message.Level.WARNING, Message.Level.ERROR)) &#123;</span><br><span class="line">            List&lt;Message&gt; messages = results.getMessages(Message.Level.WARNING, Message.Level.ERROR);</span><br><span class="line">            <span class="keyword">for</span> (Message message : messages) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Error: "</span>+message.getText());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// throw new IllegalStateException("Compilation errors were found. Check the logs.");</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kieHelper.build().newKieSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// realPath为Excel文件绝对路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KieSession <span class="title">getKieSessionFromXLS</span><span class="params">(String realPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createKieSessionFromDRL(getDRL(realPath));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第六步：创建RuleService类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.InsuranceInfo;</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.utils.KieSessionUtils;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">insuranceInfoCheck</span><span class="params">(InsuranceInfo insuranceInfo)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        KieSession session = KieSessionUtils.getKieSessionFromXLS(<span class="string">"D:\\rules.xls"</span>);</span><br><span class="line">        session.getAgenda().getAgendaGroup(<span class="string">"sign"</span>).setFocus();</span><br><span class="line"></span><br><span class="line">        session.insert(insuranceInfo);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; listRules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        session.setGlobal(<span class="string">"listRules"</span>, listRules);</span><br><span class="line"></span><br><span class="line">        session.fireAllRules();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> listRules;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第七步：创建RuleController类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.entity.InsuranceInfo;</span><br><span class="line"><span class="keyword">import</span> com.itheima.drools.service.RuleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rule"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RuleService ruleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/insuranceInfoCheck"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">insuranceInfoCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模拟数据，实际应为页面传递过来</span></span><br><span class="line">        InsuranceInfo insuranceInfo = <span class="keyword">new</span> InsuranceInfo();</span><br><span class="line">        insuranceInfo.setParam1(<span class="string">"picc"</span>);</span><br><span class="line">        insuranceInfo.setParam4(<span class="string">"上海"</span>);</span><br><span class="line">        insuranceInfo.setParam5(<span class="string">"101"</span>);</span><br><span class="line">        insuranceInfo.setParam6(<span class="string">"12"</span>);</span><br><span class="line">        insuranceInfo.setParam7(<span class="string">"222"</span>);</span><br><span class="line">        insuranceInfo.setParam8(<span class="string">"1"</span>);</span><br><span class="line">        insuranceInfo.setParam13(<span class="string">"3"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = ruleService.insuranceInfoCheck(insuranceInfo);</span><br><span class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                map.put(<span class="string">"checkResult"</span>,<span class="keyword">false</span>);</span><br><span class="line">                map.put(<span class="string">"msg"</span>,<span class="string">"准入失败"</span>);</span><br><span class="line">                map.put(<span class="string">"detail"</span>,list);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(<span class="string">"checkResult"</span>,<span class="keyword">true</span>);</span><br><span class="line">                map.put(<span class="string">"msg"</span>,<span class="string">"准入成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            map.put(<span class="string">"checkResult"</span>,<span class="keyword">false</span>);</span><br><span class="line">            map.put(<span class="string">"msg"</span>,<span class="string">"未知错误"</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第八步：创建启动类DroolsApplication</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.drools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroolsApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DroolsApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-Supplement"><a href="#12-Supplement" class="headerlink" title="12. Supplement"></a>12. Supplement</h2><h3 id="12-1-Kiehelper"><a href="#12-1-Kiehelper" class="headerlink" title="12.1 Kiehelper"></a>12.1 Kiehelper</h3><p>KieHelper是高版本的drools官方提供的工具操作类，可以更加方便的操作KIE中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KieHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">KieHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Constructing instances is not allowed for this class</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KieContainer <span class="title">getKieContainer</span><span class="params">(ReleaseId releaseId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               Resource... resources)</span> </span>&#123;</span><br><span class="line">        KieServices ks = KieServices.Factory.get();</span><br><span class="line">        createJar(ks, releaseId, resources);</span><br><span class="line">        <span class="keyword">return</span> ks.newKieContainer(releaseId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KieModule <span class="title">createAndDeployJar</span><span class="params">(KieServices ks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               ReleaseId releaseId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               Resource... resources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] jar = createJar(ks, releaseId, resources);</span><br><span class="line"></span><br><span class="line">        KieModule km = deployJarIntoRepository(ks, jar);</span><br><span class="line">        <span class="keyword">return</span> km;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] createJar(KieServices ks, ReleaseId releaseId, Resource... resources) &#123;</span><br><span class="line">        KieFileSystem kfs = ks.newKieFileSystem().generateAndWritePomXML(releaseId);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resources.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resources[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                kfs.write(resources[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        KieBuilder kieBuilder = ks.newKieBuilder(kfs);</span><br><span class="line">        ((InternalKieBuilder) kieBuilder).buildAll(o -&gt; <span class="keyword">true</span>);</span><br><span class="line">        Results results = kieBuilder.getResults();</span><br><span class="line">        <span class="keyword">if</span> (results.hasMessages(Message.Level.ERROR)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(results.getMessages(Message.Level.ERROR).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        InternalKieModule kieModule = (InternalKieModule) ks.getRepository()</span><br><span class="line">                .getKieModule(releaseId);</span><br><span class="line">        <span class="keyword">byte</span>[] jar = kieModule.getBytes();</span><br><span class="line">        <span class="keyword">return</span> jar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KieModule <span class="title">deployJarIntoRepository</span><span class="params">(KieServices ks, <span class="keyword">byte</span>[] jar)</span> </span>&#123;</span><br><span class="line">        Resource jarRes = ks.getResources().newByteArrayResource(jar);</span><br><span class="line">        KieModule km = ks.getRepository().addKieModule(jarRes);</span><br><span class="line">        <span class="keyword">return</span> km;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-KieSession-和StatelessSession"><a href="#12-2-KieSession-和StatelessSession" class="headerlink" title="12.2 KieSession 和StatelessSession"></a>12.2 KieSession 和StatelessSession</h3><p><strong>KieSession</strong></p><p>通过KieContainer可以获取KieSession，在kmodule.xml配置文件中如果不指定ksession的type默认也是有状态的session。有状态session的特性是，我们可以通过建立一次session完成多次与规则引擎之间的交互，在没有调用dispose方法时，会维持会话状态。使用KieSession的一般步骤为，获取session，insert Fact对象，然后调用fireAllRules进行规则匹配，随后调用dispose方法关闭session。</p><p><strong>StatelessSession</strong></p><p>StatelessKieSession提供了一个更加便利的API，是对KisSession的封装，不再调用dispose方法进行session的关闭。它隔离了每次与规则引擎的交互，不会再去维护会话的状态。同时也不再提供fireAllRules方法。<br>使用场景：<br>（1）数据校验<br>（2）运算<br>（3）数据过滤<br>（4）消息路由<br>（5）任何能被描述成函数或公式的规则</p><h2 id="13-Tips"><a href="#13-Tips" class="headerlink" title="13. Tips"></a>13. Tips</h2><p>DSL文件汇中写的判断条件，并不是直接使用的POJO类里面的属性，目前我的理解比较粗浅，应该是自动补全了get这个方法来获得的属性值，因为原来POJO里面的类属性是Private的。（也存在使用映射获得这个属性值的可能性）</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gjnlz4pysij20hc068wev.jpg&quot; alt=&quot;WX20201013-124607@2x.png&quot; style=&quot;zoom:67%;&quot;&gt;

&lt;p&gt;Drools的复杂度非常高，本文前面Base Component出处是网络上流传的黑马教学文档。&lt;/p&gt;
&lt;p&gt;后面复杂的部分晚些我会补上。&lt;/p&gt;
&lt;p&gt;笑，maybe&lt;/p&gt;</summary>
    
    
    
    
    <category term="Drools" scheme="http://yoursite.com/tags/Drools/"/>
    
  </entry>
  
  <entry>
    <title>Jackson初体验</title>
    <link href="http://yoursite.com/2020/09/25/Jackson%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2020/09/25/Jackson%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2020-09-25T10:49:45.000Z</published>
    <updated>2021-01-28T09:45:06.436Z</updated>
    
    <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj33mj14koj20lm0a20tj.jpg" alt="WX20200925-185945@2x.png" style="zoom:50%;"><a id="more"></a> <h1 id="Jsckson"><a href="#Jsckson" class="headerlink" title="Jsckson"></a>Jsckson</h1><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><p><strong>Streaming</strong> : jackson-core jar，定义了底层的streaming API和实现了Json特性。<br><strong>Annotations</strong>: jackson-annotations jar，包含了标准的Jackson注解。<br><strong>Databind</strong> : jackson-databind jar，实现了数据绑定和对象序列化，它依赖于streaming和annotations的包。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="Object-gt-Json"><a href="#Object-gt-Json" class="headerlink" title="Object -&gt; Json"></a>Object -&gt; Json</h3><p><strong>writevalue(….)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">Staff obj = <span class="keyword">new</span> Staff();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object to JSON in file</span></span><br><span class="line">mapper.writeValue(<span class="keyword">new</span> File(<span class="string">"c:\\file.json"</span>), obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object to JSON in String</span></span><br><span class="line">String jsonInString = mapper.writeValueAsString(obj);</span><br></pre></td></tr></table></figure><h3 id="Json-gt-object"><a href="#Json-gt-object" class="headerlink" title="Json -&gt; object"></a>Json -&gt; object</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String jsonInString = <span class="string">"&#123;'name' : 'mjw'&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON from file to Object</span></span><br><span class="line">Staff obj = mapper.readValue(<span class="keyword">new</span> File(<span class="string">"c:\\file.json"</span>), Staff.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON from URL to Object</span></span><br><span class="line">Staff obj = mapper.readValue(<span class="keyword">new</span> URL(<span class="string">"http://www.jianshu.com/u/c38e94dcec65"</span>), Staff.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON from String to Object</span></span><br><span class="line">Staff obj = mapper.readValue(jsonInString, Staff.class);</span><br></pre></td></tr></table></figure><h3 id="Pojo"><a href="#Pojo" class="headerlink" title="Pojo"></a>Pojo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-和-JSON-的相互转换"><a href="#Java-和-JSON-的相互转换" class="headerlink" title="Java 和 JSON 的相互转换"></a>Java 和 JSON 的相互转换</h3><p>下面通过一个实例，说明如何使用 Jackson 实现JSON和Java对象相互转换。<br> Album 类，包含一个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Album</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Album</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-ObjectMapper-进行转换"><a href="#使用-ObjectMapper-进行转换" class="headerlink" title="使用 ObjectMapper 进行转换"></a>使用 ObjectMapper 进行转换</h4><p>Jackson 默认使用 BeanSerializer 序列化POJO，要求对应的字段为 public，或者有对应的 getter 方法。</p><p>输出：</p><blockquote><p>{“title”:”Kind Of Blue”}</p></blockquote><h4 id="数组序列化"><a href="#数组序列化" class="headerlink" title="数组序列化"></a>数组序列化</h4><p>现在继续向 Album 添加一个数组字段及对应的 getter 和 setter 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] links;</span><br><span class="line"><span class="keyword">public</span> String[] getLinks()&#123;</span><br><span class="line">    <span class="keyword">return</span> links;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLinks</span><span class="params">(String[] links)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.links = links;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Album album = <span class="keyword">new</span> Album(<span class="string">"Kind Of Blue"</span>);</span><br><span class="line">album.setLinks(<span class="keyword">new</span> String[]&#123;<span class="string">"link1"</span>, <span class="string">"link2"</span>&#125;);</span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">mapper.writeValue(System.out, album);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>{“title”:”Kind Of Blue”,”links”:[“link1”,”link2”]}</p></blockquote><h4 id="List-序列化"><a href="#List-序列化" class="headerlink" title="List 序列化"></a>List 序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; songs;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getSongs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> songs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSongs</span><span class="params">(List&lt;String&gt; songs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.songs = songs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Album album = <span class="keyword">new</span> Album(<span class="string">"Kind Of Blue"</span>);</span><br><span class="line">album.setLinks(<span class="keyword">new</span> String[]&#123;<span class="string">"link1"</span>, <span class="string">"link2"</span>&#125;);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; songs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">songs.add(<span class="string">"So what"</span>);</span><br><span class="line">songs.add(<span class="string">"Flamenco Sketches"</span>);</span><br><span class="line">songs.add(<span class="string">"Freddie Freeloader"</span>);</span><br><span class="line"></span><br><span class="line">album.setSongs(songs);</span><br><span class="line"></span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">mapper.writeValue(System.out, album);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>{“title”:”Kind Of Blue”,”links”:[“link1”,”link2”],”songs”:[“So what”,”Flamenco Sketches”,”Freddie Freeloader”]}</p></blockquote><p>从输出结构可以看到，List和数组的输出格式是一样的。</p><h4 id="Java-对象序列化"><a href="#Java-对象序列化" class="headerlink" title="Java 对象序列化"></a>Java 对象序列化</h4><p>Java 对象，序列化后在JSON中被 {} 括起来。<br> 定义Artist 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Artist</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Date birthDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Album 中添加对应的字段，并在 main 中设置其值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Artist artist = <span class="keyword">new</span> Artist();</span><br><span class="line">artist.name = <span class="string">"Miles Davis"</span>;</span><br><span class="line">SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd-MM-yyyy"</span>);</span><br><span class="line">artist.birthDate = format.parse(<span class="string">"26-05-1926"</span>);</span><br><span class="line">album.setArtist(artist);</span><br></pre></td></tr></table></figure><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>配置 ObjectMapper ，可以让输出更好看一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapper.configure(SerializationFeature.INDENT_OUTPUT, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>此时的JSON输出如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span> : <span class="string">"Kind Of Blue"</span>,</span><br><span class="line">  <span class="attr">"links"</span> : [ <span class="string">"link1"</span>, <span class="string">"link2"</span> ],</span><br><span class="line">  <span class="attr">"songs"</span> : [ <span class="string">"So what"</span>, <span class="string">"Flamenco Sketches"</span>, <span class="string">"Freddie Freeloader"</span> ],</span><br><span class="line">  <span class="attr">"artist"</span> : &#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Miles Davis"</span>,</span><br><span class="line">    <span class="attr">"birthDate"</span> : <span class="number">-1376035200000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Map-序列化"><a href="#Map-序列化" class="headerlink" title="Map 序列化"></a>Map 序列化</h4><p>向 Album 中添加如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; musicians = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getMusicians</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableMap(musicians);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMusician</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">    musicians.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main 中添加如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">album.addMusician(<span class="string">"Miles Davis"</span>, <span class="string">"Trumpet, Band leader"</span>);</span><br><span class="line">album.addMusician(<span class="string">"Julian Adderley"</span>, <span class="string">"Alto Saxophone"</span>);</span><br><span class="line">album.addMusician(<span class="string">"Paul Chambers"</span>, <span class="string">"double bass"</span>);</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span> : <span class="string">"Kind Of Blue"</span>,</span><br><span class="line">  <span class="attr">"links"</span> : [ <span class="string">"link1"</span>, <span class="string">"link2"</span> ],</span><br><span class="line">  <span class="attr">"songs"</span> : [ <span class="string">"So what"</span>, <span class="string">"Flamenco Sketches"</span>, <span class="string">"Freddie Freeloader"</span> ],</span><br><span class="line">  <span class="attr">"artist"</span> : &#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Miles Davis"</span>,</span><br><span class="line">    <span class="attr">"birthDate"</span> : <span class="number">-1376035200000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"musicians"</span> : &#123;</span><br><span class="line">    <span class="attr">"Miles Davis"</span> : <span class="string">"Trumpet, Band leader"</span>,</span><br><span class="line">    <span class="attr">"Paul Chambers"</span> : <span class="string">"double bass"</span>,</span><br><span class="line">    <span class="attr">"Julian Adderley"</span> : <span class="string">"Alto Saxophone"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>设置输出时间格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat outputFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd MMM yyyy"</span>);</span><br><span class="line">mapper.setDateFormat(outputFormat);</span><br></pre></td></tr></table></figure><p>让Map按序输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>此时输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span> : <span class="string">"Kind Of Blue"</span>,</span><br><span class="line">  <span class="attr">"links"</span> : [ <span class="string">"link1"</span>, <span class="string">"link2"</span> ],</span><br><span class="line">  <span class="attr">"songs"</span> : [ <span class="string">"So what"</span>, <span class="string">"Flamenco Sketches"</span>, <span class="string">"Freddie Freeloader"</span> ],</span><br><span class="line">  <span class="attr">"artist"</span> : &#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Miles Davis"</span>,</span><br><span class="line">    <span class="attr">"birthDate"</span> : <span class="string">"26 May 1926"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"musicians"</span> : &#123;</span><br><span class="line">    <span class="attr">"Julian Adderley"</span> : <span class="string">"Alto Saxophone"</span>,</span><br><span class="line">    <span class="attr">"Miles Davis"</span> : <span class="string">"Trumpet, Band leader"</span>,</span><br><span class="line">    <span class="attr">"Paul Chambers"</span> : <span class="string">"double bass"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Tree-Model-进行转换"><a href="#使用-Tree-Model-进行转换" class="headerlink" title="使用 Tree Model 进行转换"></a>使用 Tree Model 进行转换</h3><p>我们继续使用上面的例子，来演示 Tree Model 的使用。使用 Tree 进行输出包含如下几个步骤：</p><ul><li>创建 JsonNodeFactory，用于创建 node。</li><li>使用JsonFactory创建 JsonGenerator，并指定输出方法。</li><li>创建ObjectMapper，它使用 JsonGenerator 和树的根节点输出到JSON。</li></ul><p>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationExampleTreeModel</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        JsonNodeFactory factory = <span class="keyword">new</span> JsonNodeFactory(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        JsonFactory jsonFactory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">        JsonGenerator generator = jsonFactory.createGenerator(System.out);</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        ObjectNode album = factory.objectNode();</span><br><span class="line">        mapper.writeTree(generator, album);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有添加任何实质性内容，所以输出为：</p><blockquote><p>{}</p></blockquote><p>开始添加内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">album.put(<span class="string">"Album-Title"</span>, <span class="string">"Kind Of Blue"</span>);</span><br></pre></td></tr></table></figure><p>JSON:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"Album-Title"</span>:<span class="string">"Kind Of Blue"</span>&#125;</span><br></pre></td></tr></table></figure><p>添加数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayNode links = factory.arrayNode();</span><br><span class="line">links.add(<span class="string">"link1"</span>).add(<span class="string">"link2"</span>);</span><br><span class="line">album.set(<span class="string">"links"</span>, links);</span><br></pre></td></tr></table></figure><p>JSON:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"Album-Title"</span>:<span class="string">"Kind Of Blue"</span>,<span class="attr">"links"</span>:[<span class="string">"link1"</span>,<span class="string">"link2"</span>]&#125;</span><br></pre></td></tr></table></figure><p>添加对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectNode artist = factory.objectNode();</span><br><span class="line">artist.put(<span class="string">"Artist-Name"</span>, <span class="string">"Miles Davis"</span>);</span><br><span class="line">artist.put(<span class="string">"birthDate"</span>, <span class="string">"26 May 1926"</span>);</span><br><span class="line">album.set(<span class="string">"artist"</span>, artist);</span><br></pre></td></tr></table></figure><p>JSON:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"Album-Title"</span>:<span class="string">"Kind Of Blue"</span>,<span class="attr">"links"</span>:[<span class="string">"link1"</span>,<span class="string">"link2"</span>],<span class="attr">"artist"</span>:&#123;<span class="attr">"Artist-Name"</span>:<span class="string">"Miles Davis"</span>,<span class="attr">"birthDate"</span>:<span class="string">"26 May 1926"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>添加 musicians:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectNode musicians = factory.objectNode();</span><br><span class="line">musicians.put(<span class="string">"Julian Adderley"</span>, <span class="string">"Alto Saxophone"</span>);</span><br><span class="line">musicians.put(<span class="string">"Miles Davis"</span>, <span class="string">"Trumpet, Band leader"</span>);</span><br><span class="line">album.set(<span class="string">"musicians"</span>, musicians);</span><br></pre></td></tr></table></figure><p>JSON:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"Album-Title"</span>:<span class="string">"Kind Of Blue"</span>,<span class="attr">"links"</span>:[<span class="string">"link1"</span>,<span class="string">"link2"</span>],<span class="attr">"artist"</span>:&#123;<span class="attr">"Artist-Name"</span>:<span class="string">"Miles Davis"</span>,<span class="attr">"birthDate"</span>:<span class="string">"26 May 1926"</span>&#125;,<span class="attr">"musicians"</span>:&#123;<span class="attr">"Julian Adderley"</span>:<span class="string">"Alto Saxophone"</span>,<span class="attr">"Miles Davis"</span>:<span class="string">"Trumpet, Band leader"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="注解包"><a href="#注解包" class="headerlink" title="注解包"></a>注解包</h2><h3 id="JsonIgnoreProperties"><a href="#JsonIgnoreProperties" class="headerlink" title="@JsonIgnoreProperties"></a>@JsonIgnoreProperties</h3><p><strong>类注解</strong>, 作用是json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。用法很简单@JsonIgnoreProperties({“property1”,”property2”})，Hibernate延时加载</p><p>因为jsonplugin用的是java的内审机制.hibernate会给被管理的pojo加入一个 hibernateLazyInitializer属性,jsonplugin会把hibernateLazyInitializer也拿出来操作,并读取里面一个不能被反射操作的属性就产生了这个异常，可以用annotation来排除hibernateLazyInitializer这个属性。</p><h3 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a>@JsonIgnore</h3><p><strong>作用于属性或字段上</strong>，用来表明，当生成json的时候忽略有该annotation的方法或字段</p><h3 id="JsonProperty-“firstName”"><a href="#JsonProperty-“firstName”" class="headerlink" title="@JsonProperty(“firstName”)"></a>@JsonProperty(“firstName”)</h3><p>作用于属性或字段上，重命名</p><h3 id="JsonFormat"><a href="#JsonFormat" class="headerlink" title="@JsonFormat"></a>@JsonFormat</h3><p>作用于属性或者字段上，方便的把Date类型直接转化为我们想要的模式，如@JsonFormat(pattern =”yyyy-MM-dd HH-mm-ss”)</p><h3 id="JsonSerialize"><a href="#JsonSerialize" class="headerlink" title="@JsonSerialize"></a>@JsonSerialize</h3><p>作用于属性或者字段上，指定序列化方式 @JsonSerialize(as=BasicType.class) 将类型序列化成指定类型 @JsonSerialize(using=CustomDoubleSerialize.class) 作用于属性或者字段上，用于在序列化时嵌入我们自定义的代码，比如序列化一个double<strong>时在其后面限制两位小数点。</strong></p><p>@JsonSerialize(using= CustomDoubleSerialize.class) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publicclass CustomDateDeserialize extends JsonDeserializer&lt;Date&gt; &#123;</span><br><span class="line">         <span class="keyword">private</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Date <span class="title">deserialize</span><span class="params">(JsonParser jp,DeserializationContext ctxt)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> IOException,JsonProcessingException </span>&#123;</span><br><span class="line">                   Date date = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                            date =sdf.parse(jp.getText());</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> date;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JsonDeserialize"><a href="#JsonDeserialize" class="headerlink" title="@JsonDeserialize"></a>@JsonDeserialize</h3><p>作用于属性或者字段上，指定反序列化方式 @JsonDeserialize(as=ValueImpl.class) 将类型反序列化成指定类型 @JsonDeserialize(using= CustomDateDeserialize.class) 用于在反序列化时嵌入我们自定义的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">publicclass CustomDateDeserialize extends JsonDeserializer&lt;Date&gt; &#123;</span><br><span class="line">         <span class="keyword">private</span> SimpleDateFormat sdf = newSimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Date <span class="title">deserialize</span><span class="params">(JsonParser jp,DeserializationContext ctxt)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> IOException,JsonProcessingException </span>&#123;</span><br><span class="line">                   Date date = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                            date =sdf.parse(jp.getText());</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> date;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JsonCreator"><a href="#JsonCreator" class="headerlink" title="@JsonCreator"></a>@JsonCreator</h3><p>作用于使用构造器方法或工厂方法 ，指定反序列化时创建实例方式(默认使用无参数构造器)</p><p>采用构造器方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publicclass MyBean &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@JsonCreator</span></span><br><span class="line"></span><br><span class="line">  publicMyBean(<span class="meta">@JsonProperty</span>(<span class="string">"value"</span>) <span class="keyword">int</span> v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = v;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用相同的方式，可以将@JsonCreator用在静态工厂方法上</p><p>不过，还有一个可选的替代方案，被称作“授权式”构建器（“delegating” creator）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingPOJO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> _x, _y;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JsonCreator</span></span><br><span class="line">   publicDelegatingPOJO(Map&lt;String,Object&gt; delegate) &#123;</span><br><span class="line">      _x = (Integer)delegate.get(<span class="string">"x"</span>);</span><br><span class="line">      _y = (Integer)delegate.get(<span class="string">"y"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JsonTypeInfo"><a href="#JsonTypeInfo" class="headerlink" title="@JsonTypeInfo"></a>@JsonTypeInfo</h3><p>类注解，当输出操作的对象拥有多个子类型且在反序列化时需要添加子类对象的类型信息，使用此注解可以正确地设置子类对象的类型</p><p>@JsonTypeInfo(use=Id.CLASS,include=As.PROPERTY,property=”class”)</p><p>子类类型作为属性,属性名为class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"animals"</span>: [ &#123;</span><br><span class="line">    <span class="string">"class"</span> :<span class="string">"jackson.Lion"</span>,</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"Simba"</span>,</span><br><span class="line">    <span class="string">"sound"</span> : <span class="string">"Roar"</span>,</span><br><span class="line">    <span class="string">"type"</span> : <span class="string">"carnivorous"</span>,</span><br><span class="line">    <span class="string">"endangered"</span> : <span class="keyword">true</span></span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use=Id.CLASS,include= As.WRAPPER_OBJECT)</span><br><span class="line"><span class="string">"animals"</span>: [ &#123;</span><br><span class="line">    <span class="string">"jackson.Lion"</span> : &#123;</span><br><span class="line">      <span class="string">"name"</span> : <span class="string">"Simba"</span>,</span><br><span class="line">      <span class="string">"sound"</span> : <span class="string">"Roar"</span>,</span><br><span class="line">      <span class="string">"type"</span> :<span class="string">"carnivorous"</span>,</span><br><span class="line">      <span class="string">"endangered"</span> : <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;]</span><br></pre></td></tr></table></figure><h3 id="JsonAutoDetect"><a href="#JsonAutoDetect" class="headerlink" title="@JsonAutoDetect"></a>@JsonAutoDetect</h3><p>类注解，指定属性发现规则</p><p>Jackson默认的属性发现规则将会查找到如下所述的属性：</p><p>•所有被public修饰的字段（成员变量）；</p><p>•所有被public修饰的getter（即形如“getXxx()”的方法）；</p><p>•所有被public修饰的setter（即形如“setXxx(value)”的方法）</p><p>@JsonAutoDetect(fieldVisibility=JsonAutoDetect.Visibility.ANY)</p><p>@JsonAutoDetect(fieldVisibility=JsonAutoDetect.Visibility.NONE)</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gj33mj14koj20lm0a20tj.jpg&quot; alt=&quot;WX20200925-185945@2x.png&quot; style=&quot;zoom:50%;&quot;&gt;</summary>
    
    
    
    
    <category term="Jackson" scheme="http://yoursite.com/tags/Jackson/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2020/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-09-21T15:19:21.000Z</published>
    <updated>2021-01-28T09:04:55.750Z</updated>
    
    <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/bec9bff2gy1giyopdjjcuj20y00b1abn.jpg" alt="微信截图_20200921232226.png" style="zoom: 50%;"><blockquote><p>设计模式</p></blockquote><p>设计模式也是一个重要环节，值得花时间在上面。</p><a id="more"></a> <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="Adapter模式"><a href="#Adapter模式" class="headerlink" title="Adapter模式"></a>Adapter模式</h2><p>Adapter模式即适配器模式，对于适配器的理解参考现实生活中把交流电转换成直流电的电源适配器，用于填补<strong>现有的程序</strong>和<strong>所需的程序</strong>之间差异的设计模式就是Adapter模式，有以下两种实现方式：</p><p> 1. 类适配器模式（使用继承的适配器）<br> 2. 对象适配器模式（使用委托的适配器）<br>所谓继承和委托的区别在哪呢？<strong>委托是指将某个方法中的实际处理交给其他实例的方法</strong>，继承则是自己进行处理，下面分别看下两种实现方式：</p><p>这里有一个需要被适配的Banner类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被适配角色：交流100福特电源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guozhenZhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年6月21日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.string = string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"("</span>+ string +<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*"</span>+ string +<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1giyopdjjcuj20y00b1abn.jpg&quot; alt=&quot;微信截图_20200921232226.png&quot; style=&quot;zoom: 50%;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;设计模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设计模式也是一个重要环节，值得花时间在上面。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2020/09/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/09/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-09-19T02:10:25.000Z</published>
    <updated>2021-01-28T08:59:56.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210128165843.png" alt="image-20210128165843222"></p><blockquote><p> 正则表达式，学一次忘一次，记录之。</p></blockquote><a id="more"></a> <h1 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h1><blockquote><p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1givrsiqe4xj20hl0bsq37.jpg" alt="undefined"></p><p>以上的正则表达式可以接受 <code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。 但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p><h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1.基本匹配"></a>1.基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。 例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;the&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2.元字符"></a>2.元字符</h2><p>元字符不代表他们本身的字面意思，他们都有特殊的含义。</p><p>一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>句号匹配任意单个字符除了换行符。</td></tr><tr><td>[ ]</td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr><td>[^ ]</td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td>*</td><td>匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr><td>+</td><td>匹配&gt;=1个重复的+号前的字符。</td></tr><tr><td>?</td><td>标记?之前的字符为可选.</td></tr><tr><td>{n,m}</td><td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td></tr><tr><td>(xyz)</td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td>|</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td>\</td><td>转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td></tr><tr><td>^</td><td>从开始行开始匹配.</td></tr><tr><td>$</td><td>从末端开始匹配.</td></tr></tbody></table><h3 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a>2.1 点运算符 <code>.</code></h3><p><code>.</code>是元字符中最简单的例子。 <code>.</code>匹配任意单个字符，但不匹配换行符。 例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;.ar&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure><h3 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h3><p>字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[Tt]he&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure><p>方括号的句号就表示句号。 表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ar[.]&quot; =&gt; A garage is a good place to park a car.</span><br></pre></td></tr></table></figure><h4 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h4><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[^c]ar&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure><h3 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a>2.3 重复次数</h3><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。</p><h4 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a>2.3.1 <code>*</code> 号</h4><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。 例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[a-z]*&quot; =&gt; The car parked in the garage #21.</span><br></pre></td></tr></table></figure><p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。 <code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\s*cat\s*&quot; =&gt; The fat cat sat on the concatenation.</span><br></pre></td></tr></table></figure><h4 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a>2.3.2 <code>+</code> 号</h4><p><strong><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。</strong> 例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;c.+t&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h4 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a>2.3.3 <code>?</code> 号</h4><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[T]he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[T]?he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h3 id="2-4-号"><a href="#2-4-号" class="headerlink" title="2.4 {} 号"></a>2.4 <code>{}</code> 号</h3><p>在正则表达式中 <code>{}</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,3&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure><p>我们可以省略第二个参数。 例如，<code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,&#125;&quot; =&gt; The number was 9.9997 but we rounded it of</span><br></pre></td></tr></table></figure><p>如果逗号也省略掉则表示重复固定的次数。 例如，<code>[0-9]{3}</code> 匹配3位数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;3&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure><h3 id="2-5-特征标群"><a href="#2-5-特征标群" class="headerlink" title="2.5 (...) 特征标群"></a>2.5 <code>(...)</code> 特征标群</h3><p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, <strong>表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。</strong>再比如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>{}</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p><p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(c|g|p)ar&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h3 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a>2.6 <code>|</code> 或运算符</h3><p>或运算符就表示或，用作判断条件。</p><p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he|car&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h3 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a>2.7 转码特殊字符</h3><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p><p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(f|c|m)at\.?&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h3 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a>2.8 锚点</h3><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p><h4 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a>2.8.1 <code>^</code> 号</h4><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p><p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;^(T|t)he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h4 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a>2.8.2 <code>$</code> 号</h4><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p><p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(at\.)&quot; =&gt; The fat cat. sat. on the mat.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(at\.)$&quot; =&gt; The fat cat. sat. on the mat.</span><br></pre></td></tr></table></figure><h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式提供一些常用的字符集简写。如下:</p><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>除换行符外的所有字符</td></tr><tr><td>\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td>\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td>\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td>\s</td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p{Z}]</code></td></tr><tr><td>\S</td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符</td></tr><tr><td>\p</td><td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><hr><blockquote><p>进阶内容：</p></blockquote><h2 id="4-零宽断言"><a href="#4-零宽断言" class="headerlink" title="4.零宽断言"></a>4.零宽断言</h2><blockquote><p>无论是零宽还是断言，听起来都古古怪怪的，<br>那先解释一下这两个词。</p></blockquote><ol><li><p>断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，<br>意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”,正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.</p></li><li><p>零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</p></li></ol><p>假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1   &quot;&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;&quot;</span><br></pre></td></tr></table></figure><p>其中也就‘641’这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果正则应该怎么匹配呢？</p><p>下面先来讲几种类型的断言：</p><ol><li>正向先行断言（正前瞻）：</li></ol><ul><li>语法：（?=pattern）<br>作用：匹配pattern表达式的前面内容，不返回本身。</li></ul><p>这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到<code>&lt;/span&gt;</code>前面的数字内容</p><p>按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=) 就可以匹配到前面的内容了。</p><p>匹配什么内容呢？如果要所有内容那就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">".+(?=&lt;/span&gt;)"</span>;</span><br><span class="line"></span><br><span class="line">String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=  pattern.matcher(test);</span><br><span class="line"><span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">System.out.println(<span class="string">"匹配结果："</span>);</span><br><span class="line">System.out.println(mc.group());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配结果：</span></span><br><span class="line"><span class="comment">//&lt;span class="read-count"&gt;阅读数：641</span></span><br></pre></td></tr></table></figure><p>可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"\\d+(?=&lt;/span&gt;)"</span>;</span><br><span class="line"></span><br><span class="line">String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=  pattern.matcher(test);</span><br><span class="line"><span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">  System.out.println(mc.group());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配结果：</span></span><br><span class="line"><span class="comment">//641</span></span><br></pre></td></tr></table></figure><ol start="2"><li>正向后行断言（正后顾）:</li></ol><ul><li><p>语法：（?&lt;=pattern）</p><p>作用：匹配pattern表达式的后面的内容，不返回本身。</p></li></ul><p>有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。<br>上面的栗子，我们也可以用后行断言来处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(?&lt;=&lt;span class="read-count"&gt;阅读数：)\d+</span></span><br><span class="line">String reg=<span class="string">"(?&lt;=&lt;span class=\"read-count\"&gt;阅读数：)\\d+"</span>;</span><br><span class="line"></span><br><span class="line">String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=    pattern.matcher(test);</span><br><span class="line">     <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">       System.out.println(mc.group());</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//匹配结果：</span></span><br><span class="line"><span class="comment">//641</span></span><br></pre></td></tr></table></figure><p>就这么简单。</p><ol start="3"><li>负向先行断言（负前瞻）</li></ol><ul><li>语法：(?!pattern)</li><li>作用：匹配非pattern表达式的前面内容，不返回本身。</li></ul><p>有正向也有负向，负向在这里其实就是非的意思。<br>举个栗子：<strong>比如有一句 “我爱祖国，我是祖国的花朵”</strong><br><strong>现在要找到不是’的花朵’前面的祖国</strong><br>用正则就可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">祖国(?!的花朵)</span><br></pre></td></tr></table></figure><ol start="4"><li>负向后行断言（负后顾）</li></ol><ul><li>语法：(?&lt;!pattern)</li><li>作用：匹配非pattern表达式的后面内容，不返回本身。</li></ul><h2 id="5-捕获和非捕获"><a href="#5-捕获和非捕获" class="headerlink" title="5. 捕获和非捕获"></a>5. 捕获和非捕获</h2><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”</p><blockquote><p>捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。</p></blockquote><p>而根据命名方式的不同，又可以分为两种组：</p><ol><li>数字编号捕获组：<br>语法：(exp)<br>解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。<br>比如固定电话的：020-85653333<br>他的正则表达式为：(0\d{2})-(\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</li></ol><table><thead><tr><th>序号</th><th>编号</th><th>分组</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>(0\d{2})-(\d{8})</td><td>020-85653333</td></tr><tr><td>1</td><td>1</td><td>(0\d{2})</td><td>020</td></tr><tr><td>2</td><td>2</td><td>(\d{8})</td><td>85653333</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"020-85653333"</span>;</span><br><span class="line">     String reg=<span class="string">"(0\\d&#123;2&#125;)-(\\d&#123;8&#125;)"</span>;</span><br><span class="line">     Pattern pattern = Pattern.compile(reg);</span><br><span class="line">     Matcher mc= pattern.matcher(test);</span><br><span class="line">     <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line">       System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mc.groupCount();i++)&#123;</span><br><span class="line">             System.out.println(<span class="string">"第"</span>+i+<span class="string">"个分组为："</span>+mc.group(i));</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">第0个分组为：020-85653333</span><br><span class="line">第1个分组为：020</span><br><span class="line">第2个分组为：85653333</span><br></pre></td></tr></table></figure><p>可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。</p><ol start="2"><li>命名编号捕获组：<br>语法：(?<name>exp)<br>解释：分组的命名由表达式中的name指定<br>比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</haoma></quhao></name></li></ol><table><thead><tr><th>序号</th><th>编号</th><th>分组</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>(0\d{2})-(\d{8})</td><td>020-85653333</td></tr><tr><td>1</td><td>quhao</td><td>(0\d{2})</td><td>020</td></tr><tr><td>2</td><td>haoma</td><td>(\d{8})</td><td>85653333</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"020-85653333"</span>;</span><br><span class="line">     String reg=<span class="string">"(?&lt;quhao&gt;0\\d&#123;2&#125;)-(?&lt;haoma&gt;\\d&#123;8&#125;)"</span>;</span><br><span class="line">     Pattern pattern = Pattern.compile(reg);</span><br><span class="line">     Matcher mc= pattern.matcher(test);</span><br><span class="line">     <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line">         System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line">         System.out.println(mc.group(<span class="string">"quhao"</span>));</span><br><span class="line">         System.out.println(mc.group(<span class="string">"haoma"</span>));</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">分组名称为:quhao,匹配内容为：020</span><br><span class="line">分组名称为:haoma,匹配内容为：85653333</span><br></pre></td></tr></table></figure><ol start="3"><li>非捕获组：<br>语法：(?:exp)<br>解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。</li></ol><p>比如上面的正则表达式，程序<strong>不需要用到第一个分组</strong>，那就可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?:\0\d&#123;2&#125;)-(\d&#123;8&#125;)</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>编号</th><th>分组</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>(0\d{2})-(\d{8})</td><td>020-85653333</td></tr><tr><td>1</td><td>1</td><td>(\d{8})</td><td>85653333</td></tr></tbody></table><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：1</span><br><span class="line">第0个分组为：020-85653333</span><br><span class="line">第1个分组为：85653333</span><br></pre></td></tr></table></figure><h2 id="6-反向引用"><a href="#6-反向引用" class="headerlink" title="6.反向引用"></a>6.反向引用</h2><p>上面讲到捕获，我们知道：**<em>捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用**</em>。</p><p>根据捕获组的命名规则，反向引用可分为：</p><ol><li>数字编号组反向引用：\k<br>或\number</li><li>命名编号组反向引用：\k<br>或者&#39;name’</li></ol><p>上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用<br>注意两个字眼：“内容” 和 “使用”<br>这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住<br>那这里所说的“使用”是怎样使用呢？</p><ul><li>1）匹配到一个字母</li><li>2）匹配第下一个字母，检查是否和上一个字母是否一样</li><li>3）如果一样，则匹配成功，否则失败</li></ul><p>首先匹配一个字母：\w<br>我们需要做成分组才能捕获，因此写成这样：(\w)</p><p>那这个表达式就有一个捕获组：（\w）<br>然后我们要用这个捕获组作为条件，那就可以：(\w)\1<br>这样就大功告成了<br>可能有人不明白了，\1是什么意思呢？<br>还记得捕获组有两种命名方式吗，<strong>一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名</strong><br>在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的</p><p>因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k&lt;1&gt;或者\1<br>当然，通常都是是后者。<br>我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"aabbbbgbddesddfiid"</span>;</span><br><span class="line">     Pattern pattern = Pattern.compile(<span class="string">"(\\w)\\1"</span>);</span><br><span class="line">     Matcher mc= pattern.matcher(test);</span><br><span class="line">     <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">         System.out.println(mc.group());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">bb</span><br><span class="line">dd</span><br><span class="line">dd</span><br><span class="line">ii</span><br></pre></td></tr></table></figure><p>嗯，这就是我们想要的了。</p><p>在举个替换的例子，假如想要把字符串中abc换成a</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"abcbbabcbcgbddesddfiid"</span>;</span><br><span class="line">String reg=<span class="string">"(a)(b)c"</span>;</span><br><span class="line">System.out.println(test.replaceAll(reg, <span class="string">"$1"</span>));</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abbabcgbddesddfiid</span><br></pre></td></tr></table></figure><h2 id="7-贪婪和非贪婪"><a href="#7-贪婪和非贪婪" class="headerlink" title="7.贪婪和非贪婪"></a>7.贪婪和非贪婪</h2><p>我们都知道，贪婪就是不满足，尽可能多的要。<br>在正则中，贪婪也是差不多的意思:</p><blockquote><p>贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。<br>特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。</p></blockquote><p>前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;3,6&#125;</span><br></pre></td></tr></table></figure><p>用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"\\d&#123;3,6&#125;"</span>;        </span><br><span class="line">String test=<span class="string">"61762828 176 2991 871"</span>;</span><br><span class="line">System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line">System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line">Pattern p1 =Pattern.compile(reg);</span><br><span class="line">Matcher m1 = p1.matcher(test);</span><br><span class="line"> <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line">   System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文本：61762828 176 2991 44 871</span><br><span class="line">贪婪模式：\d&#123;3,6&#125;</span><br><span class="line">匹配结果：617628</span><br><span class="line">匹配结果：176</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：871</span><br></pre></td></tr></table></figure><p>由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。<br>一个量词就如此贪婪了，<br>那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？</p><blockquote><p>是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"(\\d&#123;1,2&#125;)(\\d&#123;3,4&#125;)"</span>;        </span><br><span class="line">String test=<span class="string">"61762828 176 2991 87321"</span>;</span><br><span class="line">System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line">System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line">Pattern p1 =Pattern.compile(reg);</span><br><span class="line">Matcher m1 = p1.matcher(test);</span><br><span class="line"> <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line">   System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>“617628” 是前面的\d{1,2}匹配出了61，后面的匹配出了7628</li><li>“2991” 是前面的\d{1,2}匹配出了29 ，后面的匹配出了91</li><li>“87321”是前面的\d{1,2}匹配出了87，后面的匹配出了321</li></ol><p><strong>2. 懒惰（非贪婪）</strong></p><blockquote><p>懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。<br>特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。</p></blockquote><p>懒惰量词是在贪婪量词后面加个“？”</p><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+?</td><td>重复1次或者更多次，但尽可能减少重复</td></tr><tr><td>??</td><td>重复0次或者1次，但尽可能减少重复</td></tr><tr><td>(n,m)?</td><td>重复n到m次，尽可能减少重复</td></tr><tr><td>(n,)?</td><td>重复n次以上，但尽可能减少重复</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"(\\d&#123;1,2&#125;?)(\\d&#123;3,4&#125;)"</span>;        </span><br><span class="line">     String test=<span class="string">"61762828 176 2991 87321"</span>;</span><br><span class="line">     System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line">     System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line">     Pattern p1 =Pattern.compile(reg);</span><br><span class="line">     Matcher m1 = p1.matcher(test);</span><br><span class="line">     <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line">         System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文本：61762828 176 2991 87321</span><br><span class="line">贪婪模式：(\d&#123;1,2&#125;?)(\d&#123;3,4&#125;)</span><br><span class="line">匹配结果：61762</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：87321</span><br></pre></td></tr></table></figure><blockquote><p>“61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762<br>“2991” 是左边的懒惰匹配出2，右边的贪婪匹配出991<br>“87321” 左边的懒惰匹配出8，右边的贪婪匹配出7321</p></blockquote><h2 id="8-反义"><a href="#8-反义" class="headerlink" title="8.反义"></a>8.反义</h2><p>前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：</p><table><thead><tr><th>字符</th><th>解释</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了x以外的任意字符</td></tr><tr><td>[^aeiou]</td><td>匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210128165843.png&quot; alt=&quot;image-20210128165843222&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 正则表达式，学一次忘一次，记录之。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Regex" scheme="http://yoursite.com/tags/Regex/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2020/09/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/09/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-09-05T15:30:58.000Z</published>
    <updated>2021-01-28T10:04:40.629Z</updated>
    
    <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210128180320.png" style="zoom: 67%;"><p>终于到经典的动态规划问题，希望能顺利拿下。</p><a id="more"></a> <h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><strong>首先，动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离等等。</p><p>既然是要求最值，求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p><p>动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p><p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p><p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p><p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因。</p><p>提供一个思维框架，辅助思考状态转移方程：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] = base</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] = 求最值(选择1，选择2...)</span><br></pre></td></tr></table></figure><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gikkkp114ij20g60dcjsi.jpg" alt="{B0242798-1A3E-4D63-B93D-D09AB2CBEFC4}_20200909182025.jpg"></p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p><p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p>递归算法的时间复杂度怎么计算？就是用<strong>子问题个数乘以解决一个子问题需要的时间</strong>。</p><p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><p><strong>带备忘录的递归</strong></p><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><h3 id="DP-数组的迭代解法"><a href="#DP-数组的迭代解法" class="headerlink" title="DP 数组的迭代解法"></a>DP 数组的迭代解法</h3><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gilbzj0oe5j20zk0k0whe.jpg" alt="undefined"></p><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gilc0f38y1j20cw02p3yb.jpg" alt="undefined"></p><p>为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p><h3 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h3><p>上面的斐波那契数列很好理解，这个凑零钱问题，理解难度也并不是很高，但是这个凑零钱问题的代码如果直接接触的话会有点难度。</p><p>先看下题目：给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。</p><p>那么那么首先理一下思路，递归的思路如下，我们在这使用递归先解一遍。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gimhknub0vj20j009caba.jpg" alt="undefined"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coin2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> amount = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="keyword">new</span> Coin2().coinChange(coins, amount);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coins.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(coins, amount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (res == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            res = Math.min(res, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">            helper(coins, amount - coins[i], count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样解有个很大的问题，很明显的，这里的时间复杂度已经到了令人无法接受的程度，用时非常非常久。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> amount = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>如果用100来试最小硬币的耗时已经到了使用小时为单位的程度。</p><p>为了优化，接下来使用记忆化递归。</p><p>我们对其进行优化，进行记忆化递归，记忆化递归就是将已运算的结果进行存储，如上图我们对剩9元进行存储，在下次遍历到剩9元硬币时就可以直接返回结果，不必再次遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/11 11:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coin3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> amount = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="keyword">new</span> Coin3().coinChange(coins, amount);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(coins, amount, <span class="keyword">new</span> <span class="keyword">int</span>[amount]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span>[] res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res[amount - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res[amount - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ress = helper(coins, amount - coins[i], res);</span><br><span class="line">            <span class="keyword">if</span> (ress &gt;= <span class="number">0</span> &amp;&amp; ress &lt; min) &#123;</span><br><span class="line">                min = ress + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[amount - <span class="number">1</span>] = min == Integer.MAX_VALUE ? -<span class="number">1</span> : min;</span><br><span class="line">        System.out.println(<span class="string">"index = "</span> + (amount-<span class="number">1</span>) + <span class="string">"的时候，值是"</span>+ res[amount - <span class="number">1</span>] );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[amount - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面最重要的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> ress = helper(coins, amount - coins[i], res);</span><br><span class="line">    <span class="keyword">if</span> (ress &gt;= <span class="number">0</span> &amp;&amp; ress &lt; min) &#123;</span><br><span class="line">        min = ress + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是状态转移方程</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gimp0dfjubj20iy03jdfp.jpg" alt="undefined"></p><p>只要用这个方程的角度来理解这个代码就很好理解，</p><p>外面一层For是用来遍历coins的，然后里面就是递归到最后求值，整个程序的执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C:\Env\jdk1.8.0_144\bin\java.exe &quot;-javaagent:C:\App\IntelliJ IDEA </span><br><span class="line">index = 0的时候，值是1</span><br><span class="line">index = 1的时候，值是1</span><br><span class="line">index = 2的时候，值是2</span><br><span class="line">index = 3的时候，值是2</span><br><span class="line">index = 4的时候，值是1</span><br><span class="line">index = 5的时候，值是2</span><br><span class="line">index = 6的时候，值是2</span><br><span class="line">index = 7的时候，值是3</span><br><span class="line">index = 8的时候，值是3</span><br><span class="line">index = 9的时候，值是2</span><br><span class="line">index = 10的时候，值是3</span><br><span class="line">1599804625398</span><br><span class="line">200</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>整个程序从最里面，amount最小的值开始往字典上面记录，然后到最后结束。</p><p>下面第三种解法，动态规划解法。</p><p>动态规划解法也就是自底向上，动态规划就是将前面计算的结果拿来给后面用，因此如何定义就是一个问题，在这个问题中，我们定义数组res【amount+1】，数组代表数组下标对应的硬币元数所需的最小个数的合集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/11 14:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coin4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> amount = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="keyword">new</span> Coin4().coinChange(coins, amount);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  对于题意，对于任意给出的数来说，需要的硬币数量 &gt; 这个数本身必定是最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  dp的函含义是     对于每个index为amount的钱，value总是其需要的最小硬币数量、</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//  对dp的每个值进行填充</span></span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        <span class="comment">//  0元需要0个硬币来兑换</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//  外层是 amount的遍历，从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="comment">// 内层遍历的是 硬币的种类</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="comment">/** 这个判断要思考一下，比如说  i = 1的时候，</span></span><br><span class="line"><span class="comment">                 *  coins[j] 前后分别是 1，2，5</span></span><br><span class="line"><span class="comment">                 *  如果coins &lt;= j 的时候也就是说，当硬币面额小于余额的时候才会判断。</span></span><br><span class="line"><span class="comment">                 *  这个时候读取了 dp[0]的值，dp[1] = dp[0] + 1</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 *  当数组比较大(大于最大值的硬币)的时候，这个判断有点类似于没用了，</span></span><br><span class="line"><span class="comment">                 *  后面进行的的判断，会把dp[i]中每个硬币的组合都判断一遍。同时更新到了数组里面，取最小值</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  最后返回了数组。</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这个时候本文仅仅引入了状态转移方程这一个概念，下面从动态规划的角度讲一下这题。</p><p>这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。啥叫相互独立？用一个直观的例子来讲解。</p><p>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p><p>PS：关于最优子结构的问题，后文还会再举例探讨。</p><p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p><p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p><p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p><p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p><p>4、<strong>明确</strong> <strong><code>dp</code></strong> <strong>函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 <code>dp</code> 函数：</p><p><code>dp(n)</code> 的定义：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</p><p>搞清楚上面这几个关键点，解法的伪码就可以写出来了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪码框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义：要凑出金额 n，至少要 dp(n) 个硬币</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 做选择，选择需要硬币最少的那个结果</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            res = min(res, <span class="number">1</span> + dp(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 题目要求的最终结果是 dp(amount)</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gimp833eibj20iy03jdfp.jpg" alt="undefined"></p><p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p><p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p><p><strong>2、带备忘录的递归</strong></p><p>类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line">    <span class="comment"># 备忘录</span></span><br><span class="line">    memo = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 查备忘录，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记入备忘录</span></span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><p><strong>3、dp 数组的迭代解法</strong></p><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p><p><strong><code>dp</code></strong> <strong>数组的定义：当目标金额为</strong> <strong><code>i</code></strong> <strong>时，至少需要</strong> <strong><code>dp[i]</code></strong> <strong>枚硬币凑出</strong>。</p><p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, amount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p><p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p><p>之后我们会有一章专门讲解动态规划问题，如果有任何问题都可以随时回来重读本文，希望读者在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>下面主要讲两个常见问题：</p><p>1、到底什么才叫「最优子结构」，和动态规划什么关系。</p><p>2、为什么动态规划遍历<code>dp</code>数组的方式五花八门，有的正着遍历，有的倒着遍历，有的斜着遍历，有的无论咋遍历都是对的。</p><h4 id="一、最优子结构详解"><a href="#一、最优子结构详解" class="headerlink" title="一、最优子结构详解"></a>一、最优子结构详解</h4><p>「最优子结构」是某些问题的一种特定性质，并不是动态规划问题专有的。也就是说，很多问题其实都具有最优子结构，只是其中大部分不具有<strong>重叠子</strong>问题，所以我们不把它们归为动态规划系列问题而已。</p><p>我先举个很容易理解的例子：假设你们学校有 10 个班，你已经计算出了每个班的最高考试成绩。那么现在我要求你计算全校最高的成绩，你会不会算？当然会，而且你不用重新遍历全校学生的分数进行比较，而是只要在这 10 个最高成绩中取最大的就是全校的最高成绩。</p><p>这个问题就<strong>符合最优子结构</strong>：可以从子问题的最优结果推出更大规模问题的最优结果。让你算<strong>每个班</strong>的最优成绩就是子问题，你知道所有子问题的答案后，就可以借此推出<strong>全校</strong>学生的最优成绩这个规模更大的问题的答案。</p><p>你看，这么简单的问题都有最优子结构性质，只是因为显然没有重叠子问题，所以我们简单地求最值肯定用不出动态规划。</p><p>再举个例子：假设你们学校有 10 个班，你已知每个班的最大分数差（最高分和最低分的差值）。那么现在我让你计算全校学生中的最大分数差，你会不会算？可以想办法算，但是肯定不能通过已知的这 10 个班的最大分数差推到出来。因为这 10 个班的最大分数差不一定就包含全校学生的最大分数差，比如全校的最大分数差可能是 3 班的最高分和 6 班的最低分之差。</p><p>这次我给你提出的问题就<strong>不符合最优子结构</strong>，因为你没办通过每个班的最优值推出全校的最优值，没办法通过子问题的最优值推出规模更大的问题的最优值。</p><p>想满足最优子结，子问题之间必须互相独立。全校的最大分数差可能出现在两个班之间，显然子问题不独立，所以这个问题本身不符合最优子结构。</p><p><strong>那么遇到这种最优子结构失效情况，怎么办？策略是：改造问题</strong>。对于最大分数差这个问题，我们不是没办法利用已知的每个班的分数差吗，那我只能这样写一段暴力代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Student a : school) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Student b : school) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a is b) <span class="keyword">continue</span>;</span><br><span class="line">        result = max(result, |a.score - b.score|);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>改造问题，也就是把问题等价转化：最大分数差，不就等价于最高分数和最低分数的差么，那不就是要求最高和最低分数么，不就是我们讨论的第一个问题么，不就具有最优子结构了么？那现在改变思路，借助最优子结构解决最值问题，再回过头解决最大分数差问题，是不是就高效多了？</p><p>当然，上面这个例子太简单了，不过请读者回顾一下，我们做动态规划问题，是不是一直在求各种最值，本质跟我们举的例子没啥区别，无非需要处理一下重叠子问题。</p><p>再举个常见但也十分简单的例子，求一棵二叉树的最大值，不难吧（简单起见，假设节点中的值都是非负数）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxVal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = maxVal(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = maxVal(root.right);</span><br><span class="line">    <span class="keyword">return</span> max(root.val, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看这个问题也符合最优子结构，以<code>root</code>为根的树的最大值，可以通过两边子树（子问题）的最大值推导出来，结合刚才学校和班级的例子，很容易理解吧。</p><p>当然这也不是动态规划问题，旨在说明，最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；</p><p><strong>但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的</strong>，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路。</p><p>动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，不断以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。</p><p>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路。</p><h4 id="二、dp-数组的遍历方向"><a href="#二、dp-数组的遍历方向" class="headerlink" title="二、dp 数组的遍历方向"></a>二、dp 数组的遍历方向</h4><p>做动态规划问题时，肯定会对<code>dp</code>数组的遍历顺序有些头疼。我们拿二维<code>dp</code>数组来举例，有时候我们是正向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[][] dp = new int[m][n];</span><br><span class="line">for (int i = 0; i &lt; m; i++)</span><br><span class="line">    for (int j = 0; j &lt; n; j++)</span><br><span class="line">        // 计算 dp[i][j]</span><br></pre></td></tr></table></figure><p>有时候我们反向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = m - 1; i &gt;= 0; i--)</span><br><span class="line">    for (int j = n - 1; j &gt;= 0; j--)</span><br><span class="line">        // 计算 dp[i][j]</span><br></pre></td></tr></table></figure><p>有时候可能会斜向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 斜着遍历数组</span><br><span class="line">for (int l = 2; l &lt;= n; l++) &#123;</span><br><span class="line">    for (int i = 0; i &lt;= n - l; i++) &#123;</span><br><span class="line">        int j = l + i - 1;</span><br><span class="line">        // 计算 dp[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至更让人迷惑的是，有时候发现正向反向遍历都可以得到正确答案，比如我们在 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect" target="_blank" rel="noopener">团灭 LeetCode 股票买卖问题</a> 中有的地方就正反皆可。</p><p>如果仔细观察的话可以发现其中的原因的:</p><p><strong>1、遍历的过程中，所需的状态必须是已经计算出来的</strong>。</p><p><strong>2、遍历的终点必须是存储结果的那个位置</strong>。</p><p>下面来具体解释上面两个原则是什么意思。</p><p>比如编辑距离这个经典的问题，详解见前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484484&idx=1&sn=74594297022c84952162a68b7f739133&chksm=9bd7fa4caca0735a1364dd13901311ecd6ec4913c8db05a1ff6cae8f069627eebe8d651bbeb1&scene=21#wechat_redirect" target="_blank" rel="noopener">经典动态规划：编辑距离</a>，我们通过对<code>dp</code>数组的定义，确定了 base case 是<code>dp[..][0]</code>和<code>dp[0][..]</code>，最终答案是<code>dp[m][n]</code>；而且我们通过状态转移方程知道<code>dp[i][j]</code>需要从<code>dp[i-1][j]</code>,<code>dp[i][j-1]</code>,<code>dp[i-1][j-1]</code>转移而来，如下图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ginx8ihf5uj20u00gw0sz.jpg" alt="undefined"></p><p>那么，参考刚才说的两条原则，你该怎么遍历<code>dp</code>数组？肯定是正向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; m; i++)</span><br><span class="line">    for (int j = 1; j &lt; n; j++)</span><br><span class="line">        // 通过 dp[i-1][j], dp[i][j - 1], dp[i-1][j-1]</span><br><span class="line">        // 计算 dp[i][j]</span><br></pre></td></tr></table></figure><p><strong>因为，这样每一步迭代的左边、上边、左上边的位置都是 base case 或者之前计算过的，而且最终结束在我们想要的答案<code>dp[m][n]</code>。</strong></p><p>再举一例，回文子序列问题，详见前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484666&idx=1&sn=e3305be9513eaa16f7f1568c0892a468&chksm=9bd7faf2aca073e4f08332a706b7c10af877fee3993aac4dae86d05783d3d0df31844287104e&scene=21#wechat_redirect" target="_blank" rel="noopener">子序列解题模板：最长回文子序列</a>，我们通过过对<code>dp</code>数组的定义，确定了 base case 处在中间的对角线，<code>dp[i][j]</code>需要从<code>dp[i+1][j]</code>,<code>dp[i][j-1]</code>,<code>dp[i+1][j-1]</code>转移而来，想要求的最终答案是<code>dp[0][n-1]</code>，如下图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ginxawe8scj20u00gwweq.jpg" alt="undefined"></p><p>这种情况根据刚才的两个原则，就可以有两种正确的遍历方式：</p><p><strong>要么从左至右斜着遍历，要么从下向上从左到右遍历，这样才能保证每次<code>dp[i][j]</code>的左边、下边、左下边已经计算完毕，最终得到正确结果。</strong></p><p>现在，你应该理解了这两个原则，主要就是看 base case 和最终结果的存储位置，保证遍历过程中使用的数据都是计算完毕的就行，有时候确实存在多种方法可以得到正确答案，可根据个人口味自行选择。</p><h2 id="动态规划设计：正则表达式"><a href="#动态规划设计：正则表达式" class="headerlink" title="动态规划设计：正则表达式"></a>动态规划设计：正则表达式</h2><blockquote><p>需求：给定一个字符串 (s) 和一个字符模式 ( p)。实现支持 <code>.</code> 和 <code>*</code> 的正则表达式匹配。</p><ul><li><code>.</code> 匹配任意单个字符。</li><li><code>*</code> 匹配零个或多个前面的元素。</li></ul><p>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。</p><ul><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li></ul></blockquote><p>示例：</p><blockquote><p>输入:<br><code>s = &quot;aa&quot;</code><br><code>p = &quot;a&quot;</code><br>输出: <code>false</code><br>解释: <code>&quot;a&quot;</code> 无法匹配 <code>&quot;aa&quot;</code> 整个字符串。</p></blockquote><blockquote><p>输入:<br><code>s = &quot;aa&quot;</code><br><code>p = &quot;a*&quot;</code><br>输出: <code>true</code><br>解释: <code>&#39;*&#39;</code> 代表可匹配零个或多个前面的元素, 即可以匹配 <code>&#39;a&#39;</code> 。因此, 重复 <code>&#39;a&#39;</code> 一次, 字符串可变为 <code>&quot;aa&quot;</code>。</p></blockquote><blockquote><p>输入:<br><code>s = &quot;ab&quot;</code><br><code>p = &quot;.*&quot;</code><br>输出: <code>true</code><br>解释: <code>&quot;.*&quot;</code> 表示可匹配零个或多个(<code>&#39;*&#39;</code>)任意字符(<code>&#39;.&#39;</code>)。</p></blockquote><blockquote><p>输入:<br><code>s = &quot;aab&quot;</code><br><code>p = &quot;c*a*b&quot;</code><br>输出: <code>true</code><br>解释: <code>&#39;c&#39;</code> 可以不被重复, <code>&#39;a&#39;</code> 可以被重复一次。因此可以匹配字符串 <code>&quot;aab&quot;</code>。</p></blockquote><blockquote><p>输入:<br><code>s = &quot;mississippi&quot;</code><br><code>p = &quot;mis*is*p*.&quot;</code><br>输出: <code>false</code></p></blockquote><p>来自<code>LeetCode</code>第10题</p><p>题意：</p><blockquote><ul><li>这道题中的<code>*</code>表示之前那个字符可以有0个，1个或是多个，就是说，字符串<code>&quot;a*b&quot;</code>，可以表示<code>&quot;b&quot;</code>或是<code>&quot;aaab&quot;</code>，即<code>a</code>的个数任意（可以是0个，可以是3个），可以从示例4看出。</li><li>还有一个需要注意的点就是 <code>&quot;.*&quot;</code> 表示可匹配零个或多个(<code>&#39;*&#39;</code>)任意字符(<code>&#39;.&#39;</code>)，示例3</li></ul></blockquote><p><code>&#39;*&#39;</code>这个字符，它能表示前一个字符的 <code>0~n</code> 个副本。说到这里，我们就要将一个编程中经常提到的概念，<strong>自动机</strong>。</p><blockquote><p>状态机由状态寄存器和组合逻辑电路构成，能够根据控制信号按照预先设定的状态进行状态转移，是协调相关信号动作、完成特定操作的控制中心。有限状态机简写为FSM(Finite State Machine)</p></blockquote><p>有些地方也把状态机称为<strong>有限自动机</strong></p><p>解决正则表达问题的关键，在于我们如何构建一个合适的<strong>自动机</strong></p><p>然后此题又是一个非确定状态有限自动机，要自己手动构建一个，这种接法姑且搁置，后面阅读FlinkCEP源码的时候我再来分析。</p><hr><p>所以这里：</p><p>从头处理<em>s</em>和<em>p</em>两个字符串：</p><ul><li><p>首先，如果<em>p</em>为空了，此时若<em>s</em>不为空，则说明匹配失败，直接返回false，如果都为空，说明匹配结束，返回true。</p></li><li><p>其次，如果<em>p</em>不为空，存在两种情况，一种是单一匹配，一种是<code>&#39;*&#39;</code>的任意匹配。</p><ul><li><p>我们先假设单一匹配，创建一个<code>boolean</code>类型的<code>match</code>变量，计算一下单一匹配是否成功：</p><ul><li>在单一匹配的情况下，s*不能为空。</li><li><em>s</em>和<em>p</em>的当前第一个字符需要相等，或者p的第一个字符为<code>&#39;.&#39;</code>。</li></ul><p>如果成功就可以将两个字符串的第一位去掉，继续匹配后续的字符。</p></li><li><p>还有可能是要进行任意匹配，任意匹配的条件是当前<code>p</code>的长度要大于2，并且<code>p[1]</code>要为<code>&#39;*&#39;</code>，这个时候，可以匹配<code>s</code>中任意数量的字符<code>p[0]</code>。那么又是两种情况：</p><ul><li><p>看：如果看（匹配）一次，就相当于去掉s的第一个字符，继续向后匹配。</p></li><li><p>不看：如果不看（就是不进行匹配=匹配0次），就相当于s不变，p向后去掉两位（字符<code>p[0]</code>和<code>p[1]</code>的’<code>*</code>‘）。</p></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.isEmpty()) <span class="keyword">return</span> s.isEmpty();</span><br><span class="line">        <span class="comment">// *不代表0的匹配条件</span></span><br><span class="line">        <span class="keyword">boolean</span> match = !s.isEmpty() &amp;&amp; ((s.charAt(<span class="number">0</span>) == p.charAt(<span class="number">0</span>)) || p.charAt(<span class="number">0</span>) == <span class="string">'.'</span>);</span><br><span class="line">        <span class="comment">// 任意匹配</span></span><br><span class="line">        <span class="keyword">if</span>(p.length() &gt;= <span class="number">2</span> &amp;&amp; p.charAt(<span class="number">1</span>) == <span class="string">'*'</span>) <span class="keyword">return</span> isMatch(s, p.substring(<span class="number">2</span>)) || (match &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p));</span><br><span class="line">        <span class="comment">// 单一匹配</span></span><br><span class="line">        <span class="keyword">return</span> match &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tips: 这里有个点要注意，通过<code>charAt</code>的方式访问要比char[]的方式慢很多，作为对比，这里附上通过<code>toCharArray</code>转换的版本，前者用时109ms，后者17ms，可见差距之大。这里主要应该是因为<code>charAt</code>方法多了一层栈的深度（需要进出对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatchChar</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> s1, <span class="keyword">char</span>[] p, <span class="keyword">int</span> p1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 &gt;= p.length) <span class="keyword">return</span> s1 &gt;= s.length;</span><br><span class="line">        <span class="keyword">boolean</span> match = s1 &lt; s.length &amp;&amp; ((s[s1] == p[p1]) || p[p1] == <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span>(p.length - p1 &gt;= <span class="number">2</span> &amp;&amp; p[p1 + <span class="number">1</span>] == <span class="string">'*'</span>) <span class="keyword">return</span> isMatchChar(s, s1, p, p1 + <span class="number">2</span>) || (match &amp;&amp; isMatchChar(s, s1 + <span class="number">1</span>, p, p1));</span><br><span class="line">        <span class="keyword">return</span> match &amp;&amp; isMatchChar(s, s1 + <span class="number">1</span>, p, p1 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray(), pp = p.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> isMatchChar(ss, <span class="number">0</span>, pp, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gj12glvvzzj20kk07vgly.jpg" alt="微信截图_20200924004758.png"></p><p>记忆化递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] mem;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatchChar</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> s1, <span class="keyword">char</span>[] p, <span class="keyword">int</span> p1)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p1 &gt;= p.length) <span class="keyword">return</span> s1 &gt;= s.length;</span><br><span class="line">    <span class="keyword">if</span>(mem[s1][p1] != <span class="number">0</span>) <span class="keyword">return</span> mem[s1][p1] &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> match = s1 &lt; s.length &amp;&amp; ((s[s1] == p[p1]) || p[p1] == <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.length - p1 &gt;= <span class="number">2</span> &amp;&amp; p[p1 + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> t = isMatchChar(s, s1, p, p1 + <span class="number">2</span>) || (match &amp;&amp; isMatchChar(s, s1 + <span class="number">1</span>, p, p1));</span><br><span class="line">        <span class="keyword">if</span>(t) mem[s1][p1] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> mem[s1][p1] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> t = match &amp;&amp; isMatchChar(s, s1 + <span class="number">1</span>, p, p1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(t) mem[s1][p1] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> mem[s1][p1] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mem = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span>[] ss = s.toCharArray(), pp = p.toCharArray();</span><br><span class="line">    <span class="keyword">return</span> isMatchChar(ss, <span class="number">0</span>, pp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段就是记忆化递归的套路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">this</span>.mem = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mem[s1][p1] != <span class="number">0</span>) <span class="keyword">return</span> mem[s1][p1] &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t) mem[s1][p1] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> mem[s1][p1] = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>动态规划</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s和p倒着看，dp[i][j]的取值分为以下几种情况：</span><br><span class="line">1.p[j - 1]p[j−1]为普通字符,若s[i - 1] == p[j - 1]，则dp[i][j] = dp[i - 1][j - 1]，否则匹配失败</span><br><span class="line">两个Char数组相同那么dp表中</span><br><span class="line">2.p[j−1]为&apos;.&apos;，则dp[i][j] = dp[i - 1][j - 1]</span><br><span class="line"></span><br><span class="line">3.p[j - 1]p[j−1]为&apos;*&apos;：</span><br><span class="line">(1)不看，则dp[i][j] = dp[i][j - 2]</span><br><span class="line">(2)看，则dp[i][j] = dp[i - 1][j]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch_DP</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray(), ptr = p.toCharArray();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[str.length + <span class="number">1</span>][ptr.length + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ptr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ptr[j - <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (str[i - <span class="number">1</span>] == ptr[j - <span class="number">1</span>] || ptr[j - <span class="number">1</span>] == <span class="string">'.'</span>)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//ptr[j - 1] == '*'</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">1</span>) dp[i][j] |= dp[i][j - <span class="number">2</span>];   <span class="comment">//不看</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">1</span> &amp;&amp; (str[i - <span class="number">1</span>] == ptr[j - <span class="number">2</span>] || ptr[j - <span class="number">2</span>] == <span class="string">'.'</span>))dp[i][j] |= dp[i - <span class="number">1</span>][j];    <span class="comment">//看</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[str.length][ptr.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210128180320.png&quot; style=&quot;zoom: 67%;&quot;&gt;

&lt;p&gt;终于到经典的动态规划问题，希望能顺利拿下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>IDEA编译Flink1.11.1</title>
    <link href="http://yoursite.com/2020/08/29/IDEA%E7%BC%96%E8%AF%91Flink1-11-1/"/>
    <id>http://yoursite.com/2020/08/29/IDEA%E7%BC%96%E8%AF%91Flink1-11-1/</id>
    <published>2020-08-29T01:13:03.000Z</published>
    <updated>2020-08-31T16:10:58.579Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尝试熟悉一下IDEA直接编译Flink，顺手记录一下全过程。</p></blockquote><a id="more"></a> <h1 id="IDEA编译Flink1-11-1"><a href="#IDEA编译Flink1-11-1" class="headerlink" title="IDEA编译Flink1.11.1"></a>IDEA编译Flink1.11.1</h1><p>下载源码确保网路通畅不再赘述</p><h2 id="编译说明"><a href="#编译说明" class="headerlink" title="编译说明"></a>编译说明</h2><p>要想把技术沉淀下来，阅读源码是必不可少的，既然要阅读源码怎么能不会编译呢？</p><p>根据我的总结，编译中遇到的问题可以归纳为几种</p><p>网络问题和组件环境版本不兼容</p><p>网络问题在编译的过程中是始终困扰我的，后面详细讲讲。</p><p>组件环境版本我一直没怎么注意，觉得是想当然向下兼容。</p><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p><strong>编译平台 mac &amp; win10</strong></p><p><strong>编译java版本 8u202</strong></p><p><strong>编译maven版本 3.2.5</strong></p><p><strong>win10推荐使用Administrator账户（非必须）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user administrator /active:yes</span><br></pre></td></tr></table></figure><p><strong>mac对于账户没有特别的要求</strong></p><p><strong>Git设置proxy（详细可以见<a href="%5Bhttps://flymetothemars.github.io/2020/04/09/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/%5D(https://flymetothemars.github.io/2020/04/09/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/)">设置</a> 27条）</strong></p><p><strong>Maven设置proxy（详细可以见<a href="%5Bhttps://flymetothemars.github.io/2020/04/09/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/%5D(https://flymetothemars.github.io/2020/04/09/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/)">设置</a> 29条）</strong></p><h2 id="Nodejs版本管理"><a href="#Nodejs版本管理" class="headerlink" title="Nodejs版本管理"></a>Nodejs版本管理</h2><p>mac下的nodejs版本管理工具，就是n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n list</span><br><span class="line"></span><br><span class="line">n 直接选择版本</span><br></pre></td></tr></table></figure><p>window下要安装一个<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">nvm</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">先给nvm设置镜像</span><br><span class="line">root: C:\APP\tools\nvm</span><br><span class="line">path: C:\APP\tools\nodejs</span><br><span class="line"></span><br><span class="line">node_mirror: https://npm.taobao.org/mirrors/node/ </span><br><span class="line">npm_mirror: https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure><p>nvm设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nvm lsit</span><br><span class="line"></span><br><span class="line">nvm install</span><br><span class="line"></span><br><span class="line">nvm use</span><br></pre></td></tr></table></figure><p>Flink 1.11.1的版本是 <code>v10.9.0</code></p><h2 id="编译flink-runtime-web包"><a href="#编译flink-runtime-web包" class="headerlink" title="编译flink-runtime-web包"></a>编译flink-runtime-web包</h2><p>根据经验，凡是要用到WebUI，涉及到nodejs编译是最麻烦的，先把这个包单独拿出来编译试一下。</p><p>首先确保网络通畅，我们在国内所谓网络通畅，少不了一个好用的VPN，有了VPN再谈别的，不然啥都白扯。</p><p>SSR或者别的VPN在我们喜欢的端口设置了全局代理之后，Git和Maven才能顺利的下载依赖。</p><p>但是在这个<code>flink-runtime-web</code>包里遇到一个双重代理的问题，我在Maven的<code>setting.xml</code>文件里面设置了proxy，所以在这里对于nodejs的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Found proxies: [ss&#123;protocol='socks5', host='127.0.0.1', port=1080&#125;]</span><br><span class="line">[INFO] Running 'npm ci --cache-max=0 --no-save --https-proxy=http://127.0.0.1:1080 --proxy=http://127.0.0.1:1080' in /Users/flyhugh/Documents/Compile/flink-1.11.1/flink-runtime-web/web-dashboard</span><br></pre></td></tr></table></figure><p>这样代理是无法正常下载的，我在setting.xml里面关掉了这个代理，运行的时候就变成了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Running 'npm ci --cache-max=0 --no-save' in /Users/flyhugh/Documents/Compile/flink-1.11.1/flink-runtime-web/web-dashboard</span><br></pre></td></tr></table></figure><p>这样的代码是可以通过的</p><h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><p>我宿舍的网是50M的，VPN的速度也很不错，但是使用maven代理的时候，速度却总是跟不上？不知道为什么</p><p>还好现在流量不贵了，使用流量代理速度总还凑合，以后有了5G速度就更行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前写过一篇杂七杂八的编译，成功的也莫名其妙，这次特地用了两个平台对比编译，其实只要调试好网络，设置好组件的proxy，Java和Maven的版本选择正确，编译并不是特别麻烦的事情。</p><p>不过那个pom确实是很复杂，如果自己修改源码的话，感觉还是挺麻烦的。</p><p>不过总算是解决了心头的一个结。</p><p>后续根据使用情况不定期更新。</p><p>内存设置得大一点（idea64.vmoptions &lt;&lt; -Xmx8192m），编译速度会快不少。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gi9z89rfj3j22gw19snka.jpg" alt="WX20200831-142614@2x.png"></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1giag2k12elj22kp1m14cx.jpg" alt="QzpcVXNlcnNcZmx5aG9cQXBwRGF0YVxSb2FtaW5nXERpbmdUYWxrXDExMzI4MDM2MF92MlxJbWFnZUZpbGVzXDIxODg5NzUyOFwxNTk4ODgyNzcxODMwXzZGQjI5NjM4LTdGRDYtNDNjNC1CNTlBLUJGQ0FFMDA3RDEyRS5wbmc=.png"></p><p>win10下通过普通用户也编译成功，内存多给，编译速度加快。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;尝试熟悉一下IDEA直接编译Flink，顺手记录一下全过程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Apache Flink" scheme="http://yoursite.com/tags/Apache-Flink/"/>
    
  </entry>
  
  <entry>
    <title>Kafka-Record</title>
    <link href="http://yoursite.com/2020/08/13/Kafka-Record/"/>
    <id>http://yoursite.com/2020/08/13/Kafka-Record/</id>
    <published>2020-08-13T02:14:05.000Z</published>
    <updated>2020-10-15T23:09:25.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kafka的命令一段时间不用总会有点遗忘，这边会记录我对Kafka的一些理解，今后会做一些Kafka源码方面的工作(但愿如此，也会在此延伸记录 ~</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ghoywg2k7gj20jg0b9755.jpg" alt="undefined"></p><a id="more"></a> <h1 id="Kafka命令"><a href="#Kafka命令" class="headerlink" title="Kafka命令"></a>Kafka命令</h1><h2 id="Mac-Brew安装的Kafka"><a href="#Mac-Brew安装的Kafka" class="headerlink" title="Mac Brew安装的Kafka"></a>Mac Brew安装的Kafka</h2><p>位置：<code>/usr/local/Cellar/kafka</code></p><h3 id="查看所有Topic"><a href="#查看所有Topic" class="headerlink" title="查看所有Topic"></a>查看所有Topic</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic topicname</span><br></pre></td></tr></table></figure><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>如果想要这台电脑的Kafka能被别的电脑访问，那么有个问题是必须要注意的，那就是要自己修改<code>server.properties</code>里面的<code>listeners=PLAINTEXT://192.168.31.130:9092</code>的ip为绑定的ip，不能是localhost或者127.0.0.1，我记得之前zpl里面也是这样的，如果绑定的ip地址不正确，那么就会出现连接不上的问题。</p><h3 id="命令行查看-consumer-offsets下保存的Offset"><a href="#命令行查看-consumer-offsets下保存的Offset" class="headerlink" title="命令行查看__consumer_offsets下保存的Offset"></a>命令行查看__consumer_offsets下保存的Offset</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-consumer-offset-checker --zookeeper localhost :2181/kafka --group test-consumer-group  --topic stable-test</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2017</span>-<span class="number">08</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">24</span>:<span class="number">24</span>,<span class="number">222</span>] WARN WARNING: ConsumerOffsetChecker is deprecated and will be dropped in releases following <span class="number">0.9</span>.0. Use ConsumerGroupCommand instead. (kafka.tools.ConsumerOffsetChecker$)</span><br><span class="line">Group           Topic                          Pid Offset          logSize         Lag             Owner</span><br><span class="line">test-consumer-group stable-test                    <span class="number">0</span>   <span class="number">601808</span>          <span class="number">601808</span>          <span class="number">0</span>               none</span><br><span class="line">test-consumer-group stable-test                    <span class="number">1</span>   <span class="number">602826</span>          <span class="number">602828</span>          <span class="number">2</span>               none</span><br><span class="line">test-consumer-group stable-test                    <span class="number">2</span>   <span class="number">602136</span>          <span class="number">602136</span>          <span class="number">0</span>               none</span><br></pre></td></tr></table></figure><p>结果说明：</p><p>Group : 消费者组</p><p>Topic : topic的名字</p><p>Pid : partition的ID</p><p>Offset : kafka消费者在对应分区上已经消费的消息数【位置】</p><p>logSize : 已经写到该分区的消息数【位置】</p><p>Lag : 还有多少消息未读取（Lag = logSize - Offset）</p><p>Owner : 分区创建在哪个broker</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Kafka的命令一段时间不用总会有点遗忘，这边会记录我对Kafka的一些理解，今后会做一些Kafka源码方面的工作(但愿如此，也会在此延伸记录 ~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1ghoywg2k7gj20jg0b9755.jpg&quot; alt=&quot;undefined&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Apache Kafka" scheme="http://yoursite.com/tags/Apache-Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Data Structures</title>
    <link href="http://yoursite.com/2020/07/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/07/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-07-20T18:12:28.000Z</published>
    <updated>2020-09-03T20:55:31.110Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ggxzqogx6kj20b304tjr8.jpg" alt="159526903056127.png"></p><blockquote><p>这个是因该很早之前就要学习的东西，一直拖今天，惭愧…</p><p>本文是<code> labuladong的算法笔记</code>的读书笔记</p></blockquote><a id="more"></a> <h1 id="Data-Structures"><a href="#Data-Structures" class="headerlink" title="Data Structures"></a>Data Structures</h1><h2 id="一、数据结构的存储方式"><a href="#一、数据结构的存储方式" class="headerlink" title="一、数据结构的存储方式"></a>一、数据结构的存储方式</h2><p>本质上讲，数据结构的存储方式只有两种：数组和链表</p><table><thead><tr><th>根本结构：</th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>存储方式：</td><td>顺序存储</td><td>链式存储</td></tr><tr><td>实现队列和栈：</td><td>处理扩容缩容问题</td><td>需要更多的内存空间存储结点指针</td></tr><tr><td>图：</td><td>邻接矩阵</td><td>邻接表</td></tr><tr><td>散列表（通过散列函数把键映射到一个大数组里）：</td><td>线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些</td><td>对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针</td></tr><tr><td>Redis：</td><td>Redis底层的存储方式直晒都提供了两种</td><td>来根据存储数据的实际情况是用合适的存储方式</td></tr><tr><td>优点和缺点：</td><td><strong>数组</strong>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 <code>O(N)</code>；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 <code>O(N)</code>。</td><td><strong>链表</strong>因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 <code>O(1)</code>。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。</td></tr></tbody></table><h2 id="二、数据结构的基本操作"><a href="#二、数据结构的基本操作" class="headerlink" title="二、数据结构的基本操作"></a>二、数据结构的基本操作</h2><p><strong>数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改</strong>。</p><p>如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。</p><table><thead><tr><th>线性</th><th>非线性</th></tr></thead><tbody><tr><td>for/while</td><td>递归</td></tr></tbody></table><p>基本的链表遍历框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的单链表节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ListNode p = head; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">        <span class="comment">// 迭代访问 p.val</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归访问 head.val</span></span><br><span class="line">    traverse(head.next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树遍历框架，典型的非线性递归遍历结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的二叉树节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root.left)</span><br><span class="line">    traverse(root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 二叉树框架可以扩展为 N 叉树的遍历框架：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的 N 叉树节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children)</span><br><span class="line">        traverse(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为图就是好几 N 叉棵树的结合体，环状图用个布尔数组 visited 做标记就行了。</p><h2 id="三、算法刷题指南"><a href="#三、算法刷题指南" class="headerlink" title="三、算法刷题指南"></a>三、算法刷题指南</h2><p>首先要明确的是，<strong>数据结构是工具，算法是通过合适的工具解决特定问题的方法</strong>。也就是说，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷。</p><p>先刷二叉树，原因：</p><p><strong>因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题</strong>。</p><h3 id="二叉树的解题框架"><a href="#二叉树的解题框架" class="headerlink" title="二叉树的解题框架"></a><strong>二叉树的解题框架</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如：</p><p><strong>LeetCode 124 题，难度 Hard，让你求二叉树中最大路径和，主要代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oneSideMax</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == nullptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = max(<span class="number">0</span>, oneSideMax(root-&gt;left));</span><br><span class="line">    <span class="keyword">int</span> right = max(<span class="number">0</span>, oneSideMax(root-&gt;right));</span><br><span class="line">    ans = max(ans, left + right + root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> max(left, right) + root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LeetCode 105 题，难度 Medium，让你根据前序遍历和中序遍历的结果还原一棵二叉树，很经典的问题吧，主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, Map&lt;Integer, Integer&gt; inMap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">    <span class="keyword">int</span> inRoot = inMap.get(root.val);</span><br><span class="line">    <span class="keyword">int</span> numsLeft = inRoot - inStart;</span><br><span class="line"></span><br><span class="line">    root.left = buildTree(preorder, preStart + <span class="number">1</span>, preStart + numsLeft, </span><br><span class="line">                          inorder, inStart, inRoot - <span class="number">1</span>, inMap);</span><br><span class="line">    root.right = buildTree(preorder, preStart + numsLeft + <span class="number">1</span>, preEnd, </span><br><span class="line">                          inorder, inRoot + <span class="number">1</span>, inEnd, inMap);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要看这个函数的参数很多，只是为了控制数组索引而已，本质上该算法也就是一个前序遍历。</p><p>LeetCode 99 题，难度 Hard，恢复一棵 BST，主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    traverse(node-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;val &lt; prev-&gt;val) &#123;</span><br><span class="line">        s = (s == NULL) ? prev : s;</span><br><span class="line">        t = node;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = node;</span><br><span class="line">    traverse(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不就是个中序遍历嘛，对于一棵 BST 中序遍历意味着什么，应该不需要解释了吧。</p><p>你看，Hard 难度的题目不过如此，而且还这么有规律可循，只要把框架写出来，然后往相应的位置加东西就行了，这不就是思路吗。</p><p>对于一个理解二叉树的人来说，刷一道二叉树的题目花不了多长时间。那么如果你对刷题无从下手或者有畏惧心理，不妨从二叉树下手，前 10 道也许有点难受；结合框架再做 20 道，也许你就有点自己的理解了；刷完整个专题，再去做什么回溯动规分治专题，<strong>你就会发现只要涉及递归的问题，都是树的问题</strong>。</p><hr><p>上面的总结是该UP主给出的解题思路，说实话，看懂是不可能看懂的，先继续往后面刷。</p><p>继续往后面copy没啥意思，反正就是突出这个框架的重要性。</p><p><strong>这就是框架的力量，能够保证你在快睡着的时候，依然能写出正确的程序；就算你啥都不会，都能比别人高一个级别。</strong></p><h2 id="四、总结几句"><a href="#四、总结几句" class="headerlink" title="四、总结几句"></a>四、总结几句</h2><p>数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非迭代和递归。</p><p>刷算法题建议从「树」分类开始刷，结合框架思维，把这几十道题刷完，对于树结构的理解应该就到位了。这时候去看回溯、动规、分治等算法专题，对思路的理解可能会更加深刻一些。</p><p>后面在本章中还介绍了一些针对细节的解题框架，我决定谨遵作者的嘱托先刷树。</p><h2 id="五、时间复杂度和空间复杂度"><a href="#五、时间复杂度和空间复杂度" class="headerlink" title="五、时间复杂度和空间复杂度"></a>五、时间复杂度和空间复杂度</h2><p>这里仅仅介绍时间复杂度和空间复杂度的入门部分，后续如果要用到详细的部分，我会再补充。</p><h4 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h4><ul><li><p>时间复杂度：就是说执行算法需要消耗的时间长短，越快越好。比如你在电脑上打开计算器，如果一个普通的运算要消耗1分钟时间，那谁还会用它呢，还不如自己口算呢。</p></li><li><p>空间复杂度：就是说执行当前算法需要消耗的存储空间大小，也是越少越好。本来计算机的存储资源就是有限的，如果你的算法总是需要耗费很大的存储空间，这样也会给机器带来很大的负担。</p></li></ul><h4 id="2-常见的时间复杂度量级"><a href="#2-常见的时间复杂度量级" class="headerlink" title="2.常见的时间复杂度量级"></a>2.常见的时间复杂度量级</h4><blockquote><p>我们一般用“大O符号表示法”来表示时间复杂度：T(n) = O(f(n))<br>n是影响复杂度变化的因子，f(n)是复杂度具体的算法。</p></blockquote><ul><li>常数阶O(1)</li><li>线性阶O(n)</li><li>对数阶O(logN)</li><li>线性对数阶O(nlogN)</li><li>平方阶O(n²)</li><li>立方阶O(n³)</li><li>K次方阶O(n^k)</li><li>指数阶(2^n)</li></ul><blockquote><p>T(n) = O((f(n))</p></blockquote><p>T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p><p>当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以表示为，推导过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(n) = O(2n+2) -&gt; T(n) = O(n)</span><br><span class="line">T(n) = O(2n2+2n+3) -&gt; T(n) = O(n2)</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gh1vdpqeo2j21w016ydh8.jpg" alt="undefined"></p><h5 id="常数阶O-1"><a href="#常数阶O-1" class="headerlink" title="常数阶O(1)"></a>常数阶O(1)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>我们假定每执行一行代码所需要消耗的时间为1个时间单位，那么以上3行代码就消耗了3个时间单位。那是不是这段代码的时间复杂度表示为O(n)呢 ？</p><p>其实不是的，*<strong>因为大O符号表示法并不是用于来真实代表算法的执行时间的<em>，</em>它是用来表示代码执行时间的增长变化趋势的。***<br>*上面的算法并没有随着某个</strong>变量*<em>的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</em></p><h5 id="线性阶O-n"><a href="#线性阶O-n" class="headerlink" title="线性阶O(n)"></a>线性阶O(n)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第1行会执行1次，第2行和第3行会分别执行n次，总的执行时间也就是 2n + 1 次，那它的时间复杂度表示是 O(2n + 1) 吗？ No !<br>还是那句话：“**<em>大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的**</em>”。<br>所以它的时间复杂度其实是O(n);</p><h5 id="对数阶O-logN"><a href="#对数阶O-logN" class="headerlink" title="对数阶O(logN)"></a>对数阶O(logN)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">平方阶O(n²)<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到每次循环的时候 i 都会乘2，那么总共循环的次数就是log2n，因此这个代码的时间复杂度为O(logn)。<br>这儿有个问题，为什么明明应该是O(log2n）,却要写成O(logn)呢？<br>其实这里的底数对于研究程序运行效率不重要，写代码时要考虑的是数据规模n对程序运行效率的影响，常数部分则忽略，同样的，如果不同时间复杂度的倍数关系为常数，那也可以近似认为两者为同一量级的时间复杂度。</p><h5 id="线性对数阶O-nlogN"><a href="#线性对数阶O-nlogN" class="headerlink" title="线性对数阶O(nlogN)"></a>线性对数阶O(nlogN)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(m = <span class="number">1</span>; m &lt; n; m++) &#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性对数阶w的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。</p><p>O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p><h5 id="平方阶O-n²"><a href="#平方阶O-n²" class="headerlink" title="平方阶O(n²)"></a>平方阶O(n²)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x = <span class="number">1</span>; i &lt;= n; x++)&#123;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。</p><h5 id="立方阶O-n³-、K次方阶O-n-k"><a href="#立方阶O-n³-、K次方阶O-n-k" class="headerlink" title="立方阶O(n³)、K次方阶O(n^k)"></a>立方阶O(n³)、K次方阶O(n^k)</h5><p>参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。</p><h5 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n) 、O(m*n)"></a>O(m+n) 、O(m*n)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">cal</span><span class="params">(m, n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p><p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。</p></blockquote><h5 id="数据结构操作的复杂性"><a href="#数据结构操作的复杂性" class="headerlink" title="数据结构操作的复杂性"></a>数据结构操作的复杂性</h5><table><thead><tr><th>数据结构</th><th align="center">连接</th><th align="center">查找</th><th align="center">插入</th><th align="center">删除</th></tr></thead><tbody><tr><td><strong>数组</strong></td><td align="center">1</td><td align="center">n</td><td align="center">n</td><td align="center">n</td></tr><tr><td><strong>栈</strong></td><td align="center">n</td><td align="center">n</td><td align="center">1</td><td align="center">1</td></tr><tr><td><strong>队列</strong></td><td align="center">n</td><td align="center">n</td><td align="center">1</td><td align="center">1</td></tr><tr><td><strong>链表</strong></td><td align="center">n</td><td align="center">n</td><td align="center">1</td><td align="center">1</td></tr><tr><td><strong>哈希表</strong></td><td align="center">-</td><td align="center">n</td><td align="center">n</td><td align="center">n</td></tr><tr><td><strong>二分查找树</strong></td><td align="center">n</td><td align="center">n</td><td align="center">n</td><td align="center">n</td></tr><tr><td><strong>B树</strong></td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td></tr><tr><td><strong>红黑树</strong></td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td></tr><tr><td><strong>AVL树</strong></td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td></tr></tbody></table><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gh233kcx4dj22xs1ko1kx.jpg" alt="undefined"></p><h5 id="数组排序算法的复杂性"><a href="#数组排序算法的复杂性" class="headerlink" title="数组排序算法的复杂性"></a>数组排序算法的复杂性</h5><table><thead><tr><th>名称</th><th align="center">最优</th><th align="center">平均</th><th align="center">最坏</th><th align="center">内存</th><th align="center">稳定</th></tr></thead><tbody><tr><td><strong>冒泡排序</strong></td><td align="center">n</td><td align="center">n^2</td><td align="center">n^2</td><td align="center">1</td><td align="center">Yes</td></tr><tr><td><strong>插入排序</strong></td><td align="center">n</td><td align="center">n^2</td><td align="center">n^2</td><td align="center">1</td><td align="center">Yes</td></tr><tr><td><strong>选择排序</strong></td><td align="center">n^2</td><td align="center">n^2</td><td align="center">n^2</td><td align="center">1</td><td align="center">No</td></tr><tr><td><strong>堆排序</strong></td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">1</td><td align="center">No</td></tr><tr><td><strong>归并排序</strong></td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n</td><td align="center">Yes</td></tr><tr><td><strong>快速排序</strong></td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n^2</td><td align="center">log(n)</td><td align="center">No</td></tr><tr><td><strong>希尔排序</strong></td><td align="center">n log(n)</td><td align="center">取决于差距序列</td><td align="center">n (log(n))^2</td><td align="center">1</td><td align="center">No</td></tr></tbody></table><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gh237albjpj21tw1ewh1q.jpg" alt="undefined"></p><h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><p>三个使用分析方法：</p><hr><ol><li>只关注循环执行次数最多的的一段代码</li></ol><blockquote><p>大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 function cal(n) &#123;</span><br><span class="line">2    var sum = 0;</span><br><span class="line">3    var i = 1;</span><br><span class="line">4    for (; i &lt;= n; ++i) &#123;</span><br><span class="line">5      sum = sum + i;</span><br><span class="line">6    &#125;</span><br><span class="line">7    return sum;</span><br><span class="line">8  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.3行代码都是常量级别的执行时间，与n的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是滴4、5行代码，所以这块代码要重点分析。那两行代码执行了n次，所以总的时间复杂度就是O(n)</p></blockquote><hr><ol start="2"><li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li></ol><blockquote><p>综合这三段代码的时间复杂度(分别是O(1), O(n), O(n2))，我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n2)。也就是说：总的时间复杂度就等于量级最大的那段代码的时间复杂度。那我们将这个规律抽象成公式就是：</p><p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p></blockquote><hr><ol start="3"><li>嵌套代码的复杂度等于嵌套内外代码复杂度的乘积，类似嵌套循环的，都是用乘法来处理</li></ol><h4 id="大O"><a href="#大O" class="headerlink" title="大O"></a>大O</h4><blockquote><p>大O描述的是算法的运行时间和输入数据之间的关系</p><p>以下是一些最常用的 大O标记法 列表以及它们与不同大小输入数据的性能比较。</p></blockquote><table><thead><tr><th>大O标记法</th><th>计算10个元素</th><th>计算100个元素</th><th>计算1000个元素</th></tr></thead><tbody><tr><td><strong>O(1)</strong></td><td>1</td><td>1</td><td>1</td></tr><tr><td><strong>O(log N)</strong></td><td>3</td><td>6</td><td>9</td></tr><tr><td><strong>O(N)</strong></td><td>10</td><td>100</td><td>1000</td></tr><tr><td><strong>O(N log N)</strong></td><td>30</td><td>600</td><td>9000</td></tr><tr><td><strong>O(N^2)</strong></td><td>100</td><td>10000</td><td>1000000</td></tr><tr><td><strong>O(2^N)</strong></td><td>1024</td><td>1.26e+29</td><td>1.07e+301</td></tr><tr><td><strong>O(N!)</strong></td><td>3628800</td><td>9.3e+157</td><td>4.02e+2567</td></tr></tbody></table><h4 id="3-常见空间复杂度计算"><a href="#3-常见空间复杂度计算" class="headerlink" title="3.常见空间复杂度计算"></a>3.常见空间复杂度计算</h4><h5 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度 O(1)"></a>空间复杂度 O(1)</h5><p>如果算法执行<strong>所需要的临时空间不随着某个变量n的大小而变化</strong>，即<strong>此算法空间复杂度为一个常量</strong>，可表示为 O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure><p>代码中的 <strong>i、j、m 所分配的空间都不随着处理数据量变化</strong>，因此它的空间复杂度 S(n) = O(1)。</p><h5 id="空间复杂度-O-n"><a href="#空间复杂度-O-n" class="headerlink" title="空间复杂度 O(n)"></a>空间复杂度 O(n)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] m = <span class="keyword">new</span> <span class="keyword">int</span>[n]</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h5><blockquote><p>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。</p><p>类比一下，空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。</p><p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。</p></blockquote><h5 id="最好最坏情况时间复杂度"><a href="#最好最坏情况时间复杂度" class="headerlink" title="最好最坏情况时间复杂度"></a>最好最坏情况时间复杂度</h5><p>最简单的例子，如果我们在某个数组中查找某个元素，这个元素可能在各个位置，然后我们一旦找到了这个元素立即跳出循环，这段代码的时间复杂度还是 O(n) 吗？</p><p>我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。</p><p>总之分析下来，最好情况时间复杂度没有啥意义，最坏情况时间复杂度和平均情况时间貌似区别不大？后续有新的理解会更新上来。</p><h5 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h5><blockquote><p>大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。找出所有的输入情况及相应的发生概率，然后再计算加权平均值。</p><blockquote><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p></blockquote><p>Ex. 某段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p><p>那这段代码的时间复杂度是多少呢？你可以先用我们刚讲到的三种时间复杂度的分析方法来分析一下。</p><p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p><p>那平均时间复杂度是多少呢？答案是 O(1)。我们还是可以通过前面讲的概率论的方法来分析。</p><p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p><p>O(1)</p><p>至此为止，前面的最好、最坏、平均时间复杂度的计算，理解起来应该都没有问题。但是这个例子里的平均复杂度分析其实并不需要这么复杂，不需要引入概率论的知识。这是为什么呢？我们先来对比一下这个 insert() 的例子和前面那个 find() 的例子，你就会发现这两者有很大差别。</p><p>首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()第一个区别于 find() 的地方。</p><p>我们再来看第二个不同的地方。对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p><p>所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。</p><p>针对这种特殊的场景，我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。</p><p>那究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？</p><p>我们还是继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。</p></blockquote><p>均摊时间复杂度我没有去深刻理解，没必要看这个冷门知识点看睡着了。</p><h5 id="对数据规模有一个概念和分析"><a href="#对数据规模有一个概念和分析" class="headerlink" title="对数据规模有一个概念和分析"></a>对数据规模有一个概念和分析</h5><p>想要在1s内解决问题：</p><ul><li>O(n2)的算法可以处理大约10^4级别的数据</li><li>O(n)的算法可以处理大约10^8级别的数据</li><li>O(nlogn)的算法可以处理大约10^7级别的数据</li><li>保险起见，在实际处理过程中最好降一个级</li></ul><h4 id="4-递归算法复杂度分析"><a href="#4-递归算法复杂度分析" class="headerlink" title="4.递归算法复杂度分析"></a>4.递归算法复杂度分析</h4><p>鉴于我对递归的使用并不熟练，这个坑放在这，日后来填。</p><h4 id="5-避免复杂度的震荡"><a href="#5-避免复杂度的震荡" class="headerlink" title="5.避免复杂度的震荡"></a>5.避免复杂度的震荡</h4><p>常见场景：</p><blockquote><p>java数组动态扩容</p><p>假设我们现在有一个数组，这个数组的容量为n，并且现在也装满了元素，那么现在我们再调用一下addLast操作，显然在添加一个新的元素的时候会需要扩容（扩容会耗费O(N)的时间），之后我们马上进行removeLast操作（根据我们之前的逻辑，在上一个操作里通过扩容，容量变为了2n，在我们删除1个元素之后，元素又变为了n = 2n/2，根据我们代码中的逻辑，会触发缩容的操作，同样耗费了O(n)的时间）；那么我们如果再addLast、removeLast…等相继依次操作。</p><p>对于addLast和removeLast来说，都是每隔n次操作都会触发resize，而不会每次都触发<br>但是现在我们制造了一种情景：同时看addLast和removeLast的时候，每一次都会耗费O(n)的复杂度，那么这就是复杂度的震荡</p><p>resize的复杂度分析——出现复杂度震荡的原因及解决方案</p><p>removeLast时resize过于着急（采用了Eager的策略: 一旦我们的元素变为当前容积的1/2的时候，我们马上就把当前的容积也缩容为1/2）<br>解决方案: Lazy （在线段树中，也会用到类似的思路）<br>当元素变为当前容积的1/2时，不着急把当前容积缩容，而是等等；如果后面一直有删除操作的话，当删除元素到整个数组容积的1/4时，那么这样看来我们的数组确实用不了这么大的容积，此时我们再来进行缩容，缩容整个数组的1/2（这样，即便我们要添加元素，也不需要马上触发扩容操作）</p><p>当 size == capacity / 4时，才将capacity减半！</p></blockquote><p>这里只谈了如何避免，却没有说为什么要避免。</p><h4 id="6-复杂度分析的4个概念"><a href="#6-复杂度分析的4个概念" class="headerlink" title="6. 复杂度分析的4个概念"></a>6. 复杂度分析的4个概念</h4><p>一、复杂度分析的4个概念</p><ul><li>1.最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。</li><li>2.最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。</li><li>3.平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。</li><li>4.均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</li></ul><p>二、为什么要引入这4个概念？</p><p>1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。</p><p>2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</p><p>三、如何分析平均、均摊时间复杂度？</p><p>1.平均时间复杂度</p><p>代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。</p><p>2.均摊时间复杂度</p><p>两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</p><h4 id="7-常用排序算法"><a href="#7-常用排序算法" class="headerlink" title="7.常用排序算法"></a>7.常用排序算法</h4><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gh30c6sa08j20jv0az3yl.jpg" alt="undefined"></p><p>排序晚点再来看</p><hr><p>《算法第四版》是肯定要看的，到时候再来完备整个复杂度体系。</p><h2 id="六、实操"><a href="#六、实操" class="headerlink" title="六、实操"></a>六、实操</h2><p>在经过了上面得简单梳理之后，没啥好说得，开始自己的实际操作。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="链表（Linked-List）数据结构概览"><a href="#链表（Linked-List）数据结构概览" class="headerlink" title="链表（Linked List）数据结构概览"></a>链表（Linked List）数据结构概览</h4><p>链表（Linked List）是线性表的一种（线性表包含顺序表与链表），通过指针将一系列位于不连续的内存空间中的元素连接起来，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理，但也失去了快速随机存取的优点，同时增大了内存开销（存储指针域）。</p><p>链表数据结构由一连串节点（Node）组成，每个节点包含数据域（Data Fields）和一或两个用来指向上一个/或下一个节点位置的指针域（Pointer Fields）。链表可以方便地插入或移除表中任意位置的节点，但是随机存取效率不高。链表有很多种不同的类型：单向链表，双向链表以及循环链表。</p><h4 id="链表（Linked-List）数据结构操作接口"><a href="#链表（Linked-List）数据结构操作接口" class="headerlink" title="链表（Linked List）数据结构操作接口"></a>链表（Linked List）数据结构操作接口</h4><p>我们将要使用 Java 语言手写一枚链表数据结构。首先，明确链表数据结构所具有的操作接口方法。</p><table><thead><tr><th align="left">接口方法</th><th align="left">解释说明</th></tr></thead><tbody><tr><td align="left"><code>void addFirst(E element)</code></td><td align="left">向链表头部添加一个新的元素。</td></tr><tr><td align="left"><code>void addLast(E element)</code></td><td align="left">向链表尾部添加一个新的元素。</td></tr><tr><td align="left"><code>E removeFirst()</code></td><td align="left">移除链表头部第一个元素。</td></tr><tr><td align="left"><code>E removeLast()</code></td><td align="left">移除链表尾部最后一个元素。</td></tr><tr><td align="left"><code>E getFirst()</code></td><td align="left">返回链表头部第一个元素。</td></tr><tr><td align="left"><code>E getLast()</code></td><td align="left">返回链表尾部最后一个元素。</td></tr><tr><td align="left"><code>boolean contains(E element)</code></td><td align="left">检查链表中是否包含指定元素。</td></tr><tr><td align="left"><code>E insert(int index, E element)</code></td><td align="left">向链表指定索引位置插入新元素。</td></tr><tr><td align="left"><code>E get(int index)</code></td><td align="left">返回链表中指定索引的元素。</td></tr><tr><td align="left"><code>E set(int index, E element)</code></td><td align="left">为链表中指定索引的元素设新值。</td></tr><tr><td align="left"><code>E remove(int index)</code></td><td align="left">移除链表中指定索引的元素。</td></tr><tr><td align="left"><code>boolean remove(E element)</code></td><td align="left">移除链表中指定的元素。</td></tr><tr><td align="left"><code>int indexOf(E element)</code></td><td align="left">返回指定元素所在链表的索引，元素不存在则返回<code>-1</code>，若存在多个相同元素，则返回第一次出现的索引下标。</td></tr><tr><td align="left"><code>int size()</code></td><td align="left">返回链表存储元素数量。</td></tr><tr><td align="left"><code>boolean isEmpty()</code></td><td align="left">检查链表是否为空。</td></tr><tr><td align="left"><code>void clear()</code></td><td align="left">清空链表。</td></tr><tr><td align="left"><code>String toString()</code></td><td align="left">返回链表的字符串形式。</td></tr></tbody></table><h4 id="单向链表（Single-Linked-List）"><a href="#单向链表（Single-Linked-List）" class="headerlink" title="单向链表（Single Linked List）"></a>单向链表（Single Linked List）</h4><p>我们使用 Java 语言实现一枚简单的<strong>单向链表</strong>。顾名思义，单向链表只能做单向遍历（头节点 -&gt; 尾节点），因为单向链表的节点（Node）只包含数据域和一个指针域（指向下一个节点）。</p><p>我们来定义出单链表中节点（Node）的数据结构，使用泛型类提高节点存储数据的灵活性。节点数据结构包含<strong>构造方法</strong>，两个私有变量：<strong>数据域和指针域</strong>，及其<strong>对应的<code>Getter/Setter</code>公开方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 单链表中节点（Node）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-22 22:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> E elem;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指针域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E element, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elem = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Setter &amp; Getter */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElem</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elem = element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getElem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;E&gt; <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑单链表数据结构：<strong>单链表包含一枚头节点（Head），头结点不存储数据，而是指向第一个实际存储数据的节点；尾节点可以被定义为指针域为<code>null</code>的最后一枚节点。</strong></p><p>这边先把单向链表的完整代码放出来，后面再放出讲解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 单链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-22 23:02</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> fly.hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 23:26 2020/7/22</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向链表头部添加一个新的元素（头插法）。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(element, <span class="keyword">null</span>);</span><br><span class="line">        node.setNext(head.getNext());</span><br><span class="line">        head.setNext(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向链表尾部添加一个新的元素（尾插法）。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(element, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;E&gt; tail = head;</span><br><span class="line">        <span class="keyword">while</span> (tail.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = tail.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        tail.setNext(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得链表头部第一个元素，链表为空则抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> First element of &#123;<span class="doctag">@code</span> LinkedList&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if this &#123;<span class="doctag">@code</span> LinkedList&#125; is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.getNext().getElem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得链表尾部最后一个元素，链表为空则抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Last element of &#123;<span class="doctag">@code</span> LinkedList&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if this &#123;<span class="doctag">@code</span> LinkedList&#125; is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException </span>&#123;</span><br><span class="line">        Node&lt;E&gt; tail = head;</span><br><span class="line">        <span class="keyword">while</span> (tail.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = tail.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tail == head) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail.getElem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算链表存储元素数量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Size of elements in &#123;<span class="doctag">@code</span> LinkedList&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; n = head; n.getNext() != <span class="keyword">null</span>; n = n.getNext()) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查链表是否为空。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean &#123;<span class="doctag">@code</span> true&#125; or &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.getNext() == <span class="keyword">null</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查链表是否为空。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean &#123;<span class="doctag">@code</span> true&#125; or &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">_isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size() &gt; <span class="number">0</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回并移除链表头部第一个元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> First element of this &#123;<span class="doctag">@code</span> Linked List&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; first = head.getNext();</span><br><span class="line">        head.setNext(</span><br><span class="line">                first.getNext()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> first.getElem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回并移除链表尾部最后一个元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Last element of this &#123;<span class="doctag">@code</span> Linked List&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; prev = head;</span><br><span class="line">        <span class="keyword">while</span> (prev.getNext().getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev = prev.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; last = prev.getNext();</span><br><span class="line">        prev.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> last.getElem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查链表中是否包含目标元素，</span></span><br><span class="line"><span class="comment">     * 元素相等使用 &#123;<span class="doctag">@code</span> o.equals(obj)&#125; 判断。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; current = head.getNext();</span><br><span class="line">             current != <span class="keyword">null</span>;</span><br><span class="line">             current = current.getNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.equals(current.getElem())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回指定元素所在链表的索引。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The index of element in &#123;<span class="doctag">@code</span> LinkedList&#125;,</span></span><br><span class="line"><span class="comment">     *  return &#123;<span class="doctag">@code</span> -1&#125; if element does not found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; current = head.getNext();</span><br><span class="line">             current != <span class="keyword">null</span>;</span><br><span class="line">             current = current.getNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.equals(current.getElem())) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表指定索引的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; n = head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = n.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n.getElem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为链表指定索引位置的元素设新值。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Previous element in the index.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; n = head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = n.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        E oldValue = n.getElem();</span><br><span class="line">        n.setElem(element);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除链表指定索引下标元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Removed element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        index -= <span class="number">1</span>;</span><br><span class="line">        Node&lt;E&gt; prev = head;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            prev = prev.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; current = prev.getNext();</span><br><span class="line">        Node&lt;E&gt; next = current.getNext();</span><br><span class="line">        prev.setNext(next);</span><br><span class="line">        <span class="keyword">return</span> current.getElem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除链表指定元素，</span></span><br><span class="line"><span class="comment">     * 操作成功返回&#123;<span class="doctag">@code</span> true&#125;，不存在目标元素则返回&#123;<span class="doctag">@code</span> false&#125;。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = indexOf(element);</span><br><span class="line">        <span class="keyword">return</span> index == -<span class="number">1</span> ?</span><br><span class="line">                <span class="keyword">false</span> : element.equals(remove(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向列表指定位置插入一个新的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Previous element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        index -= <span class="number">1</span>;</span><br><span class="line">        Node&lt;E&gt; prev = head;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            prev = prev.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; current = prev.getNext();</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(element, <span class="keyword">null</span>);</span><br><span class="line">        node.setNext(current);</span><br><span class="line">        prev.setNext(node);</span><br><span class="line">        <span class="keyword">return</span> current == <span class="keyword">null</span> ? <span class="keyword">null</span> : current.getElem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空链表。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;E&gt; n = head;</span><br><span class="line">            head = head.getNext();</span><br><span class="line">            n.setElem(<span class="keyword">null</span>);</span><br><span class="line">            n.setNext(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        head = <span class="keyword">new</span> Node&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; current = head.getNext();</span><br><span class="line">             current != <span class="keyword">null</span>;</span><br><span class="line">             current = current.getNext()) &#123;</span><br><span class="line">            sb.append(current.getElem().toString());</span><br><span class="line">            sb.append(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">']'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析完了整个流程，先来推导一遍单向链表的结点Node</p><ol><li><p>数据域</p></li><li><p>指针域</p></li><li><p>构造方法</p></li><li><p>无参构造方法</p></li><li><p>getter &amp; setter</p></li></ol><p>在双向链表的DLNode里面还多一个内容就是多了一个向前的指针域。</p><p>下面是单向链表的详细分析</p><p>我们使用 Java 语言实现一枚简单的<strong>单向链表</strong>。顾名思义，单向链表只能做单向遍历（头节点 -&gt; 尾节点），因为单向链表的节点（Node）只包含数据域和一个指针域（指向下一个节点）。</p><p>我们来定义出单链表中节点（Node）的数据结构，使用泛型类提高节点存储数据的灵活性。节点数据结构包含<strong>构造方法</strong>，两个私有变量：<strong>数据域和指针域</strong>，及其<strong>对应的<code>Getter/Setter</code>公开方法</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Node&lt;E&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 数据域</span><br><span class="line">     */</span><br><span class="line">    private E elem;</span><br><span class="line">    /**</span><br><span class="line">     * 指针域</span><br><span class="line">     */</span><br><span class="line">    private Node&lt;E&gt; next;</span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     */</span><br><span class="line">    public Node(E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.elem = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 无参构造方法</span><br><span class="line">     */</span><br><span class="line">    public Node() &#123;</span><br><span class="line">        this(null, null);</span><br><span class="line">    &#125;</span><br><span class="line">    /* Setter &amp; Getter */</span><br><span class="line">    public void setElem(E element) &#123;</span><br><span class="line">        this.elem = element;</span><br><span class="line">    &#125;</span><br><span class="line">    public E getElem() &#123;</span><br><span class="line">        return this.elem;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNext(Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    public Node&lt;E&gt; getNext() &#123;</span><br><span class="line">        return this.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表节点（Node）</p></blockquote><p>我们考虑单链表数据结构：<strong>单链表包含一枚头节点（Head），头结点不存储数据，而是指向第一个实际存储数据的节点；尾节点可以被定义为指针域为<code>null</code>的最后一枚节点。</strong></p><p>单链表的构造方法即为单链表初始化：<strong>构造一枚数据域和指针域均为空的头节点。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingleLinkedList&lt;E&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 链表头节点</span><br><span class="line">     */</span><br><span class="line">    private Node&lt;E&gt; head;</span><br><span class="line">    /**</span><br><span class="line">     * 构造方法：创建空链表</span><br><span class="line">     * @param void</span><br><span class="line">     */</span><br><span class="line">    public SingleLinkedList() &#123;</span><br><span class="line">        this.head = new Node&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表（Single Linked List）结构</p></blockquote><p>单链表<code>addFirst()</code>方法向链表头部添加一个新的元素，插入的新元素总是位于链表头部（头节点指向的节点），这种插入元素的方式称为<strong>头插法</strong>，通过以下3步，即可完成向链表头部插入元素。</p><ol><li>根据新元素构建一枚新节点</li><li>将新节点指针域置为头节点指向的节点</li><li>头节点指向新节点</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 向链表头部添加一个新的元素（头插法）。</span><br><span class="line">     * @param element</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public void addFirst(E element) &#123;</span><br><span class="line">        Node&lt;E&gt; node = new Node&lt;E&gt;(element, null);</span><br><span class="line">        node.setNext(head.getNext());</span><br><span class="line">        head.setNext(node);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>addFirst()</code>头插法</p></blockquote><p>单链表<code>addLast()</code>方法向链表尾部添加一个新的元素，插入的新元素总是位于链表尾部（指针域为空的尾节点），这种插入元素的方式称为<strong>尾插法</strong>，通过以下4步，即可完成向链表尾部插入元素。</p><ol><li>根据新元素构建一枚新节点</li><li>将新节点指针域置空</li><li>遍历链表找到尾节点（指针域为空的节点）</li><li>尾节点指向新节点</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 向链表尾部添加一个新的元素（尾插法）。</span><br><span class="line">     * @param element</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public void addLast(E element) &#123;</span><br><span class="line">        Node&lt;E&gt; node = new Node&lt;E&gt;(element, null);</span><br><span class="line">        Node&lt;E&gt; tail = head;</span><br><span class="line">        while (tail.getNext() != null) &#123;</span><br><span class="line">            tail = tail.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        tail.setNext(node);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>addLast()</code>尾插法</p></blockquote><p>理解了<code>addFirst()</code>与<code>addLast()</code>方法实现后，实现<code>getFirst()</code>与<code>getLast()</code>方法就非常简单了，返回头/尾节点数据域中存储的数据即可，但是需要考虑到<strong>链表为空</strong>的情况：直接抛出<code>NoSuchElementException</code>异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 取得链表头部第一个元素，链表为空则抛出异常。</span><br><span class="line">     * @param void</span><br><span class="line">     * @return First element of &#123;@code LinkedList&#125;.</span><br><span class="line">     * @throws NoSuchElementException if this &#123;@code LinkedList&#125; is empty.</span><br><span class="line">     */</span><br><span class="line">    public E getFirst() throws NoSuchElementException &#123;</span><br><span class="line">        if (head.getNext() == null) &#123;</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        return head.getNext().getElem();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 取得链表尾部最后一个元素，链表为空则抛出异常。</span><br><span class="line">     * @param void</span><br><span class="line">     * @return Last element of &#123;@code LinkedList&#125;.</span><br><span class="line">     * @throws NoSuchElementException if this &#123;@code LinkedList&#125; is empty.</span><br><span class="line">     */</span><br><span class="line">    public E getLast() throws NoSuchElementException &#123;</span><br><span class="line">        Node&lt;E&gt; tail = head;</span><br><span class="line">        while (tail.getNext() != null) &#123;</span><br><span class="line">            tail = tail.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        if (tail == head) &#123;</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        return tail.getElem();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>getFirst()</code>与<code>getLast()</code>方法实现</p></blockquote><p>上述实现代码段其实已经涉及到了<code>isEmpty()</code>与<code>size()</code>接口方法，现在我们来实现这两个方法。</p><ul><li><code>size()</code>：遍历链表元素并计数，计算链表存储元素数量。</li><li><code>isEmpty()</code>：判断链表是否为空，可以借用<code>size()</code>方法（链表存储元素数量为<code>0</code>则表示链表为空），也可以直接判断头结点指针域是否为空。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 计算链表存储元素数量。</span><br><span class="line">     * @param void</span><br><span class="line">     * @return Size of elements in &#123;@code LinkedList&#125;.</span><br><span class="line">     */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for (Node&lt;E&gt; n = head; n.getNext() != null; n = n.getNext()) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 检查链表是否为空。</span><br><span class="line">     * @param void</span><br><span class="line">     * @return Boolean &#123;@code true&#125; or &#123;@code false&#125;.</span><br><span class="line">     */</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return head.getNext() == null ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 检查链表是否为空。</span><br><span class="line">     * @param void</span><br><span class="line">     * @return Boolean &#123;@code true&#125; or &#123;@code false&#125;.</span><br><span class="line">     */</span><br><span class="line">    public boolean _isEmpty() &#123;</span><br><span class="line">        return this.size() &gt; 0 ? false : true;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>isEmpty()</code>与<code>size()</code>方法实现</p></blockquote><p>单链表<code>removeFirst()</code>方法返回并移除链表第一个元素，通过以下步骤完成。</p><ol><li>检查链表是否为空</li><li>获取链表首元素节点</li><li>头节点指向第二元素节点（首元素节点的下一个节点）</li><li>返回首元素节点数据域</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 返回并移除链表头部第一个元素。</span><br><span class="line">     * @param void</span><br><span class="line">     * @return First element of this &#123;@code Linked List&#125;.</span><br><span class="line">     * @throws NoSuchElementException</span><br><span class="line">     */</span><br><span class="line">    public E removeFirst() throws NoSuchElementException &#123;</span><br><span class="line">        if (this.isEmpty()) &#123;</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; first = head.getNext();</span><br><span class="line">        head.setNext(</span><br><span class="line">            first.getNext()</span><br><span class="line">        );</span><br><span class="line">        return first.getElem();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>removeFirst()</code>方法实现</p></blockquote><p>单链表<code>removeLast()</code>方法返回并移除链表最后一个元素，通过以下步骤完成。</p><ol><li>检查链表是否为空</li><li>获取链表倒数第二元素节点（尾元素前一节点）</li><li>获取链表尾元素节点</li><li>将链表倒数第二元素节点指针域置空</li><li>返回尾元素节点数据域</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 返回并移除链表尾部最后一个元素。</span><br><span class="line">     * @param void</span><br><span class="line">     * @return Last element of this &#123;@code Linked List&#125;.</span><br><span class="line">     * @throws NoSuchElementException</span><br><span class="line">     */</span><br><span class="line">    public E removeLast() throws NoSuchElementException &#123;</span><br><span class="line">        if (this.isEmpty()) &#123;</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; prev = head;</span><br><span class="line">        while (prev.getNext().getNext() != null) &#123;</span><br><span class="line">            prev = prev.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; last = prev.getNext();</span><br><span class="line">        prev.setNext(null);</span><br><span class="line">        return last.getElem();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>removeLast()</code>方法实现</p></blockquote><p>我们来考虑单链表的<code>contains(E e)</code>方法，检查链表中是否包含指定元素。我们使用<code>equals()</code>比较方法判断两个元素是否相等，因此，存入链表的数据类型必须实现<code>equals()</code>比较方法。</p><p><code>contains(E e)</code>方法具体实现为：<strong>遍历链表，比较每个元素，找到即返回<code>true</code>，找不到则返回<code>false</code>。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 检查链表中是否包含目标元素，</span><br><span class="line">     * 元素相等使用 &#123;@code o.equals(obj)&#125; 判断。</span><br><span class="line">     * @param element</span><br><span class="line">     * @return Boolean</span><br><span class="line">     */</span><br><span class="line">    public boolean contains(E element) &#123;</span><br><span class="line">        for (Node&lt;E&gt; current = head.getNext();</span><br><span class="line">            current != null;</span><br><span class="line">            current = current.getNext()) &#123;</span><br><span class="line">            if (element.equals(current.getElem())) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>contains()</code>方法实现</p></blockquote><p>链表使用链式存储结构，存储的数据在内存空间中不连续，不能做到像数组一般高效的直接随即访问。我们来实现<code>indexOf(E e)</code>方法，返回指定元素所在链表的索引，元素不存在则返回<code>-1</code>，若存在多个相同元素，则返回第一次出现的索引。<strong>注意，我们将链表索引下标从<code>0</code>计起，与数组保持一致。<code>indexOf()</code>方法实现与<code>contains()</code>方法相似，加入一枚索引下标计数器即可。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 返回指定元素所在链表的索引。</span><br><span class="line">     * @param element</span><br><span class="line">     * @return The index of element in &#123;@code LinkedList&#125;,</span><br><span class="line">     *  return &#123;@code -1&#125; if element does not found.</span><br><span class="line">     */</span><br><span class="line">    public int indexOf(E element) &#123;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (Node&lt;E&gt; current = head.getNext();</span><br><span class="line">            current != null;</span><br><span class="line">            current = current.getNext()) &#123;</span><br><span class="line">                if (element.equals(current.getElem())) &#123;</span><br><span class="line">                    return index;</span><br><span class="line">                &#125;</span><br><span class="line">                ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>indexOf()</code>方法实现</p></blockquote><p>我们使用<code>get(int index)</code>方法获取链表中指定索引的元素，如果索引越界，抛出<code>IndexOutOfBoundsException</code>异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 获取链表指定索引的元素。</span><br><span class="line">     * @param index</span><br><span class="line">     * @return element</span><br><span class="line">     * @throws IndexOutOfBoundsException</span><br><span class="line">     */</span><br><span class="line">    public E get(int index) throws IndexOutOfBoundsException &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;= size()) &#123;</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; n = head.getNext();</span><br><span class="line">        while (index &gt; 0) &#123;</span><br><span class="line">            n = n.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        return n.getElem();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>get()</code>方法实现</p></blockquote><p>我们使用<code>set(int index, E element)</code>方法为链表中指定索引位置的元素设新值，如果索引越界，抛出<code>IndexOutOfBoundsException</code>异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 为链表指定索引位置的元素设新值。</span><br><span class="line">     * @param index</span><br><span class="line">     * @param element</span><br><span class="line">     * @return Previous element in the index.</span><br><span class="line">     * @throws IndexOutOfBoundsException</span><br><span class="line">     */</span><br><span class="line">    public E set(int index, E element) throws IndexOutOfBoundsException &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;= size()) &#123;</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; n = head.getNext();</span><br><span class="line">        while (index &gt; 0) &#123;</span><br><span class="line">            n = n.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        E oldValue = n.getElem();</span><br><span class="line">        n.setElem(element);</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>set()</code>方法实现</p></blockquote><p>我们使用<code>remove(int index)</code>方法移除链表中指定索引下标位置的元素，具体步骤如下。如果索引下标越界，则抛出<code>IndexOutOfBoundsException</code>异常。</p><ol><li>找到链表中指定索引下标的待移除节点及其前驱、后继节点</li><li>将指定索引下标节点的前后节点使用指针连接起来</li><li>返回移除节点数据域</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 移除链表指定索引下标元素。</span><br><span class="line">     * @param index</span><br><span class="line">     * @return Removed element</span><br><span class="line">     * @throws IndexOutOfBoundsException</span><br><span class="line">     */</span><br><span class="line">    public E remove(int index) throws IndexOutOfBoundsException &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;= size()) &#123;</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        index -= 1;</span><br><span class="line">        Node&lt;E&gt; prev = head;</span><br><span class="line">        while (index &gt;= 0) &#123;</span><br><span class="line">            prev = prev.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; current = prev.getNext();</span><br><span class="line">        Node&lt;E&gt; next = current.getNext();</span><br><span class="line">        prev.setNext(next);</span><br><span class="line">        return current.getElem();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>remove(int index)</code>方法实现</p></blockquote><p>移除元素<code>remove()</code>方法还有另一种形式：<code>boolean remove(E element)</code>，移除链表中的指定元素。我们可以使用<code>indexOf(E element)</code>配合<code>remove(int index)</code>实现，先获取指定元素在链表中的索引下标，再移除掉，操作成功返回<code>true</code>，如果不存在目标元素，则返回<code>false</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 移除链表指定元素，</span><br><span class="line">     * 操作成功返回&#123;@code true&#125;，不存在目标元素则返回&#123;@code false&#125;。</span><br><span class="line">     * @param element</span><br><span class="line">     * @return Boolean</span><br><span class="line">     */</span><br><span class="line">    public boolean remove(E element) &#123;</span><br><span class="line">        int index = indexOf(element);</span><br><span class="line">        return index == -1 ?</span><br><span class="line">        false : element.equals(remove(index));</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>remove(E element)</code>方法实现</p></blockquote><p>链表数据结构的优势在于其插入元素的开销比起数组要小很多，我们来实现链表插入元素<code>insert()</code>方法，具体步骤如下所示。如果索引下标越界，则抛出<code>IndexOutOfBoundsException</code>异常。</p><ol><li>找到链表中指定索引下标节点（当前节点）及其前驱节点</li><li>创建一枚新节点</li><li>新节点指向当前节点</li><li>前驱节点指向新节点</li><li>返回当前节点数据域</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 向列表指定位置插入一个新的元素。</span><br><span class="line">     * @param index</span><br><span class="line">     * @param element</span><br><span class="line">     * @return Previous element</span><br><span class="line">     * @throws IndexOutOfBoundsException</span><br><span class="line">     */</span><br><span class="line">    public E insert(int index, E element)</span><br><span class="line">    throws IndexOutOfBoundsException &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt; size()) &#123;</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        index -= 1;</span><br><span class="line">        Node&lt;E&gt; prev = head;</span><br><span class="line">        while (index &gt;= 0) &#123;</span><br><span class="line">            prev = prev.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; current = prev.getNext();</span><br><span class="line">        Node&lt;E&gt; node = new Node&lt;E&gt;(element, null);</span><br><span class="line">        node.setNext(current);</span><br><span class="line">        prev.setNext(node);</span><br><span class="line">        return current == null ? null : current.getElem();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>insert()</code>方法实现</p></blockquote><p>我们为链表提供一枚<code>clear()</code>方法，用于清空链表元素。由于 Java 语言的自动垃圾回收机制，直接将头节点（Head）置空即可表示清空链表，不用担心内存泄露问题，但是为了帮助垃圾收集器更好地做内存回收工作，这里我们选择<strong>显式清空每一个节点</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * 清空链表。</span><br><span class="line">     * @param void</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        while (head != null) &#123;</span><br><span class="line">            Node&lt;E&gt; n = head;</span><br><span class="line">            head = head.getNext();</span><br><span class="line">            n.setElem(null);</span><br><span class="line">            n.setNext(null);</span><br><span class="line">        &#125;</span><br><span class="line">        head = new Node&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>clear()</code>方法实现</p></blockquote><p>最后，我们来覆写链表<code>toString()</code>方法，更加方便地查看链表元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.append(&apos;[&apos;);</span><br><span class="line">        for (Node&lt;E&gt; current = head.getNext();</span><br><span class="line">            current != null;</span><br><span class="line">            current = current.getNext()) &#123;</span><br><span class="line">                sb.append(current.getElem().toString());</span><br><span class="line">                sb.append(&quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&apos;]&apos;);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>代码清单：单链表<code>toString()</code>方法实现</p></blockquote><h4 id="双向链表（Double-Linked-List）"><a href="#双向链表（Double-Linked-List）" class="headerlink" title="双向链表（Double Linked List）"></a>双向链表（Double Linked List）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.IndexOutOfBoundsException;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 双向链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-22 23:46</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DLNode&lt;E&gt; head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DLNode&lt;E&gt; tail;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法：创建空链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DLNode&lt;E&gt;();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DLNode&lt;E&gt;();</span><br><span class="line">        head.setNext(tail);</span><br><span class="line">        tail.setPrev(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向双向链表指定索引位置插入一个新元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Previous element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        DLNode&lt;E&gt; current = head;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            current = current.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        DLNode&lt;E&gt; node = <span class="keyword">new</span> DLNode&lt;E&gt;(element, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        node.setNext(current);</span><br><span class="line">        node.setPrev(current.getPrev());</span><br><span class="line">        current.getPrev().setNext(node);</span><br><span class="line">        current.setPrev(node);;</span><br><span class="line">        <span class="keyword">return</span> current.getNext() == <span class="keyword">null</span> ? <span class="keyword">null</span> : current.getElem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除双向链表指定元素，</span></span><br><span class="line"><span class="comment">     * 操作成功返回&#123;<span class="doctag">@code</span> true&#125;，不存在目标元素则返回&#123;<span class="doctag">@code</span> false&#125;。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = indexOf(element);</span><br><span class="line">        <span class="keyword">return</span> index == -<span class="number">1</span> ?</span><br><span class="line">                <span class="keyword">false</span> : element.equals(remove(index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除双向链表指定索引下标元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Removed element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Input: 1 */</span></span><br><span class="line">        <span class="comment">/* head &lt;--&gt; elem(1) &lt;--&gt; elem(2) &lt;--&gt; elem(3) &lt;--&gt; tail */</span></span><br><span class="line">        DLNode&lt;E&gt; node = head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        node.getPrev().setNext(node.getNext());</span><br><span class="line">        node.getNext().setPrev(node.getPrev());</span><br><span class="line">        node.setPrev(<span class="keyword">null</span>);</span><br><span class="line">        node.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> node.getElem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为双向链表指定索引位置的元素设新值。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Previous element in the index.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        DLNode&lt;E&gt; node = head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        E oldElem = node.getElem();</span><br><span class="line">        node.setElem(element);</span><br><span class="line">        <span class="keyword">return</span> oldElem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取双向链表指定索引位置的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        DLNode&lt;E&gt; node = head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.getNext();</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.getElem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回指定元素所在双向链表的索引位置。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The index of element in &#123;<span class="doctag">@code</span> DoubleLinkedList&#125;,</span></span><br><span class="line"><span class="comment">     * return &#123;<span class="doctag">@code</span> -1&#125; if element does not found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DLNode&lt;E&gt; current = head.getNext();</span><br><span class="line">             current.getNext() != <span class="keyword">null</span>;</span><br><span class="line">             current = current.getNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.equals(current.getElem())) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查双向链表中是否包含目标元素，</span></span><br><span class="line"><span class="comment">     * 元素相等使用 &#123;<span class="doctag">@code</span> o.equals(obj)&#125; 判断。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DLNode&lt;E&gt; current = head.getNext();</span><br><span class="line">             current.getNext() != <span class="keyword">null</span>;</span><br><span class="line">             current = current.getNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.equals(current.getElem())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除并返回双向链表尾部最后一个元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Last element of this &#123;<span class="doctag">@code</span> DoubleLinkedList&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        DLNode&lt;E&gt; node = tail.getPrev();</span><br><span class="line">        node.getPrev().setNext(tail);</span><br><span class="line">        tail.setPrev(node.getPrev());</span><br><span class="line">        node.setPrev(<span class="keyword">null</span>);</span><br><span class="line">        node.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> node.getElem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除并返回双向链表头部第一个元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> First element of this &#123;<span class="doctag">@code</span> DoubleLinkedList&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        DLNode&lt;E&gt; node = head.getNext();</span><br><span class="line">        node.getNext().setPrev(head);</span><br><span class="line">        head.setNext(node.getNext());</span><br><span class="line">        node.setPrev(<span class="keyword">null</span>);</span><br><span class="line">        node.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> node.getElem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向双向链表头部添加一个新元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        DLNode&lt;E&gt; node = <span class="keyword">new</span> DLNode&lt;E&gt;(element, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        node.setPrev(head);</span><br><span class="line">        node.setNext(</span><br><span class="line">                head.getNext()</span><br><span class="line">        );</span><br><span class="line">        head.setNext(node);</span><br><span class="line">        head.getNext().setPrev(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向双端链表尾部添加一个新元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        DLNode&lt;E&gt; node = <span class="keyword">new</span> DLNode&lt;E&gt;(element, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        node.setPrev(tail.getPrev());</span><br><span class="line">        node.setNext(tail);</span><br><span class="line">        tail.getPrev().setNext(node);</span><br><span class="line">        tail.setPrev(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得双向链表头部第一个元素，链表为空则抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> First element of &#123;<span class="doctag">@code</span> DoubleLinkedList&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.getNext().getElem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得双向链表尾部最后一个元素，链表为空则抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Last element of &#123;<span class="doctag">@code</span> DoubleLinkedList&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail.getPrev().getElem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算双向链表存储元素数量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Size of &#123;<span class="doctag">@code</span> DoubleLinkedList&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DLNode&lt;E&gt; n = head.getNext();</span><br><span class="line">             n.getNext() != <span class="keyword">null</span>;</span><br><span class="line">             n = n.getNext()) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查双向链表是否为空。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean &#123;<span class="doctag">@code</span> true&#125; or &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size() &gt; <span class="number">0</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空双向链表。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            DLNode&lt;E&gt; current = head;</span><br><span class="line">            head = head.getNext();</span><br><span class="line">            current.setElem(<span class="keyword">null</span>);</span><br><span class="line">            current.setPrev(<span class="keyword">null</span>);</span><br><span class="line">            current.setNext(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        head = <span class="keyword">new</span> DLNode&lt;E&gt;();</span><br><span class="line">        tail = <span class="keyword">new</span> DLNode&lt;E&gt;();</span><br><span class="line">        head.setNext(tail);</span><br><span class="line">        tail.setPrev(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回双向链表字符串形式。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span> (DLNode&lt;E&gt; current = head.getNext();</span><br><span class="line">             current.getNext() != <span class="keyword">null</span>;</span><br><span class="line">             current = current.getNext()) &#123;</span><br><span class="line">            sb.append(current.getElem().toString());</span><br><span class="line">            sb.append(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">']'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找出两个链表的交点"><a href="#找出两个链表的交点" class="headerlink" title="找出两个链表的交点"></a>找出两个链表的交点</h4><ol start="160"><li>Intersection of Two Linked Lists (Easy)</li></ol><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">力扣</a></p><p>例如以下示例中 A 和 B 两个链表相交于 c1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                    ↘</span><br><span class="line">                      c1 → c2 → c3</span><br><span class="line">                    ↗</span><br><span class="line">B:    b1 → b2 → b3</span><br></pre></td></tr></table></figure><p>但是不会出现以下相交的情况，因为每个节点只有一个 next 指针，也就只能有一个后继节点，而以下示例中节点 c 有两个后继节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2       d1 → d2</span><br><span class="line">                    ↘  ↗</span><br><span class="line">                      c</span><br><span class="line">                    ↗  ↘</span><br><span class="line">B:    b1 → b2 → b3        e1 → e2</span><br></pre></td></tr></table></figure><p>要求时间复杂度为 O(N)，空间复杂度为 O(1)。如果不存在交点则返回 null。</p><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 <code>a + c + b = b + c + a</code>。</p><p>给出来的标准答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    ListNode l1 = headA, l2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span>) ? headB : l1.next;</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? headA : l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码只能跑一跑基本类型的链表，真正要运行的话还有一些坑要踩</p><p>当Node泛型是String的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">getIntersectionNode</span><span class="params">(Node headA, Node headB)</span> </span>&#123;</span><br><span class="line">    Node l1 = headA, l2 = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1.getElem() != l2.getElem()) &#123;</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span>) ? headB : l1.getNext();</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? headA : l2.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码是可以通过的，但是这是特例，因为</p><blockquote><p>equals不Override的情况下总是调用==，==在基本数据类型里面是比较值，在别的类型里面是比较内存地址，复写的情况下会调用equals方法，String类型不是基本数据类型，但是使用String a=”a”的时候，默认使用的不是堆内存，使用的常量池，所以使用 == 会判定true，使用new的话会使用堆内存所以判定false</p></blockquote><p>举例一个普通的pojo类，需要实现一些方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: java pojo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-24 23:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getName().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">getIntersectionNode</span><span class="params">(Node&lt;Person&gt; headA, Node&lt;Person&gt; headB)</span> </span>&#123;</span><br><span class="line">    Node&lt;Person&gt; l1 = headA, l2 = headB;</span><br><span class="line">    Person NULL = <span class="keyword">new</span> Person(<span class="string">"NULL"</span>);</span><br><span class="line">    Node&lt;Person&gt; l3 = <span class="keyword">new</span> Node&lt;Person&gt;(NULL,headA);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(l1.getElem().equals(l2.getElem()))) &#123;</span><br><span class="line"></span><br><span class="line">        l1 = (l1 == l3) ? headB : l1.getNext();</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) l1 = l3;</span><br><span class="line"></span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? headA : l2.getNext();</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) l2 = l3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中引入了一个<code>l3</code>，引入的原因是如果两个链表不一样长的时候会出现某个链表先遍历完毕，然后这个时候<code>null.getElem()</code>就会报错。</p><p>这个问题有个变种，就是判断两个链表是否存在交点，直接判断<code>LinkedListA</code>和<code>LinkedListB</code>两个链表最后一个Node元素是否相等即可。</p><p>解到这里，我突然感觉我走偏了，我这里链表相同的条件出了点问题，可能要判断的其实是Node是否相同而已，直接判断地址即可。</p><p>也就是说第一段代码，没有问题。</p><p>我仅仅通过<code>addLast</code>是没有办法创建出两个有用相同节点的链表的，如果要模拟那种链表的话，需要三个链表，把第一个链表的Last节点的指针指向第三个链表的头结点即可。造成这种乌龙的原因是因为对一些底层的概念忘得差不多了。</p><p>这题同时还有一个变种就是是否存在交点。</p><p>如果仅仅问是否存在交点的话，最简单的办法就是直接把两个链表的最后一个节点分别拿出来判断，如果两个节点相等（地址相等）的话，和存在交点是互为充要条件的。</p><p>其实解法很多，有一种取巧解法先把两个链表的size拿出来，因为是有公共部分的，公共部分的长度肯定相等，于是乎把长的链表多出来的那个部分忽略，假设长链表的size是m，短链表的size是n，m-n得到多出来的部分，长链表从m-n+1的位置开始，锻炼表从head位置开始，在同一个循环里面遍历，如果两者相等了，那么就说明有交点。</p><p>有一种经典的解法可以把这个问题转化一下，把链表<code>alist</code>的尾节点挂到<code>blist</code>的头节点上面，于是问题变成了探究<code>blist</code>是否存在环，如果存在的话，就说明两个链表存在着交点。</p><p>这里前面两种都相对简单，仅仅探讨第三种情况。</p><p>使用两个指针从头节点开始遍历，一个速度是1，一个速度是2，如果链表存在环的，那么速度块的指针总是会给速度慢的套圈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judgeIfTheIntersectionExists</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Node slow = head;</span><br><span class="line">    Node fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.getNext() != <span class="keyword">null</span>)&#123;</span><br><span class="line">        slow = slow.getNext();</span><br><span class="line">        fast = fast.getNext().getNext();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，即可。</p><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>反转链表介绍两种办法，一种是递归，一种是头插入法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.LinkedListUtils;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.dllist.DLNode;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.dllist.MyDoubleLinkedList;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.MySingleLinkedList;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.Node;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.pojo.Person;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/7/25 17:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger(ReverseLinkedList.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MySingleLinkedList list = LinkedListUtils.generateSingleLinkList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        Node node = reverseList(list.getFirst());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为整个链表已经反转，所以只能根据新的头节点往下便利出新的节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(node.getElem());</span><br><span class="line">            node = node.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> com.hugh.datastructure.linkedlist.Node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 递归反转列表 head -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9</span></span><br><span class="line"><span class="comment">     * 变为  head -&gt; 1 &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5 &lt;- 6 &lt;- 7 &lt;- 8 &lt;- 9  可以因为我的链表设计了null的head 所以导致了反转之后使用原先输出方式就不正确了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 16:35 2020/7/26</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> [head]</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"step1:"</span> + head + <span class="string">" "</span> + head.getElem());</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node next = head.getNext();</span><br><span class="line">        Node newhead = reverseList(next);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里的 newhead 的赋值过程，在head = 9的时候，作为head Node类型返回</span></span><br><span class="line"><span class="comment">         * 返回是9之后，这个9在每一次递归的过程中都在传递，因为不涉及newhead元素的再次赋值，只是简单的值传递，</span></span><br><span class="line"><span class="comment">         * 所以一直到最后返回的都是9，也就是头节点。</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        logger.info(<span class="string">"newhead:"</span> + newhead + <span class="string">" "</span> + newhead.getElem());</span><br><span class="line">        next.setNext(head);</span><br><span class="line">        head.setNext(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头插法，</span></span><br><span class="line"><span class="comment">     * 从第一个值开始改变，有三个指针，pre指针，next指针，head也就是cur指针，每次循环改变pre和next的值，</span></span><br><span class="line"><span class="comment">     * pre 和 next 分别记录上一个迭代和下一个迭代head的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseIterativeltly</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.为next赋值</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            next = head.getNext();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2.pre指针每次使用的值都是延迟一个迭代，所以先使用再赋值</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            head.setNext(pre);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 3.为pre赋新值进入下一个轮回</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            pre = head;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 4.head指针重新赋值</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并两个有序的链表"><a href="#归并两个有序的链表" class="headerlink" title="归并两个有序的链表"></a>归并两个有序的链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.LinkedListUtils;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.MySingleLinkedList;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.Node;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.SingleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/7/27 5:40 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTwoSortedLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MySingleLinkedList&lt;Integer&gt; listA = LinkedListUtils.generateSingleLinkList(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">20</span>);</span><br><span class="line">        MySingleLinkedList&lt;Integer&gt; listB = LinkedListUtils.generateSingleLinkList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">100</span>);</span><br><span class="line">        Node node = mergeTwoLists(listA.getFirst(), listB.getFirst());</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(node.getElem());</span><br><span class="line">            node = node.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并两个有序的链表，</span></span><br><span class="line"><span class="comment">     * 继续使用递归的方法，非常优雅的代码</span></span><br><span class="line"><span class="comment">     * 要适应使用递归的方法，就要适应一个自下而上的思维。</span></span><br><span class="line"><span class="comment">     * 此情况下，通过递归先找到最大的值，然后每次回溯上一个节点的时候都有两个选项，所以代码最终变成了这个样子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">mergeTwoLists</span><span class="params">(Node&lt;Integer&gt; l1, Node&lt;Integer&gt; l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1.getElem() &lt;= l2.getElem()) &#123;</span><br><span class="line">            l1.setNext(mergeTwoLists(l1.getNext(),l2));</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.setNext(mergeTwoLists(l1,l2.getNext()));</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从有序链表中删除重复节点"><a href="#从有序链表中删除重复节点" class="headerlink" title="从有序链表中删除重复节点"></a>从有序链表中删除重复节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node&lt;Integer&gt; <span class="title">deleteDuplicatesThird</span><span class="params">(Node&lt;Integer&gt; head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    head.setNext(deleteDuplicatesThird(head.getNext()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 根据递归三问</span></span><br><span class="line"><span class="comment">     * 第一问 终止条件是什么</span></span><br><span class="line"><span class="comment">     * 第二问 本级递归需要做什么</span></span><br><span class="line"><span class="comment">     * 第三问 返回值是什么</span></span><br><span class="line"><span class="comment">     * 本题目中，根据递归三问，追溯到链表的最后，首先拿到了最后一个值</span></span><br><span class="line"><span class="comment">     * 这个值跟前面一个值进行对比，如果相等话，应该返还哪一个呢？</span></span><br><span class="line"><span class="comment">     * 肯定是返回后面一个的。</span></span><br><span class="line"><span class="comment">     * 原因是我们设置的返回值同时设置了前面一个链表的next</span></span><br><span class="line"><span class="comment">     * 如果我们返回第一个的话，等同于没有进行去重操作。</span></span><br><span class="line"><span class="comment">     * 如果返回第二个的话等于把倒数第三个的next设置在了最后一个上面。</span></span><br><span class="line"><span class="comment">     * 这样才是符合逻辑的。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 4:17 2020/7/31</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [head]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> com.hugh.datastructure.linkedlist.Node&lt;java.lang.Integer&gt;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">return</span> (head.getElem() == head.getNext().getElem()) ? head.getNext() : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除链表的倒数第-n-个节点"><a href="#删除链表的倒数第-n-个节点" class="headerlink" title="删除链表的倒数第 n 个节点"></a>删除链表的倒数第 n 个节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 汗颜，想起我做的第一道题目，求两链表交点的那题，当时那题，我引入了一个L3节点</span></span><br><span class="line"><span class="comment">     * 因为两个链表长度不一样的时候，先遍历完毕的那个链表会出现一个Null.getElement的空指针问题，</span></span><br><span class="line"><span class="comment">     * 我他妈研究了好久，引入了一个L3，因为没有总结，在这道题目用例是[1] 1的时候出现的空指针又卡了好久。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node&lt;Integer&gt; <span class="title">removeNthNodeFromEndOfList</span><span class="params">(Node&lt;Integer&gt; head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Node&lt;Integer&gt; pre = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        pre.setNext(head);</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        Node&lt;Integer&gt; slow = pre;</span><br><span class="line">        Node&lt;Integer&gt; fast = pre;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">            fast = fast.getNext();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一种写法</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            fast = fast.getNext();</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.getNext();</span><br><span class="line">            slow = slow.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow.setNext(slow.getNext().getNext());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  pre.getNext();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="交换链表中的相邻结点"><a href="#交换链表中的相邻结点" class="headerlink" title="交换链表中的相邻结点"></a>交换链表中的相邻结点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一次自己写这个迭代法的时候，其实就完成得差不多了，但是没有加一把劲解出来，有点可惜，一道medium的题目</span></span><br><span class="line"><span class="comment"> * 这个解法引入了多个变量</span></span><br><span class="line"><span class="comment"> * 首先要弄清楚一个东西，不能因为变量变多了人就开始晕了</span></span><br><span class="line"><span class="comment"> * 首先定义了三个指针变量，然后考虑到将来要返回头节点，所以这边还多了一个node是为了将来要返回的，也就是四个变量，再加上一个head变量</span></span><br><span class="line"><span class="comment"> * 除了变量多了点，别的都没啥，有手就行。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">swapPairsIteration</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node dummy = <span class="keyword">new</span> Node();</span><br><span class="line">    dummy.setNext(head);</span><br><span class="line"></span><br><span class="line">    Node pre = dummy;</span><br><span class="line"></span><br><span class="line">    Node first = <span class="keyword">null</span>;</span><br><span class="line">    Node second = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = head;</span><br><span class="line">        second = head.getNext();</span><br><span class="line"></span><br><span class="line">        pre.setNext(second);</span><br><span class="line">        first.setNext(second.getNext());</span><br><span class="line">        second.setNext(first);</span><br><span class="line"></span><br><span class="line">        pre = first;</span><br><span class="line">        head = first.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.getNext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其实拿到这个题目，我就在想能不能用递归做了。</span></span><br><span class="line"><span class="comment"> * 感觉没有什么好的思路。</span></span><br><span class="line"><span class="comment"> * 三板斧</span></span><br><span class="line"><span class="comment"> *      整个递归的终止条件。</span></span><br><span class="line"><span class="comment"> *      一级递归需要做什么？</span></span><br><span class="line"><span class="comment"> *      应该返回给上一级的返回值是什么？</span></span><br><span class="line"><span class="comment"> * 返回值应该是偶数位置的值？</span></span><br><span class="line"><span class="comment"> * 递归终止条件还是比较常规的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">swapPairsRecursion</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node odd = head;</span><br><span class="line">    Node even = head.getNext();</span><br><span class="line"></span><br><span class="line">    odd.setNext(swapPairsRecursion(even.getNext()));</span><br><span class="line">    even.setNext(odd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.linkedlist.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.LinkedListUtils;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.MySingleLinkedList;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/5 15:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTwoNumbers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MySingleLinkedList listA = LinkedListUtils.generateSingleLinkList(<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">        MySingleLinkedList listB = LinkedListUtils.generateSingleLinkList(<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">//        Node node = addTwoNumbersMedium(listA.getFirst(), listB.getFirst());</span></span><br><span class="line">        Node node = addTwoNumbersEasy(listA.getFirst(), listB.getFirst());</span><br><span class="line">        LinkedListUtils.traverseLinkListFromFirst(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 说实话 我只想用递归来做这题</span></span><br><span class="line"><span class="comment">     * 但是递归并没有很好地办法来解决这个问题。</span></span><br><span class="line"><span class="comment">     * 这个问题里面引入了Java6 开始使用的Stack，stack可以作为一个新的知识点存入我的leeocode框架。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headB</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">addTwoNumbersMedium</span><span class="params">(Node&lt;Integer&gt; headA, Node&lt;Integer&gt; headB)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s1.push(headA.getElem());</span><br><span class="line">            headA = headA.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (headB != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s2.push(headB.getElem());</span><br><span class="line">            headB = headB.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty() || !s2.isEmpty() || c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (s1.isEmpty() ? <span class="number">0</span> : s1.pop()) + (s2.isEmpty() ? <span class="number">0</span> : s2.pop()) + c;</span><br><span class="line">            Node n = <span class="keyword">new</span> Node(sum % <span class="number">10</span>, <span class="keyword">null</span>);</span><br><span class="line">            c = sum / <span class="number">10</span>;</span><br><span class="line">            n.setNext(res);</span><br><span class="line">            res = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> com.hugh.datastructure.linkedlist.Node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 这个情况要比上面的情况简单不少，少了一个过程，就是那个压栈 弹栈的过程。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 21:37 2020/8/5</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> [headA, headB]</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">addTwoNumbersEasy</span><span class="params">(Node&lt;Integer&gt; headA, Node&lt;Integer&gt; headB)</span> </span>&#123;</span><br><span class="line">        Node nh = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        Node index = nh;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (headA != <span class="keyword">null</span> || headB != <span class="keyword">null</span> || c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum =</span><br><span class="line">                    ((headA == <span class="keyword">null</span>) ? <span class="number">0</span> : headA.getElem()) +</span><br><span class="line">                            ((headB == <span class="keyword">null</span>) ? <span class="number">0</span> : headB.getElem()) +</span><br><span class="line">                            c;</span><br><span class="line">            index.setNext(<span class="keyword">new</span> Node(sum % <span class="number">10</span>, <span class="keyword">null</span>));</span><br><span class="line">            index = index.getNext();</span><br><span class="line">            c = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (headA != <span class="keyword">null</span>) headA = headA.getNext();</span><br><span class="line">            <span class="keyword">if</span> (headB != <span class="keyword">null</span>) headB = headB.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) index.setNext(<span class="keyword">new</span> Node(c, <span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">return</span> nh.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.linkedlist.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.LinkedListUtils;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.MySingleLinkedList;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.Node;</span><br><span class="line"><span class="keyword">import</span> sun.awt.image.ImageWatched;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 回文链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-06 03:35</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">isPalindrome</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MySingleLinkedList list = LinkedListUtils.generateSingleLinkList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//        boolean flag = isPalindromeFirst(list.getFirst());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        boolean flag = new isPalindrome().isPalindromeSecond(list.getFirst());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">new</span> isPalindrome().isPalindromeThird(list.getFirst());</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        MySingleLinkedList listRecursion = LinkedListUtils.generateSingleLinkList(1, 2, 3,4,5,6,7,8,9);</span></span><br><span class="line"><span class="comment">        Node&lt;Integer&gt; node = new isPalindrome().reverseList(listRecursion.getFirst());</span></span><br><span class="line"><span class="comment">        System.out.println(node.getElem());</span></span><br><span class="line"><span class="comment">        LinkedListUtils.traverseLinkListFromFirst(node);*/</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 首先介绍一下回文词的意思: 正反看都一样的英文单词</span></span><br><span class="line"><span class="comment">     * 这里就是链表前后两个部分是呈轴对称。</span></span><br><span class="line"><span class="comment">     * 在LeeCode里面这道题目难度判定是Easy，可能是因为并没有强制指定这道题目的时间复杂度和空间复杂度。</span></span><br><span class="line"><span class="comment">     * 贴上三种典型一点的解法：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * First:将值复制到数组中后用双指针法</span></span><br><span class="line"><span class="comment">     * 数组列表(ArrayList) 底层是使用数组存储值，我们可以通过索引在 O(1) 的时间访问列表任何位置的值，这是由于内存寻址的方式。</span></span><br><span class="line"><span class="comment">     * 链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n) 时间，因为要通过指针获取到下一个位置的节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 定数组列表是否为回文很简单，我们可以使用双指针法来比较两端的元素，并向中间移动。一个指针从起点向中间移动，另一个指针从终点向中间移动。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这需要 O(n) 的时间，因为访问每个元素的时间是 O(1)，而有 n 个元素要访问。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 直接在链表上操作并不简单，因为不论是正向访问还是反向访问都不是 O(1), 下面的两种方式演示了特意用递归来解决问题。</span></span><br><span class="line"><span class="comment">     * 而将链表的值复制到数组列表中是 O(n)，因此最简单的方法就是将链表的值复制到数组列表中，再使用双指针法判断。</span></span><br><span class="line"><span class="comment">     * 因此我们可以分为两个步骤：</span></span><br><span class="line"><span class="comment">     * 1.复制链表值到数组列表中。</span></span><br><span class="line"><span class="comment">     * 2.使用双指针法判断是否为回文。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 3:36 2020/8/6</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [head]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeFirst</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        ArrayList arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123; <span class="comment">//这边的判断我一开始用的是head.getNext, 是错误的，最后一个值没法放入数组。</span></span><br><span class="line">            arr.add(head.getElem());</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> back = arr.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(front &lt; back) &#123;   <span class="comment">// 我自己解的时候这里用的是 != ，在数据个数为基数的时候无法生效</span></span><br><span class="line">            <span class="keyword">if</span>(((<span class="keyword">int</span>)arr.get(front)) != ((<span class="keyword">int</span>)arr.get(back))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            front ++;</span><br><span class="line">            back --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================== Second ====================&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 考虑用递归</span></span><br><span class="line"><span class="comment">     * 既然是回文链表，从第一个节点开始往后遍历和递归到最后一个然后往前面递归，类似双指针，每组节点的值应该都是相等的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里关键问题就是：</span></span><br><span class="line"><span class="comment">     * 如何在递归的过程中同时控制两边的指针比较？</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我想了半天没想到，</span></span><br><span class="line"><span class="comment">     * 看了答案，引入了一个外部变量，很巧妙，不过也就是这个外部变量把整个递归的空间复杂度从O(1)提升到了O(n).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 4:40 2020/8/6</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [head]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindromeSecond</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        firstNode = head;</span><br><span class="line">        <span class="keyword">return</span> compare(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node firstNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个递归并不像我之前接触的递归，之前我接触的递归返回的返回值总是Node</span></span><br><span class="line"><span class="comment">     * 这里的递归返回值是bool类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当某一层递归出现了return的时候并不代表了就会直接跳出循环。</span></span><br><span class="line"><span class="comment">     * 他会把返回值返回给上层</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 本体逻辑：</span></span><br><span class="line"><span class="comment">     * -- 如果在递归的过程中，一旦出现了某一层递归返回的是false，</span></span><br><span class="line"><span class="comment">     * 那么就要一直返回false到跳出递归，如果是true，则继续逻辑判断，</span></span><br><span class="line"><span class="comment">     * 某些角度上来讲，这个逻辑和if的逻辑正好相反。</span></span><br><span class="line"><span class="comment">     *                      if(!flag(next)) = false;        return true;</span></span><br><span class="line"><span class="comment">     * 这就是 bool型递归的真谛。</span></span><br><span class="line"><span class="comment">     * flag()就是函数本身，后面一级的函数返上来的bool就是最后return的true，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Node&lt;Integer&gt; head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!compare(head.getNext())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (head.getElem() != firstNode.getElem()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            firstNode = firstNode.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;==================== Finish ====================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================== Third ====================&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 第三种方案，为了实现空间复杂度O(n)</span></span><br><span class="line"><span class="comment">     * 才用了一种更加复杂一点的方案</span></span><br><span class="line"><span class="comment">     * 题解中此种解法分为了五个步骤</span></span><br><span class="line"><span class="comment">     * 1 找到前半部分链表的尾节点。</span></span><br><span class="line"><span class="comment">     * 2 反转后半部分链表。</span></span><br><span class="line"><span class="comment">     * 3 判断是否为回文。</span></span><br><span class="line"><span class="comment">     * 4 恢复链表。</span></span><br><span class="line"><span class="comment">     * 5 返回结果。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 1:23 2020/8/7</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [head]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindromeThird</span><span class="params">(Node&lt;Integer&gt; head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;              <span class="comment">// 修正</span></span><br><span class="line"></span><br><span class="line">        Node&lt;Integer&gt; firstHalfEnd  = endOfFirstHalf(head);</span><br><span class="line">        Node&lt;Integer&gt; secondHalfStart  = reverseList_interpolation(firstHalfEnd.getNext());</span><br><span class="line">        LinkedListUtils.traverseLinkListFromFirst(head);</span><br><span class="line"></span><br><span class="line">        Node&lt;Integer&gt; index1 = head;</span><br><span class="line">        Node&lt;Integer&gt; index2 = secondHalfStart;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(flag &amp;&amp; index2 != <span class="keyword">null</span>) &#123;                       <span class="comment">// 修正，我原先用的是 head.getNext() != null，就变成了比对最后一位的值。 再修正，一开始用的index1 != null 会报错。 index1 遍历比index2多一位，这里面index1 和index2存在交点。</span></span><br><span class="line">            <span class="keyword">if</span>(index1.getElem() != index2.getElem()) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index1 = index1.getNext();</span><br><span class="line">            index2 = index2.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        firstHalfEnd.setNext(reverseList_interpolation(secondHalfStart));     <span class="comment">// 修正 牛逼 牛大逼，自己的函数用两次，第一次的结果套进去再运行一次把链表指针的顺序改过来。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首先要说明 我在这里使用递归肯定是错误的，因为反转链表的时候使用递归就导致了空间复杂度到达了O(n)，</span></span><br><span class="line"><span class="comment">     * 整体的空间复杂度必然不可能小于这个值。</span></span><br><span class="line"><span class="comment">     * 然后考虑功能，虽然递归能够做到翻转链表，</span></span><br><span class="line"><span class="comment">     * 但是并没有切断第一段链表最后一个节点指向第二段头节点这个指向，也就是从理论上来说，</span></span><br><span class="line"><span class="comment">     * 1 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; 2 -&gt; 1 变成了</span></span><br><span class="line"><span class="comment">     * 1 -&gt; 2 -&gt; 3 -&gt; 3 &lt;- 2 &lt;- 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里的这个特性主要是对上面值判断的时候非空判断提出了要求。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Node next = head.getNext();</span><br><span class="line">        Node newhead = reverseList(next);</span><br><span class="line">        next.setNext(head);</span><br><span class="line">        head.setNext(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里还是使用头插法来更换指针,头插法可以把空间复杂度限制在 O(1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">reverseList_interpolation</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = cur.getNext();</span><br><span class="line">            cur.setNext(pre);</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">endOfFirstHalf</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * head有两种情况，</span></span><br><span class="line"><span class="comment">         * 当head是真的head节点的时候 两者都等于head可以实现模拟快慢指针，</span></span><br><span class="line"><span class="comment">         * 因为head是没有意义的，</span></span><br><span class="line"><span class="comment">         * 但是当head是first节点的时候 如果仍然用head的话，</span></span><br><span class="line"><span class="comment">         * 相当于slow和fast都走了相同距离的第一步 和我们预期不同</span></span><br><span class="line"><span class="comment">         * 所以fast用 head.Next 模拟了走两步</span></span><br><span class="line"><span class="comment">         * 任然符合我们对fast和slow的期待。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node slow = head;</span><br><span class="line">        Node fast = head.getNext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast.getNext() != null 理应放在前面</span></span><br><span class="line">        <span class="keyword">while</span>(fast.getNext() != <span class="keyword">null</span> &amp;&amp; fast.getNext().getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.getNext();</span><br><span class="line">            fast = fast.getNext().getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;==================== Finish ====================</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips 之前的Code都是用我自己的用例写的，后面为了方便直接调试代码，我会使用LeeCode的用例。</p></blockquote><h4 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h4><p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p><p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p><p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p><p>返回一个符合上述规则的链表的列表。</p><p>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</p><p>示例 1：</p><p>输入:<br>root = [1, 2, 3], k = 5<br>输出: [[1],[2],[3],[],[]]<br>解释:<br>输入输出各部分都应该是链表，而不是数组。<br>例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。<br>第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。<br>最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。<br>示例 2：</p><p>输入:<br>root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3<br>输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br>解释:<br>输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</p><p>提示:</p><p>root 的长度范围： [0, 1000].<br>输入的每个节点的大小范围：[0, 999].<br>k 的取值范围： [1, 50].</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.linkedlist.leecode.nativecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.leecode.realex.ListNode;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.leecode.realex.ListNodeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 回文链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-08 21:27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsPalindrome</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IsPalindrome isPalindrome = <span class="keyword">new</span> IsPalindrome();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        System.out.println("====================对findEndOfHalf的校验====================");</span></span><br><span class="line"><span class="comment">        ListNode head = ListNodeUtils.generateLinkedList(1,2,3,4,5,6,7);</span></span><br><span class="line"><span class="comment">        ListNode slow = isPalindrom.findEndOfHalf(head);</span></span><br><span class="line"><span class="comment">        System.out.println(slow.val);</span></span><br><span class="line"><span class="comment">        System.out.println("========================================");*/</span></span><br><span class="line"></span><br><span class="line">        ListNode head = ListNodeUtils.generateLinkedList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">boolean</span> palindrom = isPalindrome.isPalindrome(head);</span><br><span class="line">        System.out.println(palindrom);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode endOfHalf = findEndOfHalf(head);</span><br><span class="line">        ListNode backHead = findBackHead(endOfHalf.next);</span><br><span class="line"></span><br><span class="line">        ListNode index1 = head;</span><br><span class="line">        ListNode index2 = backHead;</span><br><span class="line">        Boolean flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag == <span class="keyword">true</span> &amp;&amp; index2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1.val != index2.val) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index1 = index1.next;</span><br><span class="line">            index2 = index2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        findBackHead(backHead);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    private ListNode findBackHead(ListNode head) &#123;</span></span><br><span class="line"><span class="comment">        if(head.next == null) &#123;</span></span><br><span class="line"><span class="comment">            return head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ListNode next = head.next;</span></span><br><span class="line"><span class="comment">        ListNode newHead = findBackHead(next);</span></span><br><span class="line"><span class="comment">        next.next = head;</span></span><br><span class="line"><span class="comment">        head.next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return newHead;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头插法反转列表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">findBackHead</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">findEndOfHalf</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 考虑奇数和偶数的情况</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.linkedlist.leecode.nativecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.leecode.realex.ListNode;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.leecode.realex.ListNodeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/11 15:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OddEvenLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OddEvenLinkedList oddEvenLinkedList = <span class="keyword">new</span> OddEvenLinkedList();</span><br><span class="line"></span><br><span class="line">        ListNode node = ListNodeUtils.generateLinkedList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">        ListNode listNode = oddEvenLinkedList.oddEvenList(node);</span><br><span class="line">        ListNodeUtils.traverseLinkListFromFirst(listNode);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要求：使用原地算法（一句话总结就是: 原地算法不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。）</span></span><br><span class="line"><span class="comment">     * 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span></span><br><span class="line"><span class="comment">     * 输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span></span><br><span class="line"><span class="comment">     * 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 说明:</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 应当保持奇数节点和偶数节点的相对顺序。</span></span><br><span class="line"><span class="comment">     * 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*    public ListNode oddEvenList(ListNode head) &#123;</span></span><br><span class="line"><span class="comment">        if(head == null || head.next == null) &#123;</span></span><br><span class="line"><span class="comment">            return head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        ListNode pre = new ListNode(0);</span></span><br><span class="line"><span class="comment">        pre.next = head;</span></span><br><span class="line"><span class="comment">        ListNode odd = head;</span></span><br><span class="line"><span class="comment">        ListNode even = head.next;</span></span><br><span class="line"><span class="comment">        while (head != null) &#123;</span></span><br><span class="line"><span class="comment">            ListNode next = head.next;</span></span><br><span class="line"><span class="comment">            pre.next = next;</span></span><br><span class="line"><span class="comment">            pre = head;</span></span><br><span class="line"><span class="comment">            head = head.next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ListNode findOddLast = odd;</span></span><br><span class="line"><span class="comment">        while (findOddLast.next != null) &#123;</span></span><br><span class="line"><span class="comment">            findOddLast = findOddLast.next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        findOddLast.next = even;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return odd;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 上面是我自己的写法，下面这种更巧妙一点，生了一个变量并且少了一次递归</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 20:47 2020/8/11</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [head]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> com.hugh.datastructure.linkedlist.leecode.realex.ListNode</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 特判：头结点为 null，返回null</span></span><br><span class="line">        <span class="comment">// head是奇链表的头</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// odd是奇链表的当前节点，先初始化为head（初始化为奇链表头）</span></span><br><span class="line">        ListNode odd  = head;</span><br><span class="line">        <span class="comment">// even是偶链表的当前节点，初始化为第二个节点也就是head.next</span></span><br><span class="line">        ListNode even = head.next;</span><br><span class="line">        <span class="comment">// evenHead是偶链表的头节点，初始化为链表第二个节点（初始化为奇链表头的下一个节点）</span></span><br><span class="line">        ListNode evenHead = even;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里while退出判断条件还是画图一下才能理解（也就是官方题解的STEP2）</span></span><br><span class="line">            odd.next = even.next;  <span class="comment">// 相当于odd.next = odd.next.next(跳过一个偶数节点)</span></span><br><span class="line">            odd = odd.next;        <span class="comment">// odd向前前进一位</span></span><br><span class="line">            even.next = odd.next;   <span class="comment">// 奇链表的下一个节点就是偶链表的节点</span></span><br><span class="line">            even = even.next;       <span class="comment">// even向前前进一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while条件结束，把偶链表头指针拼接到奇链表的最后</span></span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="comment">// 返回奇链表头就是返回整个奇偶排序后的链表</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：后期用到的工具类，样例类，能直接在本地能够调试的<code>LeeCode</code>的代码环境在<a href="https://github.com/FlyMeToTheMars/draft/blob/master/DataStructures/src/main/java/com/hugh/datastructure/linkedlist/leecode/standardutils/ListNodeUtils.java" target="_blank" rel="noopener">github</a>可获取。</p></blockquote><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p><strong>树</strong>（tree）是一种抽象数据类型（ADT），用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限<strong>节点</strong>通过连接它们的<strong>边</strong>组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><p>树有很多种，向上面的一个节点有多余两个的子节点的树，称为多路树，后面会讲解2-3-4树和外部存储都是多路树的例子。而每个节点最多只能有两个子节点的一种形式称为二叉树。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ghn9q0y3htj20o10dzwha.jpg" alt="undefined"></p><p><strong>节点</strong>：上图的圆圈，比如A,B,C等都是表示节点。节点一般代表一些实体，在java面向对象编程中，节点一般代表对象。</p><p><strong>边</strong>：连接节点的线称为边，边表示节点的关联关系。一般从一个节点到另一个节点的<strong>唯一方法</strong>就是沿着一条顺着有边的道路前进。在Java当中通常表示引用。</p><p><strong>根</strong>：树顶端的节点称为根。一棵树只有一个根，如果要把一个节点和边的集合称为树，那么从根到其他任何一个节点都必须有且只有一条路径。A是根节点。</p><p><strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点</p><p><strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点</p><p><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；比如上图的D和E就互称为兄弟节点</p><p><strong>叶节点</strong>：没有子节点的节点称为叶节点</p><p><strong>子树</strong>：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中。</p><p><strong>节点的层次</strong>：从根开始定义，根为第一层，根的子节点为第二层，以此类推。</p><p><strong>深度</strong>：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</p><p><strong>高度</strong>：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0</p><h4 id="关于二叉树不成熟的一些理解"><a href="#关于二叉树不成熟的一些理解" class="headerlink" title="关于二叉树不成熟的一些理解"></a>关于二叉树不成熟的一些理解</h4><blockquote><p>二叉树，本质上，是对链表和数组的一个折中（不成熟的说法，有说法是区块链）</p><p>链表和数组都是纯粹的数据结构，而二叉树就已经是分类器。</p><p>比如，我有一个任务，需要输入<br>10万个数据（32位整数），然后有两个操作：<br>1.添加(删除)一个整数。<br>2.询问第x大的数据。</p><p>比如，给出 1, 8, 13, 10（等等一堆数据）…….<br>然后询问第3大的数据，<br>然后插入 18<br>然后询问第4大的数据<br>再插入 9<br>再询问第2大的数据</p><p>不停的重复1,2<br>重复10万次。。</p><p>用有序链表，不行，查找（包括1需要找到对应位置，以及2查找）成本大O(N)，但具体这个插入操作成本小O(1)。<br>用有序数组，查找（2的查找）成本小O(1)。但1的插入操作成本很大O(N)。</p><p>所以，我们折中使用排序二叉树（二叉树仅仅作为排序二叉树的基础），查找（包括1需要找到对应位置，以及2查找）成本挺小O(logN)。具体这个插入操作成本也挺小O(logN)。</p><p>具体的应用就是由排序二叉树（由于普通排序二叉树可能会有不平衡的情况）引申出来的红黑树（linux中ext3文件系统管理），avl树“windows对进程地址空间的管理”。</p></blockquote><h4 id="二叉树工具类"><a href="#二叉树工具类" class="headerlink" title="二叉树工具类"></a>二叉树工具类</h4><h5 id="前序、中序、后续遍历三种遍历方式都是DFS（深度优先遍历的三种方式）"><a href="#前序、中序、后续遍历三种遍历方式都是DFS（深度优先遍历的三种方式）" class="headerlink" title="前序、中序、后续遍历三种遍历方式都是DFS（深度优先遍历的三种方式）"></a>前序、中序、后续遍历三种遍历方式都是DFS（深度优先遍历的三种方式）</h5><h5 id="广度优先遍历是另外一种遍历方法"><a href="#广度优先遍历是另外一种遍历方法" class="headerlink" title="广度优先遍历是另外一种遍历方法"></a>广度优先遍历是另外一种遍历方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 二叉树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-12 04:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-12 06:10</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode treeNode = generateTreeFromArray(<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>);</span><br><span class="line">        System.out.println(treeNode.val);</span><br><span class="line">        preOrderTraverse(treeNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 从LeeCode给出的数组还原出树</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 6:28 2020/8/12</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [nums]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> com.hugh.datastructure.binarytree.utils.TreeNode</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">generateTreeFromArray</span><span class="params">(Integer... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// stack的本质是由linked list或者array实现的</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; subTree = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        subTree.push(head);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!subTree.isEmpty()) &#123;</span><br><span class="line">                TreeNode cur = subTree.pop();</span><br><span class="line">                <span class="keyword">if</span> (nums[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.left = <span class="keyword">new</span> TreeNode(nums[i]);</span><br><span class="line">                    subTree.add(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= nums.length) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.right = <span class="keyword">new</span> TreeNode(nums[i]);</span><br><span class="line">                    subTree.add(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 前序遍历</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 6:26 2020/8/12</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">            preOrderTraverse(root.left);</span><br><span class="line">            preOrderTraverse(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 中序遍历</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 6:27 2020/8/12</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inOrderTraverse(root.left);</span><br><span class="line">            System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">            inOrderTraverse(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 后序遍历</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 6:27 2020/8/12</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postOrderTraverse(root.left);</span><br><span class="line">            postOrderTraverse(root.right);</span><br><span class="line">            System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 层次遍历</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 6:27 2020/8/12</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            System.out.print(node.val+<span class="string">"  "</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 深度优先遍历</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 6:28 2020/8/12</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val+<span class="string">"  "</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 广度优先遍历</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 6:36 2020/8/12</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [nodeHead]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BroadFirstSearch</span><span class="params">(TreeNode nodeHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nodeHead==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; myQueue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        myQueue.add(nodeHead);</span><br><span class="line">        <span class="keyword">while</span>(!myQueue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node=myQueue.poll();</span><br><span class="line">            System.out.print(node.val+<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=node.left) &#123;</span><br><span class="line">                myQueue.add(node.left);    <span class="comment">//深度优先遍历，我们在这里采用每一行从左到右遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=node.right) &#123;</span><br><span class="line">                myQueue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树题通用模板"><a href="#树题通用模板" class="headerlink" title="树题通用模板"></a>树题通用模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="套用模板：求二叉树中最大路径和"><a href="#套用模板：求二叉树中最大路径和" class="headerlink" title="套用模板：求二叉树中最大路径和"></a>套用模板：求二叉树中最大路径和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/12 15:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeMaximumPathSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = TreeUtils.generateTreeFromArray(-<span class="number">10</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>);</span><br><span class="line">        BinaryTreeMaximumPathSum binaryTreeMaximumPathSum = <span class="keyword">new</span> BinaryTreeMaximumPathSum();</span><br><span class="line">        <span class="keyword">int</span> i = binaryTreeMaximumPathSum.maxPathSum(root);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求二叉树中的最大路径和</span></span><br><span class="line"><span class="comment">     * 原题描述：</span></span><br><span class="line"><span class="comment">     * 给定一个非空二叉树，返回其最大路径和。</span></span><br><span class="line"><span class="comment">     * 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: [1,2,3]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *        1</span></span><br><span class="line"><span class="comment">     *       / \</span></span><br><span class="line"><span class="comment">     *      2   3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出: 6</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: [-10,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    -10</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   9  20</span></span><br><span class="line"><span class="comment">     *     /  \</span></span><br><span class="line"><span class="comment">     *    15   7</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出: 42</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -------------------------------------------------------</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 题意：从树中任意一个节点出发，寻找最大的路径和，就是在该节点的 子树 中寻找以该节点所在的一条路径，使得该路径上的节点值之和最大。</span></span><br><span class="line"><span class="comment">     * 从下而上进行分析求解。</span></span><br><span class="line"><span class="comment">     * 官方题解中有个贡献值的概念：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1、空节点的最大贡献值等于 0。</span></span><br><span class="line"><span class="comment">     * 2、非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）,考虑到如果叶节点都为负值时，只是单纯引入最大贡献值的子节点也是不太恰当的，所以如果两个子节点都为负值时，此节点的最大贡献值为它本身的值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里的贡献值呢，就是如果把该节点作为路径的一个节点，它所能提供的最大路径选择。即到当前节点后，选择下一步的节点的时候选择两个子节点中贡献值大的那个节点，来保证路径最大。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 下面进行分析：就用官方题解这个二叉树来举例说明。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * 我的理解</span></span><br><span class="line"><span class="comment">     * 路径，可以理解为指向，根据LeeCode的用例，每个节点都是往下一层指向两个节点，如果想把这个路径传递得尽可能长，只有可能根据箭头的方向，左右各找到一个点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 从思路上面来讲这题肯定是要遍历的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本质上是后序遍历。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 要讨论四种情况 四种情况分别是</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 单个数字最大值，</span></span><br><span class="line"><span class="comment">     * left + cur最大，</span></span><br><span class="line"><span class="comment">     * cur + right最大，</span></span><br><span class="line"><span class="comment">     * left + right + cur最大，</span></span><br><span class="line"><span class="comment">     * 四种</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 一，二，三这几种情况都可以作为树的一个子树再计算，但第四种是不能作为一个子树再计算的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">        <span class="keyword">int</span> leftGain = Math.max(maxGain(node.left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGain = Math.max(maxGain(node.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">int</span> priceNewpath = node.val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = Math.max(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node.val + Math.max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这题得递归手法是之前见过的，通过引入第三个变量来完成递归的输出。</span></span><br><span class="line"><span class="comment">     * 在这个递归的过程中，原函数仅仅用来返回结果，递归另外起了一个函数，然后在这个另外起的函数里面进行递归</span></span><br><span class="line"><span class="comment">     * 返回的值回到上面的left/right Gain里面继续参加下面的计算。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 树的高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-12 06:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumDepthOfBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode node = TreeUtils.generateTreeFromArray(<span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">15</span>, <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> MaximumDepthOfBinaryTree().maxDepth(node);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 又是一种全新的递归形式</span></span><br><span class="line"><span class="comment">     * 再接触几种递归应该就能总结出属于我自己的递归之道。</span></span><br><span class="line"><span class="comment">     * 每次有一层都会加一。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 求二叉树的最大深度，根的深度是0，其实就是在求离根节点距离最远的叶节点的和根节点的距离。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 7:04 2020/8/12</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (root == <span class="keyword">null</span>) ? <span class="number">0</span> : Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断是否是平衡二叉树"><a href="#判断是否是平衡二叉树" class="headerlink" title="判断是否是平衡二叉树"></a>判断是否是平衡二叉树</h4><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/13 10:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = TreeUtils.generateTreeFromArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">4</span>);</span><br><span class="line">        TreeUtils.preOrderTraverse(root);</span><br><span class="line"></span><br><span class="line">        BalancedBinaryTree balancedBinaryTree = <span class="keyword">new</span> BalancedBinaryTree();</span><br><span class="line">        <span class="keyword">boolean</span> balanced = balancedBinaryTree.isBalanced(root);</span><br><span class="line">        System.out.println(balanced);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是平衡二叉树（每个节点的子数深度不超过1）</span></span><br><span class="line"><span class="comment">     * 借助外面的变量实现递归，加上了一个尾部遍历，第三次接触这种递归方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        getMaxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxDepth</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getMaxDepth(node.left);</span><br><span class="line">        <span class="keyword">int</span> right = getMaxDepth(node.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left - right) &gt; <span class="number">1</span>) flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求二叉树的直径"><a href="#求二叉树的直径" class="headerlink" title="求二叉树的直径"></a>求二叉树的直径</h4><p>基本套路和求二叉树的最大路径和相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/13 11:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiameterOfBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求二叉树的直径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> diameter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        getDiameter(root);</span><br><span class="line">        <span class="keyword">return</span> diameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDiameter</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = getDiameter(node.left);</span><br><span class="line">        <span class="keyword">int</span> right = getDiameter(node.right);</span><br><span class="line">        diameter = Math.max(diameter, (left + right));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="翻转树"><a href="#翻转树" class="headerlink" title="翻转树"></a>翻转树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/13 14:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvertBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = TreeUtils.generateTreeFromArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        InvertBinaryTree InvertBinaryTree = <span class="keyword">new</span> InvertBinaryTree();</span><br><span class="line">        TreeNode treeNode = InvertBinaryTree.invertTree(root);</span><br><span class="line">        TreeUtils.preOrderTraverse(treeNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻转树</span></span><br><span class="line"><span class="comment">     * Max Howell 被Google难住的题目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inverTree_improve</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        root.left = inverTree_improve(root.right);</span><br><span class="line">        root.right = inverTree_improve(left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 归并两棵树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-14 00:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTwoBinaryTrees</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode t1 = TreeUtils.generateTreeFromArray(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        TreeNode t2 = TreeUtils.generateTreeFromArray(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="keyword">null</span>, <span class="number">4</span>, <span class="keyword">null</span>, <span class="number">7</span>);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> MergeTwoBinaryTrees().mergeTrees(t1, t2);</span><br><span class="line">        TreeUtils.preOrderTraverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 这题，总的来说还是在公式里面，有个特点就是输入是两个，输出却只有一个</span></span><br><span class="line"><span class="comment">     * 这种多输入 单输出的递归，值得注意一下</span></span><br><span class="line"><span class="comment">     * 可以新建一个TreeNode或者直接在原先的某一个树上直接修改。</span></span><br><span class="line"><span class="comment">     * 原理也很简单，直接从t1最左边的节点，继续往下（不够从t2左边拉），到了最下面之后然后回到上一层，再讨论右边，就这样逐层递归。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 0:46 2020/8/14</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [t1, t2]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> com.hugh.datastructure.binarytree.utils.TreeNode</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        t1.val += t2.val;</span><br><span class="line">        t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        t1.right = mergeTrees(t1.right, t2.right); <span class="comment">// 这边的left 和 right还容易写错。。。。</span></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断路径和是否等于一个数"><a href="#判断路径和是否等于一个数" class="headerlink" title="判断路径和是否等于一个数"></a>判断路径和是否等于一个数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/14 9:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个int Sum，要判断是否存在一条路径，从Root到Leaf，各个节点的和加起来等于Sum.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 一种新的类型的递归，返回值是bool，通过 || 的特性，不断向上返回bool.有一个为true就一直为true.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PathSumIII"><a href="#PathSumIII" class="headerlink" title="PathSumIII"></a>PathSumIII</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 统计路径和等于一个数的路径数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-15 01:39</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumIII</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 给定一个二叉树，它的每个结点都存放着一个整数值。</span></span><br><span class="line"><span class="comment">     * 找出路径和等于给定数值的路径总数。</span></span><br><span class="line"><span class="comment">     * 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</span></span><br><span class="line"><span class="comment">     * 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例：</span></span><br><span class="line"><span class="comment">     * root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       10</span></span><br><span class="line"><span class="comment">     *      /  \</span></span><br><span class="line"><span class="comment">     *     5   -3</span></span><br><span class="line"><span class="comment">     *    / \    \</span></span><br><span class="line"><span class="comment">     *   3   2   11</span></span><br><span class="line"><span class="comment">     *  / \   \</span></span><br><span class="line"><span class="comment">     * 3  -2   1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回 3。和等于 8 的路径有:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.  5 -&gt; 3</span></span><br><span class="line"><span class="comment">     * 2.  5 -&gt; 2 -&gt; 1</span></span><br><span class="line"><span class="comment">     * 3.  -3 -&gt; 11</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这道题目要和前面一题结合起来看，（PathSum）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 1:41 2020/8/15</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root, sum]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里的用法十分巧妙，并没有全部递归下去，如果全部递归下去的则没有意义，递归，不要纠结在头脑风暴上</span></span><br><span class="line">        <span class="comment">// 这里左右节点都是用的是无限递归，但是头节点仅仅递归了一次，总的来说还是在套用那个模板，这里的头节点，仅仅是计算整个树的头节点符合要求的个数。</span></span><br><span class="line">        ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pathSumStartWithRoot</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里的判断条件十分重要，联想到之前的一直查找到跟节点的那个条件，那里是 left == null &amp;&amp; right == null &amp;&amp; sum = root.val ，和这里的区别就是不一定要到根节点，这里只要满足连续的条件即可</span></span><br><span class="line">        <span class="keyword">if</span> (sum == root.val) ret++;</span><br><span class="line">        ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);</span><br><span class="line">        <span class="keyword">return</span>  ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 整道题目使用了两次递归，第一次递归，套用模板，深度遍历，第二个递归，其实仍然在求和的模板之内。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 2:41 2020/8/15</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SubtreeOfAnotherTree"><a href="#SubtreeOfAnotherTree" class="headerlink" title="SubtreeOfAnotherTree"></a>SubtreeOfAnotherTree</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-15 02:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubtreeOfAnotherTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     * 给定的树 s:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      3</span></span><br><span class="line"><span class="comment">     *     / \</span></span><br><span class="line"><span class="comment">     *    4   5</span></span><br><span class="line"><span class="comment">     *   / \</span></span><br><span class="line"><span class="comment">     *  1   2</span></span><br><span class="line"><span class="comment">     * 给定的树 t：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    4</span></span><br><span class="line"><span class="comment">     *   / \</span></span><br><span class="line"><span class="comment">     *  1   2</span></span><br><span class="line"><span class="comment">     * 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     * 给定的树 s：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      3</span></span><br><span class="line"><span class="comment">     *     / \</span></span><br><span class="line"><span class="comment">     *    4   5</span></span><br><span class="line"><span class="comment">     *   / \</span></span><br><span class="line"><span class="comment">     *  1   2</span></span><br><span class="line"><span class="comment">     *     /</span></span><br><span class="line"><span class="comment">     *    0</span></span><br><span class="line"><span class="comment">     * 给定的树 t：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    4</span></span><br><span class="line"><span class="comment">     *   / \</span></span><br><span class="line"><span class="comment">     *  1   2</span></span><br><span class="line"><span class="comment">     * 返回 false。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 看到题目描述，首先判断一个树是否是另一棵树的子树，很明显想到可以用递归，但是两棵树完全相同也可以看做一棵树是另一棵树的子树。</span></span><br><span class="line"><span class="comment">     * 所以自然而然想到用一个判断两棵树是否相同的递归函数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第一个递归和 PathSumIII 第一个递归的思想相同</span></span><br><span class="line"><span class="comment">     * 第二个递归则完完全全是 单独的问题，两树是否相同。 也就是LeeCode 100.题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 2:49 2020/8/15</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [s, t]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isSameTree(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 这边 isSameTree的判断可以简化，要注意为什么可以这么写。</span></span><br><span class="line"><span class="comment">     *     if (t == null &amp;&amp; s == null) return true;</span></span><br><span class="line"><span class="comment">     *     if (t == null || s == null) return false;</span></span><br><span class="line"><span class="comment">     *     if (t.val != s.val) return false;</span></span><br><span class="line"><span class="comment">     *     return isSubtreeWithRoot(s.left, t.left) &amp;&amp; isSubtreeWithRoot(s.right, t.right);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     可以写成这样，要考虑到满足上一个条件之后就已经直接return出去了，不会参与下面的村循环，这种情况下其实和if else的语法是一样的。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 3:41 2020/8/15</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SymmetricTree"><a href="#SymmetricTree" class="headerlink" title="SymmetricTree"></a>SymmetricTree</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 对称树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-15 03:47</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 给定一个二叉树，检查它是否是镜像对称的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 例如，二叉树[1,2,2,3,4,4,3] 是对称的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     1</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   2   2</span></span><br><span class="line"><span class="comment">     *  / \ / \</span></span><br><span class="line"><span class="comment">     * 3  4 4  3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 但是下面这个[1,2,2,null,3,null,3] 则不是镜像对称的:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     1</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   2   2</span></span><br><span class="line"><span class="comment">     *    \   \</span></span><br><span class="line"><span class="comment">     *    3    3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 进阶：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 你可以运用递归和迭代两种方法解决这个问题吗？</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 先说递归，其实这题又转换成了LeeCode 100题的变种。100题是两棵树是否相等，这题是两颗树是否对称。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 3:48 2020/8/15</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val != q.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(p.left, q.right) &amp;&amp; isSymmetric(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==================================================迭代&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetricIter</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。</span></span><br><span class="line"><span class="comment">     * 初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），</span></span><br><span class="line"><span class="comment">     * 然后将两个结点的左右子结点按相反的顺序插入队列中。</span></span><br><span class="line"><span class="comment">     * 当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 4:13 2020/8/15</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [u, v]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode u, TreeNode v)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(u);</span><br><span class="line">        q.offer(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            u = q.poll();</span><br><span class="line">            v = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="keyword">null</span> &amp;&amp; v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((u == <span class="keyword">null</span> || v == <span class="keyword">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.offer(u.left);</span><br><span class="line">            q.offer(v.right);</span><br><span class="line"></span><br><span class="line">            q.offer(u.right);</span><br><span class="line">            q.offer(v.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SumOfLeftLeaves"><a href="#SumOfLeftLeaves" class="headerlink" title="SumOfLeftLeaves"></a>SumOfLeftLeaves</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.hugh.datastructure.binarytree.utils.TreeUtils.generateTreeFromArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 左叶子之和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-15 04:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumOfLeftLeaves</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = generateTreeFromArray(<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> SumOfLeftLeaves().sumOfLeftLeavesNiubi(root);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 计算给定二叉树的所有左叶子之和。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     3</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   9  20</span></span><br><span class="line"><span class="comment">     *     /  \</span></span><br><span class="line"><span class="comment">     *    15   7</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 递归解法一：</span></span><br><span class="line"><span class="comment">     * 深度优先遍历，很简单，问题的关键就在于什么是左节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 5:05 2020/8/15</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sumOfLeftLeaves(root.left);</span><br><span class="line">        sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==================================================更牛逼的迭代&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 完全从语义出发，虽然写起来更麻烦一点，用了两个判断，但是让人一看就懂，牛逼。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 5:15 2020/8/15</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeavesNiubi</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isLeaf(root.left)) <span class="keyword">return</span> root.left.val + sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LongestUnivaluePath"><a href="#LongestUnivaluePath" class="headerlink" title="LongestUnivaluePath"></a>LongestUnivaluePath</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 最长同值路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-15 05:28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestUnivaluePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：两个节点之间的路径长度由它们之间的边数表示。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *               5</span></span><br><span class="line"><span class="comment">     *              / \</span></span><br><span class="line"><span class="comment">     *             4   5</span></span><br><span class="line"><span class="comment">     *            / \   \</span></span><br><span class="line"><span class="comment">     *           1   1   5</span></span><br><span class="line"><span class="comment">     * 输出:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *               1</span></span><br><span class="line"><span class="comment">     *              / \</span></span><br><span class="line"><span class="comment">     *             4   5</span></span><br><span class="line"><span class="comment">     *            / \   \</span></span><br><span class="line"><span class="comment">     *           4   4   5</span></span><br><span class="line"><span class="comment">     * 输出:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2</span></span><br><span class="line"><span class="comment">     * 注意: 给定的二叉树不超过10000个结点。树的高度不超过1000。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 5:28 2020/8/15</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(root.right);</span><br><span class="line">        <span class="keyword">int</span> leftPath = root.left != <span class="keyword">null</span> &amp;&amp; root.left.val == root.val ? left + <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightPath = root.right != <span class="keyword">null</span> &amp;&amp; root.right.val == root.val ? right + <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">        path = Math.max(path, rightPath+leftPath);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftPath, rightPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 这道题目值得好好思考一下</span></span><br><span class="line"><span class="comment">     * 二叉树递归的难点就在于怎么构思：子节点向父节点返回的是什么?或者说，当前节点向其父节点返回的是什么?</span></span><br><span class="line"><span class="comment">     * 这题中，当前节点返回给父节点的值就是：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 从当前节点出发，向下延伸与其值相同的最大深度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 于是返回值分两种情况：</span></span><br><span class="line"><span class="comment">     * 1.                                    if( 如果当前节点与其左右节点都不相等)，那么深度为0，则返回0</span></span><br><span class="line"><span class="comment">     * 2. else，                             这个最大深度就取其 左右子树返回值中的较大者 + 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 然后，在上面这个dfs的遍历过程中，还可以做一些其他的事情，这题做的就是 计算路径长度。由于子树的返回值已经确定了，所以需要额外的一个全局变量。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 8:14 2020/8/15</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HouseRobberIII"><a href="#HouseRobberIII" class="headerlink" title="HouseRobberIII"></a>HouseRobberIII</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 间隔遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-15 16:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobberIII</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: [3,2,3,null,3,null,1]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      3</span></span><br><span class="line"><span class="comment">     *     / \</span></span><br><span class="line"><span class="comment">     *    2   3</span></span><br><span class="line"><span class="comment">     *     \   \</span></span><br><span class="line"><span class="comment">     *      3   1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出: 7</span></span><br><span class="line"><span class="comment">     * 解释:小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: [3,4,5,1,3,null,1]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      3</span></span><br><span class="line"><span class="comment">     *     / \</span></span><br><span class="line"><span class="comment">     *    4   5</span></span><br><span class="line"><span class="comment">     *   / \   \</span></span><br><span class="line"><span class="comment">     *  1   3   1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出: 9</span></span><br><span class="line"><span class="comment">     * 解释:小偷一晚能够盗取的最高金额= 4 + 5 = 9.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这题我第一时间想复杂了，要注意题目，必须是从根节点开始取得。</span></span><br><span class="line"><span class="comment">     * 那么两情况分别是取根节点（就是本节点和间隔一层的两个节点*（前提条件是判断存不存在子节点））和不取根节点的情况（就是两个子节点）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 16:24 2020/8/15</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> singleSum = root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) singleSum += rob(root.left.left) + rob(root.left.right);</span><br><span class="line">        <span class="keyword">if</span> (root.right!= <span class="keyword">null</span>) singleSum += rob(root.right.left) + rob(root.right.right);</span><br><span class="line">        <span class="keyword">int</span> doubleSum = rob(root.left) + rob(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(doubleSum, singleSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SecondMinimumNodeInABinaryTree"><a href="#SecondMinimumNodeInABinaryTree" class="headerlink" title="SecondMinimumNodeInABinaryTree"></a>SecondMinimumNodeInABinaryTree</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 找出二叉树中第二小的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-15 18:11</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondMinimumNodeInABinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入:</span></span><br><span class="line"><span class="comment">     *     2</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   2   5</span></span><br><span class="line"><span class="comment">     *      / \</span></span><br><span class="line"><span class="comment">     *     5   7</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出: 5</span></span><br><span class="line"><span class="comment">     * 说明: 最小的值是 2 ，第二小的值是 5 。</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入:</span></span><br><span class="line"><span class="comment">     *     2</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   2   2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出: -1</span></span><br><span class="line"><span class="comment">     * 说明: 最小的值是 2, 但是不存在第二小的值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 18:12 2020/8/15</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftValue = root.left.val;</span><br><span class="line">        <span class="keyword">int</span> rightValue = root.right.val;</span><br><span class="line">        <span class="comment">// 巧妙，太牛了，几个点，首先这种写法从上到下都简化了if else的else，其次这里的判断条件结合题意：每个子树的头节点总是后面最小的值，这里的值不是root，没必要再找了，就是这个最小了。在后面return.</span></span><br><span class="line">        <span class="keyword">if</span> (leftValue == root.val) leftValue = findSecondMinimumValue(root.left);</span><br><span class="line">        <span class="keyword">if</span> (rightValue == root.val) rightValue = findSecondMinimumValue(root.right);</span><br><span class="line">        <span class="keyword">if</span> (leftValue != -<span class="number">1</span> &amp;&amp; rightValue != -<span class="number">1</span>) <span class="keyword">return</span> Math.min(leftValue, rightValue);</span><br><span class="line">        <span class="keyword">if</span> (leftValue == -<span class="number">1</span>) <span class="keyword">return</span> rightValue;</span><br><span class="line">        <span class="keyword">return</span> leftValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一棵树每层节点的平均数"><a href="#一棵树每层节点的平均数" class="headerlink" title="一棵树每层节点的平均数"></a>一棵树每层节点的平均数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/20 10:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AverageOfLevelsInBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = TreeUtils.generateTreeFromArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入：</span></span><br><span class="line"><span class="comment">     *     3</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   9  20</span></span><br><span class="line"><span class="comment">     *     /  \</span></span><br><span class="line"><span class="comment">     *    15   7</span></span><br><span class="line"><span class="comment">     * 输出：[3, 14.5, 11]</span></span><br><span class="line"><span class="comment">     * 解释：</span></span><br><span class="line"><span class="comment">     * 第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 提示：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 节点值的范围在32位有符号整数范围内。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Double&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; myQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        myQueue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!myQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = myQueue.size();</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                TreeNode poll = myQueue.poll();</span><br><span class="line">                sum += poll.val;</span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    myQueue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    myQueue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(sum / cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">broadFirstSearch</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; myQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        myQueue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!myQueue.isEmpty()) &#123;</span><br><span class="line">            TreeNode poll = myQueue.poll();</span><br><span class="line">            System.out.print(poll.val + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span> (poll.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                myQueue.add(poll.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (poll.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                myQueue.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="得到左下角的节点"><a href="#得到左下角的节点" class="headerlink" title="得到左下角的节点"></a>得到左下角的节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/20 12:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindBottomLeftTreeValue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个二叉树，在树的最后一行找到最左边的值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     2</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   1   3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出:</span></span><br><span class="line"><span class="comment">     * 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *         1</span></span><br><span class="line"><span class="comment">     *        / \</span></span><br><span class="line"><span class="comment">     *       2   3</span></span><br><span class="line"><span class="comment">     *      /   / \</span></span><br><span class="line"><span class="comment">     *     4   5   6</span></span><br><span class="line"><span class="comment">     *        /</span></span><br><span class="line"><span class="comment">     *       7</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出:</span></span><br><span class="line"><span class="comment">     * 7</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意: 您可以假设树（即给定的根节点）不为 NULL。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; myQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        myQueue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!myQueue.isEmpty()) &#123;</span><br><span class="line">            root = myQueue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 顺序很重要 如果是left防癌前</span></span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                myQueue.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                myQueue.add(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归遍历二叉树"><a href="#非递归遍历二叉树" class="headerlink" title="非递归遍历二叉树"></a>非递归遍历二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 非递归实现前中后序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-21 05:45</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeOrderTraversal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode pop = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ret.add(pop.val);</span><br><span class="line">            stack.push(pop.right);</span><br><span class="line">            stack.push(pop.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            ret.add(node.val);</span><br><span class="line">            cur = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode pop = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ret.add(pop.val);</span><br><span class="line">            stack.push(pop.left);</span><br><span class="line">            stack.push(pop.right);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><h4 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树(BST)"></a>二叉查找树(BST)</h4><p>根节点大于等于左子树的所有节点，小于等于右子树的所有节点。</p><p><strong>二叉查找树使用中序遍历是有序的。</strong></p><h4 id="修剪二叉查找树"><a href="#修剪二叉查找树" class="headerlink" title="修剪二叉查找树"></a>修剪二叉查找树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/21 12:40 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrimBST</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个二叉搜索树，同时给定最小边界L和最大边界R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入:</span></span><br><span class="line"><span class="comment">     *     1</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   0   2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   L = 1</span></span><br><span class="line"><span class="comment">     *   R = 2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出:</span></span><br><span class="line"><span class="comment">     *     1</span></span><br><span class="line"><span class="comment">     *       \</span></span><br><span class="line"><span class="comment">     *        2</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入:</span></span><br><span class="line"><span class="comment">     *     3</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   0   4</span></span><br><span class="line"><span class="comment">     *    \</span></span><br><span class="line"><span class="comment">     *     2</span></span><br><span class="line"><span class="comment">     *    /</span></span><br><span class="line"><span class="comment">     *   1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   L = 1</span></span><br><span class="line"><span class="comment">     *   R = 3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出:</span></span><br><span class="line"><span class="comment">     *       3</span></span><br><span class="line"><span class="comment">     *      /</span></span><br><span class="line"><span class="comment">     *    2</span></span><br><span class="line"><span class="comment">     *   /</span></span><br><span class="line"><span class="comment">     *  1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> L</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> R</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; R) <span class="keyword">return</span> trimBST(root.left, L, R);</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; L) <span class="keyword">return</span> trimBST(root.right, L, R);</span><br><span class="line">        root.left = trimBST(root.left,L,R);</span><br><span class="line">        root.right = trimBST(root.right,L,R);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="寻找二叉查找树的第-k-个元素"><a href="#寻找二叉查找树的第-k-个元素" class="headerlink" title="寻找二叉查找树的第 k 个元素"></a>寻找二叉查找树的第 k 个元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/21 3:12 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthSmallestElementInABST</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 输入: root = [3,1,4,null,2], k = 1</span></span><br><span class="line"><span class="comment">     * 3</span></span><br><span class="line"><span class="comment">     * / \</span></span><br><span class="line"><span class="comment">     * 1   4</span></span><br><span class="line"><span class="comment">     * \</span></span><br><span class="line"><span class="comment">     * 2</span></span><br><span class="line"><span class="comment">     * 输出: 1</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 输入: root = [5,3,6,2,4,null,null,1], k = 3</span></span><br><span class="line"><span class="comment">     * 5</span></span><br><span class="line"><span class="comment">     * / \</span></span><br><span class="line"><span class="comment">     * 3   6</span></span><br><span class="line"><span class="comment">     * / \</span></span><br><span class="line"><span class="comment">     * 2   4</span></span><br><span class="line"><span class="comment">     * /</span></span><br><span class="line"><span class="comment">     * 1</span></span><br><span class="line"><span class="comment">     * 输出: 3</span></span><br><span class="line"><span class="comment">     * 进阶：</span></span><br><span class="line"><span class="comment">     * 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inOrder(root, k);</span><br><span class="line">        <span class="keyword">return</span> back;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> back;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            back = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==================================================分割符&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 说实话 上面的解法，我刚开始看LeeCOde的时候还感觉挺有意思，到了现在已经没有任何惊喜了</span></span><br><span class="line"><span class="comment">     * 简单的中序遍历</span></span><br><span class="line"><span class="comment">     * 下面的这个解法别有新意。</span></span><br><span class="line"><span class="comment">     * 从Count入手。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallestNiu</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftCnt = count(root.left);</span><br><span class="line">        <span class="keyword">if</span> (leftCnt == k-<span class="number">1</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="keyword">if</span> (leftCnt &gt; k-<span class="number">1</span>) <span class="keyword">return</span> kthSmallestNiu(root.left, k);</span><br><span class="line">        <span class="keyword">return</span> kthSmallestNiu(root.right, k - leftCnt - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + count(root.left) + count(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把二叉查找树每个节点的值都加上比它大的节点的值"><a href="#把二叉查找树每个节点的值都加上比它大的节点的值" class="headerlink" title="把二叉查找树每个节点的值都加上比它大的节点的值"></a>把二叉查找树每个节点的值都加上比它大的节点的值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/28 3:00 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertBSTToGreaterTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode treeNode = TreeUtils.generateTreeFromArray(<span class="number">5</span>, <span class="number">2</span>, <span class="number">13</span>);</span><br><span class="line">        ConvertBSTToGreaterTree ct = <span class="keyword">new</span> ConvertBSTToGreaterTree();</span><br><span class="line">        TreeNode root = ct.convertBST(treeNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，</span></span><br><span class="line"><span class="comment">     * 使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 例如：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: 原始二叉搜索树:</span></span><br><span class="line"><span class="comment">     *               5</span></span><br><span class="line"><span class="comment">     *             /   \</span></span><br><span class="line"><span class="comment">     *            2     13</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出: 转换为累加树:</span></span><br><span class="line"><span class="comment">     *              18</span></span><br><span class="line"><span class="comment">     *             /   \</span></span><br><span class="line"><span class="comment">     *           20     13</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traver(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BST的中序遍历就是从小到大,</span></span><br><span class="line"><span class="comment">     * 那么反过来就是从大到小,然后累加就好了.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traver</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traver(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        traver(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树最近公共先祖"><a href="#二叉搜索树最近公共先祖" class="headerlink" title="二叉搜索树最近公共先祖"></a>二叉搜索树最近公共先祖</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/28 6:24 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowestCommonAncestor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，</span></span><br><span class="line"><span class="comment">     * 最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 例如，给定如下二叉搜索树: root =[6,2,8,0,4,7,9,null,null,3,5]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span></span><br><span class="line"><span class="comment">     * 输出: 6</span></span><br><span class="line"><span class="comment">     * 解释: 节点 2 和节点 8 的最近公共祖先是 6。</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span></span><br><span class="line"><span class="comment">     * 输出: 2</span></span><br><span class="line"><span class="comment">     * 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 整体解决模式其实和之前那个范围 p q类似</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树最近公共先祖"><a href="#二叉树最近公共先祖" class="headerlink" title="二叉树最近公共先祖"></a>二叉树最近公共先祖</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 二叉树的最近公共祖先</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-29 06:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowestCommonAncestor</span>Ⅱ </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 例如，给定如下二叉树: root =[3,5,1,6,2,0,8,null,null,7,4]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span></span><br><span class="line"><span class="comment">     * 输出: 3</span></span><br><span class="line"><span class="comment">     * 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span></span><br><span class="line"><span class="comment">     * 示例2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span></span><br><span class="line"><span class="comment">     * 输出: 5</span></span><br><span class="line"><span class="comment">     * 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 说明:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所有节点的值都是唯一的。</span></span><br><span class="line"><span class="comment">     * p、q 为不同节点且均存在于给定的二叉树中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 6:57 2020/8/29</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [root, p, q]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> com.hugh.datastructure.binarytree.utils.TreeNode</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">         * 首先想到的是链表相交，求第一个交点的算法思想。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果每个节点有指向父节点的指针的话，我们就可以把给的两个节点当做链表头，树的根是链表尾部。</span></span><br><span class="line"><span class="comment">         * 这样问题就转化为了求两个相交链表的第一个交点。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 但是题目给的是一个普通的二叉树，没有父节点指针，所以就需要想其他方法了。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 然后是初级递归</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 先判断公共祖先是否在左子树，是则找到</span></span><br><span class="line"><span class="comment">         * 再判断公共祖先是否在右子树，是则找到</span></span><br><span class="line"><span class="comment">         * 当前根是不是公共祖先，是则找到</span></span><br><span class="line"><span class="comment">         * 当前树没有公共祖先</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 这里有一个关键问题：怎么判断当前根是不是公共祖先呢？</span></span><br><span class="line"><span class="comment">         * 这个貌似又是一个递归题，可以拆解为根是不是节点A的祖先和根是不是节点B的祖先。</span></span><br><span class="line"><span class="comment">         * 两个同时满足了，根就是这两个节点的公共祖先。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 这样这道题我们就做出来了，但是复杂度貌似有点高。</span></span><br><span class="line"><span class="comment">         * 对于每个子树，都进行了判断根是不是祖先，这样就相当于双层循环，复杂度是O(n^2)。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 高级递归</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 其实，在初级递归的时候，复杂度之所高，就是需要在每个子树里判断一个根是不是两个节点的祖先。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 这个判断在每个子树里是独立的，但是实际上树与树之间是有关系的。</span></span><br><span class="line"><span class="comment">         * 比如当前树的左儿子是节点A的祖先，那当前树的根肯定也是节点A的祖先。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 递归的时候，如果能服用这个信息，则可以将复杂度降低到O(n)。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * -----</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 最近公共祖先的定义： 设节点 rootroot 为节点 p, qp,q 的某公共祖先，若其左子节点 root.leftroot.left 和右子节点 root.rightroot.right 都不是 p,qp,q 的公共祖先，则称 rootroot 是 “最近的公共祖先” 。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 根据以上定义，若 rootroot 是 p, qp,q 的 最近公共祖先 ，则只可能为以下情况之一：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * p 和 q 在 rootroot 的子树中，且分列 rootroot 的 异侧（即分别在左、右子树中）；</span></span><br><span class="line"><span class="comment">         * p = rootp=root ，且 qq 在 rootroot 的左或右子树中；</span></span><br><span class="line"><span class="comment">         * q = rootq=root ，且 pp 在 rootroot 的左或右子树中；</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : right == <span class="keyword">null</span> ? left : root;</span><br><span class="line">        <span class="comment">// 后序遍历二叉树，如果找到了p或者q或者null（已经遍历完了这条线路），那么就返回这个本身</span></span><br><span class="line">        <span class="comment">// 然后活到整体的逻辑，最后一个判断非常关键，如果左右都不为空的话返回root根节点 也就是最近公共祖先。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 从有序数组中构建二叉查找树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-31 21:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertSortedArrayToBinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment">     * 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 给定有序数组: [-10,-3,0,5,9],</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       0</span></span><br><span class="line"><span class="comment">     *      / \</span></span><br><span class="line"><span class="comment">     *    -3   9</span></span><br><span class="line"><span class="comment">     *    /   /</span></span><br><span class="line"><span class="comment">     *  -10  5</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 21:57 2020/8/31</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [nums]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> com.hugh.datastructure.binarytree.utils.TreeNode</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 双指针控制角标</span></span><br><span class="line">        <span class="keyword">return</span> toBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">toBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> sIdx, <span class="keyword">int</span> eIdex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意循环停止的条件</span></span><br><span class="line">        <span class="keyword">if</span>(sIdx &gt; eIdex) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mIdex = (sIdx + eIdex) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mIdex]);</span><br><span class="line">        root.left = toBST(nums, sIdx, mIdex - <span class="number">1</span>);</span><br><span class="line">        root.right = toBST(nums, mIdex + <span class="number">1</span>, eIdex);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序链表转换二叉搜索树"><a href="#有序链表转换二叉搜索树" class="headerlink" title="有序链表转换二叉搜索树"></a>有序链表转换二叉搜索树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.linkedlist.leecode.standardutils.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 根据有序链表构造平衡的二叉查找树BST</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-31 23:22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertSortedListToBinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">     * public class ListNode &#123;</span></span><br><span class="line"><span class="comment">     *     int val;</span></span><br><span class="line"><span class="comment">     *     ListNode next;</span></span><br><span class="line"><span class="comment">     *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment">     *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment">     *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">     * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">     *     int val;</span></span><br><span class="line"><span class="comment">     *     TreeNode left;</span></span><br><span class="line"><span class="comment">     *     TreeNode right;</span></span><br><span class="line"><span class="comment">     *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment">     *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment">     *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment">     *         this.val = val;</span></span><br><span class="line"><span class="comment">     *         this.left = left;</span></span><br><span class="line"><span class="comment">     *         this.right = right;</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 给定的有序链表： [-10, -3, 0, 5, 9],</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       0</span></span><br><span class="line"><span class="comment">     *      / \</span></span><br><span class="line"><span class="comment">     *    -3   9</span></span><br><span class="line"><span class="comment">     *    /   /</span></span><br><span class="line"><span class="comment">     *  -10  5</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 23:26 2020/8/31</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [head]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> com.hugh.datastructure.binarytree.utils.TreeNode</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界条件的判断</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果不加这个边界条件判断，在后面得断开链表环节会出现NullException</span></span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">        <span class="comment">//这里通过快慢指针找到链表的中间结点slow，pre就是中间</span></span><br><span class="line">        <span class="comment">//结点slow的前一个结点</span></span><br><span class="line">        ListNode slow = head, fast = head, pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//链表断开为两部分，一部分是node的左子节点，一部分是node</span></span><br><span class="line">        <span class="comment">//的右子节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//node就是当前节点</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        <span class="comment">//从head节点到pre节点是node左子树的节点</span></span><br><span class="line">        node.left = sortedListToBST(head);</span><br><span class="line">        <span class="comment">//从slow.next到链表的末尾是node的右子树的结点 从这里也可以看到引入pre的原因，slow和pre分开了，这里才能引用slow.next</span></span><br><span class="line">        node.right = sortedListToBST(slow.next);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在BST中寻找两节点差绝对值的最小值"><a href="#在BST中寻找两节点差绝对值的最小值" class="headerlink" title="在BST中寻找两节点差绝对值的最小值"></a>在BST中寻找两节点差绝对值的最小值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/1 12:06 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumAbsoluteDifferenceInBST</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    1</span></span><br><span class="line"><span class="comment">     *     \</span></span><br><span class="line"><span class="comment">     *      3</span></span><br><span class="line"><span class="comment">     *     /</span></span><br><span class="line"><span class="comment">     *    2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出：</span></span><br><span class="line"><span class="comment">     * 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 解释：</span></span><br><span class="line"><span class="comment">     * 最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 提示：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 树中至少有 2 个节点。</span></span><br><span class="line"><span class="comment">     * 本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        find(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        find(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 中序遍历BST 严格递增</span></span><br><span class="line">            min = Math.min(min,root.val - pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        find(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BST的性质要利用起来 中序遍历，保存前一个节点</span></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在二叉查找树中寻找两个节点，使它们的和为一个给定值"><a href="#在二叉查找树中寻找两个节点，使它们的和为一个给定值" class="headerlink" title="在二叉查找树中寻找两个节点，使它们的和为一个给定值"></a>在二叉查找树中寻找两个节点，使它们的和为一个给定值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/1 11:43 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSumIV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 案例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: </span></span><br><span class="line"><span class="comment">     *     5</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   3   6</span></span><br><span class="line"><span class="comment">     *  / \   \</span></span><br><span class="line"><span class="comment">     * 2   4   7</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Target = 9</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出: True</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 案例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: </span></span><br><span class="line"><span class="comment">     *     5</span></span><br><span class="line"><span class="comment">     *    / \</span></span><br><span class="line"><span class="comment">     *   3   6</span></span><br><span class="line"><span class="comment">     *  / \   \</span></span><br><span class="line"><span class="comment">     * 2   4   7</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Target = 28</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出: False</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> find(root, k, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(TreeNode root, <span class="keyword">int</span> k, HashSet&lt;Integer&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(k - root.val)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> find(root.left, k, set) || find(root.right, k, set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="寻找二叉查找树中出现次数最多的值"><a href="#寻找二叉查找树中出现次数最多的值" class="headerlink" title="寻找二叉查找树中出现次数最多的值"></a>寻找二叉查找树中出现次数最多的值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hugh.datastructure.binarytree.utils.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/1 12:29 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindModeInBinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假定 BST 有如下定义：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 结点左子树中所含结点的值小于等于当前结点的值</span></span><br><span class="line"><span class="comment">     * 结点右子树中所含结点的值大于等于当前结点的值</span></span><br><span class="line"><span class="comment">     * 左子树和右子树都是二叉搜索树</span></span><br><span class="line"><span class="comment">     * 例如：</span></span><br><span class="line"><span class="comment">     * 给定 BST [1,null,2,2],</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    1</span></span><br><span class="line"><span class="comment">     *     \</span></span><br><span class="line"><span class="comment">     *      2</span></span><br><span class="line"><span class="comment">     *     /</span></span><br><span class="line"><span class="comment">     *    2</span></span><br><span class="line"><span class="comment">     * 返回[2].</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 提示：如果众数超过1个，不需考虑输出顺序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// 这个解法是为了最小的空间复杂度，仍然利用了BST的中序遍历递增的特性。</span></span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; maxCntNums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root,maxCntNums);</span><br><span class="line">        <span class="comment">// ArrayList 转换 int[]</span></span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[maxCntNums.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num :</span><br><span class="line">                maxCntNums) &#123;</span><br><span class="line">            ret[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node, ArrayList&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(node.left,nums);</span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preNode.val == node.val) curCnt++;</span><br><span class="line">            <span class="keyword">else</span> curCnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curCnt &gt; maxCnt) &#123;</span><br><span class="line">            maxCnt = curCnt;</span><br><span class="line">            nums.clear();</span><br><span class="line">            nums.add(node.val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curCnt == maxCnt) &#123;</span><br><span class="line">            nums.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;</span><br><span class="line">        inOrder(node.right,nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> curCnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxCnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> TreeNode preNode = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Trie树，字典树、单词查找树或键树-哈希树的变种"><a href="#Trie树，字典树、单词查找树或键树-哈希树的变种" class="headerlink" title="Trie树，字典树、单词查找树或键树 哈希树的变种"></a>Trie树，字典树、单词查找树或键树 哈希树的变种</h4><p>典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较。</p><p>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hash表，通过hash函数把所有的单词分别hash成key值，查询的时候直接通过hash函数即可，都知道hash表的效率是非常高的为O(1)，直接说字典树的查询效率比hash高，难道有比O(1)还快的- -。</span><br><span class="line"></span><br><span class="line">hash：</span><br><span class="line"></span><br><span class="line">当然对于单词查询，如果我们hash函数选取的好，计算量少，且冲突少，那单词查询速度肯定是非常快的。那如果hash函数的计算量相对大呢，且冲突律高呢？</span><br><span class="line"></span><br><span class="line">这些都是要考虑的因素。且hash表不支持动态查询，什么叫动态查询，当我们要查询单词apple时，hash表必须等待用户把单词apple输入完毕才能hash查询。</span><br><span class="line"></span><br><span class="line">当你输入到appl时肯定不可能hash吧。</span><br><span class="line"></span><br><span class="line">字典树（tries树）：</span><br><span class="line"></span><br><span class="line">对于单词查询这种，还是用字典树比较好，但也是有前提的，空间大小允许，字典树的空间相比较hash还是比较浪费的，毕竟hash可以用bit数组。</span><br><span class="line"></span><br><span class="line">那么在空间要求不那么严格的情况下，字典树的效率不一定比hash若，它支持动态查询，比如apple，当用户输入到appl时，字典树此刻的查询位置可以就到达l这个位置，那么我在输入e时光查询e就可以了（更何况如果我们直接用字母的ASCII作下标肯定会更快）！字典树它并不用等待你完全输入完毕后才查询。</span><br><span class="line"></span><br><span class="line">所以效率来讲我认为是相对的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所以尽管哈希表可以在 O(1)O(1) 时间内寻找键值，却无法高效的完成以下操作：</span><br><span class="line"></span><br><span class="line">找到具有同一前缀的全部键值。</span><br><span class="line">按词典序枚举字符串的数据集。</span><br></pre></td></tr></table></figure><p>本场景中，此Trie(读音try)是一个有根树，有以下特点：</p><ul><li><p>最多 R<em>R</em> 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。本文中假定 R<em>R</em> 为 26，小写拉丁字母的数量。</p></li><li><p>布尔字段，以指定节点是对应键的结尾还是只是键前缀。</p></li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gid8jmyeiwj20dw0dwq71.jpg" alt="undefined"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> trie;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/3 11:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TrieNode[] child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.child = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">this</span>.isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> trie;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/3 11:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="comment">// 对应位置上只要不是空就代表有值，并不需要填入某个确定的char，[c - 'a'] 代表了index</span></span><br><span class="line">            <span class="keyword">if</span>(p.child[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.child[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有点类似与二叉树的node = node.next;</span></span><br><span class="line">            p = p.child[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(p.child[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.child[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*if(p.isEnd == true) &#123;</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return false;*/</span></span><br><span class="line">        <span class="keyword">return</span> p.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(p.child[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.child[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现一个-Trie，用来求前缀和"><a href="#实现一个-Trie，用来求前缀和" class="headerlink" title="实现一个 Trie，用来求前缀和"></a>实现一个 Trie，用来求前缀和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hugh.datastructure.binarytree.leecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: draft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 实现一个 Trie，用来求前缀和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Fly.Hugh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-09-04 04:27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Fly.Hugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * 实现一个 MapSum 类里的两个方法，insert 和 sum。</span></span><br><span class="line"><span class="comment">     * 对于方法 insert，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。</span></span><br><span class="line"><span class="comment">     * 对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: insert("apple", 3), 输出: Null</span></span><br><span class="line"><span class="comment">     * 输入: sum("ap"), 输出: 3</span></span><br><span class="line"><span class="comment">     * 输入: insert("app", 2), 输出: Null</span></span><br><span class="line"><span class="comment">     * 输入: sum("ap"), 输出: 5</span></span><br><span class="line"><span class="comment">     * 通过次数8,509提交次数14,004</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 4:28 2020/9/4</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span> [args]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node[] child = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        insert(key, root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, Node node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            node.value = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = indexForChar(key.charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.child[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.child[index] = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        insert(key.substring(<span class="number">1</span>), node.child[index], val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum(prefix, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (prefix.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = indexForChar(prefix.charAt(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span> sum(prefix.substring(<span class="number">1</span>), node.child[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = node.value;</span><br><span class="line">        <span class="keyword">for</span> (Node child : node.child) &#123;</span><br><span class="line">            sum += sum(prefix, child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexForChar</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1ggxzqogx6kj20b304tjr8.jpg&quot; alt=&quot;159526903056127.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个是因该很早之前就要学习的东西，一直拖今天，惭愧…&lt;/p&gt;
&lt;p&gt;本文是&lt;code&gt; labuladong的算法笔记&lt;/code&gt;的读书笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/tags/数据结构/"/>
    
  </entry>
  
  <entry>
    <title>Java单例</title>
    <link href="http://yoursite.com/2020/07/14/%E5%8D%95%E4%BE%8B%E6%B5%85%E8%B0%88/"/>
    <id>http://yoursite.com/2020/07/14/%E5%8D%95%E4%BE%8B%E6%B5%85%E8%B0%88/</id>
    <published>2020-07-13T18:08:51.402Z</published>
    <updated>2020-07-16T21:52:34.439Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单复习一下Java的单例</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ggpuhjmlfbj20dm08djrh.jpg" alt="undefined"></p><a id="more"></a> <h1 id="Java单例"><a href="#Java单例" class="headerlink" title="Java单例"></a>Java单例</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>单例对象的类必须保证只有一个实例存在</code>——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p><p>对单例的实现可以分为两大类——<code>懒汉式</code>和<code>饿汉式</code>，他们的区别在于：<br><code>懒汉式</code>：指全局的单例实例在<strong>第一次</strong>被使用时构建。<br><code>饿汉式</code>：指全局的单例实例在<strong>类装载</strong>时构建。</p><p>日常我们使用的较多的应该是<code>懒汉式</code>的单例，毕竟按需加载才能做到资源的最大化利用。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Single1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进一步，把构造器改为私有的，这样能够防止被外部的类调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 1.1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Single1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当多线程工作的时候，如果有多个线程同时运行到<code>if (instance == null)</code>，都判断为null，那么两个线程就各自会创建一个实例——这样一来，就不是单例了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 2 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single2 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Single2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Single2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这种写法也有一个问题：<strong>给gitInstance方法加锁，虽然会避免了可能会出现的多个实例问题，但是会强制除T1之外的所有线程等待，实际上会对程序的执行效率造成负面影响。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 3 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single3 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Single3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Single3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的代码看起来有点复杂，注意其中有两次<code>if (instance == null)</code>的判断，这个叫做『双重检查 Double-Check』。</p><ul><li>第一个null判断，是为了解决Version2中的效率问题，只有instance是null的时候，才进入下面的synchronized的代码段，大大减少了几率。</li><li>第二个判断就是跟上面一个版本一样，是为了防止可能出现的实例情况。</li></ul><p>这么优化和同步锁的原理有关：如果有两个线程（T1、T2）同时执行到这个方法时，会有其中一个线程T1获得同步锁，得以继续执行，而另一个线程T2则需要等待，当第T1执行完毕getInstance之后（完成了null判断、对象创建、获得返回值之后）</p><p>使用两个判断后，在第一次判断之后直接跳了出去。</p><p>第二个判断的用处是，如果出现了两个线程一起访问第一个if的情况，然后到了锁，其中一个线程进去创建对象，如果没有这第二个if判断的话，那么等线程一释放了锁之后，线程二就会进去创建新对象了。</p><hr><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>首先介绍概念 ：<code>原子操作</code>、<code>指令重排</code>。</p><h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><p>比如，简单的赋值是一个原子操作：</p><blockquote><p>m = 6; // 这是个原子操作</p></blockquote><p>假如m原先的值为0，那么对于这个操作，要么执行成功m变成了6，要么是没执行m还是0，而不会出现诸如m=3这种中间态——即使是在并发的线程中。</p><p>而，声明并赋值就不是一个原子操作：</p><blockquote><p>int n = 6; // 这不是一个原子操作</p></blockquote><p>对于这个语句，至少有两个操作：<br> ①声明一个变量n<br> ②给n赋值为6<br> ——这样就会有一个中间状态：变量n已经被声明了但是还没有被赋值的状态。<br> ——这样，在多线程中，由于线程执行顺序的不确定性，如果两个线程都使用m，就可能会导致不稳定的结果出现。</p><h5 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h5><p>简单来说，就是计算机为了提高执行效率，会做的一些优化，在不影响最终结果的情况下，可能会对一些语句的执行顺序进行调整。<br> 比如，这一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a ;   <span class="comment">// 语句1 </span></span><br><span class="line">a = <span class="number">8</span> ;   <span class="comment">// 语句2</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">9</span> ;     <span class="comment">// 语句3</span></span><br><span class="line"><span class="keyword">int</span> c = a + b ; <span class="comment">// 语句4</span></span><br></pre></td></tr></table></figure><p>正常来说，对于顺序结构，执行的顺序是自上到下，也即1234。<br> 但是，由于<code>指令重排</code>的原因，因为不影响最终的结果，所以，实际执行的顺序可能会变成3124或者1324。<br> 由于语句3和4没有原子性的问题，语句3和语句4也可能会拆分成原子操作，再重排。<br> ——也就是说，对于非原子性的操作，在不影响最终结果的情况下，其拆分成的原子操作可能会被重新排列执行顺序。</p><p>上面的代码主要问题：</p><blockquote><p>主要在于singleton = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p><ol><li>给 singleton 分配内存</li><li>调用 Singleton 的构造函数来初始化成员变量，形成实例</li><li>将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）<br>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，<strong>这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错</strong>。</li></ol></blockquote><p>就是说，由于有一个<strong>『instance已经不为null但是仍没有完成初始化』</strong>的中间状态，而这个时候，如果有其他线程刚好运行到第一层<code>if (instance == null)</code>这里，这里读取到的instance已经不为null了，所以就直接把这个中间状态的instance拿去用了，就会产生问题。<br> 这里的关键在于——<strong>线程T1对instance的写操作没有完成，线程T2就执行了读操作</strong>。</p><p>当然这种几率是非常小的。</p><h5 id="完全体："><a href="#完全体：" class="headerlink" title="完全体："></a>完全体：</h5><p>只需要给instance的声明加上<code>volatile</code>关键字即可，Version4版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 4 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single4 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Single4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Single4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>volatile</code>关键字的一个作用是禁止<code>指令重排</code>，把instance声明为<code>volatile</code>之后，对它的写操作就会有一个<code>内存屏障</code>，这样，在它的赋值完成之前，就不用会调用读操作。</p><blockquote><p> volatile阻止的不是*singleton = new Singleton()*这句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-2-3]）完成之前，不会调用读操作（<code>if (instance == null)</code>）。</p></blockquote><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>如上所说，<code>饿汉式</code>单例是指：指全局的单例实例在类装载时构建的实现方式。</p><p>由于类装载的过程是由类加载器（ClassLoader）来执行的，这个过程也是由JVM来保证同步的，所以这种方式先天就有一个优势——能够免疫许多由多线程引起的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleB INSTANCE = <span class="keyword">new</span> SingleB();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleB <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个饿汉式单例的写法来说，它基本上是完美的了。</p><p>所以它的缺点也就只是饿汉式单例本身的缺点所在了——由于INSTANCE的初始化是在类加载时进行的，而类的加载是由ClassLoader来做的，所以开发者本来对于它初始化的时机就很难去准确把握：</p><ol><li>可能由于初始化的太早，造成资源的浪费</li><li>如果初始化本身依赖于一些其他数据，那么也就很难保证其他数据会在它初始化之前准备好。</li></ol><p>当然，如果所需的单例占用的资源很少，并且也不依赖于其他数据，那么这种实现方式也是很好的。</p><h3 id="Effective-Java中提供的实现方式"><a href="#Effective-Java中提供的实现方式" class="headerlink" title="Effective Java中提供的实现方式"></a>Effective Java中提供的实现方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Effective Java 第一版推荐写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我佛了，合二为一，既使用了ClassLoader来保证了同步，同时又能让开发者控制类加载的时机。从内部看是一个饿汉式的单例，但是从外部看来，又的确是懒汉式的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Effective Java 第二版推荐写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingleInstance &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">SingleInstance.INSTANCE.fun1();</span><br></pre></td></tr></table></figure><p>这是一个枚举类型，极简。<br>由于创建枚举实例的过程是线程安全的，所以这种写法也没有同步的问题。</p><p>作者对这个方法的评价：</p><blockquote><p>这种写法在功能上与共有域方法相近，但是它更简洁，无偿地提供了序列化机制，绝对防止对此实例化，即使是在面对复杂的序列化或者反射攻击的时候。虽然这中方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</p></blockquote><p>枚举单例这种方法问世一些，许多分析文章都称它是实现单例的最完美方法——写法超级简单，而且又能解决大部分的问题。<br>这种方法虽然很优秀，但是它仍然不是完美的——比如，在需要继承的场景，它就不适用了。</p><h3 id="拓展：enum"><a href="#拓展：enum" class="headerlink" title="拓展：enum"></a>拓展：enum</h3><p>最后一种写法涉及到一些Java枚举类的不常见使用方法，简单介绍一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day2 &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>,<span class="number">1</span>),</span><br><span class="line">    TUESDAY(<span class="string">"星期二"</span>,<span class="number">2</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">"星期三"</span>,<span class="number">3</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>,<span class="number">4</span>),</span><br><span class="line">    FRIDAY(<span class="string">"星期五"</span>,<span class="number">5</span>),</span><br><span class="line">    SATURDAY(<span class="string">"星期六"</span>,<span class="number">6</span>),</span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>,<span class="number">7</span>);<span class="comment">//记住要用分号结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String desc;<span class="comment">//文字描述</span></span><br><span class="line"><span class="keyword">private</span> Integer code; <span class="comment">//对应的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有构造,防止被外部调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Day2</span><span class="params">(String desc，Integer code)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.desc=desc;</span><br><span class="line"> <span class="keyword">this</span>.code=code;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义方法,返回描述,跟常规类的定义没区别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义方法,返回代码,跟常规类的定义没区别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Day2 day:Day2.values()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"name:"</span>+day.name()+</span><br><span class="line">                <span class="string">",desc:"</span>+day.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展：类的加载和初始化简单了解"><a href="#拓展：类的加载和初始化简单了解" class="headerlink" title="拓展：类的加载和初始化简单了解"></a>拓展：类的加载和初始化简单了解</h3><h4 id="类什么时候加载"><a href="#类什么时候加载" class="headerlink" title="类什么时候加载"></a>类什么时候加载</h4><p>类的加载是通过类加载器（Classloader）完成的，它既可以是饿汉式[eagerly load]（只要有其它类引用了它就加载）加载类，也可以是懒加载[lazy load]（等到类初始化发生的时候才加载）。不过我相信这跟不同的JVM实现有关，然而他又是受JLS保证的（当有静态初始化需求的时候才被加载）。</p><h4 id="类什么时候初始化"><a href="#类什么时候初始化" class="headerlink" title="类什么时候初始化"></a>类什么时候初始化</h4><p>加载完类后，类的初始化就会发生，意味着它会初始化所有类静态成员，以下情况一个类被初始化：</p><ol><li>实例通过使用new()关键字创建或者使用class.forName()反射，但它有可能导致ClassNotFoundException。</li><li>类的静态方法被调用</li><li>类的静态域被赋值</li><li>静态域被访问，而且它不是常量</li><li>在顶层类中执行assert语句</li></ol><p>反射同样可以使类初始化，比如java.lang.reflect包下面的某些方法，JLS严格的说明：一个类不会被任何除以上之外的原因初始化。</p><h4 id="类是如何被初始化的"><a href="#类是如何被初始化的" class="headerlink" title="类是如何被初始化的"></a>类是如何被初始化的</h4><p>现在我们知道什么时候触发类的初始化了，他精确地写在Java语言规范中。但了解清楚 域（fields，静态的还是非静态的）、块（block静态的还是非静态的）、不同类（子类和超类）和不同的接口（子接口，实现类和超接口）的初始化顺序也很重要类。事实上很多核心Java面试题和SCJP问题都是基于这些概念，下面是类初始化的一些规则：</p><ol><li>类从顶至底的顺序初始化，所以声明在顶部的字段的早于底部的字段初始化</li><li>超类早于子类和衍生类的初始化</li><li>如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的初始化即使静态域被子类或子接口或者它的实现类所引用。</li><li>接口初始化不会导致父接口的初始化。</li><li>静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。</li><li>非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类</li></ol><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java program to demonstrate class loading and initialization in Java.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitializationTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        NotUsed o = <span class="keyword">null</span>; <span class="comment">//this class is not used, should not be initialized</span></span><br><span class="line">        Child t = <span class="keyword">new</span> Child(); <span class="comment">//initializing sub class, should trigger super class initialization</span></span><br><span class="line">        System.out.println((Object)o == (Object)t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Super class to demonstrate that Super class is loaded and initialized before Subclass.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"static block of Super class is initialized"</span>); &#125;</span><br><span class="line">    &#123;System.out.println(<span class="string">"non static blocks in super class is initialized"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java class which is not used in this program, consequently not loaded by JVM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotUsed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"NotUsed Class is initialized "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sub class of Parent, demonstrate when exactly sub class loading and initialization occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"static block of Sub class is initialized in Java "</span>); &#125;</span><br><span class="line">    &#123;System.out.println(<span class="string">"non static blocks in sub class is initialized"</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:<br>static block of Super class is initialized<br>static block of Sub class is initialized in Java<br>non static blocks in super class is initialized<br>non static blocks in sub class is initialized<br>false</p><p>从上面结果可以看出：</p><ol><li>超类初始化早于子类</li><li>静态变量或代码块初始化早于非静态块和域</li><li>没使用的类根本不会被初始化，因为他没有被使用</li></ol><p>再来一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Another Java program example to demonstrate class initialization and loading in Java.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitializationTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">//accessing static field of Parent through child, should only initialize Parent</span></span><br><span class="line">       System.out.println(Child.familyName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">//compile time constant, accessing this will not trigger class initialization</span></span><br><span class="line">    <span class="comment">//protected static final String familyName = "Lawson";</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> String familyName = <span class="string">"Lawson"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"static block of Super class is initialized"</span>); &#125;</span><br><span class="line">    &#123;System.out.println(<span class="string">"non static blocks in super class is initialized"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"><span class="keyword">static</span> block of Super <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">initialized</span></span></span><br><span class="line"><span class="class"><span class="title">Lawson</span></span></span><br></pre></td></tr></table></figure><p>分析：</p><ol><li>这里的初始化发生是因为有静态域被访问，而且不一个编译时常量。如果声明的”familyName”是使用final关键字修饰的编译时常量使用（就是上面的注释代码块部分）超类的初始化就不会发生。</li><li>尽管静态与被子类所引用但是也仅仅是超类被初始化</li></ol><p>还有另外一个例子与接口相关的，JLS清晰地解释子接口的初始化不会触发父接口的初始化。强烈推荐阅读JLS14.4理解类加载和初始化细节。以上所有就是有关类被初始化和加载的全部内容。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>类什么时候被加载/类加载时机：<br>第一：生成该类对象的时候，会加载该类及该类的所有父类；<br>第二：访问该类的静态成员的时候；</p><p>第三：CLASS．FORNAME(“类名”)；</p><p>加载完以后JVM中就有了该类的元数据，知道这个CLASS的成员变量和方法等信息，当要NEW一个类的实例时就会根据这个CLASS对象去内存中开辟空间，存放该类的实例对象</p><p>先初始化父类的静态代码—&gt;初始化子类的静态代码–&gt;初始化父类的非静态代码—&gt;初始化父类构造函数—&gt;初始化子类非静态代码—&gt;初始化子类构造函数</p><p>JVM是比较底层的内容，上面只是简单一些推理，今后还要多加学习。</p><h3 id="拓展：volatile"><a href="#拓展：volatile" class="headerlink" title="拓展：volatile"></a>拓展：volatile</h3><p>在Sun的JDK官方文档是这样形容volatile的：</p><p>The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes. A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable.</p><p>如果一个变量加了volatile关键字，就会告诉编译器和JVM的内存模型：这个变量是对所有线程共享的、可见的，每次jvm都会读取最新写入的值并使其最新值在所有CPU可见。<strong>volatile似乎是有时候可以代替简单的锁，似乎加了volatile关键字就省掉了锁。但又说volatile不能保证原子性（java程序员很熟悉这句话：volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性）</strong>。让人费解。</p><p><strong>不要将volatile用在getAndOperate场合（这种场合不原子，需要再加锁），仅仅set或者get的场景是适合volatile的</strong>。</p><h4 id="volatile没有原子性举例：AtomicInteger自增"><a href="#volatile没有原子性举例：AtomicInteger自增" class="headerlink" title="volatile没有原子性举例：AtomicInteger自增"></a>volatile没有原子性举例：AtomicInteger自增</h4><p>例如你让一个volatile的integer自增（i++），其实要分成3步：1）读取volatile变量值到local； 2）增加变量的值；3）把local的值写回，让其它的线程可见。这3步的jvm指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    0xc(%r10),%r8d ; Load</span><br><span class="line">inc    %r8d           ; Increment</span><br><span class="line">mov    %r8d,0xc(%r10) ; Store</span><br><span class="line">lock addl $0x0,(%rsp) ; StoreLoad Barrier</span><br></pre></td></tr></table></figure><p>注意最后一步是<strong>内存屏障</strong>。</p><h4 id="什么是内存屏障（Memory-Barrier）？"><a href="#什么是内存屏障（Memory-Barrier）？" class="headerlink" title="什么是内存屏障（Memory Barrier）？"></a>什么是内存屏障（Memory Barrier）？</h4><p>内存屏障是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p><p>内存屏障和volatile什么关系？上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p><h4 id="volatile为什么没有原子性"><a href="#volatile为什么没有原子性" class="headerlink" title="volatile为什么没有原子性?"></a>volatile为什么没有原子性?</h4><p>明白了内存屏障（<a href="http://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">memory barrier</a>）这个CPU指令，回到前面的JVM指令：从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但<strong>中间的几步（从Load到Store）</strong>是不安全的，中间如果其他的CPU修改了值将会丢失。下面的测试代码可以实际测试voaltile的自增没有原子性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span> _longVal = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopVolatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (val &lt; <span class="number">10000000L</span>) &#123;</span><br><span class="line">                _longVal++;</span><br><span class="line">                val++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopVolatile2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (val &lt; <span class="number">10000000L</span>) &#123;</span><br><span class="line">                _longVal++;</span><br><span class="line">                val++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">testVolatile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopVolatile());</span><br><span class="line">        t1.start();</span><br><span class="line">         </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopVolatile2());</span><br><span class="line">        t2.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"final val is: "</span> + _longVal);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">Output:-------------</span><br><span class="line">     </span><br><span class="line"><span class="keyword">final</span> val is: <span class="number">11223828</span></span><br><span class="line"><span class="keyword">final</span> val is: <span class="number">17567127</span></span><br><span class="line"><span class="keyword">final</span> val is: <span class="number">12912109</span></span><br></pre></td></tr></table></figure><h4 id="volatile没有原子性举例：singleton单例模式实现"><a href="#volatile没有原子性举例：singleton单例模式实现" class="headerlink" title="volatile没有原子性举例：singleton单例模式实现"></a>volatile没有原子性举例：singleton单例模式实现</h4><p>这是一段线程不安全的singleton（单例模式）实现，尽管使用了volatile：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wrongsingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> wrongsingleton _instance = <span class="keyword">null</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">wrongsingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> wrongsingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> wrongsingleton();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的测试代码可以测试出是线程不安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wrongsingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> wrongsingleton _instance = <span class="keyword">null</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">wrongsingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> wrongsingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> wrongsingleton();</span><br><span class="line">            System.out.println(<span class="string">"--initialized once."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopInit());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopInit2());</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopInit());</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopInit2());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive() || t3.isAlive()|| t4.isAlive()) &#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">输出：有时输出<span class="string">"--initialized once."</span>一次，有时输出好几次</span><br></pre></td></tr></table></figure><p>原因自然和上面的例子是一样的。因为<strong>volatile保证变量对线程的可见性，但不保证原子性</strong>。</p><h4 id="为什么AtomicXXX具有原子性和可见性？"><a href="#为什么AtomicXXX具有原子性和可见性？" class="headerlink" title="为什么AtomicXXX具有原子性和可见性？"></a>为什么AtomicXXX具有原子性和可见性？</h4><p>就拿AtomicLong来说，它既解决了上述的volatile的原子性没有保证的问题，又具有可见性。它是如何做到的？CAS（比较并交换）指令。 其实AtomicLong的源码里也用到了volatile，但只是用来读取或写入，见源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicLong with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">(<span class="keyword">long</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicLong with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其CAS源码核心代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ATOMIC();</span><br><span class="line">  <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">  <span class="keyword">if</span> (old_reg_val == oldval) </span><br><span class="line">     *reg = newval;</span><br><span class="line">  END_ATOMIC();</span><br><span class="line">  <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    0xc(%r11),%eax       ; Load</span><br><span class="line">mov    %eax,%r8d            </span><br><span class="line">inc    %r8d                 ; Increment</span><br><span class="line">lock cmpxchg %r8d,0xc(%r11) ; Compare and exchange</span><br></pre></td></tr></table></figure><p>因为CAS是基于乐观锁的，也就是说当写入的时候，如果寄存器旧值已经不等于现值，说明有其他CPU在修改，那就继续尝试。所以这就保证了操作的原子性。</p><h3 id="拓展-在序列化和反序列化之后可能会出现新的单例对象"><a href="#拓展-在序列化和反序列化之后可能会出现新的单例对象" class="headerlink" title="拓展 在序列化和反序列化之后可能会出现新的单例对象"></a>拓展 在序列化和反序列化之后可能会出现新的单例对象</h3><blockquote><p> 根据Effective Java中指出的，要使单例类使用这两种方法中的任何一种（Chapter 12），仅仅在其声明中添加实现 serializable 是不够的。要维护单例保证，应声明所有实例字段为 transient，并提供 readResolve 方法（Item-89）。否则，每次反序列化实例时，都会创建一个新实例，在我们的示例中，这会导致出现虚假的 Elvis。为了防止这种情况发生，将这个 readResolve 方法添加到 单例类中：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readResolve method to preserve singleton property</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return the one true Elvis and let the garbage collector</span></span><br><span class="line">    <span class="comment">// take care of the Elvis impersonator.</span></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;简单复习一下Java的单例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1ggpuhjmlfbj20dm08djrh.jpg&quot; alt=&quot;undefined&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
