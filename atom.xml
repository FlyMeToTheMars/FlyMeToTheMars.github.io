<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mars</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-13T18:26:33.222Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Fly Hugh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java单例</title>
    <link href="http://yoursite.com/2020/07/14/%E5%8D%95%E4%BE%8B%E6%B5%85%E8%B0%88/"/>
    <id>http://yoursite.com/2020/07/14/单例浅谈/</id>
    <published>2020-07-13T18:08:51.402Z</published>
    <updated>2020-07-13T18:26:33.222Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单复习一下Java的单例</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ggpuhjmlfbj20dm08djrh.jpg" alt="undefined"></p><a id="more"></a> <h1 id="Java单例"><a href="#Java单例" class="headerlink" title="Java单例"></a>Java单例</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>单例对象的类必须保证只有一个实例存在</code>——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p><p>对单例的实现可以分为两大类——<code>懒汉式</code>和<code>饿汉式</code>，他们的区别在于：<br><code>懒汉式</code>：指全局的单例实例在<strong>第一次</strong>被使用时构建。<br><code>饿汉式</code>：指全局的单例实例在<strong>类装载</strong>时构建。</p><p>日常我们使用的较多的应该是<code>懒汉式</code>的单例，毕竟按需加载才能做到资源的最大化利用。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Single1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进一步，把构造器改为私有的，这样能够防止被外部的类调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 1.1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Single1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当多线程工作的时候，如果有多个线程同时运行到<code>if (instance == null)</code>，都判断为null，那么两个线程就各自会创建一个实例——这样一来，就不是单例了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 2 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single2 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Single2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Single2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这种写法也有一个问题：<strong>给gitInstance方法加锁，虽然会避免了可能会出现的多个实例问题，但是会强制除T1之外的所有线程等待，实际上会对程序的执行效率造成负面影响。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 3 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single3 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Single3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Single3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的代码看起来有点复杂，注意其中有两次<code>if (instance == null)</code>的判断，这个叫做『双重检查 Double-Check』。</p><ul><li>第一个null判断，是为了解决Version2中的效率问题，之哦于instance是null的时候，才进入下面的synchronized的代码段，大大减少了几率。</li><li>第二个判断就是跟上面一个版本式样，是为了防止可能出现的实例情况。</li></ul><p>这么优化和同步锁的原理有关：如果有两个线程（T1、T2）同时执行到这个方法时，会有其中一个线程T1获得同步锁，得以继续执行，而另一个线程T2则需要等待，当第T1执行完毕getInstance之后（完成了null判断、对象创建、获得返回值之后）</p><p>使用两个判断后，在第一次判断之后直接跳了出去。</p><hr><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>首先介绍概念 ：<code>原子操作</code>、<code>指令重排</code>。</p><h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><p>比如，简单的赋值是一个原子操作：</p><blockquote><p>m = 6; // 这是个原子操作</p></blockquote><p>假如m原先的值为0，那么对于这个操作，要么执行成功m变成了6，要么是没执行m还是0，而不会出现诸如m=3这种中间态——即使是在并发的线程中。</p><p>而，声明并赋值就不是一个原子操作：</p><blockquote><p>int n = 6; // 这不是一个原子操作</p></blockquote><p>对于这个语句，至少有两个操作：<br> ①声明一个变量n<br> ②给n赋值为6<br> ——这样就会有一个中间状态：变量n已经被声明了但是还没有被赋值的状态。<br> ——这样，在多线程中，由于线程执行顺序的不确定性，如果两个线程都使用m，就可能会导致不稳定的结果出现。</p><h5 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h5><p>简单来说，就是计算机为了提高执行效率，会做的一些优化，在不影响最终结果的情况下，可能会对一些语句的执行顺序进行调整。<br> 比如，这一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a ;   <span class="comment">// 语句1 </span></span><br><span class="line">a = <span class="number">8</span> ;   <span class="comment">// 语句2</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">9</span> ;     <span class="comment">// 语句3</span></span><br><span class="line"><span class="keyword">int</span> c = a + b ; <span class="comment">// 语句4</span></span><br></pre></td></tr></table></figure><p>正常来说，对于顺序结构，执行的顺序是自上到下，也即1234。<br> 但是，由于<code>指令重排</code>的原因，因为不影响最终的结果，所以，实际执行的顺序可能会变成3124或者1324。<br> 由于语句3和4没有原子性的问题，语句3和语句4也可能会拆分成原子操作，再重排。<br> ——也就是说，对于非原子性的操作，在不影响最终结果的情况下，其拆分成的原子操作可能会被重新排列执行顺序。</p><p>上面的代码主要问题：</p><blockquote><p>主要在于singleton = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p><ol><li>给 singleton 分配内存</li><li>调用 Singleton 的构造函数来初始化成员变量，形成实例</li><li>将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）<br>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，<strong>这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错</strong>。</li></ol></blockquote><p>就是说，由于有一个<strong>『instance已经不为null但是仍没有完成初始化』</strong>的中间状态，而这个时候，如果有其他线程刚好运行到第一层<code>if (instance == null)</code>这里，这里读取到的instance已经不为null了，所以就直接把这个中间状态的instance拿去用了，就会产生问题。<br> 这里的关键在于——<strong>线程T1对instance的写操作没有完成，线程T2就执行了读操作</strong>。</p><p>当然这种纪律是非常小的。</p><h5 id="完全体："><a href="#完全体：" class="headerlink" title="完全体："></a>完全体：</h5><p>只需要给instance的声明加上<code>volatile</code>关键字即可，Version4版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 4 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single4 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Single4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Single4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>volatile</code>关键字的一个作用是禁止<code>指令重排</code>，把instance声明为<code>volatile</code>之后，对它的写操作就会有一个<code>内存屏障</code>，这样，在它的赋值完成之前，就不用会调用读操作。</p><blockquote><p> volatile阻止的不是<em>singleton = new Singleton()</em>这句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-2-3]）完成之前，不会调用读操作（<code>if (instance == null)</code>）。</p></blockquote><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>如上所说，<code>饿汉式</code>单例是指：指全局的单例实例在类装载时构建的实现方式。</p><p>由于类装载的过程是由类加载器（ClassLoader）来执行的，这个过程也是由JVM来保证同步的，所以这种方式先天就有一个优势——能够免疫许多由多线程引起的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleB INSTANCE = <span class="keyword">new</span> SingleB();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleB <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个饿汉式单例的写法来说，它基本上是完美的了。</p><p>所以它的缺点也就只是饿汉式单例本身的缺点所在了——由于INSTANCE的初始化是在类加载时进行的，而类的加载是由ClassLoader来做的，所以开发者本来对于它初始化的时机就很难去准确把握：</p><ol><li>可能由于初始化的太早，造成资源的浪费</li><li>如果初始化本身依赖于一些其他数据，那么也就很难保证其他数据会在它初始化之前准备好。</li></ol><p>当然，如果所需的单例占用的资源很少，并且也不依赖于其他数据，那么这种实现方式也是很好的。</p><h3 id="Effective-Java中提供的实现方式"><a href="#Effective-Java中提供的实现方式" class="headerlink" title="Effective Java中提供的实现方式"></a>Effective Java中提供的实现方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Effective Java 第一版推荐写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我佛了，合二为一，既使用了ClassLoader来保证了同步，同时又能让开发者控制类加载的时机。从内部看是一个饿汉式的单例，但是从外部看来，又的确是懒汉式的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Effective Java 第二版推荐写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingleInstance &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">SingleInstance.INSTANCE.fun1();</span><br></pre></td></tr></table></figure><p>这是一个枚举类型，极简。<br>由于创建枚举实例的过程是线程安全的，所以这种写法也没有同步的问题。</p><p>作者对这个方法的评价：</p><blockquote><p>这种写法在功能上与共有域方法相近，但是它更简洁，无偿地提供了序列化机制，绝对防止对此实例化，即使是在面对复杂的序列化或者反射攻击的时候。虽然这中方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</p></blockquote><p>枚举单例这种方法问世一些，许多分析文章都称它是实现单例的最完美方法——写法超级简单，而且又能解决大部分的问题。<br>这种方法虽然很优秀，但是它仍然不是完美的——比如，在需要继承的场景，它就不适用了。</p><h3 id="拓展：enum"><a href="#拓展：enum" class="headerlink" title="拓展：enum"></a>拓展：enum</h3><p>最后一种写法涉及到一些Java枚举类的不常见使用方法，简单介绍一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day2 &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>,<span class="number">1</span>),</span><br><span class="line">    TUESDAY(<span class="string">"星期二"</span>,<span class="number">2</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">"星期三"</span>,<span class="number">3</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>,<span class="number">4</span>),</span><br><span class="line">    FRIDAY(<span class="string">"星期五"</span>,<span class="number">5</span>),</span><br><span class="line">    SATURDAY(<span class="string">"星期六"</span>,<span class="number">6</span>),</span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>,<span class="number">7</span>);<span class="comment">//记住要用分号结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String desc;<span class="comment">//文字描述</span></span><br><span class="line"><span class="keyword">private</span> Integer code; <span class="comment">//对应的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有构造,防止被外部调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Day2</span><span class="params">(String desc，Integer code)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.desc=desc;</span><br><span class="line"> <span class="keyword">this</span>.code=code;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义方法,返回描述,跟常规类的定义没区别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义方法,返回代码,跟常规类的定义没区别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Day2 day:Day2.values()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"name:"</span>+day.name()+</span><br><span class="line">                <span class="string">",desc:"</span>+day.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展：类的加载和初始化简单了解"><a href="#拓展：类的加载和初始化简单了解" class="headerlink" title="拓展：类的加载和初始化简单了解"></a>拓展：类的加载和初始化简单了解</h3><h4 id="类什么时候加载"><a href="#类什么时候加载" class="headerlink" title="类什么时候加载"></a>类什么时候加载</h4><p>类的加载是通过类加载器（Classloader）完成的，它既可以是饿汉式[eagerly load]（只要有其它类引用了它就加载）加载类，也可以是懒加载[lazy load]（等到类初始化发生的时候才加载）。不过我相信这跟不同的JVM实现有关，然而他又是受JLS保证的（当有静态初始化需求的时候才被加载）。</p><h4 id="类什么时候初始化"><a href="#类什么时候初始化" class="headerlink" title="类什么时候初始化"></a>类什么时候初始化</h4><p>加载完类后，类的初始化就会发生，意味着它会初始化所有类静态成员，以下情况一个类被初始化：</p><ol><li>实例通过使用new()关键字创建或者使用class.forName()反射，但它有可能导致ClassNotFoundException。</li><li>类的静态方法被调用</li><li>类的静态域被赋值</li><li>静态域被访问，而且它不是常量</li><li>在顶层类中执行assert语句</li></ol><p>反射同样可以使类初始化，比如java.lang.reflect包下面的某些方法，JLS严格的说明：一个类不会被任何除以上之外的原因初始化。</p><h4 id="类是如何被初始化的"><a href="#类是如何被初始化的" class="headerlink" title="类是如何被初始化的"></a>类是如何被初始化的</h4><p>现在我们知道什么时候触发类的初始化了，他精确地写在Java语言规范中。但了解清楚 域（fields，静态的还是非静态的）、块（block静态的还是非静态的）、不同类（子类和超类）和不同的接口（子接口，实现类和超接口）的初始化顺序也很重要类。事实上很多核心Java面试题和SCJP问题都是基于这些概念，下面是类初始化的一些规则：</p><ol><li>类从顶至底的顺序初始化，所以声明在顶部的字段的早于底部的字段初始化</li><li>超类早于子类和衍生类的初始化</li><li>如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的初始化即使静态域被子类或子接口或者它的实现类所引用。</li><li>接口初始化不会导致父接口的初始化。</li><li>静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。</li><li>非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类</li></ol><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java program to demonstrate class loading and initialization in Java.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitializationTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        NotUsed o = <span class="keyword">null</span>; <span class="comment">//this class is not used, should not be initialized</span></span><br><span class="line">        Child t = <span class="keyword">new</span> Child(); <span class="comment">//initializing sub class, should trigger super class initialization</span></span><br><span class="line">        System.out.println((Object)o == (Object)t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Super class to demonstrate that Super class is loaded and initialized before Subclass.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"static block of Super class is initialized"</span>); &#125;</span><br><span class="line">    &#123;System.out.println(<span class="string">"non static blocks in super class is initialized"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java class which is not used in this program, consequently not loaded by JVM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotUsed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"NotUsed Class is initialized "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sub class of Parent, demonstrate when exactly sub class loading and initialization occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"static block of Sub class is initialized in Java "</span>); &#125;</span><br><span class="line">    &#123;System.out.println(<span class="string">"non static blocks in sub class is initialized"</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:<br>static block of Super class is initialized<br>static block of Sub class is initialized in Java<br>non static blocks in super class is initialized<br>non static blocks in sub class is initialized<br>false</p><p>从上面结果可以看出：</p><ol><li>超类初始化早于子类</li><li>静态变量或代码块初始化早于非静态块和域</li><li>没使用的类根本不会被初始化，因为他没有被使用</li></ol><p>再来一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Another Java program example to demonstrate class initialization and loading in Java.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitializationTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">//accessing static field of Parent through child, should only initialize Parent</span></span><br><span class="line">       System.out.println(Child.familyName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">//compile time constant, accessing this will not trigger class initialization</span></span><br><span class="line">    <span class="comment">//protected static final String familyName = "Lawson";</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> String familyName = <span class="string">"Lawson"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"static block of Super class is initialized"</span>); &#125;</span><br><span class="line">    &#123;System.out.println(<span class="string">"non static blocks in super class is initialized"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"><span class="keyword">static</span> block of Super <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">initialized</span></span></span><br><span class="line"><span class="class"><span class="title">Lawson</span></span></span><br></pre></td></tr></table></figure><p>分析：</p><ol><li>这里的初始化发生是因为有静态域被访问，而且不一个编译时常量。如果声明的”familyName”是使用final关键字修饰的编译时常量使用（就是上面的注释代码块部分）超类的初始化就不会发生。</li><li>尽管静态与被子类所引用但是也仅仅是超类被初始化</li></ol><p>还有另外一个例子与接口相关的，JLS清晰地解释子接口的初始化不会触发父接口的初始化。强烈推荐阅读JLS14.4理解类加载和初始化细节。以上所有就是有关类被初始化和加载的全部内容。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>类什么时候被加载/类加载时机：<br>第一：生成该类对象的时候，会加载该类及该类的所有父类；<br>第二：访问该类的静态成员的时候；</p><p>第三：CLASS．FORNAME(“类名”)；</p><p>加载完以后JVM中就有了该类的元数据，知道这个CLASS的成员变量和方法等信息，当要NEW一个类的实例时就会根据这个CLASS对象去内存中开辟空间，存放该类的实例对象</p><p>先初始化父类的静态代码—&gt;初始化子类的静态代码–&gt;初始化父类的非静态代码—&gt;初始化父类构造函数—&gt;初始化子类非静态代码—&gt;初始化子类构造函数</p><p>JVM是比较底层的内容，上面只是简单一些推理，今后还要多加学习。</p><h3 id="拓展：volatile"><a href="#拓展：volatile" class="headerlink" title="拓展：volatile"></a>拓展：volatile</h3><p>在Sun的JDK官方文档是这样形容volatile的：</p><p>The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes. A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable.</p><p>如果一个变量加了volatile关键字，就会告诉编译器和JVM的内存模型：这个变量是对所有线程共享的、可见的，每次jvm都会读取最新写入的值并使其最新值在所有CPU可见。<strong>volatile似乎是有时候可以代替简单的锁，似乎加了volatile关键字就省掉了锁。但又说volatile不能保证原子性（java程序员很熟悉这句话：volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性）</strong>。让人费解。</p><p><strong>不要将volatile用在getAndOperate场合（这种场合不原子，需要再加锁），仅仅set或者get的场景是适合volatile的</strong>。</p><h4 id="volatile没有原子性举例：AtomicInteger自增"><a href="#volatile没有原子性举例：AtomicInteger自增" class="headerlink" title="volatile没有原子性举例：AtomicInteger自增"></a>volatile没有原子性举例：AtomicInteger自增</h4><p>例如你让一个volatile的integer自增（i++），其实要分成3步：1）读取volatile变量值到local； 2）增加变量的值；3）把local的值写回，让其它的线程可见。这3步的jvm指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    0xc(%r10),%r8d ; Load</span><br><span class="line">inc    %r8d           ; Increment</span><br><span class="line">mov    %r8d,0xc(%r10) ; Store</span><br><span class="line">lock addl $0x0,(%rsp) ; StoreLoad Barrier</span><br></pre></td></tr></table></figure><p>注意最后一步是<strong>内存屏障</strong>。</p><h4 id="什么是内存屏障（Memory-Barrier）？"><a href="#什么是内存屏障（Memory-Barrier）？" class="headerlink" title="什么是内存屏障（Memory Barrier）？"></a>什么是内存屏障（Memory Barrier）？</h4><p>内存屏障是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p><p>内存屏障和volatile什么关系？上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p><h4 id="volatile为什么没有原子性"><a href="#volatile为什么没有原子性" class="headerlink" title="volatile为什么没有原子性?"></a>volatile为什么没有原子性?</h4><p>明白了内存屏障（<a href="http://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">memory barrier</a>）这个CPU指令，回到前面的JVM指令：从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但<strong>中间的几步（从Load到Store）</strong>是不安全的，中间如果其他的CPU修改了值将会丢失。下面的测试代码可以实际测试voaltile的自增没有原子性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span> _longVal = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopVolatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (val &lt; <span class="number">10000000L</span>) &#123;</span><br><span class="line">                _longVal++;</span><br><span class="line">                val++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopVolatile2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (val &lt; <span class="number">10000000L</span>) &#123;</span><br><span class="line">                _longVal++;</span><br><span class="line">                val++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">testVolatile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopVolatile());</span><br><span class="line">        t1.start();</span><br><span class="line">         </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopVolatile2());</span><br><span class="line">        t2.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"final val is: "</span> + _longVal);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">Output:-------------</span><br><span class="line">     </span><br><span class="line"><span class="keyword">final</span> val is: <span class="number">11223828</span></span><br><span class="line"><span class="keyword">final</span> val is: <span class="number">17567127</span></span><br><span class="line"><span class="keyword">final</span> val is: <span class="number">12912109</span></span><br></pre></td></tr></table></figure><h4 id="volatile没有原子性举例：singleton单例模式实现"><a href="#volatile没有原子性举例：singleton单例模式实现" class="headerlink" title="volatile没有原子性举例：singleton单例模式实现"></a>volatile没有原子性举例：singleton单例模式实现</h4><p>这是一段线程不安全的singleton（单例模式）实现，尽管使用了volatile：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wrongsingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> wrongsingleton _instance = <span class="keyword">null</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">wrongsingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> wrongsingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> wrongsingleton();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的测试代码可以测试出是线程不安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wrongsingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> wrongsingleton _instance = <span class="keyword">null</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">wrongsingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> wrongsingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> wrongsingleton();</span><br><span class="line">            System.out.println(<span class="string">"--initialized once."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopInit());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopInit2());</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopInit());</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopInit2());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive() || t3.isAlive()|| t4.isAlive()) &#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">输出：有时输出<span class="string">"--initialized once."</span>一次，有时输出好几次</span><br></pre></td></tr></table></figure><p>原因自然和上面的例子是一样的。因为<strong>volatile保证变量对线程的可见性，但不保证原子性</strong>。</p><h4 id="为什么AtomicXXX具有原子性和可见性？"><a href="#为什么AtomicXXX具有原子性和可见性？" class="headerlink" title="为什么AtomicXXX具有原子性和可见性？"></a>为什么AtomicXXX具有原子性和可见性？</h4><p>就拿AtomicLong来说，它既解决了上述的volatile的原子性没有保证的问题，又具有可见性。它是如何做到的？CAS（比较并交换）指令。 其实AtomicLong的源码里也用到了volatile，但只是用来读取或写入，见源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicLong with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">(<span class="keyword">long</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicLong with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其CAS源码核心代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ATOMIC();</span><br><span class="line">  <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">  <span class="keyword">if</span> (old_reg_val == oldval) </span><br><span class="line">     *reg = newval;</span><br><span class="line">  END_ATOMIC();</span><br><span class="line">  <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    0xc(%r11),%eax       ; Load</span><br><span class="line">mov    %eax,%r8d            </span><br><span class="line">inc    %r8d                 ; Increment</span><br><span class="line">lock cmpxchg %r8d,0xc(%r11) ; Compare and exchange</span><br></pre></td></tr></table></figure><p>因为CAS是基于乐观锁的，也就是说当写入的时候，如果寄存器旧值已经不等于现值，说明有其他CPU在修改，那就继续尝试。所以这就保证了操作的原子性。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简单复习一下Java的单例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1ggpuhjmlfbj20dm08djrh.jpg&quot; alt=&quot;undefined&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>WSL采坑</title>
    <link href="http://yoursite.com/2020/07/04/WSL/"/>
    <id>http://yoursite.com/2020/07/04/WSL/</id>
    <published>2020-07-03T17:47:17.449Z</published>
    <updated>2020-07-03T21:56:04.148Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>WSL就不多介绍了，win10内置Ubuntu</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ggeba1ihbhj20xc0hswew.jpg" alt="9e218fe95e284998aa6f4c0f011f1566c-016827de5d741acec36ad4dacf0f92123-1200x640.jpg"></p><a id="more"></a> <h1 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h1><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>本来安装的Ubuntu 20.02版本，结果远程桌面连接有问题，那就直接卸载了重新安装吧。</p><p>可以显示出目前电脑安装的所有版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /l</span><br></pre></td></tr></table></figure><p>这个是命令说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">对 Windows 上的 Linux 子系统进行操作管理</span><br><span class="line"> </span><br><span class="line">用途：</span><br><span class="line">    /l, /list [/all]</span><br><span class="line">        列出已注册的分发版。</span><br><span class="line">        /all - 有选择地列出所有分发版，包括</span><br><span class="line">               当前正在安装或卸载的分发版。</span><br><span class="line"> </span><br><span class="line">    /s, /setdefault &lt;DistributionName&gt;</span><br><span class="line">        将该分发版设为默认。</span><br><span class="line"> </span><br><span class="line">    /t, /terminate &lt;DistributionName&gt;</span><br><span class="line">        终止分发。</span><br><span class="line"> </span><br><span class="line">    /u, /unregister &lt;DistributionName&gt;</span><br><span class="line">        取消分发版注册。</span><br><span class="line"> </span><br><span class="line">    /upgrade &lt;DistributionName&gt;</span><br><span class="line">        将分发版升级至 WslFs 文件系统格式。</span><br></pre></td></tr></table></figure><p>可以选择先注销 然后在开始菜单 右击卸载</p><p>或者直接<code>wslconfig /u  版本名</code></p><h3 id="win10端口异常"><a href="#win10端口异常" class="headerlink" title="win10端口异常"></a>win10端口异常</h3><p>这边我在重启的时候win10出现了异常，我打开SSR报端口冲突，进入一般套路</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|findstr "1080"</span><br></pre></td></tr></table></figure><p>如果找到PID的话我直接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist|findstr "pid"</span><br></pre></td></tr></table></figure><p>或者在<a href="http://www.nirsoft.net/utils/cports.html#DownloadLinks这个网站上下载CurrPorts找到进程，右键，Close" target="_blank" rel="noopener">http://www.nirsoft.net/utils/cports.html#DownloadLinks这个网站上下载CurrPorts找到进程，右键，Close</a> Selected TCP Connections</p><p>诡异的根本没有pid占用这个端口但是却报出了端口冲突这样的错误。</p><p>于是管理员CMD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh winsock reset</span><br></pre></td></tr></table></figure><p>重启电脑即可。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="win10版本号"><a href="#win10版本号" class="headerlink" title="win10版本号"></a>win10版本号</h3><p>官方文档：<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a></p><p><code>win+X</code> 然后 <code>A</code></p><p>输入<code>winver</code></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ggehu7la3bj20s70nuq3u.jpg" alt="微信截图_20200704053206.png"></p><p>版本太低 升级</p><p>额，尬住了，我已经更新到了最新版本，但是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Check your Windows version by selecting the Windows logo key + R, type winver, select OK. (Or enter the ver command in Windows Command Prompt). Please update to the latest Windows version if your build is lower than 19041. Get Windows Update Assistant.</span><br></pre></td></tr></table></figure><p>我的build是18362，正式版并没有推送升级，不想更新使用版本，WSL计划推迟。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;WSL就不多介绍了，win10内置Ubuntu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1ggeba1ihbhj20xc0hswew.jpg&quot; alt=&quot;9e218fe95e284998aa6f4c0f011f1566c-016827de5d741acec36ad4dacf0f92123-1200x640.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WSL" scheme="http://yoursite.com/categories/WSL/"/>
    
    
      <category term="WSL" scheme="http://yoursite.com/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>Apache Maven配置详解</title>
    <link href="http://yoursite.com/2020/06/22/Apache%20Maven%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/06/22/Apache Maven配置详解/</id>
    <published>2020-06-22T07:28:27.101Z</published>
    <updated>2020-06-23T08:28:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gg13jsumtfj209s02mglm.jpg" alt="微信截图_20200622152314.png"></p><a id="more"></a> <h1 id="Apache-Maven-详解"><a href="#Apache-Maven-详解" class="headerlink" title="Apache Maven 详解"></a>Apache Maven 详解</h1><h2 id="全局配置文件settings-xml"><a href="#全局配置文件settings-xml" class="headerlink" title="全局配置文件settings.xml"></a>全局配置文件settings.xml</h2><h3 id="文件位置"><a href="#文件位置" class="headerlink" title="文件位置"></a>文件位置</h3><p>settings.xml文件一般存在于两个位置：<br>全局配置: ${M2_HOME}/conf/settings.xml<br>用户配置: ({user.home}/.m2/settings.xml note：用户配置优先于全局配置。){user.home} 和和所有其他系统属性只能在3.0+版本上使用。请注意windows和Linux使用变量的区别。</p><h3 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h3><p>需要注意的是：<strong>局部配置优先于全局配置</strong>。<br>配置优先级从高到低：pom.xml&gt; user settings &gt; global settings<br>如果这些文件同时存在，在应用配置时，会合并它们的内容，如果有重复的配置，优先级高的配置会覆盖优先级低的。</p><h3 id="settings-xml"><a href="#settings-xml" class="headerlink" title="settings.xml"></a>settings.xml</h3><p>顶级元素介绍</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                          https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interactiveMode</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">usePluginRegistry</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">offline</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="LocalRepository"><a href="#LocalRepository" class="headerlink" title="LocalRepository"></a>LocalRepository</h4><p><strong>作用</strong>：该值表示构建系统本地仓库的路径。<br>其默认值：~/.m2/repository。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>$&#123;user.home&#125;/.m2/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="InteractiveMode"><a href="#InteractiveMode" class="headerlink" title="InteractiveMode"></a>InteractiveMode</h4><p><strong>作用</strong>：表示maven是否需要和用户交互以获得输入。<br>如果maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interactiveMode</span>&gt;</span>true<span class="tag">&lt;/<span class="name">interactiveMode</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="UsePluginRegistry"><a href="#UsePluginRegistry" class="headerlink" title="UsePluginRegistry"></a>UsePluginRegistry</h4><p><strong>作用</strong>：maven是否需要使用plugin-registry.xml文件来管理插件版本。<br>如果需要让maven使用文件~/.m2/plugin-registry.xml来管理插件版本，则设为true。默认为false。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">usePluginRegistry</span>&gt;</span>false<span class="tag">&lt;/<span class="name">usePluginRegistry</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Offline"><a href="#Offline" class="headerlink" title="Offline"></a>Offline</h4><p><strong>作用</strong>：表示maven是否需要在离线模式下运行。<br>如果构建系统需要在离线模式下运行，则为true，默认为false。<br>当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">offline</span>&gt;</span>false<span class="tag">&lt;/<span class="name">offline</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PluginGroups"><a href="#PluginGroups" class="headerlink" title="PluginGroups"></a>PluginGroups</h4><p><strong>作用</strong>：当插件的组织id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。<br>该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。<br>当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。默认情况下该列表包含了<code>org.apache.maven.plugins</code>和<code>org.codehaus.mojo</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--plugin的组织Id（groupId） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Servers"><a href="#Servers" class="headerlink" title="Servers"></a>Servers</h4><p><strong>作用</strong>：一般，仓库的下载和部署是在pom.xml文件中的<code>repositories</code>和<code>distributionManagement</code>元素中定义的。然而，一般类似用户名、密码（<strong>有些仓库访问是需要安全认证的</strong>）等信息不应该在pom.xml文件中配置，这些信息可以配置在<code>settings.xml</code>中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">&lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--服务器元素包含配置服务器时需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>server001<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>my_login<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>my_password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是$&#123;user.home&#125;/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">privateKey</span>&gt;</span>$&#123;usr.home&#125;/.ssh/id_dsa<span class="tag">&lt;/<span class="name">privateKey</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--鉴权时使用的私钥密码。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">passphrase</span>&gt;</span>some_passphrase<span class="tag">&lt;/<span class="name">passphrase</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filePermissions</span>&gt;</span>664<span class="tag">&lt;/<span class="name">filePermissions</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--目录被创建时的权限。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directoryPermissions</span>&gt;</span>775<span class="tag">&lt;/<span class="name">directoryPermissions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Mirrors"><a href="#Mirrors" class="headerlink" title="Mirrors"></a>Mirrors</h4><p><strong>作用</strong>：为仓库列表配置的下载镜像列表。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 给定仓库的下载镜像。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>planetmirror.com<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 镜像名称 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>PlanetMirror Australia<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://downloads.planetmirror.com/pub/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h4><p><strong>作用</strong>：用来配置不同的代理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--代理元素包含配置代理时需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>myproxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">host</span>&gt;</span>proxy.somewhere.com<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>proxyuser<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>somepassword<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>*.google.com|ibiblio.org<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h4><p><strong>作用</strong>：根据环境参数来调整构建配置的列表。<br><code>settings.xml</code>中的<code>profile</code>元素是<code>pom.xml</code>中<code>profile</code>元素的<strong>裁剪版本</strong>。<br>它包含了<code>id</code>、<code>activation</code>、<code>repositories</code>、<code>pluginRepositories</code>和 <code>properties</code>元素。这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个<code>settings.xml</code>中的<code>profile</code>被激活，它的值会覆盖任何其它定义在<code>pom.xml</code>中带有相同id的<code>profile</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- profile的唯一标识 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 自动触发profile的条件逻辑 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 扩展属性列表 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 远程仓库列表 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repositories</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 插件仓库列表 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pluginRepositories</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Activation"><a href="#Activation" class="headerlink" title="Activation"></a>Activation</h4><p><strong>作用</strong>：自动触发<code>profile</code>的条件逻辑。<br>如<code>pom.xml</code>中的<code>profile</code>一样，<code>profile</code>的作用在于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过<code>activation</code>元素指定。<br><code>activation</code>元素并不是激活<code>profile</code>的唯一方式。<code>settings.xml</code>文件中的<code>activeProfile</code>元素可以包含<code>profile</code>的<code>id</code>。<code>profile</code>也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--profile默认是否激活的标识 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;name&#125;引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exists</span>&gt;</span>$&#123;basedir&#125;/file2.properties<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">missing</span>&gt;</span>$&#123;basedir&#125;/file1.properties<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>注：在maven工程的pom.xml所在目录下执行<code>mvn help:active-profiles</code>命令可以查看中央仓储的profile是否在工程中生效。</em></strong></p><h4 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h4><p><strong>作用</strong>：对应<code>profile</code>的扩展属性列表。<br>maven属性和ant中的属性一样，可以用来存放一些值。这些值可以在<code>pom.xml</code>中的任何地方使用标记<code>${X}</code>来使用，这里X是指属性的名称。属性有五种不同的形式，并且都能在settings.xml文件中访问。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  1. env.X: 在一个变量前加上"env."的前缀，会返回一个shell环境变量。例如,"env.PATH"指代了$path环境变量（在Windows上是%PATH%）。 </span></span><br><span class="line"><span class="comment">  2. project.x：指代了POM中对应的元素值。例如: &lt;project&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt;通过$&#123;project.version&#125;获得version的值。 </span></span><br><span class="line"><span class="comment">  3. settings.x: 指代了settings.xml中对应元素的值。例如：&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/settings&gt;通过 $&#123;settings.offline&#125;获得offline的值。 </span></span><br><span class="line"><span class="comment">  4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问，例如 $&#123;java.home&#125;。 </span></span><br><span class="line"><span class="comment">  5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以$&#123;someVar&#125;的形式使用。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user.install</span>&gt;</span>$&#123;user.home&#125;/our-project<span class="tag">&lt;/<span class="name">user.install</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>注：如果该profile被激活，则可以在<code>pom.xml</code>中使用${user.install}。</em></strong></p><h4 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h4><p><strong>作用</strong>：远程仓库列表，它是maven用来填充构建系统本地仓库所使用的一组远程仓库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库唯一标识 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>codehausSnapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Codehaus Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="pluginRepositories"><a href="#pluginRepositories" class="headerlink" title="pluginRepositories"></a>pluginRepositories</h4><p><strong>作用</strong>：发现插件的远程仓库列表。<br>和<code>repository</code>类似，只是<code>repository</code>是管理jar包依赖的仓库，<code>pluginRepositories</code>则是管理插件的仓库。<br>maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。<code>pluginRepositories</code>元素的结构和<code>repositories</code>元素的结构类似。每个<code>pluginRepository</code>元素指定一个Maven可以用来寻找新插件的远程地址。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="ActiveProfiles"><a href="#ActiveProfiles" class="headerlink" title="ActiveProfiles"></a>ActiveProfiles</h4><p><strong>作用</strong>：手动激活profiles的列表，按照<code>profile</code>被应用的顺序定义<code>activeProfile</code>。<br>该元素包含了一组<code>activeProfile</code>元素，每个<code>activeProfile</code>都含有一个profile id。任何在<code>activeProfile</code>中定义的profile id，不论环境设置如何，其对应的 <code>profile</code>都会被激活。如果没有匹配的<code>profile</code>，则什么都不会发生。<br>例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 要激活的profile id --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>env-test<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="POM-XML"><a href="#POM-XML" class="headerlink" title="POM.XML"></a>POM.XML</h2><h3 id="pom是什么"><a href="#pom是什么" class="headerlink" title="pom是什么"></a>pom是什么</h3><p>pom代表项目对象模型，它是Maven中工作的基本组成单位。它是一个XML文件，始终保存在项目的基本目录中的pom.xml文件中。pom包含的对象是使用maven来构建的，pom.xml文件包含了项目的各种配置信息。 创建一个POM之前，应该要先决定项目组(groupId)，项目名(artifactId)和版本（version），因为这些属性在项目仓库是唯一标识的。需要特别注意，每个项目都只有一个pom.xml文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 基本配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>...<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 依赖配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>...<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span>...<span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>...<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 构建配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span>...<span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>...<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>...<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>...<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inceptionYear</span>&gt;</span>...<span class="tag">&lt;/<span class="name">inceptionYear</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span>...<span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span>...<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span>...<span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span>...<span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 环境设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span>...<span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span>...<span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span>...<span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基本配置信息"><a href="#基本配置信息" class="headerlink" title="基本配置信息"></a>基本配置信息</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- pom模型版本，maven2和3只能为4.0.0--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 项目的组ID，用于maven定位--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.company.bank<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 项目ID，通常是项目的名称,唯一标识符--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 项目的版本--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 项目的打包方式--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>节点</strong></th><th>解释说明</th></tr></thead><tbody><tr><td>modelVersion</td><td>pom模型版本，maven2和3只能为4.0.0</td></tr><tr><td>groupId</td><td>这是项目组的编号，这在组织或项目中通常是独一无二的。 例如，一家银行集团com.company.bank拥有所有银行相关项目。</td></tr><tr><td>artifactId</td><td>这是项目的ID。这通常是项目的名称。 例如，consumer-banking。 除了groupId之外，artifactId还定义了artifact在存储库中的位置。</td></tr><tr><td>version</td><td>这是项目的版本。与groupId一起使用，artifact在存储库中用于将版本彼此分离。 例如：com.company.bank:consumer-banking:1.0，com.company.bank:consumer-banking:1.1</td></tr><tr><td>packaging</td><td>项目打包方式，有以下值：pom, jar, maven-plugin, ejb, war, ear, rar, par</td></tr></tbody></table><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><h4 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h4><p>项目相关依赖配置，如果在父项目写的依赖，会被子项目引用。一般会在父项目中定义子项目中所有共用的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h4><p>用于确定父项目的坐标位置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.learnPro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SIP-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span><span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>groupId: 父项目的组Id标识符</p><p>artifactId:父项目的唯一标识符</p><p>relativePath：Maven首先在当前项目中找父项目的pom，然后在文件系统的这个位置（relativePath），然后在本地仓库，再在远程仓库找。</p><p>version: 父项目的版本</p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p>有些maven项目会做成多模块的，这个标签用于指定当前项目所包含的所有模块。之后对这个项目进行的maven操作，会让所有子模块也进行相同操作。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">module</span>&gt;</span>com-a<span class="tag">&lt;/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">module</span>&gt;</span>com-b<span class="tag">&lt;/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">module</span>&gt;</span>com-c<span class="tag">&lt;/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="properties-1"><a href="#properties-1" class="headerlink" title="properties"></a>properties</h4><p>用于定义pom常量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个常量可以在pom文件的任意地方通过${<a href="https://link.jianshu.com/?t=http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>.version}来引用</p><h4 id="dependencyManagement"><a href="#dependencyManagement" class="headerlink" title="dependencyManagement"></a>dependencyManagement</h4><p>配置写法同dependencies</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在父模块中定义后，子模块不会直接使用对应依赖，但是在使用相同依赖的时候可以不加版本号,这样的好处是，父项目统一了版本，而且子项目可以在需要的时候才引用对应的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父项目：</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">子项目：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>/&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">testSourceDirectory</span>/&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--被编译过的应用程序class文件存放的目录。--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">outputDirectory</span>/&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--被编译过的测试class文件存放的目录。--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">testOutputDirectory</span>/&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--使用来自该项目的一系列构建扩展--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>    </span><br><span class="line">   <span class="comment">&lt;!--描述使用到的构建扩展。--&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">extension</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--构建扩展的groupId--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--构建扩展的artifactId--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--构建扩展的版本--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>/&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;/<span class="name">extension</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultGoal</span>/&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span>    </span><br><span class="line">   <span class="comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">targetPath</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">filtering</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--包含的模式列表，例如**/*.xml.--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--排除的模式列表，例如**/*.xml--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">excludes</span>/&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">testResources</span>&gt;</span>    </span><br><span class="line">   <span class="comment">&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">testResource</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">targetPath</span>/&gt;</span><span class="tag">&lt;<span class="name">filtering</span>/&gt;</span><span class="tag">&lt;<span class="name">directory</span>/&gt;</span><span class="tag">&lt;<span class="name">includes</span>/&gt;</span><span class="tag">&lt;<span class="name">excludes</span>/&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--构建产生的所有文件存放的目录--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">directory</span>/&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>/&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">filters</span>/&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span>    </span><br><span class="line">   <span class="comment">&lt;!--使用的插件列表 。--&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">     <span class="comment">&lt;!--插件在仓库里的group ID--&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>/&gt;</span>    </span><br><span class="line">     <span class="comment">&lt;!--插件在仓库里的artifact ID--&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>/&gt;</span>    </span><br><span class="line">     <span class="comment">&lt;!--被使用的插件的版本（或版本范围）--&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>/&gt;</span>    </span><br><span class="line">     <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">extensions</span>/&gt;</span>    </span><br><span class="line">     <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">executions</span>&gt;</span>    </span><br><span class="line">      <span class="comment">&lt;!--execution元素包含了插件执行需要的信息--&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span>    </span><br><span class="line">       <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt;</span>    </span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>/&gt;</span>    </span><br><span class="line">       <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt;</span>    </span><br><span class="line">       <span class="tag">&lt;<span class="name">phase</span>/&gt;</span>    </span><br><span class="line">       <span class="comment">&lt;!--配置的执行目标--&gt;</span>    </span><br><span class="line">       <span class="tag">&lt;<span class="name">goals</span>/&gt;</span>    </span><br><span class="line">       <span class="comment">&lt;!--配置是否被传播到子POM--&gt;</span>    </span><br><span class="line">       <span class="tag">&lt;<span class="name">inherited</span>/&gt;</span>    </span><br><span class="line">       <span class="comment">&lt;!--作为DOM对象的配置--&gt;</span>    </span><br><span class="line">       <span class="tag">&lt;<span class="name">configuration</span>/&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>    </span><br><span class="line">     <span class="comment">&lt;!--项目引入插件所需要的额外依赖--&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    </span><br><span class="line">      <span class="comment">&lt;!--参见dependencies/dependency元素--&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">       ......    </span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>         </span><br><span class="line">     <span class="comment">&lt;!--任何配置是否被传播到子项目--&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">inherited</span>/&gt;</span>    </span><br><span class="line">     <span class="comment">&lt;!--作为DOM对象的配置--&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">configuration</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--使用的插件列表--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">   <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>/&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>/&gt;</span><span class="tag">&lt;<span class="name">version</span>/&gt;</span><span class="tag">&lt;<span class="name">extensions</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">execution</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>/&gt;</span><span class="tag">&lt;<span class="name">phase</span>/&gt;</span><span class="tag">&lt;<span class="name">goals</span>/&gt;</span><span class="tag">&lt;<span class="name">inherited</span>/&gt;</span><span class="tag">&lt;<span class="name">configuration</span>/&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    </span><br><span class="line">     <span class="comment">&lt;!--参见dependencies/dependency元素--&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">      ......    </span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">goals</span>/&gt;</span><span class="tag">&lt;<span class="name">inherited</span>/&gt;</span><span class="tag">&lt;<span class="name">configuration</span>/&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    </span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="reporting"><a href="#reporting" class="headerlink" title="reporting"></a>reporting</h4><p>该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">reporting</span>&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">excludeDefaults</span>/&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">outputDirectory</span>/&gt;</span>    </span><br><span class="line">  <span class="comment">&lt;!--使用的报表插件和他们的配置。--&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">   <span class="comment">&lt;!--plugin元素包含描述报表插件需要的信息--&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--报表插件在仓库里的group ID--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--报表插件在仓库里的artifact ID--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--被使用的报表插件的版本（或版本范围）--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--任何配置是否被传播到子项目--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">inherited</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--报表插件的配置--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span>    </span><br><span class="line">     <span class="comment">&lt;!--表示报表的一个集合，以及产生该集合的配置--&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span>    </span><br><span class="line">      <span class="comment">&lt;!--报表集合的唯一标识符，POM继承时用到--&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>/&gt;</span>    </span><br><span class="line">      <span class="comment">&lt;!--产生报表集合时，被使用的报表的配置--&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>/&gt;</span>    </span><br><span class="line">      <span class="comment">&lt;!--配置是否被继承到子POMs--&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">inherited</span>/&gt;</span>    </span><br><span class="line">      <span class="comment">&lt;!--这个集合里使用到哪些报表--&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">reports</span>/&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    </span><br><span class="line"> <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="项目信息"><a href="#项目信息" class="headerlink" title="项目信息"></a>项目信息</h4><p>name：给用户提供更为友好的项目名</p><p>description：项目描述，maven文档中保存</p><p>url：主页的URL，maven文档中保存</p><p>inceptionYear：项目创建年份，4位数字。当产生版权信息时需要使用这个值</p><p>licenses：该元素描述了项目所有License列表。 应该只列出该项目的-</p><p>license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。（如下）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--license用于法律上的名称--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>...<span class="tag">&lt;/<span class="name">name</span>&gt;</span>     </span><br><span class="line">    <span class="comment">&lt;!--官方的license正文页面的URL--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>....<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目分发的主要方式：repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span>     </span><br><span class="line">    <span class="comment">&lt;!--关于license的补充信息--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">comments</span>&gt;</span>....<span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>organization：1.name 组织名 2.url 组织主页url</li><li>developers：项目开发人员列表（如下）</li><li>contributors：项目其他贡献者列表，同developers</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">developers</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--某个开发者信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developer</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--开发者的唯一标识符--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>....<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--开发者的全名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>...<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--开发者的email--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>...<span class="tag">&lt;/<span class="name">email</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--开发者的主页--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>...<span class="tag">&lt;<span class="name">url</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开发者在项目中的角色--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">roles</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">role</span>&gt;</span>Java Dev<span class="tag">&lt;/<span class="name">role</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">role</span>&gt;</span>Web UI<span class="tag">&lt;/<span class="name">role</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">roles</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--开发者所属组织--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">organization</span>&gt;</span>sun<span class="tag">&lt;/<span class="name">organization</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--开发者所属组织的URL--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>...<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--开发者属性，如即时消息如何处理等--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 和主标签中的properties一样，可以随意定义子标签 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--开发者所在时区， -11到12范围内的整数。--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>-5<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>issueManagement<br>目的问题管理系统(Bugzilla, Jira, Scarab)的名称和URL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system</span>&gt;</span>Bugzilla<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1/bugzilla/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="ciManagement"><a href="#ciManagement" class="headerlink" title="ciManagement"></a>ciManagement</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">system</span>&gt;</span>continuum<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8080/continuum<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">notifier</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">type</span>&gt;</span>mail<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">sendOnError</span>&gt;</span>true<span class="tag">&lt;/<span class="name">sendOnError</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">sendOnFailure</span>&gt;</span>true<span class="tag">&lt;/<span class="name">sendOnFailure</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">sendOnSuccess</span>&gt;</span>false<span class="tag">&lt;/<span class="name">sendOnSuccess</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">sendOnWarning</span>&gt;</span>false<span class="tag">&lt;/<span class="name">sendOnWarning</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">address</span>&gt;</span>continuum@127.0.0.1<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>system：持续集成系统的名字</li><li>url：持续集成系统的URL</li><li>notifiers：构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）<br> type：通知方式<br> sendOnError：错误时是否通知<br> sendOnFailure：失败时是否通知<br> sendOnSuccess：成功时是否通知<br> sendOnWarning：警告时是否通知<br> address：通知发送到的地址<br> configuration：扩展项</li></ul><h4 id="mailingLists"><a href="#mailingLists" class="headerlink" title="mailingLists"></a>mailingLists</h4><p> 项目相关邮件列表信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>User List<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span>user-subscribe@127.0.0.1<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span>user-unsubscribe@127.0.0.1<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">post</span>&gt;</span>user@127.0.0.1<span class="tag">&lt;/<span class="name">post</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">archive</span>&gt;</span>http://127.0.0.1/user/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">otherArchives</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherArchive</span>&gt;</span>http://base.google.com/base/1/127.0.0.1<span class="tag">&lt;/<span class="name">otherArchive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">otherArchives</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span></span><br><span class="line">    .....</span><br><span class="line">  <span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>subscribe, unsubscribe: 订阅邮件（取消订阅）的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建</li><li>archive：浏览邮件信息的URL</li><li>post：接收邮件的地址</li></ul><h4 id="scm"><a href="#scm" class="headerlink" title="scm"></a>scm</h4><p> 许你配置你的代码库，供Maven web站点和其它插件使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">connection</span>&gt;</span>scm:svn:http://127.0.0.1/svn/my-project<span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>scm:svn:https://127.0.0.1/svn/my-project<span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag</span>&gt;</span>HEAD<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1/websvn/my-project<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br></pre></td></tr></table></figure><p>connection, developerConnection：这两个表示我们如何连接到maven的版本库。connection只提供读，developerConnection将提供写的请求<br> 写法如：scm:[provider]:[provider_specific]<br> 如果连接到CVS仓库，可以配置如下：-</p><p>scm:cvs:pserver:127.0.0.1:/cvs/root:my-project</p><p>tag：项目标签，默认HEAD</p><p>url：共有仓库路径</p><h4 id="prerequisites"><a href="#prerequisites" class="headerlink" title="prerequisites"></a>prerequisites</h4><p>项目构建的前提</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">maven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="repositories-pluginRepositories"><a href="#repositories-pluginRepositories" class="headerlink" title="repositories,pluginRepositories"></a>repositories,pluginRepositories</h4><p>依赖和扩展的远程仓库列表，同上篇文章，setting.xml配置中介绍的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>fail<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>codehausSnapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Codehaus Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p>releases, snapshots:这是各种构件的策略，release或者snapshot。这两个集合，POM就可以根据独立仓库任意类型的依赖改变策略。如：一个人可能只激活下载snapshot用来开发。</p><p>enable：true或者false，决定仓库是否对于各自的类型激活(release 或者 snapshot)。</p><p>updatePolicy: 这个元素决定更新频率。maven将比较本地pom的时间戳（存储在仓库的maven数据文件中）和远程的. 有以下选择: always, daily (默认), interval:X (x是代表分钟的整型) ， never.</p><p>checksumPolicy：当Maven向仓库部署文件的时候，它也部署了相应的校验和文件。可选的为：ignore，fail，warn，或者不正确的校验和。</p><p>layout：在上面描述仓库的时候，提到他们有统一的布局。Maven 2有它仓库默认布局。然而，Maven 1.x有不同布局。使用这个元素来表明它是default还是legacy。</p><hr><p>第一次更新于2020年6月22日</p><p>第二次更新于2020年6月23日</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gg13jsumtfj209s02mglm.jpg&quot; alt=&quot;微信截图_20200622152314.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Apache Maven" scheme="http://yoursite.com/categories/Apache-Maven/"/>
    
    
      <category term="Apache Maven" scheme="http://yoursite.com/tags/Apache-Maven/"/>
    
  </entry>
  
  <entry>
    <title>Apache Maven 编译打包 Flink1.10</title>
    <link href="http://yoursite.com/2020/05/30/%E4%BD%BF%E7%94%A8Maven%E7%BC%96%E8%AF%91Flink/"/>
    <id>http://yoursite.com/2020/05/30/使用Maven编译Flink/</id>
    <published>2020-05-30T10:15:38.636Z</published>
    <updated>2020-06-11T07:17:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Apache Maven 编译打包Flink</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf9x6qsh2lj20tk0fnta2.jpg" alt="微信截图_20200530031106.png"></p><p>给爷狠狠得Success</p><hr><p>第二次更新于 2019/6/11</p><a id="more"></a> <h1 id="Apache-Maven-编译打包Flink"><a href="#Apache-Maven-编译打包Flink" class="headerlink" title="Apache Maven 编译打包Flink"></a>Apache Maven 编译打包Flink</h1><p>因为需要修改一些Flink的模块，所以需要自己编译打包Flink，花了好长时间摸索，成功打包1.8.1和1.10.1之后，记录下自己踩的坑。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在打包Flink之前就有一些准备工作需要做。</p><h3 id="环境和预处理"><a href="#环境和预处理" class="headerlink" title="环境和预处理"></a>环境和预处理</h3><table><thead><tr><th>类型</th><th>版本</th></tr></thead><tbody><tr><td>系统版本</td><td>win10</td></tr><tr><td>maven</td><td>3.6.3</td></tr><tr><td>JDK</td><td>8u231</td></tr><tr><td>scala</td><td>2.11.8</td></tr><tr><td>hadoop</td><td>2.7.6</td></tr><tr><td>node</td><td>v12.14.0</td></tr><tr><td>Flink版本</td><td>1.8.1&amp;1.10.1</td></tr></tbody></table><p>路径注意全英文</p><h4 id="一些区别"><a href="#一些区别" class="headerlink" title="一些区别"></a>一些区别</h4><p>Flink1.8.1编译的时候，编译遇到几次错误是因为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>test-jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Flink1.10.1并没有遇到，主要出现在两个模块，<code>flink-s3-fs-hadoop</code> 和 <code>flink-oss-fs-hadoop</code> </p><p>Flink1.8.1还在<code>flink-connectors/flink-hadoop-compatibility/pom.xml</code>模块里面添加了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-cli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-cli<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以及在<code>flink-connectors/pom.xml</code>里面添加了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-net<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-net<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些问题在github下载下来的release版本1.10.1里面并没有出现，不知道是改进了还是什么原因。</p><h4 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h4><p>为了在编译的过程中，排错彻底排除网络原因，我采用了几个办法：</p><p><strong>连接手机热点</strong>：非常有用的措施，电信宽带被DNS污染非常严重，移动对于外网应该是最宽容的</p><p><strong>SSR</strong>：快速 稳定的线路一条</p><p><strong>配置Maven的代理到SSR的端口上</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Licensed to the Apache Software Foundation (ASF) under one</span></span><br><span class="line"><span class="comment">or more contributor license agreements.  See the NOTICE file</span></span><br><span class="line"><span class="comment">distributed with this work for additional information</span></span><br><span class="line"><span class="comment">regarding copyright ownership.  The ASF licenses this file</span></span><br><span class="line"><span class="comment">to you under the Apache License, Version 2.0 (the</span></span><br><span class="line"><span class="comment">"License"); you may not use this file except in compliance</span></span><br><span class="line"><span class="comment">with the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Unless required by applicable law or agreed to in writing,</span></span><br><span class="line"><span class="comment">software distributed under the License is distributed on an</span></span><br><span class="line"><span class="comment">"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></span><br><span class="line"><span class="comment">KIND, either express or implied.  See the License for the</span></span><br><span class="line"><span class="comment">specific language governing permissions and limitations</span></span><br><span class="line"><span class="comment">under the License.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> | This is the configuration file for Maven. It can be specified at two levels:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |  1. User Level. This settings.xml file provides configuration for a single user,</span></span><br><span class="line"><span class="comment"> |                 and is normally provided in $&#123;user.home&#125;/.m2/settings.xml.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 <span class="doctag">NOTE:</span> This location can be overridden with the CLI option:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 -s /path/to/user/settings.xml</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |  2. Global Level. This settings.xml file provides configuration for all Maven</span></span><br><span class="line"><span class="comment"> |                 users on a machine (assuming they're all using the same Maven</span></span><br><span class="line"><span class="comment"> |                 installation). It's normally provided in</span></span><br><span class="line"><span class="comment"> |                 $&#123;maven.conf&#125;/settings.xml.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 <span class="doctag">NOTE:</span> This location can be overridden with the CLI option:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 -gs /path/to/global/settings.xml</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> | The sections in this sample file are intended to give you a running start at</span></span><br><span class="line"><span class="comment"> | getting the most out of your Maven installation. Where appropriate, the default</span></span><br><span class="line"><span class="comment"> | values (values used when the setting is not specified) are provided.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- interactiveMode</span></span><br><span class="line"><span class="comment">   | This will determine whether maven prompts you when it needs input. If set to false,</span></span><br><span class="line"><span class="comment">   | maven will use a sensible default value, perhaps based on some other setting, for</span></span><br><span class="line"><span class="comment">   | the parameter in question.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: true</span></span><br><span class="line"><span class="comment">  &lt;interactiveMode&gt;true&lt;/interactiveMode&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- offline</span></span><br><span class="line"><span class="comment">   | Determines whether maven should attempt to connect to the network when executing a build.</span></span><br><span class="line"><span class="comment">   | This will have an effect on artifact downloads, artifact deployment, and others.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: false</span></span><br><span class="line"><span class="comment">  &lt;offline&gt;false&lt;/offline&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- pluginGroups</span></span><br><span class="line"><span class="comment">   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.</span></span><br><span class="line"><span class="comment">   | when invoking a command line like "mvn prefix:goal". Maven will automatically add the group identifiers</span></span><br><span class="line"><span class="comment">   | "org.apache.maven.plugins" and "org.codehaus.mojo" if these are not already contained in the list.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- pluginGroup</span></span><br><span class="line"><span class="comment">     | Specifies a further group identifier to use for plugin lookup.</span></span><br><span class="line"><span class="comment">    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- proxies</span></span><br><span class="line"><span class="comment">   | This is a list of proxies which can be used on this machine to connect to the network.</span></span><br><span class="line"><span class="comment">   | Unless otherwise specified (by system property or command-line switch), the first proxy</span></span><br><span class="line"><span class="comment">   | specification in this list marked as active will be used.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    proxy</span></span><br><span class="line"><span class="comment">     | Specification for one proxy, to be used in connecting to the network.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     &lt;proxy&gt;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">      &lt;id&gt;httpproxy&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;active&gt;true&lt;/active&gt;</span></span><br><span class="line"><span class="comment">      &lt;protocol&gt;http&lt;/protocol&gt;</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">        &lt;username&gt;proxyuser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">        &lt;password&gt;proxypass&lt;/password&gt;</span></span><br><span class="line"><span class="comment">        &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      &lt;host&gt;socks5://127.0.0.1&lt;/host&gt;</span></span><br><span class="line"><span class="comment">      &lt;port&gt;1080&lt;/port&gt;</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">    &lt;/proxy&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &lt;proxy&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;httpsproxy&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;active&gt;true&lt;/active&gt;</span></span><br><span class="line"><span class="comment">      &lt;protocol&gt;https&lt;/protocol&gt;</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">        &lt;username&gt;proxyuser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">        &lt;password&gt;proxypass&lt;/password&gt;</span></span><br><span class="line"><span class="comment">        &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      &lt;host&gt;socks5://127.0.0.1&lt;/host&gt;</span></span><br><span class="line"><span class="comment">      &lt;port&gt;1080&lt;/port&gt;</span></span><br><span class="line"><span class="comment">    &lt;/proxy&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>ss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>socks5<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">host</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span>&gt;</span>1080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- servers</span></span><br><span class="line"><span class="comment">   | This is a list of authentication profiles, keyed by the server-id used within the system.</span></span><br><span class="line"><span class="comment">   | Authentication profiles can be used whenever maven must make a connection to a remote server.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- server</span></span><br><span class="line"><span class="comment">     | Specifies the authentication information to use when connecting to a particular server, identified by</span></span><br><span class="line"><span class="comment">     | a unique name within the system (referred to by the 'id' attribute below).</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | <span class="doctag">NOTE:</span> You should either specify username/password OR privateKey/passphrase, since these pairings are</span></span><br><span class="line"><span class="comment">     |       used together.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;deploymentRepo&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;username&gt;repouser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">      &lt;password&gt;repopwd&lt;/password&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Another sample, using keys to authenticate.</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;siteServer&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;</span></span><br><span class="line"><span class="comment">      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- mirrors</span></span><br><span class="line"><span class="comment">   | This is a list of mirrors to be used in downloading artifacts from remote repositories.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | It works like this: a POM may declare a repository to use in resolving certain artifacts.</span></span><br><span class="line"><span class="comment">   | However, this repository may have problems with heavy traffic at times, so people have mirrored</span></span><br><span class="line"><span class="comment">   | it to several places.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | That repository definition will have a unique id, so we can create a mirror reference for that</span></span><br><span class="line"><span class="comment">   | repository, to be used as an alternate download site. The mirror site will be the preferred</span></span><br><span class="line"><span class="comment">   | server for that repository.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;mirrorId&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span></span><br><span class="line"><span class="comment">    &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">     <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>ibiblio<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://mirrors.ibiblio.org/pub/mirrors/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss-public-repository-group<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Public Repository Group<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.org/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Repository Switchboard<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- profiles</span></span><br><span class="line"><span class="comment">   | This is a list of profiles which can be activated in a variety of ways, and which can modify</span></span><br><span class="line"><span class="comment">   | the build process. Profiles provided in the settings.xml are intended to provide local machine-</span></span><br><span class="line"><span class="comment">   | specific paths and repository locations which allow the build to work in the local environment.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | For example, if you have an integration testing plugin - like cactus - that needs to know where</span></span><br><span class="line"><span class="comment">   | your Tomcat instance is installed, you can provide a variable here such that the variable is</span></span><br><span class="line"><span class="comment">   | dereferenced during the build process to configure the cactus plugin.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles</span></span><br><span class="line"><span class="comment">   | section of this document (settings.xml) - will be discussed later. Another way essentially</span></span><br><span class="line"><span class="comment">   | relies on the detection of a system property, either matching a particular value for the property,</span></span><br><span class="line"><span class="comment">   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a</span></span><br><span class="line"><span class="comment">   | value of '1.4' might activate a profile when the build is executed on a JDK version of '1.4.2_07'.</span></span><br><span class="line"><span class="comment">   | Finally, the list of active profiles can be specified directly from the command line.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | <span class="doctag">NOTE:</span> For profiles defined in the settings.xml, you are restricted to specifying only artifact</span></span><br><span class="line"><span class="comment">   |       repositories, plugin repositories, and free-form properties to be used as configuration</span></span><br><span class="line"><span class="comment">   |       variables for plugins in the POM.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- profile</span></span><br><span class="line"><span class="comment">     | Specifies a set of introductions to the build process, to be activated using one or more of the</span></span><br><span class="line"><span class="comment">     | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt;</span></span><br><span class="line"><span class="comment">     | or the command line, profiles have to have an ID that is unique.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | An encouraged best practice for profile identification is to use a consistent naming convention</span></span><br><span class="line"><span class="comment">     | for profiles, such as 'env-dev', 'env-test', 'env-production', 'user-jdcasey', 'user-brett', etc.</span></span><br><span class="line"><span class="comment">     | This will make it more intuitive to understand what the set of introduced profiles is attempting</span></span><br><span class="line"><span class="comment">     | to accomplish, particularly when you only have a list of profile id's for debug.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.</span></span><br><span class="line"><span class="comment">    &lt;profile&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;jdk-1.4&lt;/id&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;activation&gt;</span></span><br><span class="line"><span class="comment">        &lt;jdk&gt;1.4&lt;/jdk&gt;</span></span><br><span class="line"><span class="comment">      &lt;/activation&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;repositories&gt;</span></span><br><span class="line"><span class="comment">        &lt;repository&gt;</span></span><br><span class="line"><span class="comment">          &lt;id&gt;jdk14&lt;/id&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt;</span></span><br><span class="line"><span class="comment">          &lt;layout&gt;default&lt;/layout&gt;</span></span><br><span class="line"><span class="comment">          &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt;</span></span><br><span class="line"><span class="comment">        &lt;/repository&gt;</span></span><br><span class="line"><span class="comment">      &lt;/repositories&gt;</span></span><br><span class="line"><span class="comment">    &lt;/profile&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     | Here is another profile, activated by the system property 'target-env' with a value of 'dev',</span></span><br><span class="line"><span class="comment">     | which provides a specific path to the Tomcat instance. To use this, your plugin configuration</span></span><br><span class="line"><span class="comment">     | might hypothetically look like:</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | ...</span></span><br><span class="line"><span class="comment">     | &lt;plugin&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;artifactId&gt;myplugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     |   &lt;configuration&gt;</span></span><br><span class="line"><span class="comment">     |     &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;/configuration&gt;</span></span><br><span class="line"><span class="comment">     | &lt;/plugin&gt;</span></span><br><span class="line"><span class="comment">     | ...</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | <span class="doctag">NOTE:</span> If you just wanted to inject this configuration whenever someone set 'target-env' to</span></span><br><span class="line"><span class="comment">     |       anything, you could just leave off the &lt;value/&gt; inside the activation-property.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;profile&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;env-dev&lt;/id&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;activation&gt;</span></span><br><span class="line"><span class="comment">        &lt;property&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;target-env&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;value&gt;dev&lt;/value&gt;</span></span><br><span class="line"><span class="comment">        &lt;/property&gt;</span></span><br><span class="line"><span class="comment">      &lt;/activation&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;properties&gt;</span></span><br><span class="line"><span class="comment">        &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt;</span></span><br><span class="line"><span class="comment">      &lt;/properties&gt;</span></span><br><span class="line"><span class="comment">    &lt;/profile&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- activeProfiles</span></span><br><span class="line"><span class="comment">   | List of profiles that are active for all builds.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">  &lt;activeProfiles&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">  &lt;/activeProfiles&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>稍微测试一下，连上了代理然后连接阿里云，如果有插件下载不下来再把阿里云的镜像地址注释掉。如此确保网络没有问题。</p><h4 id="框架的可视化部分"><a href="#框架的可视化部分" class="headerlink" title="框架的可视化部分"></a>框架的可视化部分</h4><p>对于可视化部分，需要用到node js，在我实际编译的过程中，如果不提前做好node.js的准备工作，很容易就会卡死在那，原因未知。</p><p>在Flink的安装过程中，会执行一次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ci --cache-max=0 --no-save</span><br></pre></td></tr></table></figure><p>应该提前在<code>flink-release-1.10.1\flink-runtime-web\web-dashboard</code>文件目录中执行一次，如果能够轻松执行成功的话说明ok</p><p>我遇到的问题：</p><p>首先我这条命令是执行不了的，执行到某一行命令，自动去github上面抓取某个<code>.node</code>文件，结果一直下载不下来，因为上面已经排除了网络原因，我自己打开那个链接找了一下发现那个网页已经换过了位置，自己手动下载下载之后，我使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node XX.node</span><br></pre></td></tr></table></figure><p>命令手动装载，这条命令有没有执行效果我并不确定，因为后面我的npm大量报错，我进行了非常多的操作，不确定有没有重置这个操作。</p><p>出现的错误：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf9xv0euitj20sv13kn1u.jpg" alt="微信图片_20200530033900.png"></p><p>这个错误在我更新了个如下代码后得到缓解，之所以说缓解，稍后会解释。</p><p><a href="https://www.npmjs.com/package/@angular-devkit/build-angular" target="_blank" rel="noopener">首先查询到这个插件的最新版本</a>，然后在<code>flink-release-1.10.1\flink-runtime-web\web-dashboard</code>目录下执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall @angular-devkit/build-angular</span><br><span class="line">npm install @angular-devkit/build-angular@0.901.7</span><br></pre></td></tr></table></figure><p>同时可能用到的npm清缓存重新安装命令在这里附上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules</span><br><span class="line">rm package-lock.json</span><br><span class="line">npm cache clear --force</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><h3 id="flink-fd-hadoop-shaded"><a href="#flink-fd-hadoop-shaded" class="headerlink" title="flink-fd-hadoop-shaded"></a>flink-fd-hadoop-shaded</h3><p>首先遇到的 <em>flink-shaded-hadoop-2</em> 模块在中央仓库找不到，后来发现官网已经进行了说明</p><p>进行编译之前根据需求在官方文档上面找到自己需要的内容：<a href="https://ci.apache.org/projects/flink/flink-docs-stable/flinkDev/building.html" target="_blank" rel="noopener">Building Flink From Source</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If the used Hadoop version is not listed on the download page (possibly due to being a Vendor-specific version), then it is necessary to build flink-shaded against this version. You can find the source code for this project in the Additional Components section of the download page.</span><br></pre></td></tr></table></figure><p>这里有两种解决方式：</p><ol><li>自己去maven仓库下载一个版本相近的jar包回来，然后用安装命令安装到本地仓库，修改一下版本号即可，大多数情况下都能使用。这种方法很通用。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -DgroupId=org.apache.flink -DartifactId=flink-shaded-hadoop-2 -Dversion=2.7.6-9.0 -Dpackaging=jar  -Dfile=./flink-shaded-hadoop-2-2.7.5-7.0.jar</span><br></pre></td></tr></table></figure><ol start="2"><li>下载 <code>flink-shaded</code>包先进行编译打包，需要注意的是，会存在CDH版本等等不同的hadoop版本。</li></ol><p>因为涉及到不同的CDH版本的包，所以这里添加下面仓库，防止找不到需要的包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>vendor-repos<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>vendor-repos<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Add vendor maven repositories --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Cloudera --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hortonworks --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>HDPReleases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>HDP Releases<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.hortonworks.com/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>HortonworksJettyHadoop<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>HDP Jetty<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.hortonworks.com/content/repositories/jetty-hadoop<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MapR --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>mapr-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.mapr.com/maven/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>CDH示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn  clean install -DskipTests -Drat.skip=true -Pvendor-repos  -Dhadoop.version=2.6.0-cdh5.16.1</span><br></pre></td></tr></table></figure><p>新版本的Flink 这个模块都需要自己编译和hadoop适配的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/flink-shaded.git</span><br></pre></td></tr></table></figure><p>或者在release里面下载某个特定版本，这个特定版本是什么版本呢，在报错里面的后缀可以找到版本，这个版本号和Flinkd版本并不相同，需要注意。</p><p>我是使用git下载的，所以首先要配置好git的代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos; </span><br><span class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br></pre></td></tr></table></figure><p>下载完成后，进入文件夹</p><p>查看远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/release-1.0</span><br><span class="line">  remotes/origin/release-10.0</span><br><span class="line">  remotes/origin/release-11.0</span><br><span class="line">  remotes/origin/release-3.0</span><br><span class="line">  remotes/origin/release-4.0</span><br><span class="line">  remotes/origin/release-5.0</span><br><span class="line">  remotes/origin/release-6.0</span><br><span class="line">  remotes/origin/release-7.0</span><br><span class="line">  remotes/origin/release-8.0</span><br><span class="line">  remotes/origin/release-9.0</span><br></pre></td></tr></table></figure><p>查看本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>查看分支详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -va</span><br></pre></td></tr></table></figure><p>拉下缺少对应版本的shade，并且建立名为<code>v0.9</code>的分支，并且以这个分支为基础编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b v9.0 origin/release-9.0</span><br></pre></td></tr></table></figure><p>然后选择合适的hadooop版本，用上面的命令编译即可。</p><p>后面出了个<code>flink-shaded-hadoop-2-uber</code>出了个差不多的问题，但是因为没有找到这个项目，所以直接下载了一个，然后用上面提到的命令安装到了maven仓库里面。</p><p><strong>Node权限(参考 版本并非最新)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget https://npm.taobao.org/mirrors/node/v10.14.1/node-v10.14.1-linux-x64.tar.gz</span><br><span class="line">tar zxvf node-v10.14.1-linux-x64.tar.gz</span><br><span class="line">mv node-v10.14.1-linux-x64 node</span><br><span class="line">ln -s ~/node/bin/node /usr/local/bin/node   </span><br><span class="line">ln -s ~/node/bin/npm /usr/local/bin/npm</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">alias cnpm="npm --registry=https://registry.npm.taobao.org \</span><br><span class="line">--cache=$HOME/.npm/.cache/cnpm \</span><br><span class="line">--disturl=https://npm.taobao.org/dist \</span><br><span class="line">--userconfig=$HOME/.cnpmrc"</span><br><span class="line"><span class="meta">#</span> 处理 npm 权限</span><br><span class="line">npm config -g set unsafe-perm</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 输入 </span><br><span class="line">npm </span><br><span class="line"><span class="meta">#</span> 显示如下 则环境正常</span><br><span class="line">Usage: npm &lt;command&gt;</span><br><span class="line">where &lt;command&gt; is one of:</span><br></pre></td></tr></table></figure><h3 id="Maven命令"><a href="#Maven命令" class="headerlink" title="Maven命令"></a>Maven命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dfast -DskipTests -Pvendor-repos -Drat.skip=true -Pinclude-hadoop -Dhadoop.version=2.7.6 -Dmaven.compile.fork=true -Dscala-2.11 -T 2C</span><br></pre></td></tr></table></figure><p>windows powershell下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -DskipTests -Dfast -Pvendor-repos '-Drat.skip=true' -Pinclude-hadoop '-Dhadoop.version=2.7.6' '-Dmaven.compile.fork=true' '-Dscala-2.11 -T 8C'</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> -Dscala-2.11     # 指定scala的版本为2.11</span><br><span class="line"><span class="meta">#</span> -Pvendor-repos   # 使用cdh、hdp 的hadoop 需要添加该参数</span><br><span class="line"><span class="meta">#</span> -Dfast  #在flink根目录下pom.xml文件中fast配置项目中含快速设置,其中包含了多项构建时的跳过参数. #例如apache的文件头(rat)合法校验，代码风格检查，javadoc生成的跳过等，详细可阅读pom.xml</span><br><span class="line"><span class="meta">#</span> install maven的安装命令</span><br><span class="line"><span class="meta">#</span> -T2C #支持多处理器或者处理器核数参数,加快构建速度,推荐Maven3.3及以上</span><br><span class="line"><span class="meta">#</span> -Dhadoop.version=2.6.0-cdh5.7.0  指定 hadoop 的版本</span><br></pre></td></tr></table></figure><hr><h3 id="重要补丁1"><a href="#重要补丁1" class="headerlink" title="重要补丁1"></a>重要补丁1</h3><p>Maven clean install 成功了 未必打包出来的东西就能运行，打包出来的东西必须经过验证才知道能不能运行。</p><p>在使用了上面的mvn置顶hadoop版本的命令之后，勉强能打包，但是跑出来的东西并不能运行，最后使用的还是最简单的命令打包运行成功了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -DskipTests -Dfast</span><br></pre></td></tr></table></figure><h3 id="重要补丁2"><a href="#重要补丁2" class="headerlink" title="重要补丁2"></a>重要补丁2</h3><p>在打包的过程中遇到过几次很头疼的问题，其中之一应该还是test-jar包在install安装的时候会卡住，然后就一直卡住，后来发现是pom里面的profile没有添加一些属性，添加完成之后就ok了。</p><p>上面的问题还算是比较简单，下面这个问题我再处理一次感觉也只能随机应变，不一定说就一定能够处理好，主要讲一下思路。</p><p>这个问题就是框架的可视化模版，<code>Flink-runtime-web</code>模块以及里面的仪表盘模块。</p><p>这个模块首先依赖于node.js和npm，因为是在mac上面编译的，但是mac对node.js的管理有点小复杂，又是用brew安装n 又是这 又是那的，<br>推荐只要使用最简单的安装解压包 然后在<code>zsh</code>或者<code>bash</code>里面配置一下属性，然后source生效即可。</p><p>首先确保了全局唯一node之后，然后挺坑的一点就是执行过程中，Flink会在仪表盘目录下重新安装一个新的node</p><p>。。。</p><p>这样一来就有点扯了，本地配置的module无法在新环境里面奏效</p><p>但是有一点要说明一下 这种情况并非是绝对的，并非会在这个环节出问题，但是如果在这个环节出问题的话，要耐心根据日志找到新的<code>module</code>，然后在<code>module</code>里面操作<code>execution</code>标签页，<br>新的<code>execution</code>修改完之后可以然后在使用 mvn 中的 -rf : 模块名 命令来执行直接跳到这个模块编译的命令。</p><p>我当时的大概处理方法是，找到<code>flink-runtime-web</code>模块里的<code>execution</code>然后把他要执行的命令配合日志记录下来，在仪表盘目录下先执行一遍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd flink-runtime-web/web-dashboard</span><br><span class="line">npm ci --cache-max=0 --no-save</span><br><span class="line">npm update</span><br></pre></td></tr></table></figure><p>执行完成之后，不急着运行mvn命令，可以吧module里面的文件夹和系统的module对比，合并出来，然后再放到仪表盘文件夹，修改pom里面的<code>execution</code>，去掉初始化的命令即可。（因为已经手动运行过了）</p><p>还有需要安装一个ng</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g @angular/cli@1.3.0</span><br></pre></td></tr></table></figure><p>确认ng可用即可，如果版本过高的话需要退下来<br>版本过高报错：<br>too many symbolic links encountered, stat …..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall -g @angular/cli </span><br><span class="line"></span><br><span class="line">npm remove -g @angular/cli </span><br><span class="line"></span><br><span class="line">npm cache clean </span><br><span class="line"></span><br><span class="line">npm i -g @angular/cli@1.3.0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 建立软链接</span><br><span class="line">ln -s ~/node/bin/node /usr/local/bin/node</span><br><span class="line">ln -s ~/node/bin/npm /usr/local/bin/npm</span><br><span class="line"></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"># 处理npm权限</span><br><span class="line">npm config -g set unsafe-perm</span><br></pre></td></tr></table></figure><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>比如说如果没有apache 2.0协议 没有办法把代码加进去编译/有的test没必要一起编译 有两种办法 一个是pom里面有的东西去掉 还有里面是把协议加上去的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Apache Maven 编译打包Flink&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gf9x6qsh2lj20tk0fnta2.jpg&quot; alt=&quot;微信截图_20200530031106.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;给爷狠狠得Success&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第二次更新于 2019/6/11&lt;/p&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://yoursite.com/categories/Apache/"/>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Apache/Maven/"/>
    
    
      <category term="Apache Maven" scheme="http://yoursite.com/tags/Apache-Maven/"/>
    
  </entry>
  
  <entry>
    <title>HiveSQL 行列转换</title>
    <link href="http://yoursite.com/2020/05/28/HiveSQL%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/28/HiveSQL行列转换/</id>
    <published>2020-05-28T08:59:36.435Z</published>
    <updated>2020-06-02T04:43:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此中应用场景常见于特征值表</p></blockquote><a id="more"></a> <h1 id="HiveSQL-行列转换"><a href="#HiveSQL-行列转换" class="headerlink" title="HiveSQL 行列转换"></a>HiveSQL 行列转换</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>特征值表：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf8058v9zwj20f0078mxe.jpg" alt="微信图片_20200528112630.png"></p><p>要求：表1 用hivesql变为表2 不能用union all 使用不止一种方法解</p><h3 id="UNION-ALL的解法"><a href="#UNION-ALL的解法" class="headerlink" title="UNION ALL的解法"></a>UNION ALL的解法</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf86v1o38fj20xq0epwf0.jpg" alt="微信截图_20200528151916.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">a, <span class="string">"k1"</span>,k1 <span class="keyword">as</span> sel</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">t_row_column</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">a, <span class="string">"k2"</span>,k2 <span class="keyword">as</span> sel</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">t_row_column</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">a, <span class="string">"k3"</span>,k3 <span class="keyword">as</span> sel</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">t_row_column</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HIVE 的 UNION 和 UNION ALL</span><br><span class="line"></span><br><span class="line">UNION用于联合多个select语句的结果集，合并为一个独立的结果集，结果集去重。</span><br><span class="line"></span><br><span class="line">UNION ALL也是用于联合多个select语句的结果集。但是不能消除重复行。现在hive只支持UNION ALL。</span><br><span class="line"></span><br><span class="line">这里需要特别注意，每个select语句返回的列的数量和名字必须一样，同时字段类型必须完全匹配，否则会抛出语法错误。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">example</span><br><span class="line">例一：字段名完全一样</span><br><span class="line"></span><br><span class="line">select a,b,c from t1</span><br><span class="line"></span><br><span class="line">union all</span><br><span class="line"></span><br><span class="line">select a,b,c from t2</span><br><span class="line"></span><br><span class="line">例二：字段名前面有表名不一致，其他一致</span><br><span class="line"></span><br><span class="line">select t1.a,t2.b,t2.c from t1</span><br><span class="line"></span><br><span class="line">inner join t2 on t1.a = t2.a</span><br><span class="line"></span><br><span class="line">union all</span><br><span class="line"></span><br><span class="line">select t3.a,t4.b,t4.c from t3</span><br><span class="line"></span><br><span class="line">inner join t4 on t3.a = t4.a</span><br><span class="line"></span><br><span class="line">这两个例子都不报错</span><br><span class="line"></span><br><span class="line">但</span><br><span class="line"></span><br><span class="line">例三：第一个查询第二个字段重命名为k，与第二个查询字段名不一样了，此时会报错</span><br><span class="line"></span><br><span class="line">select a,&apos;&apos; as k,c from t1</span><br><span class="line"></span><br><span class="line">union all</span><br><span class="line"></span><br><span class="line">select a,b,c from t2</span><br><span class="line"></span><br><span class="line">会报编译错误</span><br><span class="line"></span><br><span class="line">编译错误：SemanticException The abstract syntax tree is null</span><br></pre></td></tr></table></figure><h3 id="使用行列转换SQL"><a href="#使用行列转换SQL" class="headerlink" title="使用行列转换SQL"></a>使用行列转换SQL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">a,<span class="keyword">key</span>,<span class="keyword">value</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">t_row_column</span><br><span class="line"><span class="keyword">LATERAL</span> <span class="keyword">VIEW</span></span><br><span class="line"><span class="keyword">explode</span>(<span class="keyword">map</span>(<span class="string">'k1'</span>,k1,<span class="string">'k2'</span>,k2,<span class="string">'k3'</span>,k3)) tmp</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">key</span>,<span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gfdug3wd4dj20xn0aiaab.jpg" alt="微信截图_20200602124207.png"></p><p><strong>建表语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_row_column (</span><br><span class="line">    a <span class="built_in">int</span>,</span><br><span class="line">    k1 <span class="built_in">int</span>,</span><br><span class="line">    k2 <span class="built_in">int</span>,</span><br><span class="line">    k3 <span class="built_in">int</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span>;</span><br></pre></td></tr></table></figure><h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><h3 id="collect-list-和-collect-set"><a href="#collect-list-和-collect-set" class="headerlink" title="collect_list 和 collect_set"></a>collect_list 和 collect_set</h3><p><strong>建表语句：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_visit_video (</span><br><span class="line">    username <span class="keyword">string</span>,</span><br><span class="line">    video_name <span class="keyword">string</span></span><br><span class="line">) partitioned <span class="keyword">by</span> (<span class="keyword">day</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span>;</span><br></pre></td></tr></table></figure><p><strong>文件内容：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">张三,大唐双龙传</span><br><span class="line">李四,天下无贼</span><br><span class="line">张三,神探狄仁杰</span><br><span class="line">李四,霸王别姬</span><br><span class="line">李四,霸王别姬</span><br><span class="line">王五,机器人总动员</span><br><span class="line">王五,放牛班的春天</span><br><span class="line">王五,盗梦空间</span><br></pre></td></tr></table></figure><p><strong>加载数据:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'/tmp/visit.data'</span> <span class="keyword">into</span> <span class="keyword">table</span> t_visit_video</span><br></pre></td></tr></table></figure><p><strong>数据展示:</strong></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf80b4ce9bj20xl0eoaah.jpg" alt="微信截图_20200528113224.png"></p><p><strong>按用户分组，取出每个用户每天看过的所有视频的名字：</strong></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf80e2x6ozj20xb0avq3a.jpg" alt="微信截图_20200528113521.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username, collect_list(video_name)[<span class="number">0</span>] <span class="keyword">from</span> t_visit_video <span class="keyword">group</span> <span class="keyword">by</span> username;</span><br><span class="line"><span class="comment"># 这个结果稍微有一些问题，应为里面某个元素 霸王别姬出现了两次</span></span><br></pre></td></tr></table></figure><p><strong>优化：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">username, collect_set(video_name)</span><br><span class="line"><span class="keyword">FROM</span> t_visit_video</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> username</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf80jehbtbj20ya0abq39.jpg" alt="微信截图_20200528114031.png"></p><p>如果希望第二列仅出现一个数值的话：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username, collect_list(video_name)[<span class="number">0</span>] <span class="keyword">from</span> t_visit_video <span class="keyword">group</span> <span class="keyword">by</span> username;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf80kx6kc3j20y50cdjrs.jpg" alt="微信截图_20200528114201.png"></p><h3 id="concat-和-concat-ws"><a href="#concat-和-concat-ws" class="headerlink" title="concat 和 concat_ws"></a>concat 和 concat_ws</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select concat(&apos;大&apos;,&apos;小&apos;) as size from 表</span><br><span class="line">查询出结果为：大小</span><br><span class="line">select concat(&apos;大&apos;, NULL) as size from 表</span><br><span class="line">查询出结果为：null</span><br><span class="line">concat中又一个参数为NULL，查出来的就为NULL</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select concat_ws(&apos;_&apos;,&apos;大&apos;,&apos;小&apos;,&apos;中&apos;) as size from 表</span><br><span class="line">查询出结果为：大_小_中</span><br><span class="line">select concat_ws(&apos;_&apos;,&apos;大&apos;,&apos;小&apos;,NULL) as size from 表</span><br><span class="line">查询出结果为：大_小</span><br></pre></td></tr></table></figure><h3 id="explode"><a href="#explode" class="headerlink" title="explode"></a>explode</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># explode有两种基本使用方式：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">explode</span>(<span class="built_in">array</span>(<span class="string">'liubei'</span>,<span class="string">'zhangfei'</span>,<span class="string">'guanyu'</span>));</span><br><span class="line">+<span class="comment">-----------+--+</span></span><br><span class="line">|    col    |</span><br><span class="line">+<span class="comment">-----------+--+</span></span><br><span class="line">| liubei    |</span><br><span class="line">| zhangfei  |</span><br><span class="line">| guanyu    |</span><br><span class="line">+<span class="comment">-----------+--+</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">explode</span>(<span class="keyword">map</span>(<span class="string">'liubei'</span>,<span class="string">'18'</span>,<span class="string">'zhangfei'</span>,<span class="string">'19'</span>));</span><br><span class="line">+<span class="comment">-----------+--------+--+</span></span><br><span class="line">|    key    | value  |</span><br><span class="line">+<span class="comment">-----------+--------+--+</span></span><br><span class="line">| liubei    | 18     |</span><br><span class="line">| zhangfei  | 19     |</span><br><span class="line">+<span class="comment">-----------+--------+--+</span></span><br></pre></td></tr></table></figure><p>但是如果我们直接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  movie，<span class="keyword">explode</span>(<span class="keyword">category</span>) <span class="keyword">from</span> movie_info;</span><br></pre></td></tr></table></figure><p>这样会报错，因为movie的查询结果只有三条，但是explode()出来有多条语句，两者数量无法对齐</p><p>那么，我们由此引入LATERAL VIEW函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LATERAL VIEW:</span><br><span class="line">1.Lateral View 用于和UDTF函数【explode,split】结合来使用。</span><br><span class="line">2.首先通过UDTF函数将数据拆分成多行，再将多行结果组合成一个支持别名的虚拟表。</span><br><span class="line">3.主要解决在select使用UDTF做查询的过程中查询只能包含单个UDTF，不能包含其它字段以及多个UDTF的情况。</span><br><span class="line">4.语法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias (&apos;,&apos; columnAlias)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> movie,category_name </span><br><span class="line"><span class="keyword">from</span> movie_info</span><br><span class="line"><span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> <span class="keyword">explode</span>(<span class="keyword">category</span>) tmpTable <span class="keyword">as</span> category_name;</span><br><span class="line"><span class="comment">-- category_name 是给 explode(category) 列起的别名</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此中应用场景常见于特征值表&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
      <category term="HiveSQL" scheme="http://yoursite.com/categories/SQL/HiveSQL/"/>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Flink CEP 文档</title>
    <link href="http://yoursite.com/2020/05/27/Flink%20CEP%E6%96%87%E6%A1%A3/"/>
    <id>http://yoursite.com/2020/05/27/Flink CEP文档/</id>
    <published>2020-05-27T11:20:36.351Z</published>
    <updated>2020-05-27T09:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1.5版本</p></blockquote><a id="more"></a> <h1 id="Flink-CEP"><a href="#Flink-CEP" class="headerlink" title="Flink CEP"></a>Flink CEP</h1><h2 id="0-本文概述简介"><a href="#0-本文概述简介" class="headerlink" title="0. 本文概述简介"></a>0. 本文概述简介</h2><p>FlinkCEP是在Flink之上实现的复杂事件处理（CEP）库。 它允许你在无界的事件流中检测事件模式，让你有机会掌握数据中重要的事项。</p><p>本文描述了Flink CEP中可用的API调用。 首先介绍Pattern API，它允许你指定要在流中检测的模式，然后介绍如何检测匹配事件序列并对其进行操作。 然后，我们将介绍CEP库在处理事件时间延迟时所做的假设。</p><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h2><p>首先是要在你的pom.xml文件中，引入CEP库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-cep_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意要应用模式匹配的DataStream中的事件必须实现正确的equals（）和hashCode（）方法，因为FlinkCEP使用它们来比较和匹配事件。</p><p>第一个demo如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Event&gt; input = ...</span><br><span class="line"></span><br><span class="line">Pattern&lt;Event, ?&gt; pattern = Pattern.&lt;Event&gt;begin(<span class="string">"start"</span>).where(</span><br><span class="line">        <span class="keyword">new</span> SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> event.getId() == <span class="number">42</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ).next(<span class="string">"middle"</span>).subtype(SubEvent.class).where(</span><br><span class="line">        <span class="keyword">new</span> SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(SubEvent subEvent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> subEvent.getVolume() &gt;= <span class="number">10.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ).followedBy(<span class="string">"end"</span>).where(</span><br><span class="line">         <span class="keyword">new</span> SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> event.getName().equals(<span class="string">"end"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">PatternStream&lt;Event&gt; patternStream = CEP.pattern(input, pattern);</span><br><span class="line"></span><br><span class="line">DataStream&lt;Alert&gt; result = patternStream.select(</span><br><span class="line">    <span class="keyword">new</span> PatternSelectFunction&lt;Event, Alert&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Alert <span class="title">select</span><span class="params">(Map&lt;String, List&lt;Event&gt;&gt; pattern)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> createAlertFrom(pattern);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-Pattern-API"><a href="#2-Pattern-API" class="headerlink" title="2.Pattern API"></a>2.Pattern API</h2><p>Pattern API允许你定义要从输入流中提取的复杂模式序列。</p><p>每个复杂模式序列都是由多个简单模式组成，即寻找具有相同属性的单个事件的模式。我们可以先定义一些简单的模式，然后组合成复杂的模式序列。 可以将模式序列视为此类模式的结构图，基于用户指定的条件从一个模式转换到下一个模式，例如， event.getName().equals(“start”)。 匹配是一系列输入事件，通过一系列有效的模式转换访问复杂模式图中的所有模式。</p><p>注意每个模式必须具有唯一的名称，以便后续可以使用该名称来标识匹配的事件。</p><p>注意模式名称不能包含字符“：”。</p><p>在本节接下来的部分，我们将首先介绍如何定义单个模式，然后如何将各个模式组合到复杂模式中。</p><h3 id="2-1-单个模式"><a href="#2-1-单个模式" class="headerlink" title="2.1 单个模式"></a>2.1 单个模式</h3><p>Pattern可以是单单个，也可以是循环模式。单个模式接受单个事件，而循环模式可以接受多个事件。在模式匹配符号中，模式“a b + c？d”（或“a”，后跟一个或多个“b”，可选地后跟“c”，后跟“d”），a，c ？，和d是单例模式，而b +是循环模式。 默认情况下，模式是单个模式，您可以使用Quantifiers将其转换为循环模式。每个模式可以有一个或多个条件，基于它接受事件。</p><h4 id="2-1-1-Quantifiers"><a href="#2-1-1-Quantifiers" class="headerlink" title="2.1.1 Quantifiers"></a>2.1.1 Quantifiers</h4><p>在FlinkCEP中，您可以使用以下方法指定循环模式：pattern.oneOrMore（），用于期望一个或多个事件发生的模式（例如之前提到的b +）;和pattern.times（#ofTimes）， 用于期望给定类型事件的特定出现次数的模式，例如4个;和patterntimes（#fromTimes，＃toTimes），用于期望给定类型事件的最小出现次数和最大出现次数的模式，例如， 2-4。</p><p>您可以使用pattern.greedy（）方法使循环模式变得贪婪，但是还不能使组模式变得贪婪。您可以使用pattern.optional（）方法使得所有模式，循环与否，变为可选。</p><p>对于名为start的模式，以下是有效的Quantifiers：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expecting 4 occurrences</span></span><br><span class="line">start.times(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 0 or 4 occurrences</span></span><br><span class="line">start.times(<span class="number">4</span>).optional();</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 2, 3 or 4 occurrences</span></span><br><span class="line">start.times(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 2, 3 or 4 occurrences and repeating as many as possible</span></span><br><span class="line">start.times(<span class="number">2</span>, <span class="number">4</span>).greedy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 0, 2, 3 or 4 occurrences</span></span><br><span class="line">start.times(<span class="number">2</span>, <span class="number">4</span>).optional();</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 0, 2, 3 or 4 occurrences and repeating as many as possible</span></span><br><span class="line">start.times(<span class="number">2</span>, <span class="number">4</span>).optional().greedy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 1 or more occurrences</span></span><br><span class="line">start.oneOrMore();</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 1 or more occurrences and repeating as many as possible</span></span><br><span class="line">start.oneOrMore().greedy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 0 or more occurrences</span></span><br><span class="line">start.oneOrMore().optional();</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 0 or more occurrences and repeating as many as possible</span></span><br><span class="line">start.oneOrMore().optional().greedy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 2 or more occurrences</span></span><br><span class="line">start.timesOrMore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 2 or more occurrences and repeating as many as possible</span></span><br><span class="line">start.timesOrMore(<span class="number">2</span>).greedy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// expecting 0, 2 or more occurrences and repeating as many as possible</span></span><br><span class="line">start.timesOrMore(<span class="number">2</span>).optional().greedy();</span><br></pre></td></tr></table></figure><h4 id="2-1-2-Conditions-条件"><a href="#2-1-2-Conditions-条件" class="headerlink" title="2.1.2 Conditions-条件"></a>2.1.2 Conditions-条件</h4><p>在每个模式中，从一个模式转到下一个模式，可以指定其他条件。您可以将使用下面这些条件：</p><ol><li>传入事件的属性，例如其值应大于5，或大于先前接受的事件的平均值。</li><li>匹配事件的连续性，例如检测模式a，b，c，序列中间不能有任何非匹配事件。</li></ol><h4 id="2-1-3-Conditions-on-Properties关于属性的条件"><a href="#2-1-3-Conditions-on-Properties关于属性的条件" class="headerlink" title="2.1.3 Conditions on Properties关于属性的条件"></a>2.1.3 Conditions on Properties关于属性的条件</h4><p>可以通过pattern.where（），pattern.or（）或pattern.until（）方法指定事件属性的条件。 条件可以是IterativeConditions或SimpleConditions。</p><ol><li><strong>迭代条件：</strong></li></ol><p>这是最常见的条件类型。 你可以指定一个条件，该条件基于先前接受的事件的属性或其子集的统计信息来接受后续事件。</p><p>下面代码说的是：如果名称以“foo”开头同时如果该模式的先前接受的事件的价格总和加上当前事件的价格不超过该值 5.0，则迭代条件接受名为“middle”的模式的下一个事件，。 迭代条件可以很强大的，尤其是与循环模式相结合，例如， oneOrMore()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">middle.oneOrMore().where(<span class="keyword">new</span> IterativeCondition&lt;SubEvent&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(SubEvent value, Context&lt;SubEvent&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!value.getName().startsWith(<span class="string">"foo"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> sum = value.getPrice();</span><br><span class="line">        <span class="keyword">for</span> (Event event : ctx.getEventsForPattern(<span class="string">"middle"</span>)) &#123;</span><br><span class="line">            sum += event.getPrice();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(sum, <span class="number">5.0</span>) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意对context.getEventsForPattern（…）的调用,将为给定潜在匹配项查找所有先前接受的事件。 此操作的代价可能会变化巨大，因此在使用条件时，请尽量减少其使用。</p><ol start="2"><li><strong>简单条件：</strong></li></ol><p>这种类型的条件扩展了前面提到的IterativeCondition类，并且仅根据事件本身的属性决定是否接受事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start.where(<span class="keyword">new</span> SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getName().startsWith(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，还可以通过pattern.subtype（subClass）方法将接受事件的类型限制为初始事件类型的子类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start.subtype(SubEvent.class).where(<span class="keyword">new</span> SimpleCondition&lt;SubEvent&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(SubEvent value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ... <span class="comment">// some condition</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>组合条件：</strong></li></ol><p>如上所示，可以将子类型条件与其他条件组合使用。 这适用于所有条件。 您可以通过顺序调用where（）来任意组合条件。 最终结果将是各个条件的结果的逻辑AND。 要使用OR组合条件，可以使用or（）方法，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pattern.where(<span class="keyword">new</span> SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ... <span class="comment">// some condition</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).or(<span class="keyword">new</span> SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ... <span class="comment">// or condition</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>停止条件：</strong></li></ol><p>在循环模式（oneOrMore()和oneOrMore().optional()）的情况下，还可以指定停止条件，例如： 接受值大于5的事件，直到值的总和小于50。</p><p>为了更好的理解，可以看看下面的例子：</p><p>给定模式：(a+ until b)，b之前，要出现一个或者多个a。</p><p>给定输入序列：a1，c，a2，b，a3</p><p>输出结果: {a1 a2}{a1}{a2}{a3}</p><p>可以看到{a1,a2,a3},{a2,a3}这两个并没有输出，这就是停止条件的作用。</p><ol start="5"><li><strong>连续事件条件</strong><br>FlinkCEP支持事件之间以下形式进行连续：</li></ol><p>严格连续性：希望所有匹配事件一个接一个地出现，中间没有任何不匹配的事件。</p><p>宽松连续性：忽略匹配的事件之间出现的不匹配事件。 不能忽略两个事件之间的匹配事件。</p><p>非确定性轻松连续性：进一步放宽连续性，允许忽略某些匹配事件的其他匹配。</p><p>为了解释上面的内容，我们举个例子。假如有个模式序列”a+ b”，输入序列”a1,c,a2,b”，不同连续条件下有不同的区别：</p><p>严格连续性：{a2 b} - 由于c的存在导致a1被废弃</p><p>宽松连续性：{a1,b}和{a1 a2 b} - c被忽略</p><p>非确定性宽松连续性：{a1 b}, {a2 b}, 和 {a1 a2 b}</p><p>对于循环模式（例如oneOrMore()和times()），默认是宽松的连续性。 如果你想要严格的连续性，你必须使用consecutive()显式指定它， 如果你想要非确定性的松弛连续性，你可以使用allowCombinations()方法。</p><p>注意在本节中，我们讨论的是单个循环模式中的连续性，并且需要在该上下文中理解consecutive()和allowCombinations()。 稍后在讲解组合模式时，我们将讨论其他方法，例如next（）和followedBy（），用于指定模式之间的连续条件。</p><h4 id="2-1-4-API简介"><a href="#2-1-4-API简介" class="headerlink" title="2.1.4 API简介"></a>2.1.4 API简介</h4><ol><li>where(condition)</li></ol><p>定义当前模式的条件。 为了匹配模式，事件必须满足条件。 多个连续的where()，其条件为AND：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern.where(new IterativeCondition&lt;Event&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean filter(Event value, Context ctx) throws Exception &#123;</span><br><span class="line">        return ... // some condition</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>or(condition)</li></ol><p>添加与现有条件进行OR运算的新条件。 只有在至少通过其中一个条件时，事件才能匹配该模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pattern.where(new IterativeCondition&lt;Event&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean filter(Event value, Context ctx) throws Exception &#123;</span><br><span class="line">        return ... // some condition</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).or(new IterativeCondition&lt;Event&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean filter(Event value, Context ctx) throws Exception &#123;</span><br><span class="line">        return ... // alternative condition</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>until(condition)</li></ol><p>指定循环模式的停止条件。 意味着如果匹配给定条件的事件发生，则不再接受该模式中的事件。</p><p>仅适用于oneOrMore（）</p><p>注意：它允许在基于事件的条件下清除相应模式的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern.oneOrMore().until(new IterativeCondition&lt;Event&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean filter(Event value, Context ctx) throws Exception &#123;</span><br><span class="line">        return ... // alternative condition</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>subtype(subClass)</li></ol><p>定义当前模式的子类型条件。 如果事件属于此子类型，则事件只能匹配该模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.subtype(SubEvent.class);</span><br></pre></td></tr></table></figure><ol start="5"><li>oneOrMore()</li></ol><p>指定此模式至少发生一次匹配事件。</p><p>默认情况下，使用宽松的内部连续性。</p><p>注意：建议使用until（）或within（）来启用状态清除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern.oneOrMore().until(new IterativeCondition&lt;Event&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean filter(Event value, Context ctx) throws Exception &#123;</span><br><span class="line">        return ... // alternative condition</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li>timesOrMore(#times)</li></ol><p>指定此模式至少需要#times次出现匹配事件。</p><p>默认情况下，使用宽松的内部连续性（在后续事件之间）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.timesOrMore(2);</span><br></pre></td></tr></table></figure><ol start="7"><li>times(#ofTimes)</li></ol><p>指定此模式需要匹配事件的确切出现次数。</p><p>默认情况下，使用宽松的内部连续性（在后续事件之间）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.times(2);</span><br></pre></td></tr></table></figure><ol start="8"><li>times(#fromTimes, #toTimes)</li></ol><p>指定此模式期望在匹配事件的#fromTimes次和#toTimes次之间出现。</p><p>默认情况下，使用宽松的内部连续性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.times(2, 4);</span><br></pre></td></tr></table></figure><ol start="9"><li>optional()</li></ol><p>指定此模式是可选的，即有可能根本不会发生。 这适用于所有上述量词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.oneOrMore().optional();</span><br></pre></td></tr></table></figure><ol start="10"><li>greedy()</li></ol><p>指定此模式是贪婪的，即它将尽可能多地重复。 这仅适用于quantifiers，目前不支持组模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.oneOrMore().greedy();</span><br></pre></td></tr></table></figure><ol start="11"><li>consecutive()</li></ol><p>与oneOrMore（）和times（）一起使用并在匹配事件之间强加严格的连续性，即任何不匹配的元素都会中断匹配。</p><p>如果不使用，则使用宽松的连续性（如followBy（））。</p><p>例如，这样的模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Pattern.&lt;Event&gt;begin(&quot;start&quot;).where(new SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean filter(Event value) throws Exception &#123;</span><br><span class="line">    return value.getName().equals(&quot;c&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.followedBy(&quot;middle&quot;).where(new SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean filter(Event value) throws Exception &#123;</span><br><span class="line">    return value.getName().equals(&quot;a&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).oneOrMore().consecutive()</span><br><span class="line">.followedBy(&quot;end1&quot;).where(new SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean filter(Event value) throws Exception &#123;</span><br><span class="line">    return value.getName().equals(&quot;b&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>针对上面的模式，我们假如输入序列如：C D A1 A2 A3 D A4 B</p><p>使用consecutive：{C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}</p><p>不使用:{C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}, {C A1 A2 A3 A4 B}</p><ol start="12"><li>allowCombinations()</li></ol><p>与oneOrMore（）和times（）一起使用，并在匹配事件之间强加非确定性宽松连续性（如 followedByAny()）。</p><p>如果不应用，则使用宽松的连续性（如followBy()）。</p><p>例如,这样的模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Pattern.&lt;Event&gt;begin(&quot;start&quot;).where(new SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean filter(Event value) throws Exception &#123;</span><br><span class="line">    return value.getName().equals(&quot;c&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.followedBy(&quot;middle&quot;).where(new SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean filter(Event value) throws Exception &#123;</span><br><span class="line">    return value.getName().equals(&quot;a&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).oneOrMore().allowCombinations()</span><br><span class="line">.followedBy(&quot;end1&quot;).where(new SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean filter(Event value) throws Exception &#123;</span><br><span class="line">    return value.getName().equals(&quot;b&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>针对上面的模式，我们假如输入序列如：C D A1 A2 A3 D A4 B</p><p>使用allowCombinations：{C A1 B}, {C A1 A2 B}, {C A1 A3 B}, {C A1 A4 B}, {C A1 A2 A3 B}, {C A1 A2 A4 B}, {C A1 A3 A4 B}, {C A1 A2 A3 A4 B}</p><p>不使用:{C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}, {C A1 A2 A3 A4 B}</p><h3 id="2-2-组合模式"><a href="#2-2-组合模式" class="headerlink" title="2.2 组合模式"></a>2.2 组合模式</h3><h4 id="2-2-1-简介"><a href="#2-2-1-简介" class="headerlink" title="2.2.1 简介"></a>2.2.1 简介</h4><p>已经了解了单个模式的样子，现在是时候看看如何将它们组合成一个完整的模式序列。</p><p>模式序列必须以初始模式开始，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; start = Pattern.&lt;Event&gt;begin(&quot;start&quot;);</span><br></pre></td></tr></table></figure><p>接下来，您可以通过指定它们之间所需的连续条件，为模式序列添加更多模式。 在上一节中，我们描述了Flink支持的不同邻接模式，即严格，宽松和非确定性宽松，以及如何在循环模式中应用它们。 要在连续模式之间应用它们，可以使用：</p><blockquote><p>next() 对应 严格, followedBy() 对应 宽松连续性 followedByAny() 对应 非确定性宽松连续性</p></blockquote><p>亦或</p><blockquote><p>notNext() 如果不希望一个事件类型紧接着另一个类型出现。 notFollowedBy() 不希望两个事件之间任何地方出现该事件。</p></blockquote><blockquote><p>注意 模式序列不能以notFollowedBy（）结束。</p></blockquote><blockquote><p>注意 NOT模式前面不能有可选模式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// strict contiguity</span><br><span class="line">Pattern&lt;Event, ?&gt; strict = start.next(&quot;middle&quot;).where(...);</span><br><span class="line"></span><br><span class="line">// relaxed contiguity</span><br><span class="line">Pattern&lt;Event, ?&gt; relaxed = start.followedBy(&quot;middle&quot;).where(...);</span><br><span class="line"></span><br><span class="line">// non-deterministic relaxed contiguity</span><br><span class="line">Pattern&lt;Event, ?&gt; nonDetermin = start.followedByAny(&quot;middle&quot;).where(...);</span><br><span class="line"></span><br><span class="line">// NOT pattern with strict contiguity</span><br><span class="line">Pattern&lt;Event, ?&gt; strictNot = start.notNext(&quot;not&quot;).where(...);</span><br><span class="line"></span><br><span class="line">// NOT pattern with relaxed contiguity</span><br><span class="line">Pattern&lt;Event, ?&gt; relaxedNot = start.notFollowedBy(&quot;not&quot;).where(...);</span><br></pre></td></tr></table></figure><p>宽松连续性指的是仅第一个成功匹配的事件会被匹配到，然而非确定性宽松连续性，相同的开始会有多个匹配结果发出。距离，如果一个模式是”a b”，给定输入序列是”a c b1 b2”。对于不同连续性会有不同输出。</p><ol><li>a和b之间严格连续性，将会返回{},也即是没有匹配。因为c的出现导致a，抛弃了。</li><li>a和b之间宽松连续性，返回的是{a，b1},因为宽松连续性将会抛弃为匹配成功的元素，直至匹配到下一个要匹配的事件。</li><li>a和b之间非确定性宽松连续性，返回的是{a,b1},{a,b2}。</li></ol><p>也可以为模式定义时间约束。 例如，可以通过pattern.within（）方法定义模式应在10秒内发生。 时间模式支持处理和事件时间。 注意模式序列只能有一个时间约束。 如果在不同的单独模式上定义了多个这样的约束，则应用最小的约束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next.within(Time.seconds(10));</span><br></pre></td></tr></table></figure><p>可以为begin，followBy，followByAny和next定义一个模式序列作为条件。模式序列将被逻辑地视为匹配条件，而且将返回GroupPattern并且 可对GroupPattern使用oneOrMore（），times（#ofTimes），times（＃fromTimes，＃toTimes），optional（），consecutive（）， allowCombinations（）等方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PatternPatte &lt;Event, ?&gt; start = Pattern.begin(</span><br><span class="line">    Pattern.&lt;Event&gt;begin(&quot;start&quot;).where(...).followedBy(&quot;start_middle&quot;).where(...)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// strict contiguity</span><br><span class="line">Pattern&lt;Event, ?&gt; strict = start.next(</span><br><span class="line">    Pattern.&lt;Event&gt;begin(&quot;next_start&quot;).where(...).followedBy(&quot;next_middle&quot;).where(...)</span><br><span class="line">).times(3);</span><br><span class="line"></span><br><span class="line">// relaxed contiguity</span><br><span class="line">Pattern&lt;Event, ?&gt; relaxed = start.followedBy(</span><br><span class="line">    Pattern.&lt;Event&gt;begin(&quot;followedby_start&quot;).where(...).followedBy(&quot;followedby_middle&quot;).where(...)</span><br><span class="line">).oneOrMore();</span><br><span class="line"></span><br><span class="line">// non-deterministic relaxed contiguity</span><br><span class="line">Pattern&lt;Event, ?&gt; nonDetermin = start.followedByAny(</span><br><span class="line">    Pattern.&lt;Event&gt;begin(&quot;followedbyany_start&quot;).where(...).followedBy(&quot;followedbyany_middle&quot;).where(...)</span><br><span class="line">).optional();</span><br></pre></td></tr></table></figure><h4 id="2-2-2-API"><a href="#2-2-2-API" class="headerlink" title="2.2.2 API"></a>2.2.2 API</h4><ol><li>begin(#name)</li></ol><p>定义一个开始模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; start = Pattern.&lt;Event&gt;begin(&quot;start&quot;);</span><br></pre></td></tr></table></figure><ol><li>begin(#pattern_sequence)</li></ol><p>定义一个开始模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; start = Pattern.&lt;Event&gt;begin(</span><br><span class="line">    Pattern.&lt;Event&gt;begin(&quot;start&quot;).where(...).followedBy(&quot;middle&quot;).where(...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>next(#name)</li></ol><p>追加一个新的模式。匹配事件必须直接跟着先前的匹配事件（严格连续性）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; next = start.next(&quot;middle&quot;);</span><br></pre></td></tr></table></figure><ol><li>next(#pattern_sequence)</li></ol><p>追加一个新的模式。匹配事件必须直接接着先前的匹配事件（严格连续性）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; next = start.next(</span><br><span class="line">    Pattern.&lt;Event&gt;begin(&quot;start&quot;).where(...).followedBy(&quot;middle&quot;).where(...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>followedBy(#name)</li></ol><p>追加加新模式。 匹配事件和先前匹配事件（宽松连续）之间可能发生其他非匹配事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; followedBy = start.followedBy(&quot;middle&quot;);</span><br></pre></td></tr></table></figure><ol><li>followedBy(#pattern_sequence)</li></ol><p>追加新模式。 匹配事件和先前匹配事件（宽松连续）之间可能发生其他非匹配事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; followedBy = start.followedBy(</span><br><span class="line">    Pattern.&lt;Event&gt;begin(&quot;start&quot;).where(...).followedBy(&quot;middle&quot;).where(...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>followedByAny(#name)</li></ol><p>添加新模式。 匹配事件和先前匹配事件之间可能发生其他事件，并且将针对每个备选匹配事件（非确定性放松连续性）呈现替代匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; followedByAny = start.followedByAny(&quot;middle&quot;);</span><br></pre></td></tr></table></figure><ol><li>followedByAny(#pattern_sequence)</li></ol><p>添加新模式。 匹配事件和先前匹配事件之间可能发生其他事件，并且将针对每个备选匹配事件（非确定性放松连续性）呈现替代匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; followedByAny = start.followedByAny(</span><br><span class="line">    Pattern.&lt;Event&gt;begin(&quot;start&quot;).where(...).followedBy(&quot;middle&quot;).where(...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>notNext()</li></ol><p>添加新的否定模式。 匹配（否定）事件必须直接跟着先前的匹配事件（严格连续性）才能丢弃部分匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; notNext = start.notNext(&quot;not&quot;);</span><br></pre></td></tr></table></figure><ol><li>notFollowedBy()</li></ol><p>追加一个新的否定模式匹配。即使在匹配（否定）事件和先前匹配事件（宽松连续性）之间发生其他事件，也将丢弃部分匹配事件序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; notFollowedBy = start.notFollowedBy(&quot;not&quot;);</span><br></pre></td></tr></table></figure><ol><li>within(time)</li></ol><p>定义事件序列进行模式匹配的最大时间间隔。 如果未完成的事件序列超过此时间，则将其丢弃：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.within(Time.seconds(10));</span><br></pre></td></tr></table></figure><h3 id="2-3-匹配后的跳过策略"><a href="#2-3-匹配后的跳过策略" class="headerlink" title="2.3 匹配后的跳过策略"></a>2.3 匹配后的跳过策略</h3><p>对于给定模式，可以将同一事件分配给多个成功匹配。 要控制将分配事件的匹配数，需要指定名为AfterMatchSkipStrategy的跳过策略。 跳过策略有四种类型，如下所示：</p><ul><li>NO_SKIP：将发出每个可能的匹配。</li><li>SKIP_PAST_LAST_EVENT：丢弃包含匹配事件的每个部分匹配。</li><li>SKIP_TO_FIRST：丢弃包含PatternName第一个之前匹配事件的每个部分匹配。</li><li>SKIP_TO_LAST：丢弃包含PatternName最后一个匹配事件之前的每个部分匹配。</li></ul><p>请注意，使用SKIP_TO_FIRST和SKIP_TO_LAST跳过策略时，还应指定有效的PatternName。</p><p>例如，对于给定模式a b {2}和数据流ab1，ab2，ab3，ab4，ab5，ab6，这四种跳过策略之间的差异如下：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf7530gz4bj20oq0gktcy.jpg" alt="undefined"></p><p>要指定要使用的跳过策略，只需调用以下命令创建AfterMatchSkipStrategy：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf754c9zi6j20oi06uabd.jpg" alt="undefined"></p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AfterMatchSkipStrategy skipStrategy = ...</span><br><span class="line">Pattern.begin(&quot;patternName&quot;, skipStrategy);</span><br></pre></td></tr></table></figure><h3 id="2-4-检测模式-Detecting-Patterns"><a href="#2-4-检测模式-Detecting-Patterns" class="headerlink" title="2.4 检测模式-Detecting Patterns"></a>2.4 检测模式-Detecting Patterns</h3><p>指定要查找的模式序列后，就可以将其应用于输入流以检测潜在匹配。 要针对模式序列运行事件流，必须创建PatternStream。 给定输入流 input，模式 pattern 和可选的比较器 comparator，用于在EventTime的情况下对具有相同时间戳的事件进行排序或在同一时刻到达，通过调用以下命令创建PatternStream：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Event&gt; input = ...</span><br><span class="line">Pattern&lt;Event, ?&gt; pattern = ...</span><br><span class="line">EventComparator&lt;Event&gt; comparator = ... // optional</span><br><span class="line"></span><br><span class="line">PatternStream&lt;Event&gt; patternStream = CEP.pattern(input, pattern, comparator);</span><br></pre></td></tr></table></figure><p>根据实际情况，创建的流可以是有key，也可以是无key的。</p><p>请注意，在无key的流上使用模式，将导致job的并行度为1。</p><h3 id="2-5-Selecting-from-Patterns"><a href="#2-5-Selecting-from-Patterns" class="headerlink" title="2.5 Selecting from Patterns"></a>2.5 Selecting from Patterns</h3><p>获得PatternStream后，您可以通过select或flatSelect方法从检测到的事件序列中进行查询。</p><p>select（）方法需要PatternSelectFunction的实现。 PatternSelectFunction具有为每个匹配事件序列调用的select方法。 它以Map &lt;String，List &gt;的形式接收匹配，其中key是模式序列中每个模式的名称，值是该模式的所有已接受事件的列表（IN是输入元素的类型）。 给定模式的事件按时间戳排序。 返回每个模式的接受事件列表的原因是当使用循环模式（例如oneToMany（）和times（））时，对于给定模式可以接受多个事件。 选择函数只返回一个结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyPatternSelectFunction&lt;IN, OUT&gt; implements PatternSelectFunction&lt;IN, OUT&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OUT select(Map&lt;String, List&lt;IN&gt;&gt; pattern) &#123;</span><br><span class="line">        IN startEvent = pattern.get(&quot;start&quot;).get(0);</span><br><span class="line">        IN endEvent = pattern.get(&quot;end&quot;).get(0);</span><br><span class="line">        return new OUT(startEvent, endEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PatternFlatSelectFunction类似于PatternSelectFunction，唯一的区别是它可以返回任意数量的结果。 为此，select方法有一个额外的Collector参数，用于将输出元素向下游转发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyPatternFlatSelectFunction&lt;IN, OUT&gt; implements PatternFlatSelectFunction&lt;IN, OUT&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void flatSelect(Map&lt;String, List&lt;IN&gt;&gt; pattern, Collector&lt;OUT&gt; collector) &#123;</span><br><span class="line">        IN startEvent = pattern.get(&quot;start&quot;).get(0);</span><br><span class="line">        IN endEvent = pattern.get(&quot;end&quot;).get(0);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; startEvent.getValue(); i++ ) &#123;</span><br><span class="line">            collector.collect(new OUT(startEvent, endEvent));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-处理超时部分模式"><a href="#2-6-处理超时部分模式" class="headerlink" title="2.6 处理超时部分模式"></a>2.6 处理超时部分模式</h3><p>每当模式具有通过within关键字附加的时间窗口长度时，部分事件序列可能因为超出时间窗口长度而被丢弃。 为了对这些超时的部分匹配作出相应的处理，select和flatSelect API调用允许指定超时处理程序。 为每个超时的部分事件序列调用此超时处理程序。 超时处理程序接收到目前为止由模式匹配的所有事件，以及检测到超时时的时间戳。</p><p>为了处理部分模式，select和flatSelect API提供了一个带参数的重载版本</p><ul><li>PatternTimeoutFunction/ PatternFlatTimeoutFunction。</li><li>OutputTag 超时的匹配将会在其中返回。</li><li>PatternSelectFunction / PatternFlatSelectFunction。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PatternStreamPatte &lt;Event&gt; patternStream = CEP.pattern(input, pattern);</span><br><span class="line"></span><br><span class="line">OutputTag&lt;String&gt; outputTag = new OutputTag&lt;String&gt;(&quot;side-output&quot;)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;ComplexEvent&gt; result = patternStream.select(</span><br><span class="line">    new PatternTimeoutFunction&lt;Event, TimeoutEvent&gt;() &#123;...&#125;,</span><br><span class="line">    outputTag,</span><br><span class="line">    new PatternSelectFunction&lt;Event, ComplexEvent&gt;() &#123;...&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DataStream&lt;TimeoutEvent&gt; timeoutResult = result.getSideOutput(outputTag);</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;ComplexEvent&gt; flatResult = patternStream.flatSelect(</span><br><span class="line">    new PatternFlatTimeoutFunction&lt;Event, TimeoutEvent&gt;() &#123;...&#125;,</span><br><span class="line">    outputTag,</span><br><span class="line">    new PatternFlatSelectFunction&lt;Event, ComplexEvent&gt;() &#123;...&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DataStream&lt;TimeoutEvent&gt; timeoutFlatResult = flatResult.getSideOutput(outputTag);</span><br></pre></td></tr></table></figure><h3 id="2-7-事件事件模式下处理滞后数据"><a href="#2-7-事件事件模式下处理滞后数据" class="headerlink" title="2.7 事件事件模式下处理滞后数据"></a>2.7 事件事件模式下处理滞后数据</h3><p>在CEP中，元素处理的顺序很重要。为了保证在采用事件事件时以正确的顺序处理事件，最初将传入的事件放入缓冲区，其中事件基于它们的时间戳以升序排序， 并且当watermark到达时，处理该缓冲区中时间戳小于watermark时间的所有元素。这意味着watermark之间的事件按事件时间顺序处理。</p><p>请注意，在采用事件时间时，CEP library会假设watermark是正确的。</p><p>为了保证跨watermark的记录按照事件事件顺序处理，Flink的CEP库假定watermark是正确的，并将时间戳小于上次可见watermark的时间视为滞后事件。滞后事件不会被进一步处理。</p><h3 id="2-8-栗子"><a href="#2-8-栗子" class="headerlink" title="2.8 栗子"></a>2.8 栗子</h3><p>以下示例检测事件的带key数据流上的模式start，middle（name =“error”） - &gt; end（name =“critical”）。 事件的key是其id，并且有效模式必须在10秒内发生。 整个处理是用事件时间完成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = ...</span><br><span class="line">env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">DataStream&lt;Event&gt; input = ...</span><br><span class="line"></span><br><span class="line">DataStream&lt;Event&gt; partitionedInput = input.keyBy(new KeySelector&lt;Event, Integer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Integer getKey(Event value) throws Exception &#123;</span><br><span class="line">return value.getId();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Pattern&lt;Event, ?&gt; pattern = Pattern.&lt;Event&gt;begin(&quot;start&quot;)</span><br><span class="line">.next(&quot;middle&quot;).where(new SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean filter(Event value) throws Exception &#123;</span><br><span class="line">return value.getName().equals(&quot;error&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).followedBy(&quot;end&quot;).where(new SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean filter(Event value) throws Exception &#123;</span><br><span class="line">return value.getName().equals(&quot;critical&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).within(Time.seconds(10));</span><br><span class="line"></span><br><span class="line">PatternStream&lt;Event&gt; patternStream = CEP.pattern(partitionedInput, pattern);</span><br><span class="line"></span><br><span class="line">DataStream&lt;Alert&gt; alerts = patternStream.select(new PatternSelectFunction&lt;Event, Alert&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Alert select(Map&lt;String, List&lt;Event&gt;&gt; pattern) throws Exception &#123;</span><br><span class="line">return createAlert(pattern);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;1.5版本&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Flink CEP" scheme="http://yoursite.com/categories/Flink-CEP/"/>
    
    
      <category term="Flink CEP" scheme="http://yoursite.com/tags/Flink-CEP/"/>
    
  </entry>
  
  <entry>
    <title>Flink Sabre</title>
    <link href="http://yoursite.com/2020/05/27/Flink%20Sabre/"/>
    <id>http://yoursite.com/2020/05/27/Flink Sabre/</id>
    <published>2020-05-27T11:20:36.307Z</published>
    <updated>2020-05-27T08:42:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Flink CEP在奇安信的拓展</p><p>此 Flink CEP 改版应用场景：安全检测和数据分析</p></blockquote><a id="more"></a> <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自下而上分为四个业务处理流程，分别是数据的<strong>采集</strong>、<strong>解析</strong>、<strong>处理</strong>和<strong>展示</strong>结果，这其中<strong>最核心的是第三层数据处理</strong>。<strong>该产品的用户主要是安全规则团队</strong>，其可以<strong>使用规则编辑器来对安全规则进行添加、删除、编辑和查找操作</strong>，并可<strong>批量启动/停用多个规则</strong>，<strong>同时可以将处于启动状态的有效规则统一发送给产品</strong>。</p><p>在数据规模方面，<strong>产品解决的不是一个或几个大型数据集群的问题</strong>，<strong>而是数以百计的中小型数据集群的运维问题</strong>。在 B2B 领域，<strong>由于产品是直接部署到客户方</strong>，很多客户使用的是内部隔离网，无法连接外网，且没有专门人员负责集群的运维，这种情况下哪怕一个小升级都会耗费大量时间。因此，<strong>产品更多关注该领域下数据集群可运维性问题的解决</strong>。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5tunz99ej20zk0igmyt.jpg" alt="undefined"></p><h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><h3 id="1-不能进行语义优化、不便于动态更新规则。"><a href="#1-不能进行语义优化、不便于动态更新规则。" class="headerlink" title="1.不能进行语义优化、不便于动态更新规则。"></a>1.不能进行语义优化、不便于动态更新规则。</h3><p>网络安全事件井喷式发生的今天，安全需求迅速扩展。为了能够在有限时间内对特定语义的快速支持，关联引擎的整体架构必须异常灵活，才能适应未来安全分析场景的各种需求，而基于开源关联引擎实现的产品会在激烈的需求变化时遇到很多问题。</p><h3 id="2-状态监控-amp-高可用支持不足。"><a href="#2-状态监控-amp-高可用支持不足。" class="headerlink" title="2.状态监控 &amp; 高可用支持不足。"></a>2.状态监控 &amp; 高可用支持不足。</h3><p>面向企业级的网络安全监测引擎具有一些特定需求，当前解决方案对此支持较差。</p><ul><li>比如，现实情况中客户对算子实例和 Taskmanager 概念较为模糊，真正关心的运行状态的基本单位是规则。Flink 监控页面显示的是算子实例及 Task manager 进程整体内存的运行状态，而在网络安全监控的业务场景中，对运行状态和资源的监控均需要细化到规则层面。</li><li>其次，在算子层面，Flink 原生 Window 算子，没有较好的资源（CPU / 内存）保护机制，且存在大量重复告警，不符合网络安全监测领域的业务需求。</li><li>再次，Flink 缺乏一些必要算子，例如不支持“不发生算子”。一个较为常见的应用场景，某条规则指定在较长时间内没收到某台服务器的系统日志，则认为此台服务器发生了异常，需要及时通知用户。</li></ul><h3 id="3-CEP-网络负载高、CPU-利用率低"><a href="#3-CEP-网络负载高、CPU-利用率低" class="headerlink" title="3.CEP 网络负载高、CPU 利用率低"></a>3.CEP 网络负载高、CPU 利用率低</h3><p>和互联网企业内部使用的大型集群相比，奇安信面向的企业级应用集群规模较小，硬件资源受限，且客户的定制需求较多，导致安全监测的规则要求更严格，引擎发布成本较高。但是，现有的 Flink 开源解决方案，或者需要根据业务需求进行改造，或者性能较差，均不能较好地解决上述问题。</p><ul><li>首先，原生 Flink 只提供了函数式编程模式，即需要手动编写复合特定业务需求的固定程序代码，由此导致开发测试周期较长，不便于动态更新规则，可复用性较弱，且不能从全局语义层面进行优化，性能较差。</li><li>其次，Flink-CEP 仅是一个受限的序列算子，在运行时需要将所有数据传输到 CEP 算子，然后在 CEP 算子中串行执行各个条件语句。这种汇集到单点的运行模式，较多的冗余数据需要执行条件匹配，由此产生了不必要的网络负载，而且降低了 CPU 利用率。</li><li>再次，还存在一些非官方开源的轻量级 CEP 引擎，比如 Flink-siddhi，功能简单，不是一个完整的解决方案。</li></ul><p>其他的痛点问题还包括不支持空值窗口出发、以及聚合不保存原始数据等。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5u75m23tj20zk0imgng.jpg" alt="undefined"></p><h2 id="架构改动"><a href="#架构改动" class="headerlink" title="架构改动"></a>架构改动</h2><p>为了解决上述问题，奇安信在 Flink 的基础上推出了一种全新的 CEP 引擎， Sabre。其整体架构如下图所示，其中包含三大核心模块，左侧是<strong>配置端</strong>，中间是 <strong>Sabre-server</strong>，右侧是 <strong>Sabre 运行端</strong>。核心数据流存在两条主线，红线表示规则的<strong>提交</strong>、<strong>编译</strong>、<strong>发布</strong>和<strong>运行</strong>流程。绿线表示状态监控的<strong>生成</strong>、<strong>收集</strong>、<strong>统计</strong>和<strong>展示</strong>流程。如图所示，此架构与 Hive 极为相似，是一种通用的大数据 OLAP 系统架构。下面详细介绍三大核心模块和两大核心数据流。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5ud5rdx7j22bb1av7d4.jpg" alt="undefined"></p><ul><li>首先，通过规则配置端创建规则，采用性能保护配置端修改性能保护策略；</li><li>然后，将任务所属的规则文件和性能保护策略文件一并推送到 Sabre-server 提供的 REST 接口，该接口会调用文件解析及优化方法构建规则有向无环图。</li><li>接着，执行词法语法分析方法，将规则有向无环图中各个节点的 EPL 转换为与其对应的 AST（AbstractSyntax Tree，抽象语法树），再将 AST 翻译为任务 java 代码。</li><li>最后，调用 maven 命令打包 java 代码为任务 jar 包，并将任务 jar 包及基础运行库一并提交到 Flink-on-YARN 集群。</li></ul><p><strong>Flink 有多种运行模式（例如 standalone Flink cluster、Flink cluster on YARN、Flink job on YARN 等）</strong>，Sabre 采用了“Flink job on YARN”模式，在奇安信 NGSOC 应用的特定场景下，采用 YARN 可统一维护硬件资源，并且使用 Flink job on YARN 可与 Hadoop 平台进行无缝对接，以此很好的实现了任务间资源隔离。</p><p>在 Sabre 任务执行过程中，<strong>Kafka 数据源向引擎提供原始事件</strong>。引擎处理结果分为回注事件和告警事件两类。告警事件会输出到目的 Kafka，供下级应用消费。回注事件表示一条规则的处理结果可直接回注到下级规则，作为下级规则的数据源事件，由此可实现规则的相互引用。</p><p>绿线流程表示任务执行过程中会定时输出节点的运行监控消息到 Sabre-server 的监控消息缓存器，然后监控消息统计器再汇总各个规则实例的运行监控消息，统计为整条规则的运行监控状态，最后通过 Sabre-server 提供的 REST 接口推送给规则监控端。</p><h3 id="组件依赖与版本"><a href="#组件依赖与版本" class="headerlink" title="组件依赖与版本"></a>组件依赖与版本</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5uupr3mdj20zk0k0q5i.jpg" alt="undefined"></p><ul><li>大多数情况下，奇安信会以黑盒的方式发布产品，但是如果用户方已经部署大数据处理平台，则产品会以 APP 的方式提供使用。</li><li>由于客户规模较大，项目种类较多，部署环境较为复杂，或者存在多种 Yarn 集群版本，或者 Sabre 需作为单一 Flink 应用发布到客户已部署的 Flink 集群。</li><li>如何节省成本及提高实施效率，快速适配上述复杂的部署环境是个亟需解决的问题，为此 Sabre 的设计原则是仅采用 Flink 的分布式计算能力，业务代码尽可能减少对 API 层的依赖，以便于兼容多种 Flink 版本。</li></ul><p>如图所示，Deploy、Core、APIs、Libraries 四层是大家熟知的 Flink 基本的组件栈。Sabre 对 API 层的依赖降到了最低，只引用了 DataStream、KeyedStream 和 SplitStream 三种数据流 API。函数依赖只包括 DataStream 的 assignTimestamps、flatMap、union、keyBy、split、process、addSink 等函数，KeyedStream 最基础的 process 函数，以及 SplitStream 的 select 函数。由于依赖的 Flink API 较少，Sabre 可以很容易适配到各个 Flink 版本，从而具有良好的 Flink 版本兼容性。</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>在算子方面，Sabre 对 Flink 进行了一系列的重构，下图展示了这 Flink 和 Sabre 这二者之间的对比关系，其中主要包含三列，即 Flink 原生算子、Sabre 算子和两者之间的比较结果。比较结果主要有四种情况，相同（Same）、实现（Implement）、优化(优化)和新增（New）。Sabre 共有 13 种完全自研的核心算子，其中 Datasource、CustomKafkaSink 和 CustomDatabase 按照 Flink 接口要求做了具体实现，Filter、Key、Join 和 Aggregation 按照 Flink 原有算子的语义做了重新实现，CustomWindow 和 Sequence 在 Flink 原有算子语义的基础上做了优化实现。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5uynys4oj20zk0k0ju4.jpg" alt="undefined"></p><p>下图展示了 Sabre 的规则与 EPL 设计。序列 Sequence、聚合 Aggregation、不发生 NotOccur、流式机器学习 StreamML 和连接 Join 均属于 Window 执行时间包含的计算性算子。蓝色虚线表示引用动态数据（Dynamic data），紫色虚线表示 Filter 无须经过 Window 可直连输出组件。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5uyswqdej20zk0imdih.jpg" alt="undefined"></p><h3 id="windows算子"><a href="#windows算子" class="headerlink" title="windows算子"></a>windows算子</h3><p>众所周知，Join 和 Aggregation 的时间范围由 Window 限定，而 Flink 原有 Window 算子不适合网络安全监测需求，为此 Sabre 设计了一种“自定义 Window 算子”，且重新实现了与“自定义 Window 算子”相匹配的 Join 和 Aggregation 算子。全新的 Window 具有以下六个主要特点：</p><ul><li>实时触发、即刻匹配：其目的是为了满足自动化实时响应的需求，一旦告警发出，会及时触发响应；</li><li>匹配不重复：重复告警对于规则引擎来讲是一个常见问题，大量重复告警会增加安全人员的工作量，而该算子会将整个窗口与告警相关的事件全部清空，以此减少重复告警的数量；</li><li>纠正乱序：将 Window 窗口以特定单位为边界切成一个个的时间槽，一旦发现乱序情况，插入乱序事件时可直接定位时间槽，基于流式状态机进行局部计算，并且窗口事件超时，同步更新计算性算子的值，并入 count 算子，删除超时事件的同时，同步减少 count 值；</li><li>实时资源和状态监控：由于 Window 对与内存和 CPU 的影响比较大，因此需要对该类资源进行特别监控以及保护；</li><li>流量控制：主要是为了更好地保护下级应用。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5vypwqujj20zk0gct9s.jpg" alt="undefined"></p><h3 id="Sequence-序列算子"><a href="#Sequence-序列算子" class="headerlink" title="Sequence 序列算子"></a>Sequence 序列算子</h3><p>Sabre 用 EPL 对 Flink CEP 实现的序列算子进行了重新设计，左边是 Flink CEP 官方代码展示，采用程序代码的方式拼凑“NFA 自动机”。右边是 Sabre 中 Sequence 算子的实现方式，其中包含了三个不同的 filter,通过正则表达式的使用来提升其表达的能力，并且，Sabre 将 filter 前置，无效事件不会传输到 window 算子，从而较少了不必要的网络负载。并且，只有较少的有效数据需要执行正则匹配，降低了 CPU 利用率（filter 可以并行）。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5w0byssvj20zk0ipmys.jpg" alt="undefined"></p><h3 id="NotOccur-不发生算子"><a href="#NotOccur-不发生算子" class="headerlink" title="NotOccur 不发生算子"></a>NotOccur 不发生算子</h3><p>NotOccur 是 Sabre 在 Flink 基础上新增的一个算子，支持空事件触发。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5w2ch3b9j20zk0hywg9.jpg" alt="undefined"></p><h3 id="Trigger-全局算子"><a href="#Trigger-全局算子" class="headerlink" title="Trigger 全局算子"></a>Trigger 全局算子</h3><p>Sabre 还实现了一种针对窗口的全局触发器 Trigger，Trigger 能够将多个子计算性算子组合为复杂表达式，并实现了具有GroupBy/Distinct 功能的 Key 算子以适配此 Trigger 算子。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5w38hws1j20zk0ibdh9.jpg" alt="undefined"></p><h3 id="Dynamic-Data"><a href="#Dynamic-Data" class="headerlink" title="Dynamic Data"></a>Dynamic Data</h3><p>Dynamicdata 可以映射为数据库中的一个表，但是对这个表要进行特别的优化，具体来讲，如果一个事件的 IP 在威胁情报列表中，而这个威胁情报有可能比较长，比如十几万行甚至更长，这种情况下需要对该表数据结构进行优化以提升效率。Dynamic data 可以在其他算子中使用，如 Filter、Join 等。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5w45t1kjj20zk0igmym.jpg" alt="undefined"></p><h3 id="流式统计与机器学习-StreamML"><a href="#流式统计与机器学习-StreamML" class="headerlink" title="流式统计与机器学习 StreamML"></a>流式统计与机器学习 StreamML</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5w8doz5uj20zk0igtad.jpg" alt="undefined"></p><p>机器学习在网络异常检测上已经越来越重要，为适应实时检测的需求，Sabre 没有使用 Flink MachineLearning，而是引入了自研的流式机器学习算子 StreamML。</p><p>Flink MachineLearning 是一种基于批模式 DataSetApi 实现的机器学习函数库，而 StreamML 是一种流式的机器学习算子，其目的是为了满足网络安全监测的特定需求。与阿里巴巴开源的 Alink 相比，StreamML 允许机器学习算法工程师通过配置规则的方式即可快速验证算法模型，无需编写任何程序代码。并且，流式机器学习算子 StreamML 实现了“模型训练/更新”与“模型使用”统一的理念。其核心功能是通过算法、技术及模型实现数据训练及对新数据检测。该流式机器学习算子 StreamML 引入的输入有三类，分别是：事件流、检测对象和对象属性；输出也包含三类，分别是：事件、告警和预警。</p><p>流式机器学习算子 StreamML 的组件栈包含三部分，从下往上依次为：机器学习方法、应用场景和产品业务。通过基本的机器学习算法（比如：统计学习算法、序列分析算法、聚类分析算法），流式机器学习算子 StreamML 可满足具体特定的安全监测应用场景（比如：行为特征异常检测、时间序列异常检测、群组聚类分析），进而为用户提供可理解的产品业务（比如：基线、用户及实体行为分析 UEBA）。</p><ul><li>行为特征异常检测：根据采集的样本数据（长时间）对统计分析对象建立行为基线，并以此基线为准，检测发现偏离正常行为模式的行为。例如：该用户通常从哪里发起连接？哪个运营商？哪个国家？哪个地区？这个用户行为异常在组织内是否为常见异常？</li><li>时间序列异常检测：根据某一个或多个统计属性，判断按时间顺序排列的数值序列是否异常，由此通过监测指标变化来发现安全事件。例如：监测某网站每小时的访问量以防止 DDOS 攻击；建模每个账号传输文件大小的平均值，检测出传输文件大小的平均值离群的账号。</li><li>群组聚类分析：对数据的特征属性间潜在相关性进行挖掘，将具有类似特征值的数据进行分组聚类。例如：该用户是否拥有任何特殊特征？可执行权限/特权用户？基于执行的操作命令和可访问的实体，来识别IT管理员、DBA 和其它高权限用户。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5whemng3j20zk0igmym.jpg" alt="undefined"></p><p>因为采用了 Flink 作为底层运行组件，所以 Sabre 具有与 Flink 等同的执行性能。并且，针对网络安全监测领域的特定需求，Sabre 还在以下方面进行了性能优化：</p><ul><li>全局组件（数据源、动态表）引用优化。由于 Kafka 类型的数据源 topic 有限，而规则数量可动态扩展，导致多个规则会有极大概率共用同一个数据源，根据 EPL 语义等价原则合并相同的数据源，进而可以减少数据输入总量及线程总数。</li><li>全新的匹配引擎。序列 Sequence 算子采用了新颖的流式状态机引擎，复用了状态机缓存的状态，提升了匹配速度。类似优化还包含大规模 IP 匹配引擎和大规模串匹配引擎。在流量、日志中存在大规模 IP 和字符串匹配需求，通过 IP 匹配引擎和大规模串匹配引擎进行优化以提高效率。</li><li>表计算表达式优化。对于规则中引用的动态表，会根据表达式的具体特性构建其对应的最优计算数据结构，以避免扫描全表数据，进而确保了执行的时间复杂度为常量值。</li><li>自定义流式 Window 算子。采用“时间槽”技术实现了乱序纠正功能，并具有可以实时输出无重复、无遗漏告警的特性。</li><li>图上字段自动推导，优化事件结构。根据规则前后逻辑关系，推导出规则中标注使用的原始日志相关字段，无须输出所有字段，以此优化输出事件结构，减少了输出事件大小。</li><li>图上数据分区自动推导，优化流拓扑。由于特定的功能需要，Window 往往会缓存大量数据，以致消耗较多内存。通过对全局窗口 Hash 优化，避免所有全局窗口都分配到同一个 Taskmanager 进程，由此提高了引擎整体内存的利用率。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf5wi109c0j20zk0ikabf.jpg" alt="undefined"></p><p>上图是 Sabre 流式状态机引擎的表示，其主要负责的功能是序列匹配。图中左边是标准的正则引擎，通常的流程可以从 Pattern 到语法树到 NFA 再到 DFA，也可以从 Paterrn 直接到 NFA；图左下侧是一个正则表达式的 NFA 表示，右侧是该正则表达式的 DFA 表示，使用该 DFA 的时候进行了改进（如图中绿色线）。其目的是为了在出现乱序的时候提升处理性能，在乱序发生在正则表达式后半段的时候，该改进对于性能提升的效果最好。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf73cbq36rj20zk0ibgmm.jpg" alt="undefined"></p><p>大规模正则引擎主要使用了两种互补的方法（图上半侧和下半侧）。在将 NFA 转向 DFA 的时候，很多情况下是不成功的，这种情况下往往会生成 DFA 的半成品，称为Unfinished-DFA，第一种方法属于混合状态自动机，包含 NFA 和 DFA，其适用于Pattern 量少于 1000 的情况。而第二种方法适用于 Pattern 量大于 1000 甚至上万的情况，该方法中首先需要寻找锚点，再做匹配，以降低整体的时间复杂度。这两种方法相结合能够较好地解决大规模正则匹配的问题。</p><h3 id="产品运维"><a href="#产品运维" class="headerlink" title="产品运维"></a>产品运维</h3><h4 id="多级规则"><a href="#多级规则" class="headerlink" title="多级规则"></a>多级规则</h4><p>多级规则是产品运维的一个显著特点。如下图所示，为满足复杂场景需求，一种规则的输出可直接作为另一种规则的输入。通过这种规则拆分的方式，能分层构造较为复杂的“多级规则”。如：图中的“暴力探测”规则结果可以直接回注到下面的“登陆成功 ”规则，而无须额外的通信组件，由此实现更为复杂的“暴力破解”规则。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf73cylk82j20zk0gnab5.jpg" alt="undefined"></p><h4 id="服务化-多租户-资源监控"><a href="#服务化-多租户-资源监控" class="headerlink" title="服务化/多租户/资源监控"></a>服务化/多租户/资源监控</h4><p>产品采用微服务架构，使用多租户、多任务来满足多个规则引擎的使用场景，同时对资源进行了实时监控来保证系统的稳定运行。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf73e5qsfnj20zk0hlgmw.jpg" alt="undefined"></p><h4 id="规则级的状态-资源监控"><a href="#规则级的状态-资源监控" class="headerlink" title="规则级的状态/资源监控"></a>规则级的状态/资源监控</h4><p>规则级的状态和资源监控是非常重要的产品需求，产品采用分布式监控，提供三级分布式监控能力（用户、任务和规则），并支持吞吐量、EPS、CPU 和内存的监控。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf73eick1mj20zk0ieta4.jpg" alt="undefined"></p><h4 id="整体系统保护"><a href="#整体系统保护" class="headerlink" title="整体系统保护"></a>整体系统保护</h4><p>整体系统保护主要涉及两方面，即流量控制和自我保护。</p><ul><li>流量控制：为了增强 Sabre 引擎的健壮性，避免因规则配置错误，导致生成大量无效告警，在输出端做了流量控制，以更好地保护下级应用。当下级抗压能力较弱时（例如数据库），整个系统会做输出降级。</li><li>自我保护：跑在 JVM 上的程序，经常会遇到由于长时间 Full GC 导致 OOM 的错误，并且此时 CPU 占用率往往非常高，Flink 同样存在上述问题。自我保护功能采用了同时兼顾“Window隶属规则的优先级”及“Window引用规则数量”两个条件的加权算法，以此根据全局规则语义实现自动推导 Window 优先级，并根据此优先级确定各个 Window 的自我保护顺序。实时监控 CPU 及内存占用，当超过一定阈值时，智能优化事件分布，以防出现 CPU 长期过高或内存使用率过大而导致的 OOM 问题。</li></ul><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gf73euyybhj20zk0gwq46.jpg" alt="undefined"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Flink CEP在奇安信的拓展&lt;/p&gt;
&lt;p&gt;此 Flink CEP 改版应用场景：安全检测和数据分析&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Flink CEP" scheme="http://yoursite.com/categories/Flink-CEP/"/>
    
    
      <category term="Flink CEP" scheme="http://yoursite.com/tags/Flink-CEP/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java</title>
    <link href="http://yoursite.com/2020/05/23/EffectiveJava/"/>
    <id>http://yoursite.com/2020/05/23/EffectiveJava/</id>
    <published>2020-05-23T12:38:22.746Z</published>
    <updated>2020-07-13T17:17:00.361Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>拓展自《高效Java第四版》</p></blockquote><a id="more"></a> <h1 id="Effective-Java"><a href="#Effective-Java" class="headerlink" title="Effective Java"></a>Effective Java</h1><h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><h3 id="【01】考虑以静态工厂方法代替构造函数"><a href="#【01】考虑以静态工厂方法代替构造函数" class="headerlink" title="【01】考虑以静态工厂方法代替构造函数"></a>【01】考虑以静态工厂方法代替构造函数</h3><p>在 Java 中，获得一个类实例最简单的方法就是使用 <code>new</code> 关键字，通过构造函数来实现对象的创建。<br>就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fragment fragment = <span class="keyword">new</span> MyFragment();</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure><p>不过在实际的开发中，我们经常还会见到另外一种获取类实例的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fragment fragment = MyFragment.newIntance();</span><br><span class="line"><span class="comment">// or </span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">// or </span></span><br><span class="line">Integer number = Integer.valueOf(<span class="string">"3"</span>);</span><br></pre></td></tr></table></figure><p>↑ 像这样的：不通过 <code>new</code>，而是用一个静态方法来对外提供自身实例的方法，即为我们所说的<code>静态工厂方法(Static factory method)</code>。</p><h4 id="静态工厂方法与构造器不同的第一优势在于，它们有名字"><a href="#静态工厂方法与构造器不同的第一优势在于，它们有名字" class="headerlink" title="静态工厂方法与构造器不同的第一优势在于，它们有名字"></a>静态工厂方法与构造器不同的第一优势在于，它们有名字</h4><p>由于语言的特性，Java 的构造函数都是跟类名一样的。这导致的一个问题是构造函数的名称不够灵活，经常不能准确地描述返回值，在有多个重载的构造函数时尤甚，如果参数类型、数目又比较相似的话，那更是很容易出错。</p><p>比如，如下的一段代码 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date date0 = <span class="keyword">new</span> Date();</span><br><span class="line">Date date1 = <span class="keyword">new</span> Date(<span class="number">0L</span>);</span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="string">"0"</span>);</span><br><span class="line">Date date3 = <span class="keyword">new</span> Date(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">Date date4 = <span class="keyword">new</span> Date(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">Date date5 = <span class="keyword">new</span> Date(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>—— Date 类有很多重载函数，对于开发者来说，假如不是特别熟悉的话，恐怕是需要犹豫一下，才能找到合适的构造函数的。而对于其他的代码阅读者来说，估计更是需要查看文档，才能明白每个参数的含义了。</p><p>（当然，Date 类在目前的 Java 版本中，只保留了一个无参和一个有参的构造函数，其他的都已经标记为 @Deprecated 了）</p><p>而如果使用静态工厂方法，就可以给方法起更多有意义的名字，比如前面的 <code>valueOf</code>、<code>newInstance</code>、<code>getInstance</code> 等，对于代码的编写和阅读都能够更清晰。</p><h4 id="第二个优势，不用每次被调用时都创建新对象"><a href="#第二个优势，不用每次被调用时都创建新对象" class="headerlink" title="第二个优势，不用每次被调用时都创建新对象"></a>第二个优势，不用每次被调用时都创建新对象</h4><h4 id="第三个优势，可以返回原返回类型的子类"><a href="#第三个优势，可以返回原返回类型的子类" class="headerlink" title="第三个优势，可以返回原返回类型的子类"></a>第三个优势，可以返回原返回类型的子类</h4><p>这条不用多说，设计模式中的基本的原则之一——『里氏替换』原则，就是说子类应该能替换父类。<br> 显然，构造方法只能返回确切的自身类型，而静态工厂方法则能够更加灵活，可以根据需要方便地返回任何它的子类型的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 这里可以改为 return new Player() / Cooker()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class Player extends Person&#123;</span><br><span class="line">&#125;</span><br><span class="line">Class Cooker extends Person&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面这段代码，Person 类的静态工厂方法可以返回 Person 的实例，也可以根据需要返回它的子类 Player 或者 Cooker。（当然，这只是为了演示，<strong>在实际的项目中，一个类是不应该依赖于它的子类的。</strong>但如果这里的 getInstance () 方法位于其他的类中，就更具有的实际操作意义了）</p><h4 id="第四个优势，在创建带泛型的实例时，能使代码变得简洁"><a href="#第四个优势，在创建带泛型的实例时，能使代码变得简洁" class="headerlink" title="第四个优势，在创建带泛型的实例时，能使代码变得简洁"></a>第四个优势，在创建带泛型的实例时，能使代码变得简洁</h4><h4 id="可以减少对外暴露的属性"><a href="#可以减少对外暴露的属性" class="headerlink" title="可以减少对外暴露的属性"></a>可以减少对外暴露的属性</h4><h4 id="多了一层控制，方便统一修改"><a href="#多了一层控制，方便统一修改" class="headerlink" title="多了一层控制，方便统一修改"></a>多了一层控制，方便统一修改</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;拓展自《高效Java第四版》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Reading Note" scheme="http://yoursite.com/categories/Reading-Note/"/>
    
    
      <category term="Reading Note" scheme="http://yoursite.com/tags/Reading-Note/"/>
    
  </entry>
  
  <entry>
    <title>macOS安装Hadoop3</title>
    <link href="http://yoursite.com/2020/05/22/mac%E5%AE%89%E8%A3%85hadoop3/"/>
    <id>http://yoursite.com/2020/05/22/mac安装hadoop3/</id>
    <published>2020-05-22T10:30:13.018Z</published>
    <updated>2020-05-22T10:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Mac上的Hadoop一直没有安装。。。Flink总是跑在local模式上，实在不太好，于是在mac上面安装了Hadoop3，随便安装了一下，默认就是最新版本的，安装过程被zsh坑了不少，今后凡是安装模式，还是最好切换到原先的bash模式。</p></blockquote><a id="more"></a> <h1 id="macOS安装Hadoop3"><a href="#macOS安装Hadoop3" class="headerlink" title="macOS安装Hadoop3"></a>macOS安装Hadoop3</h1><h2 id="第一步是java环境"><a href="#第一步是java环境" class="headerlink" title="第一步是java环境"></a>第一步是java环境</h2><h3 id="bash环境"><a href="#bash环境" class="headerlink" title="bash环境"></a>bash环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装Java，配置环境变量</span><br><span class="line">打开vi ~/.bash_profile</span><br><span class="line">输入i在文件末尾添加export JAVA_HOME=$(/usr/libexec/java_home)，并按esc，输入:wq!保存。</span><br><span class="line">在~/目录下，执行source ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zsh</span><br><span class="line"></span><br><span class="line">打开vi ~/.zshrc</span><br><span class="line">输入i在文件末尾添加export JAVA_HOME=$(/usr/libexec/java_home)，并按esc，输入:wq!保存。</span><br><span class="line">在~/目录下，执行source ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">生成ssh公钥</span><br><span class="line">终端输入cat ~/.ssh/id_rsa.pub拷贝，cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">系统设置(System Preferences) -&gt; 共享(sharing) -&gt; 远程登录(Remote Login)</span><br><span class="line">终端测试ssh localhost</span><br></pre></td></tr></table></figure><h3 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Q:host key verification failed</span><br><span class="line"></span><br><span class="line">A:cd ~/.ssh 然后rm known_hosts。随后出现Are you sure you want to continue connecting(yes/no)，输入yes</span><br><span class="line"></span><br><span class="line">Q：Warning:” Permission denied (publickey,password,keyboard-interactive)”</span><br><span class="line"></span><br><span class="line">A:cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 若有多个秘钥，也需使用id_rsa.pub</span><br></pre></td></tr></table></figure><h3 id="安装安装配置Hadoop"><a href="#安装安装配置Hadoop" class="headerlink" title="安装安装配置Hadoop"></a>安装安装配置Hadoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">终端输入brew install hadoop，此时Hadoop被安装到/usr/local/Cellar/hadoop下。</span><br><span class="line"></span><br><span class="line">这边直接安装hadoop会下载一个openJDK14，我们需要修改一下jdk依赖，然后就可以卸载掉这个JDK</span><br><span class="line"></span><br><span class="line">若计算机原先安装前端框架yarn则会出现命名冲突name conflict，此时执行brew uninstall yarn即可</span><br><span class="line"></span><br><span class="line">终端输入cd $JAVA_HOME进入JDK目录，pwd查看JDK路径。</span><br><span class="line"></span><br><span class="line">更改Hadoop配置文件信息</span><br><span class="line"></span><br><span class="line">cd /usr/local/Cellar/hadoop</span><br><span class="line"></span><br><span class="line">ls查看Hadoop版本，本机为3.1.2</span><br><span class="line"></span><br><span class="line">cd /3.1.2/libexec/etc/hadoop</span><br><span class="line"></span><br><span class="line">用vscode打开open hadoop-env.sh，找到其中一行：</span><br><span class="line"></span><br><span class="line">export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.net.preferIPv4Stack=true&quot;</span><br><span class="line"></span><br><span class="line">将其修改为：</span><br><span class="line"></span><br><span class="line">export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.net.preferIPv4Stack=true -Djava.security.krb5.realm= -Djava.security.krb5.kdc=&quot;</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home&quot; #改为自己JDK目录</span><br></pre></td></tr></table></figure><h3 id="配置HDFS"><a href="#配置HDFS" class="headerlink" title="配置HDFS"></a>配置HDFS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Cellar/hadoop/3.1.2/libexec/etc/hadoop，打开open core-site.xml，填写&lt;configutation&gt;&lt;\configutation&gt;之间的内容。</span><br><span class="line"></span><br><span class="line">&lt;!-- Put site-specific property overrides in this file. --&gt;</span><br><span class="line"> &lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">      &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/usr/local/Cellar/hadoop/hdfs/tmp&lt;/value&gt;</span><br><span class="line">      &lt;description&gt;A base for other temporary directories.&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">      &lt;name&gt;fs.default.name&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;hdfs://localhost:8020&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="设置MAP-REDUCE中JOBTRACKER的地址和端口号"><a href="#设置MAP-REDUCE中JOBTRACKER的地址和端口号" class="headerlink" title="设置MAP-REDUCE中JOBTRACKER的地址和端口号"></a>设置MAP-REDUCE中JOBTRACKER的地址和端口号</h3><p><code>cd /usr/local/Cellar/hadoop/3.1.2/libexec/etc/hadoop</code>，打开<code>mapred-site.xml</code>，填写<code>&lt;\configutation&gt;</code>之间的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">      &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapred.job.tracker&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost:8021&lt;/value&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="更改HDFS的默认备份方式-默认为3"><a href="#更改HDFS的默认备份方式-默认为3" class="headerlink" title="更改HDFS的默认备份方式(默认为3)"></a>更改HDFS的默认备份方式(默认为3)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Cellar/hadoop/3.1.2/libexec/etc/hadoop，打开hdfs-site.xml，填写&lt;configutation&gt;&lt;\configutation&gt;之间的内容。</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">     &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="格式化新安装的HDFS"><a href="#格式化新安装的HDFS" class="headerlink" title="格式化新安装的HDFS"></a>格式化新安装的HDFS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Cellar/hadoop/3.1.2/libexec/etc/hadoop，在该目录下执行hdfs namenode -format</span><br><span class="line"></span><br><span class="line">查看控制台，若出现ERROR，则需检查配置文件内容是否出错。</span><br></pre></td></tr></table></figure><h3 id="启动后台程序"><a href="#启动后台程序" class="headerlink" title="启动后台程序"></a>启动后台程序</h3><p><code>cd /usr/local/Cellar/hadoop/3.1.2/sbin</code>，在该目录下执行以下命令：</p><ul><li><p><code>./start-dfs.sh</code> or <code>./stop-dfs.sh</code>启动或关闭hdfs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Starting namenodes on [localhost]</span><br><span class="line">Starting datanodes</span><br><span class="line">Starting secondary namenodes [MacBook-Pro.local]</span><br><span class="line">2019-05-18 10:04:32,583 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br></pre></td></tr></table></figure><p>说明成功启动本地服务，此时在浏览器输入如下网址:<code>http://localhost:9870</code>，查看Resource Manager。(<strong>Hadoop版本不同，端口号也不同</strong>)</p></li><li><p><code>./start-yarn.sh</code> or <code>./stop-yarn.sh</code>启动或关闭yarn</p><p>JobTracker <code>http://localhost:8088</code></p><p>Specific Node Information <code>http://localhost:8042</code></p></li><li><p><code>./start-all.sh</code> or <code>./stop-all.sh</code>启动或关闭Hadoop，该命令可同时开启或关闭以上三个服务。</p></li></ul><h3 id="环境配置错误"><a href="#环境配置错误" class="headerlink" title="环境配置错误"></a>环境配置错误</h3><p>Error：Invalid HADOOP_COMMON_HOME</p><p>在<code>~/.bash_profile</code>里面配置环境变量HADOOP_COMMON_HOME<br><code>HADOOP_COMMON_HOME=$HADOOP_HOME</code>，HADOOP_HOME是配置的Hadoop的安装目录，修改完之后执行：source ~/.bash_profile</p><h3 id="其他错误"><a href="#其他错误" class="headerlink" title="其他错误"></a>其他错误</h3><p>输入命令时终端未响应=&gt;<code>ssh localhost</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Mac上的Hadoop一直没有安装。。。Flink总是跑在local模式上，实在不太好，于是在mac上面安装了Hadoop3，随便安装了一下，默认就是最新版本的，安装过程被zsh坑了不少，今后凡是安装模式，还是最好切换到原先的bash模式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://yoursite.com/categories/Apache/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/categories/Apache/Hadoop/"/>
    
    
      <category term="macOS" scheme="http://yoursite.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>数仓总览</title>
    <link href="http://yoursite.com/2020/05/11/%E6%95%B0%E4%BB%93%E6%80%BB%E8%A7%88/"/>
    <id>http://yoursite.com/2020/05/11/数仓总览/</id>
    <published>2020-05-11T06:40:01.178Z</published>
    <updated>2020-05-11T06:39:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数仓要深入了解的话，可能还是得从那几本书入手，这里仅收入几篇经典的总览文，不包含之前已经收录过的美团数仓数据质量</p></blockquote><a id="more"></a> <h1 id="数据仓库介绍与实时数仓案例"><a href="#数据仓库介绍与实时数仓案例" class="headerlink" title="数据仓库介绍与实时数仓案例"></a>数据仓库介绍与实时数仓案例</h1><h2 id="1-数据仓库简介"><a href="#1-数据仓库简介" class="headerlink" title="1.数据仓库简介"></a>1.数据仓库简介</h2><p>数据仓库是一个面向主题的（Subject Oriented）、集成的（Integrate）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策。</p><p>数据仓库是伴随着企业信息化发展起来的，在企业信息化的过程中，随着信息化工具的升级和新工具的应用，数据量变的越来越大，数据格式越来越多，决策要求越来越苛刻，数据仓库技术也在不停的发展。</p><p>数据仓库的趋势：</p><p>实时数据仓库以满足实时化&amp;自动化决策需求；<br>大数据&amp;数据湖以支持大量&amp;复杂数据类型（文本、图像、视频、音频）；<br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohhu6tncj20od0dv413.jpg" alt="undefined"></p><h2 id="2-数据仓库的发展"><a href="#2-数据仓库的发展" class="headerlink" title="2.数据仓库的发展"></a>2.数据仓库的发展</h2><p>数据仓库有两个环节：数据仓库的构建与数据仓库的应用。</p><p>早期数据仓库构建主要指的是把企业的业务数据库如ERP、CRM、SCM等数据按照决策分析的要求建模并汇总到数据仓库引擎中，其应用以报表为主，目的是支持管理层和业务人员决策（中长期策略型决策）。</p><p>随着业务和环境的发展，这两方面都在发生着剧烈变化。</p><p>随着IT技术走向互联网、移动化，数据源变得越来越丰富，在原来业务数据库的基础上出现了非结构化数据，比如网站log，IoT设备数据，APP埋点数据等，这些数据量比以往结构化的数据大了几个量级，对ETL过程、存储都提出了更高的要求；<br>互联网的在线特性也将业务需求推向了实时化，随时根据当前客户行为而调整策略变得越来越常见，比如大促过程中库存管理，运营管理等（即既有中远期策略型，也有短期操作型）；同时公司业务互联网化之后导致同时服务的客户剧增，有些情况人工难以完全处理，这就需要机器自动决策。比如欺诈检测和用户审核。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohi8sf82j20ou0e3q68.jpg" alt="undefined"></p><p>总结来看，对数据仓库的需求可以抽象成两方面：<strong>实时产生结果、处理和保存大量异构数据</strong>。</p><blockquote><p>注：这里不讨论数据湖技术。</p></blockquote><h2 id="3-数据仓库建设方法论"><a href="#3-数据仓库建设方法论" class="headerlink" title="3.数据仓库建设方法论"></a>3.数据仓库建设方法论</h2><h3 id="1）面向主题"><a href="#1）面向主题" class="headerlink" title="1）面向主题"></a>1）面向主题</h3><p>从公司业务出发，是分析的宏观领域，比如供应商主题、商品主题、客户主题和仓库主题</p><h3 id="2）为多维数据分析服务"><a href="#2）为多维数据分析服务" class="headerlink" title="2）为多维数据分析服务"></a>2）为多维数据分析服务</h3><p>数据报表；数据立方体，上卷、下钻、切片、旋转等分析功能。</p><h3 id="3）反范式数据模型"><a href="#3）反范式数据模型" class="headerlink" title="3）反范式数据模型"></a>3）反范式数据模型</h3><p>以事实表和维度表组成的星型数据模型</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohis0o2pj20i90hdgqb.jpg" alt="undefined"></p><blockquote><p>注：图片来自51CTO</p></blockquote><h2 id="4-数据仓库架构的演变"><a href="#4-数据仓库架构的演变" class="headerlink" title="4.数据仓库架构的演变"></a>4.数据仓库架构的演变</h2><p>数据仓库概念是Inmon于1990年提出并给出了完整的建设方法。随着互联网时代来临，数据量暴增，开始使用大数据工具来替代经典数仓中的传统工具。此时仅仅是工具的取代，架构上并没有根本的区别，可以把这个架构叫做离线大数据架构。</p><p>后来随着业务实时性要求的不断提高，人们开始在离线大数据架构基础上加了一个加速层，使用流处理技术直接完成那些实时性要求较高的指标计算，这便是Lambda架构。</p><p>再后来，实时的业务越来越多，事件化的数据源也越来越多，实时处理从次要部分变成了主要部分，架构也做了相应调整，出现了以实时事件处理为核心的Kappa架构。<br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohjng8opj20h00hsgnb.jpg" alt="undefined"></p><h3 id="4-1离线大数据架构"><a href="#4-1离线大数据架构" class="headerlink" title="4.1离线大数据架构"></a>4.1离线大数据架构</h3><p>数据源通过离线的方式导入到离线数仓中。</p><p>下游应用根据业务需求选择直接读取DM或加一层数据服务，比如mysql 或 redis。</p><p>数据仓库从模型层面分为三层：</p><p>ODS，操作数据层，保存原始数据；<br>DWD，数据仓库明细层，根据主题定义好事实与维度表，保存最细粒度的事实数据；<br>DM，数据集市/轻度汇总层，在DWD层的基础之上根据不同的业务需求做轻度汇总；<br>典型的数仓存储是HDFS/Hive，ETL可以是MapReduce脚本或HiveSQL。<br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohk0t0djj20mk0hndi2.jpg" alt="undefined"></p><h3 id="4-2-Lambda架构"><a href="#4-2-Lambda架构" class="headerlink" title="4.2 Lambda架构"></a>4.2 Lambda架构</h3><p>随着大数据应用的发展，人们逐渐对系统的实时性提出了要求，为了计算一些实时指标，就在原来离线数仓的基础上增加了一个实时计算的链路，并对数据源做流式改造（即把数据发送到消息队列），实时计算去订阅消息队列，直接完成指标增量的计算，推送到下游的数据服务中去，由数据服务层完成离线&amp;实时结果的合并。</p><p>注：流处理计算的指标批处理依然计算，最终以批处理为准，即每次批处理计算后会覆盖流处理的结果。（这仅仅是流处理引擎不完善做的折中）</p><h4 id="Lambda架构问题："><a href="#Lambda架构问题：" class="headerlink" title="Lambda架构问题："></a>Lambda架构问题：</h4><p>1.同样的需求需要开发两套一样的代码<br>这是Lambda架构最大的问题，两套代码不仅仅意味着开发困难（同样的需求，一个在批处理引擎上实现，一个在流处理引擎上实现，还要分别构造数据测试保证两者结果一致），后期维护更加困难，比如需求变更后需要分别更改两套代码，独立测试结果，且两个作业需要同步上线。<br>2.资源占用增多：同样的逻辑计算两次，整体资源占用会增多（多出实时计算这部分）</p><h3 id="4-3-Kappa架构"><a href="#4-3-Kappa架构" class="headerlink" title="4.3 Kappa架构"></a>4.3 Kappa架构</h3><p>Lambda架构虽然满足了实时的需求，但带来了更多的开发与运维工作，其架构背景是流处理引擎还不完善，流处理的结果只作为临时的、近似的值提供参考。后来随着Flink等流处理引擎的出现，流处理技术很成熟了，这时为了解决两套代码的问题，LickedIn 的Jay Kreps提出了Kappa架构</p><p>Kappa架构可以认为是Lambda架构的简化版（只要移除lambda架构中的批处理部分即可）。</p><p>在Kappa架构中，需求修改或历史数据重新处理都通过上游重放完成。</p><p>Kappa架构最大的问题是流式重新处理历史的吞吐能力会低于批处理，但这个可以通过增加计算资源来弥补。<br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohl59dz3j20oh0hfjua.jpg" alt="undefined"></p><h4 id="Kappa架构的重新处理过程"><a href="#Kappa架构的重新处理过程" class="headerlink" title="Kappa架构的重新处理过程"></a>Kappa架构的重新处理过程</h4><p>重新处理是人们对Kappa架构最担心的点，但实际上并不复杂：</p><p>1.选择一个具有重放功能的、能够保存历史数据并支持多消费者的消息队列，根据需求设置历史数据保存的时长，比如Kafka，可以保存全部历史数据。<br>2.当某个或某些指标有重新处理的需求时，按照新逻辑写一个新作业，然后从上游消息队列的最开始重新消费，把结果写到一个新的下游表中。<br>3.当新作业赶上进度后，应用切换数据源，读取2中产生的新结果表。<br>4.停止老的作业，删除老的结果表。<br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohljejt5j20lt065q4e.jpg" alt="undefined"></p><h3 id="4-4-Lambda架构与Kappa架构的对比"><a href="#4-4-Lambda架构与Kappa架构的对比" class="headerlink" title="4.4 Lambda架构与Kappa架构的对比"></a>4.4 Lambda架构与Kappa架构的对比</h3><p>对比项    Lambda架构    Kappa架构<br>实时性    实时    实时<br>计算资源    批和流同时运行，资源开销大    只有流处理，仅针对新需求开发阶段运行两个作业，资源开销小<br>重新计算时吞吐    批式全量处理，吞吐较高    流式全量处理，吞吐较批处理低<br>开发、测试    每个需求都需要两套不同代码，开发、测试、上线难度较大    只需实现一套代码，开发、测试、上线难度相对较小<br>运维成本    维护两套系统（引擎），运维成本大    只需维护一套系统（引擎），运维成本小<br>在真实的场景中，很多时候并不是完全规范的Lambda架构或Kappa架构，可以是两者的混合，比如大部分实时指标使用Kappa架构完成计算，少量关键指标（比如金额相关）使用Lambda架构用批处理重新计算，增加一次校对过程。（1）</p><p>Kappa架构并不是中间结果完全不落地，现在很多大数据系统都需要支持机器学习（离线训练），所以实时中间结果需要落地对应的存储引擎供机器学习使用，另外有时候还需要对明细数据查询，这种场景也需要把实时明细层写出到对应的引擎中。（2）参考后面的案例</p><p>另外，随着数据多样性的发展，数据仓库这种提前规定schema的模式显得越来难以支持灵活的探索&amp;分析需求，这时候便出现了一种数据湖技术，即把原始数据全部缓存到某个大数据存储上，后续分析时再根据需求去解析原始数据。简单的说，数据仓库模式是schema on write，数据湖模式是schema on read。（3）<br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohlxfcxnj20ho0ngdiw.jpg" alt="undefined"></p><h2 id="5-实时数仓案例"><a href="#5-实时数仓案例" class="headerlink" title="5.实时数仓案例"></a>5.实时数仓案例</h2><p>菜鸟仓配实时数据仓库<br>本案例参考自菜鸟仓配团队的分享，涉及全局设计、数据模型、数据保障等几个方面。</p><p>注：特别感谢缘桥同学的无私分享。</p><h3 id="5-1-整体设计"><a href="#5-1-整体设计" class="headerlink" title="5.1 整体设计"></a>5.1 整体设计</h3><p>整体设计如右图，基于业务系统的数据，数据模型采用中间层的设计理念，建设仓配实时数仓；计算引擎，选择更易用、性能表现更佳的实时计算作为主要的计算引擎；数据服务，选择天工数据服务中间件，避免直连数据库，且基于天工可以做到主备链路灵活配置秒级切换；数据应用，围绕大促全链路，从活动计划、活动备货、活动直播、活动售后、活动复盘五个维度，建设仓配大促数据体系。<br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohmaxiwvj20o70ftq5z.jpg" alt="undefined"></p><h3 id="5-2-数据模型"><a href="#5-2-数据模型" class="headerlink" title="5.2 数据模型"></a>5.2 数据模型</h3><p>不管是从计算成本，还是从易用性，还是从复用性，还是从一致性……，我们都必须避免烟囱式的开发模式，而是以中间层的方式建设仓配实时数仓。与离线中间层基本一致，我们将实时中间层分为两层。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohnzr8cdj20ki0alq5k.jpg" alt="undefined"></p><p><strong>第一层DWD公共实时明细层</strong></p><p>实时计算订阅业务数据消息队列，然后通过数据清洗、多数据源join、流式数据与离线维度信息等的组合，将一些相同粒度的业务系统、维表中的维度属性全部关联到一起，增加数据易用性和复用性，得到最终的实时明细数据。这部分数据有两个分支，一部分直接落地到ADS，供实时明细查询使用，一部分再发送到消息队列中，供下层计算使用；</p><p><strong>第二层DWS公共实时汇总层</strong></p><p>以数据域+业务域的理念建设公共汇总层，与离线数仓不同的是，这里汇总层分为轻度汇总层和高度汇总层，并同时产出，轻度汇总层写入ADS，用于前端产品复杂的olap查询场景，满足自助分析和产出报表的需求；高度汇总层写入Hbase，用于前端比较简单的kv查询场景，提升查询性能，比如实时大屏等；</p><p>注：</p><p>1.ADS是一款提供OLAP分析服务的引擎。开源提供类似功能的有，Elastic Search、Kylin、Druid等；<br>2.案例中选择把数据写入到Hbase供KV查询，也可根据情况选择其他引擎，比如数据量不多，查询压力也不大的话，可以用mysql<br>3.因主题建模与业务关系较大，这里不做描述</p><h3 id="5-3-数据保障"><a href="#5-3-数据保障" class="headerlink" title="5.3 数据保障"></a>5.3 数据保障</h3><p>集团每年都有双十一等大促，大促期间流量与数据量都会暴增。</p><p>实时系统要保证实时性，相对离线系统对数据量要更敏感，对稳定性要求更高。</p><p>所以为了应对这种场景，还需要在这种场景下做两种准备：</p><p>大促前的系统压测；<br>大促中的主备链路保障；<br><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohpiixpsj20mu0gljto.jpg" alt="undefined"></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geohpptwlsj20o10guad9.jpg" alt="undefined"></p><h2 id="6-实时数仓与离线数仓的对比"><a href="#6-实时数仓与离线数仓的对比" class="headerlink" title="6. 实时数仓与离线数仓的对比"></a>6. 实时数仓与离线数仓的对比</h2><p>  在看过前面的叙述与菜鸟案例之后，我们看一下实时数仓与离线数仓在几方面的对比：</p><p>首先，从架构上，实时数仓与离线数仓有比较明显的区别，实时数仓以Kappa架构为主，而离线数仓以传统大数据架构为主。Lambda架构可以认为是两者的中间态。</p><p>其次，从建设方法上，实时数仓和离线数仓基本还是沿用传统的数仓主题建模理论，产出事实宽表。另外实时数仓中实时流数据的join有隐藏时间语义，在建设中需注意。</p><p>最后，从数据保障看，实时数仓因为要保证实时性，所以对数据量的变化较为敏感。在大促等场景下需要提前做好压测和主备保障工作，这是与离线数据的一个较为明显的区别。</p><p>系列文章：</p><p><a href="https://mp.weixin.qq.com/s/FJBBmlSOj5Gq5ywo3M2TIQ" target="_blank" rel="noopener">数据仓库发展趋势与架构演进（1996-2020)</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;mid=2247483934&amp;idx=1&amp;sn=76b249d26aa2f726ea9c5310d2da9777&amp;chksm=cf343013f843b9056a718ba64b181ee1c6400781ddf747ce38d2c2058b57347bca08275b107c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">系列 | 漫谈数仓第一篇NO.1 『基础架构』</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;mid=2247483973&amp;idx=1&amp;sn=3e5aecbdb26c312b21ae9073cdb0345b&amp;chksm=cf343048f843b95e7a1b3cbcbcb832e3bde9ca416025107b053b7e05319261fde7212ee6302a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">系列 | 漫谈数仓第二篇NO.2 数据模型（维度建模）</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;mid=2247484034&amp;idx=1&amp;sn=6a77c2d5c1f09ad87c10f045cedfaa21&amp;chksm=cf34308ff843b999f87ba9b0bc89fec52173b06e7f9e0f70b07430d603c99593f23c6ca75e12&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">系列 | 漫谈数仓第三篇NO.3 『数据魔法』ETL</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;mid=2247484163&amp;idx=1&amp;sn=f90ff0031e419853948ddaf75db48642&amp;chksm=cf34310ef843b818956ee1a99edf6be754758dd2a0a90a590b95844d72ee6c75afc6215d645a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">系列 | 漫谈数仓第四篇NO.4 『数据应用』（BI&amp;OLAP）</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;mid=2247485171&amp;idx=1&amp;sn=b0ecff938e7236325f2c9d3cdbfcbca0&amp;chksm=cf3434fef843bde88d868aa5952ed043764637513dbde6e6df0a2cb6e62e6c3d006e041f35ed&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">企业数据治理七把利剑</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;数仓要深入了解的话，可能还是得从那几本书入手，这里仅收入几篇经典的总览文，不包含之前已经收录过的美团数仓数据质量&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Hadoop" scheme="http://yoursite.com/categories/Hadoop/"/>
    
      <category term="数仓" scheme="http://yoursite.com/categories/Hadoop/%E6%95%B0%E4%BB%93/"/>
    
    
      <category term="数仓总览" scheme="http://yoursite.com/tags/%E6%95%B0%E4%BB%93%E6%80%BB%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发</title>
    <link href="http://yoursite.com/2020/05/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2020/05/11/java多线程与高并发/</id>
    <published>2020-05-11T06:03:09.692Z</published>
    <updated>2020-05-11T06:02:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此处暂时收集一些常见的面试题，以后针对这块的收集从此处延伸下去并补全</p></blockquote><a id="more"></a> <p>（1）synchronized的CPU原语级别是如何实现的？</p><p>（2）<strong>无锁、偏向锁、轻量级锁、重量级锁</strong>有什么差别，升级过程如何？</p><p>（3）<strong>线程</strong>间通信，<strong>同机器进程</strong>间通信，<strong>跨机器进程</strong>间通信，各有什么方法？</p><p>（4）下列三种业务，应该如何使用线程池：</p><ul><li><strong>高并发、任务执行时间短</strong>的业务</li><li><strong>并发不高、任务执行时间长</strong>的业务</li><li><strong>并发高、业务执行时间长</strong>的业务</li></ul><p>（5）秒杀系统，如何能够撑住100W级别TPS（淘宝最高54万TPS）？</p><p>下面是某网课的内容，笑笑就好</p><p>1、synchronized关键字的字节码原语；</p><p>2、volatile关键字的字节码原语；</p><p>3、synchronized与volatile的硬件级实现；</p><p>4、无锁、偏向锁、轻量级锁、重量级锁的升级过程；</p><p>5、内存屏障的基本概念；</p><p>6、JVM规范如何要求内存屏障；</p><p>7、硬件层级内存屏障如何帮助java实现高并发；</p><p>8、面试第3题（线程间通讯）的8种解法；</p><p>9、作业；</p><p>1、线程池的学与思；</p><p>2、使用线程池的好与不好；</p><p>3、为什么阿里开发手册建议自定义线程池；</p><p>4、自定义线程池的最佳实践；</p><p>5、常见线程池类型与应用场景：</p><p>   1）CachedPool</p><p>   2）FixedThreadPool</p><p>   3）ScheduledPool</p><p>   4）WorkStealingPool</p><p>   5）ForkJoinPool</p><p>6、比线程更牛X的线程，压测结果展现纤程的威力；</p><p>7、总结；</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此处暂时收集一些常见的面试题，以后针对这块的收集从此处延伸下去并补全&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程与高并发" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>美团数据质量监管平台实践</title>
    <link href="http://yoursite.com/2020/05/07/%E7%BE%8E%E5%9B%A2%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F/"/>
    <id>http://yoursite.com/2020/05/07/美团数据质量/</id>
    <published>2020-05-07T10:21:07.584Z</published>
    <updated>2020-05-07T10:29:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据质量干货中的干货</p></blockquote><p> <a href="https://tech.meituan.com/2018/03/21/mtdp-dataman.html" target="_blank" rel="noopener">DataMan-美团旅行数据质量监管平台实践</a></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek26x62b7j20ao0ar74e.jpg" alt="undefined"></p><a id="more"></a> <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>数据，已经成为互联网企业非常依赖的新型重要资产。数据质量的好坏直接关系到信息的精准度，也影响到企业的生存和竞争力。Michael Hammer（《Reengineering the Corporation》一书的作者）曾说过，看起来不起眼的数据质量问题，实际上是拆散业务流程的重要标志。 数据质量管理是测度、提高和验证质量，以及整合组织数据的方法等一套处理准则，而体量大、速度快和多样性的特点，决定了大数据质量所需的处理，有别于传统信息治理计划的质量管理方式。</p><p>本文将基于美团点评大数据平台，通过对数据流转过程中各阶段数据质量检测结果的采集分析、规则引擎、评估反馈和再监测的闭环管理过程出发，从面临挑战、建设思路、技术方案、呈现效果及总结等方面，介绍美团平台酒旅事业群（以下简称美旅）数据质量监管平台DataMan的搭建思路和建设实践。</p><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>美旅数据中心日均处理的离线和实时作业高达数万量级， 如何更加合理、高效的监控每类作业的运行状态，并将原本分散、孤岛式的监控日志信息通过规则引擎集中共享、关联、处理；洞察关键信息，形成事前预判、事中监控、事后跟踪的质量管理闭环流程；沉淀故障问题，搭建解决方案的知识库体系。在数据质量监管平台的规划建设中，面临如下挑战：</p><ul><li>缺乏统一监控视图，离线和实时作业监控分散，影响性、关联性不足。</li><li>数据质量的衡量标准缺失，数据校验滞后，数据口径不统一。</li><li>问题故障处理流程未闭环，“点”式解决现象常在；缺乏统一归档，没有形成体系的知识库。</li><li>数据模型质量监控缺失，模型重复，基础模型与应用模型的关联度不足，形成信息孤岛。</li><li>数据存储资源增长过快，不能监控细粒度资源内容。</li></ul><p>DataMan质量监管平台研发正基于此，以下为具体建设方案。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><p>构建美旅大数据质量监控平台，从可实践运用的视角出发，整合平台资源、技术流程核心要点，重点着力平台支持、技术控制、流程制度、知识体系形成等方向建设，确保质量监控平台敏捷推进落地的可行性。数据质量监控平台整体框架如图1所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek27gduukj219k10sgpi.jpg" alt="undefined"></p><h3 id="建设方法"><a href="#建设方法" class="headerlink" title="建设方法"></a>建设方法</h3><p>以数据质量检核管理PDCA方法论，基于美团大数据平台，对数据质量需求和问题进行全质量生命周期的管理，包括质量问题的定义、检核监控、发现分析、跟踪反馈及知识库沉淀。数据质量PDCA流程图如图2所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek27y11kbj21eq0loacq.jpg" alt="undefined"></p><p><strong>关键流程：</strong></p><p>质量监管平台建设实践应用及价值体现，离不开管理流程、技术实现和组织人员的紧密结合，主要包含如下8大流程步骤：</p><ol><li>质量需求：发现数据问题；信息提报、收集需求；检核规则的需求等。</li><li>提炼规则：梳理规则指标、确定有效指标、检核指标准确度和衡量标准。</li><li>规则库构建：检核对象配置、调度配置、规则配置、检核范围确认、检核标准确定等。</li><li>执行检核：调度配置、调度执行、检核代码。</li><li>问题检核：检核问题展示、分类、质量分析、质量严重等级分类等。</li><li>分析报告：数据质量报告、质量问题趋势分析，影响度分析，解决方案达成共识。</li><li>落实处理：方案落实执行、跟踪管理、解决方案Review及标准化提炼。</li><li>知识库体系形成：知识经验总结、标准方案沉淀、知识库体系建设。</li></ol><h3 id="质量检核标准"><a href="#质量检核标准" class="headerlink" title="质量检核标准"></a>质量检核标准</h3><ul><li>完整性：主要包括实体缺失、属性缺失、记录缺失和字段值缺失四个方面；</li><li>准确性：一个数据值与设定为准确的值之间的一致程度，或与可接受程度之间的差异；</li><li>合理性：主要包括格式、类型、值域和业务规则的合理有效；</li><li>一致性：系统之间的数据差异和相互矛盾的一致性，业务指标统一定义，数据逻辑加工结果一致性；</li><li>及时性：数据仓库ETL、应用展现的及时和快速性，Jobs运行耗时、运行质量、依赖运行及时性。</li></ul><p>大数据平台下的质量检核标准更需考虑到大数据的快变化、多维度、定制化及资源量大等特性，如数仓及应用BI系统的质量故障等级分类、数据模型热度标准定义、作业运行耗时标准分类等和数仓模型逻辑分层及主题划分组合如下图3所示。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek287x6r7j21j00sagoa.jpg" alt="undefined"></p><p>美旅数仓划分为客服、流量、运营、订单、门店、产品、参与人、风控、结算和公用等十大主题，按Base、Fact、Topic、App逻辑分层，形成体系化的物理模型。从数据价值量化、存储资源优化等指标评估，划分物理模型为热、温、冷、冰等四类标准，结合应用自定义其具体标准范围，实现其灵活性配置；作业运行耗时分为：优、良、一般、关注、耗时等，每类耗时定义的标准范围既符合大数据的特性又可满足具体分析需要，且作业耗时与数仓主题和逻辑分层深度整合，实现多角度质量洞察评估；针对数万的作业信息从数据时效性、作业运行等级、服务对象范围等视角，将其故障等级分为：</p><ul><li>S1：严重度极高；</li><li>S2：严重度高；</li><li>S3：严重度中；</li><li>S4：严重度低等四项标准。</li></ul><p>各项均对应具体的实施策略。整体数据质量的检核对象包括离线数仓和实时数据。</p><h3 id="监管核心点"><a href="#监管核心点" class="headerlink" title="监管核心点"></a>监管核心点</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek28hn1nlj20yc0tm77v.jpg" alt="undefined"></p><p>数据质量功能模块设计的主要功能如上图4所示，包括：监控对象管理、检核指标管理、数据质量过程监控、问题跟踪管理、推荐优化管理、知识库管理及系统管理等。其中过程监控包括离线数据监控、实时数据监控；问题跟踪处理由问题发现（支持自动检核、人工录入）、问题提报、任务推送、故障定级、故障处理、知识库沉淀等形成闭环流程。</p><h3 id="管理流程"><a href="#管理流程" class="headerlink" title="管理流程"></a>管理流程</h3><p>流程化管理是推进数据问题从发现、跟踪、解决到总结提炼的合理有效工具。质量管理流程包括：数据质量问题提报、数据质量问题分析、故障跟踪、解决验证、数据质量评估分析等主要环节步骤；从干系人员的角度分析包括数据质量管理人员、数据质量检查人员、数据平台开发人员、业务及BI商分人员等，从流程步骤到管理人员形成职责和角色的矩阵图。如图5所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek28rlex5j227o0zidkb.jpg" alt="undefined"></p><p><strong>问题汇总</strong>：数据质量提报、ETL处理及监控过程上报、数据质量检查点等多方来源，其中ETL处理部分为程序自动化上报，减少人为干预。 <strong>问题分析</strong>：通过规定的角色和岗位的人员对汇总问题分析和评估，由统一公共账号自动推送提醒消息至责任人。 <strong>问题工单</strong>：对采集的问题经过分析归类，主要划为信息提示和故障问题两大类，信息提示无需工单生成，故障问题将产生对应的工单，后推送至工单处理人。 <strong>故障定级</strong>： 针对生成的问题工单判断其故障级别，其级别分为：S1、S2、S3、S4等四类（如图3所述），针对尤为严重的故障问题需Review机制并持续跟踪CaseStudy总结。 <strong>知识库体系</strong>：从由数据问题、解决方案、典型案例等内容中，提炼总结形成标准化、完备知识库体系，以质量问题中提炼价值，形成标准，更加有效的指导业务、规范业务，提高源头数据质量，提升业务服务水平。</p><p><strong>质量流程管理：</strong></p><ul><li><strong>流程原则</strong>：统一流程、步骤稳定。</li><li><strong>权限控制</strong>：流程节点与人员账户号绑定，若节点未设置人员账户即面向所有人员，否则为规定范围的人员。</li><li><strong>权限管理</strong>：可结合美团平台的UPM系统权限管理机制。</li></ul><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><p>DataMan系统建设总体方案基于美团的大数据技术平台。自底向上包括：检测数据采集、质量集市处理层；质量规则引擎模型存储层；系统功能层及系统应用展示层等。整个数据质量检核点基于技术性、业务性检测，形成完整的数据质量报告与问题跟踪机制，创建质量知识库，确保数据质量的完整性（Completeness）、正确性（Correctness）、当前性（Currency）、一致性（Consistency）。</p><p><strong>总体架构图如图6所示：</strong></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek297pe8qj212k0pa0z1.jpg" alt="undefined"></p><ul><li><strong>数据源及集市层</strong>：首先采集数据平台质量相关的元数据信息、监控日志信息、实时日志、检测配置中心日志、作业日志及调度平台日志等关键的质量元数据；经数据质量集市的模型设计、监控对象的分类，加工形成完整、紧关联、多维度、易分析的数据质量基础数据模型，为上层质量应用分析奠定数据基础。数据来源自大数据平台、实时数仓、调度平台等，涉及到Hive、 Spark、Storm、 Kafka、MySQL及BI应用等相关平台数据源；</li><li><strong>存储模型层</strong>：主要功能包括规则引擎数据配置、质量模型结果存储；以数据质量监控、影响关联、全方位监控等目标规则引擎的推动方式，将加工结果数据存储至关系型数据库中，构成精简高质数据层；</li><li><strong>系统功能层</strong>：包括配置管理、过程监控、问题跟踪、故障流程管理、实时数据监控、知识库体系的创建等；处理的对象包括日志运行作业、物理监控模型、业务监控模型等主要实体；</li><li><strong>系统展示层</strong>：通过界面化方式管理、展示数据质量状态，包括质量监控界面、推荐优化模块、质量分析、信息展示、问题提报、故障跟踪及测量定级、系统权限管理等功能。</li></ul><h3 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a>技术框架</h3><h4 id="前后端技术"><a href="#前后端技术" class="headerlink" title="前后端技术"></a>前后端技术</h4><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek29h0s2vj222i0s6q5e.jpg" alt="undefined"></p><p>DataMan应用系统其前端框架（如上图7）基于Bootstrap开发，模板引擎为FreeMarker，Tomcat（开发环境）作为默认Web容器，通过MVC的方式实现与应用服务层对接。Bootstrap的优势基于jQuery，丰富的CSS、JS组件，兼容多种浏览器，界面风格统一等；FreeMarker为基于模板用来生成输出文本的引擎。后台基于开源框架Spring4，Spring Boot，Hibernate搭建，其集成了Druid，Apache系列和Zebra等数据库访问中间件等，为系统的功能开发带来更多选择和便利。</p><h4 id="Zebra中间件"><a href="#Zebra中间件" class="headerlink" title="Zebra中间件"></a>Zebra中间件</h4><p>系统数据库连接采用中间件Zebra，这是美团点评DBA团队推荐的官方数据源组件，基于JDBC、API协议上开发出的高可用、高性能的数据库访问层解决方案；提供如动态配置、监控、读写分离、分库分表等功能。Zebra整体架构如图8所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek29q9kb8j213e0aaq3z.jpg" alt="undefined"></p><p>Zebra客户端会据路由配置直连到MySQL数据库进行读写分离和负载均衡。RDS是一站式的数据库管理平台，提供Zebra的路由配置信息的维护；MHA组件和从库监控服务分别负责主库和从库的高可用。Zebra支持丰富的底层连接池；统一源数据配置管理；读写分离和分库分表；数据库的高可用。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>整个质量监管平台数据流向为数据质量元数据信息采集于美团平台，包括数据仓库元数据信息、质量检测元数据、调度平台日志信息、监控日志及实时元数据信息等，加工形成独立数据质量的集市模型，以此支撑应用层系统的数据需求。应用层系统数据库采用关系型数据库存储的方式，主要包含了规则配置管理信息、数据质量结果库等信息内容。数据流向层级关系图如下：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek2aduwn6j20zq0pk0ug.jpg" alt="undefined"></p><p><strong>数据平台层</strong>：基于美团大数据平台的数据质量元数据是质量分析和监管的来源，是整个系统最基础重要资源信息，此数据主要包括：数仓元数据信息，如数仓模型表基本信息、表存储空间资源信息、表分区信息、节点信息、数据库meta信息、数据库资源信息等；运行作业调度日志信息，如作业基本信息、作业运行资源信息、作业调度状态信息、作业依赖关系信息及作业调度日志监控信息等；质量检测元数据信息主要来源于SLA、DQC（美团内部系统）检测结果的信息。实时元数据采集于调度平台实时作业运行的API接口调用分析。</p><p><strong>质量集市层</strong>：DM数据质量集市的独立创建是依托基础元数据信息，根据质量监管平台配置的引擎规则ETL加工形成。规则库引擎如数仓应用主题的划分规则、数仓逻辑分层约束、数据库引擎分类、模型使用热度等级、模型存储空间分类、资源增长等级、历史周期分类、作业重要级别、作业运行耗时等级、作业故障分类、及数据质量标准化定义等；在管理方向上，如模型或作业所属的业务条线、组织架构、开发人员等；在时效上分为离线监控数据、实时数据集市等。从多个维度交叉组合分析形成模型类、作业类、监控日志类、实时类等主题的等易理解、简单、快捷的数据质量集市层，强有力的支撑上层应用层功能的数据需求。数据质量集市DM主要模型如图10所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek2apc2nvj20uu10mtc8.jpg" alt="undefined"></p><ul><li>模型设计：“统一规范、简单快捷、快速迭代、保障质量”，基于美团平台元数据、平台日志、实时数据接口等来源，通过制定的规则、标准，形成可衡量、可评估的数据质量集市层，主要包含公共维度类、模型分析类、作业监控类、平台监控类等主要内容；</li><li>实时数据：针对实时作业的监控通过API接口调用，后落地数据，实时监控作业运行日志状态；</li><li>数据加工：基于美团平台离线Hive、Spark引擎执行调度，以数仓模型分层、数仓十大主题规则和数据质量规则库等为约束条件，加工形成独立的数据集市层。</li></ul><p><strong>应用分析层</strong>：应用层系统数据采用关系型数据库（MySQL）存储的方式，主要包含了规则配置管理信息、数据质量分析结果、实时API落地数据、故障问题数据、知识库信息、流程管理及系统管理类等信息内容，直接面对前端界面的展示和管理。</p><h2 id="系统展示"><a href="#系统展示" class="headerlink" title="系统展示"></a>系统展示</h2><p>数据质量DataMan监控系统一期建设主要实现的功能包括：个人工作台、信息监控、推荐信息、信息提报、故障管理、配置管理及权限系统管理等。系统效果如图11所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek2b855vuj21zk0wgdkz.jpg" alt="undefined"></p><h3 id="个人工作台"><a href="#个人工作台" class="headerlink" title="个人工作台"></a>个人工作台</h3><p>在系统中将个人待关注、待处理、待优化、待总结等与个人相关的问题和任务形成统一的工作平台入口，通过公共账号推送的方式，第一时间提醒个人，通知反馈问题的提出者，保障问题可跟踪，进度可查询，责任到人的工作流程机制。</p><h3 id="离线监控"><a href="#离线监控" class="headerlink" title="离线监控"></a>离线监控</h3><p>系统可定时执行模型监控、作业监控、平台日志监控等元数据质量规则引擎，开展数据仓库主题模型、逻辑层级作业、存储资源空间、作业耗时、CPU及内存资源等细化深度分析和洞察；按照质量分析模型，以时间、增长趋势、同环比、历史基线点等多维度、全面整合打造统一监控平台。</p><h3 id="实时监控"><a href="#实时监控" class="headerlink" title="实时监控"></a>实时监控</h3><p>从应用角度将作业按照业务条线、数仓分层、数仓主题、组织结构和人员等维度划分，结合作业基线信息，实时监控正在运行的作业质量，并与作业基线形成对比参照，预警不符合标准的指标信息，第一时间通知责任人。实时作业运行与基线对比监控效果如图12所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gek2bkc9p3j21iy11o43f.jpg" alt="undefined"></p><h3 id="推荐信息"><a href="#推荐信息" class="headerlink" title="推荐信息"></a>推荐信息</h3><p>系统通过规则引擎的设置和自动调度的执行，从存储资源配置、数据模型优化、作业优化、日志错误超时、预警通知等方面考虑，以制定的质量标准为评估依据，自动检测评估，汇总问题，形成可靠的推荐优化内容，并在达到阈值条件后主动推送消息，触发后续任务开展。</p><h3 id="公共账号"><a href="#公共账号" class="headerlink" title="公共账号"></a>公共账号</h3><p>通过“数据治理公共账号”机器人发送消息模式，将预判触发的预警通知、任务分配、任务提醒和风险评估等信息第一时间通知相应的负责人员，开启工作流程。</p><h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><p>支持自动提报和人工填报两种模式，以闭环工作流方式开展工作，确保问题故障可跟踪、可查询、可定级、可考核、可量化，以责任到人、落地可行的处理模式，严控数据质量，从根本上提高数据质量，提升业务服务水平。</p><p>DataMan质量监管系统的投入运营，优化数据存储资源、提高作业性能、降低任务耗时、推进了管理工作的规范化和精细化。信息推荐功能以推送通知的形式将待优化、存风险和超时故障信息第一时间发送个人工作台，以工作流机制推动开展；模型监控、作业监控功能在数据存储、模型建设、作业耗时等场景合理的控制资源，节省了投资成本。 问题提报和故障管理功能的有效结合，将问题发现、提报、任务分配、处理完成及Review总结沉淀等形成了责任到人、问题可询的闭环流程。随着系统的深入运行，将在实时数据监控、质量故障统计管理、数据质量考核机制、数据资产质量权威报告、知识库体系标准化及流程深化管理等功能方面持续推进和发挥价值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据质量是数据治理建设的重要一环，与元数据管理、数据标准化及数据服务管理等共同构建了数据治理的体系框架。建设一个完整DataMan质量监管平台，将从监控、标准、流程制度等方面提升信息管理能力，优先解决所面临的数据质量和数据服务问题，其效果体现以下几个方面：</p><ul><li>监控数据资产质量状态，为优化数据平台和数据仓库性能、合理配置数据存储资源提供决策支持；</li><li>持续推动数据质量监控优化预警、实时监控的机制；</li><li>重点优先监控关键核心数据资产，管控优化20%核心资源，可提升80%需求应用性能；</li><li>规范了问题故障的跟踪、Review、优化方案。从数据中提炼价值，从方案中形成标准化的知识体系；</li><li>由技术检测到业务监督，形成闭环工作流机制，提高整体数据质量，全面提升服务业务水平。</li></ul><p>数据质量是数据仓库建设、数据应用建设和决策支持的关键因素，可通过完善组织架构和管理流程，加强部门间衔接和协调，严格按照标准或考核指标执行落地，确保数据质量方能将数据的商业价值最大化，进而提升企业的核心竞争力和保持企业的可持续发展。</p><h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><p>最后插播一个招聘广告，我们是一群擅长大数据领域数据建设、数仓建设、数据治理及数据BI应用建设的工程师，期待更多能手加入，有兴趣的同学可以发邮件给yangguang09#meituan.com，zhangdexiao#meituan.com。</p><h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><ul><li>德晓，美团点评数仓专家、大数据高级工程师，长期从事数据仓库、数据建模、数据治理、大数据方向系统实践建设等，现为美团点评大交通数据仓库建设负责人。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;数据质量干货中的干货&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;a href=&quot;https://tech.meituan.com/2018/03/21/mtdp-dataman.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DataMan-美团旅行数据质量监管平台实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gek26x62b7j20ao0ar74e.jpg&quot; alt=&quot;undefined&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Reading Notes" scheme="http://yoursite.com/categories/Reading-Notes/"/>
    
    
      <category term="数据质量" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Flink Table &amp; SQL</title>
    <link href="http://yoursite.com/2020/05/07/Flink%20Table%20&amp;%20SQL%20%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2020/05/07/Flink Table &amp; SQL 概览/</id>
    <published>2020-05-07T02:43:59.762Z</published>
    <updated>2020-05-07T06:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Flink Table 和 SQL 整体的脉络</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gejppurwd5j20ib046t9h.jpg" alt="3.png"></p><a id="more"></a> <h1 id="Flink-Table-amp-SQL"><a href="#Flink-Table-amp-SQL" class="headerlink" title="Flink Table &amp; SQL"></a>Flink Table &amp; SQL</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>依赖没啥好说的，要想一下的是Zeppelin是否需要手动把这些依赖全都加上去</p><h2 id="两种Planner的区别"><a href="#两种Planner的区别" class="headerlink" title="两种Planner的区别"></a>两种Planner的区别</h2><ul><li>最大区别 流批一体，blink不支持和dataset之间的转换了</li><li>取消了BatchTableSource，使用有界的StreamTableSource</li><li>Blink只支持全新的catalog，旧的ExternalCatalog不再支持</li><li>基于字符串的键值配置选项仅适用于Blink planner</li><li>PlannerConfig在两个planner中的实现不同</li><li>Blink planner会将多个sink优化在一个DAG中（仅在TableEnvironment上受支持，而在StreamTableEnvironment上不受支持）。而旧planner的优化总是将每一个sink放在一个新的DAG中，其中所有DAG彼此独立</li><li>旧的planner不支持目录统计，而Blink planner支持</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="基本程序结构"><a href="#基本程序结构" class="headerlink" title="基本程序结构"></a>基本程序结构</h3><p>Table API 和 SQL 的程序结构，与流式处理的程序结构类似；也可以近似地认为有这么几步：首先创建执行环境，然后定义source、transform和sink</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tableEnv = ...     <span class="comment">// 创建表的执行环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一张表，用于读取数据</span></span><br><span class="line">tableEnv.connect(...).createTemporaryTable(<span class="string">"inputTable"</span>)</span><br><span class="line"><span class="comment">// 注册一张表，用于把计算结果输出</span></span><br><span class="line">tableEnv.connect(...).createTemporaryTable(<span class="string">"outputTable"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Table API 查询算子，得到一张结果表</span></span><br><span class="line"><span class="keyword">val</span> result = tableEnv.from(<span class="string">"inputTable"</span>).select(...)</span><br><span class="line"><span class="comment">// 通过 SQL查询语句，得到一张结果表</span></span><br><span class="line"><span class="keyword">val</span> sqlResult  = tableEnv.sqlQuery(<span class="string">"SELECT ... FROM inputTable ..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果表写入输出表中</span></span><br><span class="line">result.insertInto(<span class="string">"outputTable"</span>)</span><br></pre></td></tr></table></figure><h3 id="创建表环境"><a href="#创建表环境" class="headerlink" title="创建表环境"></a>创建表环境</h3><p>创建表环境最简单的方式，就是基于流处理执行环境，调create方法直接创建:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tableEnv = <span class="type">StreamTableEnvironment</span>.create(env)</span><br></pre></td></tr></table></figure><p>表环境（TableEnvironment）是flink中集成Table API &amp; SQL的核心概念。它负责:</p><ul><li>注册catalog</li><li>在内部 catalog 中注册表</li><li>执行SQL查询</li><li>注册用户自定义函数</li><li>将DataStream或DataSet转换成表</li><li>保存对ExecutionEnvironment或者StreamExecutionEnvironment的引用</li></ul><p>在创建TableEnv的时候，可以多传入一个EnvironmentSettings 或者 TableConfig 参数，可以用来配置tEnv的一些特性</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> settings = <span class="type">EnvironmentSettings</span>.newInstance()</span><br><span class="line">  .useOldPlanner()      <span class="comment">// 使用老版本planner</span></span><br><span class="line">  .inStreamingMode()    <span class="comment">// 流处理模式</span></span><br><span class="line">  .build()</span><br><span class="line"><span class="keyword">val</span> tableEnv = <span class="type">StreamTableEnvironment</span>.create(env, settings)</span><br></pre></td></tr></table></figure><p>基于老版本的批处理环境（Flink-Batch-Query）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> batchEnv = <span class="type">ExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"><span class="keyword">val</span> batchTableEnv = <span class="type">BatchTableEnvironment</span>.create(batchEnv)</span><br></pre></td></tr></table></figure><p>基于blink版本的流处理环境(Blink-Streaming-Query):</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bsSettings = <span class="type">EnvironmentSettings</span>.newInstance()</span><br><span class="line">.useBlinkPlanner()</span><br><span class="line">.inStreamingMode().build()</span><br><span class="line"><span class="keyword">val</span> bsTableEnv = <span class="type">StreamTableEnvironment</span>.create(env, bsSettings)</span><br></pre></td></tr></table></figure><p>基于Blink版本的批处理环境(Blink-Batch-Query)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bbSettings = <span class="type">EnvironmentSettings</span>.newInstance()</span><br><span class="line">.useBlinkPlanner()</span><br><span class="line">.inBatchMode().build()</span><br><span class="line"><span class="keyword">val</span> bbTableEnv = <span class="type">TableEnvironment</span>.create(bbSettings)</span><br></pre></td></tr></table></figure><h3 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h3><p>TableEnvironment可以注册目录Catalog，并可以基于Catalog注册表。它会维护一个Catalog-Table表之间的map。</p><p>表（Table）是由一个“标识符”来指定的，由3部分组成：Catalog名、数据库（database）名和对象名（表名）。如果没有指定目录或数据库，就使用当前的默认值。</p><p>表可以是常规的（Table，表），或者虚拟的（View，视图）。常规表（Table）一般可以用来描述外部数据，比如文件、数据库表或消息队列的数据，也可以直接从 DataStream转换而来。视图可以从现有的表中创建，通常是table API或者SQL查询的一个结果。</p><h3 id="连接到文件系统（CSV）"><a href="#连接到文件系统（CSV）" class="headerlink" title="连接到文件系统（CSV）"></a>连接到文件系统（CSV）</h3><p>连接外部系统在Catalog中注册表，直接调用tableEnv.connect()就可以，里面参数要传入一个ConnectorDescriptor，也就是connector描述器。对于文件系统的connector而言，flink内部已经提供了，就叫做FileSystem()。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tableEnv</span><br><span class="line">.connect( <span class="keyword">new</span> <span class="type">FileSystem</span>().path(<span class="string">"sensor.txt"</span>))  <span class="comment">// 定义表数据来源，外部连接</span></span><br><span class="line">  .withFormat(<span class="keyword">new</span> <span class="type">OldCsv</span>())    <span class="comment">// 定义从外部系统读取数据之后的格式化方法</span></span><br><span class="line">  .withSchema( <span class="keyword">new</span> <span class="type">Schema</span>()</span><br><span class="line">    .field(<span class="string">"id"</span>, <span class="type">DataTypes</span>.<span class="type">STRING</span>())</span><br><span class="line">    .field(<span class="string">"timestamp"</span>, <span class="type">DataTypes</span>.<span class="type">BIGINT</span>())</span><br><span class="line">    .field(<span class="string">"temperature"</span>, <span class="type">DataTypes</span>.<span class="type">DOUBLE</span>())</span><br><span class="line">  )    <span class="comment">// 定义表结构</span></span><br><span class="line">  .createTemporaryTable(<span class="string">"inputTable"</span>)    <span class="comment">// 创建临时表</span></span><br></pre></td></tr></table></figure><p>这是旧版本的csv格式描述器。由于它是非标的，跟外部系统对接并不通用，所以将被弃用，以后会被一个符合RFC-4180标准的新format描述器取代。新的描述器就叫Csv()，但flink没有直接提供，需要引入依赖flink-csv：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flink-csv&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.10.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>代码非常类似，只需要把withFormat里的OldCsv改成Csv就可以了。</p><h3 id="连接到Kafka"><a href="#连接到Kafka" class="headerlink" title="连接到Kafka"></a>连接到Kafka</h3><p>kafka的连接器flink-kafka-connector中，1.10版本的已经提供了Table API的支持。我们可以在 connect方法中直接传入一个叫做Kafka的类，这就是kafka连接器的描述器ConnectorDescriptor</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.connect(</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Kafka</span>()</span><br><span class="line">    .version(<span class="string">"0.11"</span>) <span class="comment">// 定义kafka的版本</span></span><br><span class="line">    .topic(<span class="string">"sensor"</span>) <span class="comment">// 定义主题</span></span><br><span class="line">    .property(<span class="string">"zookeeper.connect"</span>, <span class="string">"localhost:2181"</span>) </span><br><span class="line">    .property(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>)</span><br><span class="line">)</span><br><span class="line">  .withFormat(<span class="keyword">new</span> <span class="type">Csv</span>())</span><br><span class="line">  .withSchema(<span class="keyword">new</span> <span class="type">Schema</span>()</span><br><span class="line">  .field(<span class="string">"id"</span>, <span class="type">DataTypes</span>.<span class="type">STRING</span>())</span><br><span class="line">  .field(<span class="string">"timestamp"</span>, <span class="type">DataTypes</span>.<span class="type">BIGINT</span>())</span><br><span class="line">  .field(<span class="string">"temperature"</span>, <span class="type">DataTypes</span>.<span class="type">DOUBLE</span>())</span><br><span class="line">)</span><br><span class="line">  .createTemporaryTable(<span class="string">"kafkaInputTable"</span>)</span><br></pre></td></tr></table></figure><p>当然也可以连接到ElasticSearch、MySql、HBase、Hive等外部系统，实现方式基本上是类似的。</p><h3 id="表的查询"><a href="#表的查询" class="headerlink" title="表的查询"></a>表的查询</h3><p>利用外部系统的连接器connector，我们可以读写数据，并在环境的Catalog中注册表。接下来就可以对表做查询转换了。</p><p>Flink给我们提供了两种查询方式：Table API和 SQL。</p><h3 id="TableAPI的调用"><a href="#TableAPI的调用" class="headerlink" title="TableAPI的调用"></a>TableAPI的调用</h3><p>Table API是集成在Scala和Java语言内的查询API。与SQL不同，Table API的查询不会用字符串表示，而是在宿主语言中一步一步调用完成的。</p><p>Table API基于代表一张“表”的Table类，并提供一整套操作处理的方法API。这些方法会返回一个新的Table对象，这个对象就表示对输入表应用转换操作的结果。有些关系型转换操作，可以由多个方法调用组成，构成链式调用结构。例如table.select(…).filter(…)，其中select（…）表示选择表中指定的字段，filter(…)表示筛选条件。</p><p>代码中的实现如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sensorTable: <span class="type">Table</span> = tableEnv.from(<span class="string">"inputTable"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> resultTable: <span class="type">Table</span> = senorTable</span><br><span class="line">.select(<span class="string">"id, temperature"</span>)</span><br><span class="line">.filter(<span class="string">"id ='sensor_1'"</span>)</span><br></pre></td></tr></table></figure><h3 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h3><p>Flink的SQL集成，基于的是<code>ApacheCalcite</code>，</p><p>它实现了SQL标准。</p><p>在Flink中，用常规字符串来定义SQL查询语句。</p><p>SQL 查询的结果，是一个新的 Table。</p><p>代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultSqlTable: <span class="type">Table</span> = tableEnv.sqlQuery(<span class="string">"select id, temperature from inputTable where id ='sensor_1'"</span>)</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultSqlTable: <span class="type">Table</span> = tableEnv.sqlQuery(</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    |select id, temperature</span></span><br><span class="line"><span class="string">    |from inputTable</span></span><br><span class="line"><span class="string">    |where id = 'sensor_1'</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span>.stripMargin)</span><br></pre></td></tr></table></figure><p>当然，也可以加上聚合操作，比如我们统计每个sensor温度数据出现的个数，做个count统计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val aggResultTable = sensorTable</span><br><span class="line">    .groupBy(&apos;id)</span><br><span class="line">    .select(&apos;id, &apos;id.count as &apos;count)</span><br></pre></td></tr></table></figure><p>SQL:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aggResultSqlTable = tableEnv.sqlQuery(<span class="string">"select id, count(id) as cnt from inputTable group by id"</span>)</span><br></pre></td></tr></table></figure><p>这里Table API里指定的字段，前面加了一个单引号’，这是Table API中定义的Expression类型的写法，可以很方便地表示一个表中的字段。</p><p>字段可以直接全部用双引号引起来，也可以用半边单引号+字段名的方式。以后的代码中，一般都用后一种形式。</p><h3 id="将DataStream转换成表"><a href="#将DataStream转换成表" class="headerlink" title="将DataStream转换成表"></a>将DataStream转换成表</h3><p>Flink允许我们把Table和DataStream做转换：</p><p>我们可以基于一个DataStream，</p><p>先流式地读取数据源，</p><p>然后map成样例类，</p><p>再把它转成Table。</p><p>Table的列字段（column fields），</p><p>就是样例类里的字段，</p><p>这样就不用再麻烦地定义schema了。</p><p><strong>Code</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val inputStream: DataStream[String] = env.readTextFile(&quot;sensor.txt&quot;)</span><br><span class="line">val dataStream: DataStream[SensorReading] = inputStream</span><br><span class="line">  .map(data =&gt; &#123;</span><br><span class="line">    val dataArray = data.split(&quot;,&quot;)</span><br><span class="line">    SensorReading(dataArray(0), dataArray(1).toLong, dataArray(2).toDouble)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">val sensorTable: Table = tableEnv.fromDataStream(dataStream)</span><br><span class="line"></span><br><span class="line">val sensorTable2 = tableEnv.fromDataStream(dataStream, &apos;id, &apos;timestamp as &apos;ts)</span><br></pre></td></tr></table></figure><h3 id="数据类型与-Table-schema的对应"><a href="#数据类型与-Table-schema的对应" class="headerlink" title="数据类型与 Table schema的对应"></a>数据类型与 Table schema的对应</h3><p>在上面的例子中，DataStream 中的数据类型，与表的 Schema 之间的对应关系，是按照样例类中的字段名来对应的（name-based mapping），所以还可以用as做重命名。</p><p>另外一种对应方式是，直接按照字段的位置来对应（position-based mapping），对应的过程中，就可以直接指定新的字段名了。</p><p><strong>基于名称的对应</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sensorTable = tableEnv.fromDataStream(dataStream, <span class="symbol">'timestamp</span> as <span class="symbol">'ts</span>, <span class="symbol">'id</span> as <span class="symbol">'myId</span>, <span class="symbol">'temperature</span>)</span><br></pre></td></tr></table></figure><p><strong>基于位置的对应</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sensorTable = tableEnv.fromDataStream(dataStream, <span class="symbol">'myId</span>, <span class="symbol">'ts</span>)</span><br></pre></td></tr></table></figure><p>Flink的DataStream和DataSet API支持多种类型。</p><p>组合类型，比如元组（内置Scala和Java元组）、POJO、Scala case类和Flink的Row类型等，允许具有多个字段的嵌套数据结构，这些字段可以在Table的表达式中访问。其他类型，则被视为原子类型。</p><p>元组类型和原子类型，一般用位置对应会好一些；如果非要用名称对应，也是可以的：</p><p>元组类型，默认的名称是 “_1”, “_2”；而原子类型，默认名称是 ”f0”。</p><h3 id="创建临时视图（Temporary-View）"><a href="#创建临时视图（Temporary-View）" class="headerlink" title="创建临时视图（Temporary View）"></a>创建临时视图（Temporary View）</h3><p>创建临时视图的第一种方式，就是直接从DataStream传唤而来。同样，可以直接对应字段转换；也可以在转换的时候，指定相应的字段。</p><p><strong>Code</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">"sensorView"</span>, dataStream)</span><br><span class="line">tableEnv.createTemporaryView(<span class="string">"sensorView"</span>, dataStream, <span class="symbol">'id</span>, <span class="symbol">'temperature</span>, <span class="symbol">'timestamp</span> as <span class="symbol">'ts</span>)</span><br></pre></td></tr></table></figure><p>另外，当然还可以基于Table创建视图：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">"sensorView"</span>, sensorTable)</span><br></pre></td></tr></table></figure><p>View和Table的Schema完全相同。事实上，在Table API中，可以认为View和Table是等价的。</p><h3 id="输出表"><a href="#输出表" class="headerlink" title="输出表"></a>输出表</h3><p>表的输出，是通过将数据写入 TableSink 来实现的。TableSink 是一个通用接口，可以支持不同的文件格式、存储数据库和消息队列。</p><p>具体实现，输出表最直接的方法，就是通过 Table.insertInto() 方法将一个 Table 写入注册过的 TableSink 中。</p><p>输出到文件</p><p><strong>Code</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册输出表</span></span><br><span class="line">tableEnv.connect(</span><br><span class="line">  <span class="keyword">new</span> <span class="type">FileSystem</span>().path(<span class="string">"…\\resources\\out.txt"</span>)</span><br><span class="line">) <span class="comment">// 定义到文件系统的连接</span></span><br><span class="line">  .withFormat(<span class="keyword">new</span> <span class="type">Csv</span>()) <span class="comment">// 定义格式化方法，Csv格式</span></span><br><span class="line">  .withSchema(<span class="keyword">new</span> <span class="type">Schema</span>()</span><br><span class="line">  .field(<span class="string">"id"</span>, <span class="type">DataTypes</span>.<span class="type">STRING</span>())</span><br><span class="line">  .field(<span class="string">"temp"</span>, <span class="type">DataTypes</span>.<span class="type">DOUBLE</span>())</span><br><span class="line">) <span class="comment">// 定义表结构</span></span><br><span class="line">  .createTemporaryTable(<span class="string">"outputTable"</span>) <span class="comment">// 创建临时表</span></span><br><span class="line"></span><br><span class="line">resultSqlTable.insertInto(<span class="string">"outputTable"</span>)</span><br></pre></td></tr></table></figure><h3 id="更新模式"><a href="#更新模式" class="headerlink" title="更新模式"></a>更新模式</h3><p>在流处理过程中，表的处理并不像传统定义的那样简单。</p><p>对于流式查询（Streaming Queries），需要声明如何在（动态）表和外部连接器之间执行转换。与外部系统交换的消息类型，由<strong>更新模式</strong>（update mode）指定。</p><p>Flink Table API中的更新模式有以下三种：</p><p><strong>1) 追加模式 Append Mode</strong></p><p>在追加模式下，表（动态表）和外部连接器只插入（Insert）消息。</p><p><strong>2)撤回模式 Retract Mode</strong></p><p>撤回模式下，表和外部连接器交换的是：添加ADD 和撤回Retract 消息。</p><p>插入（Insert）会被编码为添加消息。</p><p>删除（Delete）则编码为撤回消息。</p><p>更新（Update）则会编码为。已更新行（上一行）的撤回消息，和更新行（新行）的添加消息。</p><p>从模式下，不能定义key，这一点跟upsert模式完全不同。</p><p><strong>3)更新插入模式 Upsert</strong></p><p>在Upsert模式下，动态表和外部连接器交换Upsert和Delete消息。</p><p>这个模式需要一个唯一的key，通过这个key可以传递更新消息。为了正确应用消息，外部连接器需要知道这个唯一key的属性。</p><ul><li><p>插入（Insert）和更新（Update）都被编码为Upsert消息；</p></li><li><p>删除（Delete）编码为Delete信息。</p></li></ul><p>这种模式和Retract模式的主要区别在于，Update操作是用单个消息编码的，所以效率会更高。</p><h3 id="输出到Kafka"><a href="#输出到Kafka" class="headerlink" title="输出到Kafka"></a>输出到Kafka</h3><p>除了输出到文件，也可以输出到Kafka。我们可以结合前面Kafka作为输入数据，构建数据管道，kafka进，kafka出</p><p><strong>Code</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.connect(</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Kafka</span>()</span><br><span class="line">    .version(<span class="string">"0.11"</span>)</span><br><span class="line">    .topic(<span class="string">"sinkTest"</span>)</span><br><span class="line">    .property(<span class="string">"zookeeper.connect"</span>, <span class="string">"localhost:2181"</span>)</span><br><span class="line">    .property(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>)</span><br><span class="line">)</span><br><span class="line">  .withFormat( <span class="keyword">new</span> <span class="type">Csv</span>() )</span><br><span class="line">  .withSchema( <span class="keyword">new</span> <span class="type">Schema</span>()</span><br><span class="line">    .field(<span class="string">"id"</span>, <span class="type">DataTypes</span>.<span class="type">STRING</span>())</span><br><span class="line">    .field(<span class="string">"temp"</span>, <span class="type">DataTypes</span>.<span class="type">DOUBLE</span>())</span><br><span class="line">  )</span><br><span class="line">  .createTemporaryTable(<span class="string">"kafkaOutputTable"</span>)</span><br><span class="line"></span><br><span class="line">resultTable.insertInto(<span class="string">"kafkaOutputTable"</span>)</span><br></pre></td></tr></table></figure><h3 id="输出到ES"><a href="#输出到ES" class="headerlink" title="输出到ES"></a>输出到ES</h3><p>ElasticSearch的connector可以在upsert（update+insert，更新插入）模式下操作，这样就可以使用Query定义的键（key）与外部系统交换UPSERT/DELETE消息。</p><p>另外，对于“仅追加”（append-only）的查询，connector还可以在append 模式下操作，这样就可以与外部系统只交换insert消息。</p><p>es目前支持的数据格式，只有Json，而flink本身并没有对应的支持，所以还需要引入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flink-json&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.10.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>Code</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出到es</span></span><br><span class="line">tableEnv.connect(</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Elasticsearch</span>()</span><br><span class="line">    .version(<span class="string">"6"</span>)</span><br><span class="line">    .host(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)</span><br><span class="line">    .index(<span class="string">"sensor"</span>)</span><br><span class="line">    .documentType(<span class="string">"temp"</span>)</span><br><span class="line">)</span><br><span class="line">  .inUpsertMode()           <span class="comment">// 指定是 Upsert 模式</span></span><br><span class="line">  .withFormat(<span class="keyword">new</span> <span class="type">Json</span>())</span><br><span class="line">  .withSchema( <span class="keyword">new</span> <span class="type">Schema</span>()</span><br><span class="line">    .field(<span class="string">"id"</span>, <span class="type">DataTypes</span>.<span class="type">STRING</span>())</span><br><span class="line">    .field(<span class="string">"count"</span>, <span class="type">DataTypes</span>.<span class="type">BIGINT</span>())</span><br><span class="line">  )</span><br><span class="line">  .createTemporaryTable(<span class="string">"esOutputTable"</span>)</span><br><span class="line"></span><br><span class="line">aggResultTable.insertInto(<span class="string">"esOutputTable"</span>)</span><br></pre></td></tr></table></figure><h3 id="输出到MySQL"><a href="#输出到MySQL" class="headerlink" title="输出到MySQL"></a>输出到MySQL</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flink-jdbc_2<span class="number">.11</span>&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.10</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>jdbc连接的代码实现比较特殊，因为没有对应的java/scala类实现ConnectorDescriptor，所以不能直接tableEnv.connect()。不过Flink SQL留下了执行DDL的接口：tableEnv.sqlUpdate()。</p><p>对于jdbc的创建表操作，天生就适合直接写DDL来实现，所以我们的代码可以这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出到 Mysql</span></span><br><span class="line"><span class="keyword">val</span> sinkDDL: <span class="type">String</span> =</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    |create table jdbcOutputTable (</span></span><br><span class="line"><span class="string">    |  id varchar(20) not null,</span></span><br><span class="line"><span class="string">    |  cnt bigint not null</span></span><br><span class="line"><span class="string">    |) with (</span></span><br><span class="line"><span class="string">    |  'connector.type' = 'jdbc',</span></span><br><span class="line"><span class="string">    |  'connector.url' = 'jdbc:mysql://localhost:3306/test',</span></span><br><span class="line"><span class="string">    |  'connector.table' = 'sensor_count',</span></span><br><span class="line"><span class="string">    |  'connector.driver' = 'com.mysql.jdbc.Driver',</span></span><br><span class="line"><span class="string">    |  'connector.username' = 'root',</span></span><br><span class="line"><span class="string">    |  'connector.password' = '123456'</span></span><br><span class="line"><span class="string">    |)</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span>.stripMargin</span><br><span class="line"></span><br><span class="line">tableEnv.sqlUpdate(sinkDDL)</span><br><span class="line">aggResultSqlTable.insertInto(<span class="string">"jdbcOutputTable"</span>)</span><br></pre></td></tr></table></figure><h3 id="Table转换为DataStream"><a href="#Table转换为DataStream" class="headerlink" title="Table转换为DataStream"></a>Table转换为DataStream</h3><p>表可以转换为DataStream或DataSet。这样，自定义流处理或批处理程序就可以继续在 Table API或SQL查询的结果上运行了。</p><p>将表转换为DataStream或DataSet时，需要指定生成的数据类型，即要将表的每一行转换成的数据类型。通常，最方便的转换类型就是Row。当然，因为结果的所有字段类型都是明确的，我们也经常会用元组类型来表示。</p><p>表作为流式查询的结果，是动态更新的。</p><p>所以，将这种动态查询转换成的数据流，同样需要对表的更新操作进行编码，</p><p>进而有不同的转换模式。</p><p>Table API中表到DataStream有两种模式</p><ul><li>追加 Append Mode</li></ul><p>用于表只会被插入（Insert）操作更改的场景。</p><ul><li>撤回 RetractMode</li></ul><p>得到的数据会增加一个Boolean类型的标识位（返回的第一个字段），用它来表示到底是新增的数据（Insert），还是被删除的数据（老数据， Delete）。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultStream: <span class="type">DataStream</span>[<span class="type">Row</span>] = tableEnv.toAppendStream[<span class="type">Row</span>](resultTable)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> aggResultStream: <span class="type">DataStream</span>[(<span class="type">Boolean</span>, (<span class="type">String</span>, <span class="type">Long</span>))] = </span><br><span class="line">tableEnv.toRetractStream[(<span class="type">String</span>, <span class="type">Long</span>)](aggResultTable)</span><br><span class="line"></span><br><span class="line">resultStream.print(<span class="string">"result"</span>)</span><br><span class="line">aggResultStream.print(<span class="string">"aggResult"</span>)</span><br></pre></td></tr></table></figure><p>所以，没有经过groupby之类聚合操作，可以直接用 toAppendStream 来转换；而如果经过了聚合，有更新操作，一般就必须用 toRetractDstream。</p><h3 id="Query的解释和执行"><a href="#Query的解释和执行" class="headerlink" title="Query的解释和执行"></a>Query的解释和执行</h3><p>Table API提供了一种机制来解释（Explain）计算表的逻辑和优化查询计划。这是通过TableEnvironment.explain（table）方法或TableEnvironment.explain（）方法完成的</p><p>explain方法会返回一个字符串，描述三个计划：</p><ul><li><p>未优化的逻辑查询计划</p></li><li><p>优化后的逻辑查询计划</p></li><li><p>实际执行计划</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> explaination: <span class="type">String</span> = tableEnv.explain(resultTable)</span><br><span class="line">println(explaination)</span><br></pre></td></tr></table></figure><p>Query的解释和执行过程，老planner和blink planner大体是一致的，又有所不同。整体来讲，Query都会表示成一个逻辑查询计划，然后分两步解释：</p><p>1.优化查询计划</p><p>2.解释成DataStream或者DataSet程序</p><p>而Blink版本是批流统一的，所以所有的Query，只会被解释成DataStream程序；另外在批处理环境TableEnvironment下，Blink版本要到tableEnv.execute()执行调用才开始解释。</p><h2 id="流处理中的特殊概念"><a href="#流处理中的特殊概念" class="headerlink" title="流处理中的特殊概念"></a>流处理中的特殊概念</h2><p>Table API和SQL，本质上还是基于关系型表的操作方式；而关系型表、关系代数，以及SQL本身，一般是有界的，更适合批处理的场景。这就导致在进行流处理的过程中，理解会稍微复杂一些，需要引入一些特殊概念。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1geby8il5f3j20gj08g0sx.jpg" alt="1.png"></p><p>可以看到，其实关系代数（主要就是指关系型数据库中的表）和SQL，主要就是针对批处理的，这和流处理有天生的隔阂。</p><h3 id="Dynamic-Tables"><a href="#Dynamic-Tables" class="headerlink" title="Dynamic Tables"></a>Dynamic Tables</h3><p>因为流处理面对的数据，是连续不断的，这和我们熟悉的关系型数据库中保存的“表”完全不同。所以，如果我们把流数据转换成Table，然后执行类似于table的select操作，结果就不是一成不变的，而是随着新数据的到来，会不停更新。</p><p>我们可以随着新数据的到来，不停地在之前的基础上更新结果。这样得到的表，在Flink Table API概念里，就叫做“<strong>动态表</strong>”（Dynamic Tables）。</p><p>动态表是Flink对流数据的Table API和SQL支持的核心概念。与表示批处理数据的静态表不同，动态表是随时间变化的。动态表可以像静态的批处理表一样进行查询，查询一个动态表会产生持续查询（Continuous Query）。连续查询永远不会终止，并会生成另一个动态表。查询（Query）会不断更新其动态结果表，以反映其动态输入表上的更改。</p><h3 id="流式持续查询的过程"><a href="#流式持续查询的过程" class="headerlink" title="流式持续查询的过程"></a>流式持续查询的过程</h3><p>下图显示了流、动态表和连续查询的关系：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gebyby4r2yj20ji035jt2.jpg" alt="2.png"></p><p>流式持续查询的过程为：</p><ol><li><p>流被转换为动态表。</p></li><li><p>对动态表计算连续查询，生成新的动态表。</p></li><li><p>生成的动态表被转换回流。</p></li></ol><h3 id="将流转换成表（Table）"><a href="#将流转换成表（Table）" class="headerlink" title="将流转换成表（Table）"></a>将流转换成表（Table）</h3><p>为了处理带有关系查询的流，必须先将其转换为表。</p><p>从概念上讲，流的每个数据记录，都被解释为对结果表的插入（Insert）修改。因为流式持续不断的，而且之前的输出结果无法改变。本质上，我们其实是从一个、只有插入操作的changelog（更新日志）流，来构建一个表。</p><p>为了更好地说明动态表和持续查询的概念，我们来举一个具体的例子。</p><p>比如，我们现在的输入数据，就是用户在网站上的访问行为，数据类型（Schema）如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  user:  VARCHAR,   // 用户名</span><br><span class="line">  cTime: TIMESTAMP, // 访问某个URL的时间戳</span><br><span class="line">  url:   VARCHAR    // 用户访问的URL</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>下图显示了如何将访问URL事件流，或者叫点击事件流（左侧）转换为表（右侧）。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gebyly5qi6j20ex05e74v.jpg" alt="3.png"></p><p>随着插入更多的访问事件流记录，生成的表将不断增长。</p><h3 id="持续查询（Continuous-Query）"><a href="#持续查询（Continuous-Query）" class="headerlink" title="持续查询（Continuous Query）"></a>持续查询（Continuous Query）</h3><p>持续查询，会在动态表上做计算处理，并作为结果生成新的动态表。与批处理查询不同，连续查询从不终止，并根据输入表上的更新更新其结果表。</p><p>在任何时间点，连续查询的结果在语义上，等同于在输入表的快照上，以批处理模式执行的同一查询的结果。</p><p>在下面的示例中，我们展示了对点击事件流中的一个持续查询。</p><p>这个Query很简单，是一个分组聚合做count统计的查询。它将用户字段上的clicks表分组，并统计访问的url数。图中显示了随着时间的推移，当clicks表被其他行更新时如何计算查询。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gebyo6k1awj20lr0aljsg.jpg" alt="4.png"></p><h3 id="将动态表转换成流"><a href="#将动态表转换成流" class="headerlink" title="将动态表转换成流"></a>将动态表转换成流</h3><p>与常规的数据库表一样，动态表可以通过插入（Insert）、更新（Update）和删除（Delete）更改，进行持续的修改。将动态表转换为流或将其写入外部系统时，需要对这些更改进行编码。Flink的Table API和SQL支持三种方式对动态表的更改进行编码：</p><p>1).仅追加（Append-only）流</p><p>仅通过插入（Insert）更改，来修改的动态表，可以直接转换为“仅追加”流。这个流中发出的数据，就是动态表中新增的每一行。</p><p>2).撤回（Retract）流</p><p>Retract流是包含两类消息的流，添加（Add）消息和撤回（Retract）消息。</p><p>动态表通过将INSERT 编码为add消息、DELETE 编码为retract消息、UPDATE编码为被更改行（前一行）的retract消息和更新后行（新行）的add消息，转换为retract流。</p><p>下图显示了将动态表转换为Retract流的过程。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gebyrhzrcdj20kf081t9b.jpg" alt="5.png"></p><p>3).Upsert（更新插入）流</p><p>Upsert流包含两种类型的消息：Upsert消息和delete消息。转换为upsert流的动态表，需要有唯一的键（key）。</p><p>通过将INSERT和UPDATE更改编码为upsert消息，将DELETE更改编码为DELETE消息，就可以将具有唯一键（Unique Key）的动态表转换为流。</p><p>下图显示了将动态表转换为upsert流的过程。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gebz2a1sjmj20kk089js9.jpg" alt="6.png"></p><p>这些概念我们之前都已提到过。需要注意的是，在代码里将动态表转换为DataStream时，仅支持Append和Retract流。而向外部系统输出动态表的TableSink接口，则可以有不同的实现，比如之前我们讲到的ES，就可以有Upsert模式。</p><h2 id="时间特性"><a href="#时间特性" class="headerlink" title="时间特性"></a>时间特性</h2><p>基于时间的操作（比如Table API和SQL中窗口操作），需要定义相关的时间语义和时间数据来源的信息。所以，Table可以提供一个逻辑上的时间字段，用于在表处理程序中，指示时间和访问相应的时间戳。</p><p>时间属性，可以是每个表schema的一部分。一旦定义了时间属性，它就可以作为一个字段引用，并且可以在基于时间的操作中使用。</p><p>时间属性的行为类似于常规时间戳，可以访问，并且进行计算。</p><h3 id="Processing-Time"><a href="#Processing-Time" class="headerlink" title="Processing Time"></a>Processing Time</h3><p>处理时间语义下，允许表处理程序根据机器的本地时间生成结果。它是时间的最简单概念。它既不需要提取时间戳，也不需要生成watermark。</p><p>定义处理时间属性有三种方法：在DataStream转化时直接指定；在定义Table Schema时指定；在创建表的DDL中指定。</p><h4 id="DataStream转换成Table时指定"><a href="#DataStream转换成Table时指定" class="headerlink" title="DataStream转换成Table时指定"></a>DataStream转换成Table时指定</h4><p>由DataStream转换成表的时候，可以在后面指定字段名来定义Schema。在定义Schema期间，可以使用.proctime定义处理时间字段。</p><p>注意，这个proctime属性只能通过附加逻辑字段，来拓展物理schema，因此，</p><p><strong>只能在schema定义的末尾定义它。</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义好schema</span></span><br><span class="line"><span class="keyword">val</span> inputStream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.readTextFile(<span class="string">"\\sensor.txt"</span>)</span><br><span class="line"><span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = inputStream</span><br><span class="line">  .map(data =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> dataArray = data.split(<span class="string">","</span>)</span><br><span class="line">    <span class="type">SensorReading</span>(dataArray(<span class="number">0</span>), dataArray(<span class="number">1</span>).toLong, dataArray(<span class="number">2</span>).toDouble)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 DataStream转换为 Table，并指定时间字段</span></span><br><span class="line"><span class="keyword">val</span> sensorTable = tableEnv.fromDataStream(dataStream, <span class="symbol">'id</span>, <span class="symbol">'temperature</span>, <span class="symbol">'timestamp</span>, <span class="symbol">'pt</span>.proctime)</span><br></pre></td></tr></table></figure><h4 id="定义Table-Schema-时指定"><a href="#定义Table-Schema-时指定" class="headerlink" title="定义Table Schema 时指定"></a>定义Table Schema 时指定</h4><p>定义Schema的时候，加上一个新字段，指定成proctime就可以。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.connect(</span><br><span class="line">  <span class="keyword">new</span> <span class="type">FileSystem</span>().path(<span class="string">"..\\sensor.txt"</span>))</span><br><span class="line">  .withFormat(<span class="keyword">new</span> <span class="type">Csv</span>())</span><br><span class="line">  .withSchema(<span class="keyword">new</span> <span class="type">Schema</span>()</span><br><span class="line">    .field(<span class="string">"id"</span>, <span class="type">DataTypes</span>.<span class="type">STRING</span>())</span><br><span class="line">    .field(<span class="string">"timestamp"</span>, <span class="type">DataTypes</span>.<span class="type">BIGINT</span>())</span><br><span class="line">    .field(<span class="string">"temperature"</span>, <span class="type">DataTypes</span>.<span class="type">DOUBLE</span>())</span><br><span class="line">    .field(<span class="string">"pt"</span>, <span class="type">DataTypes</span>.<span class="type">TIMESTAMP</span>(<span class="number">3</span>))</span><br><span class="line">      .proctime()    <span class="comment">// 指定 pt字段为处理时间</span></span><br><span class="line">  ) <span class="comment">// 定义表结构</span></span><br><span class="line">  .createTemporaryTable(<span class="string">"inputTable"</span>) <span class="comment">// 创建临时表</span></span><br></pre></td></tr></table></figure><h4 id="创建表的DDL中指定"><a href="#创建表的DDL中指定" class="headerlink" title="创建表的DDL中指定"></a>创建表的DDL中指定</h4><p>在创建表的DDL中，增加一个字段并指定成proctime，也可以指定当前的时间字段。</p><p>代码如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sinkDDL: <span class="type">String</span> =</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    |create table dataTable (</span></span><br><span class="line"><span class="string">    |  id varchar(20) not null,</span></span><br><span class="line"><span class="string">    |  ts bigint,</span></span><br><span class="line"><span class="string">    |  temperature double,</span></span><br><span class="line"><span class="string">    |  pt AS PROCTIME()</span></span><br><span class="line"><span class="string">    |) with (</span></span><br><span class="line"><span class="string">    |  'connector.type' = 'filesystem',</span></span><br><span class="line"><span class="string">    |  'connector.path' = 'file:///D:\\..\\sensor.txt',</span></span><br><span class="line"><span class="string">    |  'format.type' = 'csv'</span></span><br><span class="line"><span class="string">    |)</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span>.stripMargin</span><br><span class="line"></span><br><span class="line">tableEnv.sqlUpdate(sinkDDL) <span class="comment">// 执行 DDL</span></span><br></pre></td></tr></table></figure><p>注意：运行这段DDL，必须使用Blink Planner。</p><h3 id="事件时间（Event-Time）"><a href="#事件时间（Event-Time）" class="headerlink" title="事件时间（Event Time）"></a>事件时间（Event Time）</h3><p>事件时间语义，允许表处理程序根据每个记录中包含的时间生成结果。这样即使在有乱序事件或者延迟事件时，也可以获得正确的结果。</p><p>为了处理无序事件，并区分流中的准时和迟到事件；Flink需要从事件数据中，提取时间戳，并用来推进事件时间的进展（watermark）。</p><h4 id="DataStream转化成Table时指定"><a href="#DataStream转化成Table时指定" class="headerlink" title="DataStream转化成Table时指定"></a>DataStream转化成Table时指定</h4><p>在DataStream转换成Table，schema的定义期间，使用.rowtime可以定义事件时间属性。</p><p>注意，必须在转换的数据流中分配时间戳和watermark。</p><p>在将数据流转换为表时，有两种定义时间属性的方法。根据指定的.rowtime字段名是否存在于数据流的架构中，timestamp字段可以：</p><ol><li><p><strong>作为新字段追加到schema</strong></p></li><li><p><strong>替换现有字段</strong></p></li></ol><p>在这两种情况下，定义的事件时间戳字段，都将保存DataStream中事件时间戳的值。</p><p>代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> inputStream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.readTextFile(<span class="string">"\\sensor.txt"</span>)</span><br><span class="line"><span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = inputStream</span><br><span class="line">    .map(data =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> dataArray = data.split(<span class="string">","</span>)</span><br><span class="line">        <span class="type">SensorReading</span>(dataArray(<span class="number">0</span>), dataArray(<span class="number">1</span>).toLong, dataArray(<span class="number">2</span>).toDouble)</span><br><span class="line">      &#125;)</span><br><span class="line">    .assignAscendingTimestamps(_.timestamp * <span class="number">1000</span>L)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 DataStream转换为 Table，并指定时间字段</span></span><br><span class="line"><span class="keyword">val</span> sensorTable = tableEnv.fromDataStream(dataStream, <span class="symbol">'id</span>, <span class="symbol">'timestamp</span>.rowtime, <span class="symbol">'temperature</span>)</span><br><span class="line"><span class="comment">// 或者，直接追加字段</span></span><br><span class="line"><span class="keyword">val</span> sensorTable2 = tableEnv.fromDataStream(dataStream, <span class="symbol">'id</span>, <span class="symbol">'temperature</span>, <span class="symbol">'timestamp</span>, <span class="symbol">'rt</span>.rowtime)</span><br></pre></td></tr></table></figure><h4 id="定义Schema时指定"><a href="#定义Schema时指定" class="headerlink" title="定义Schema时指定"></a>定义Schema时指定</h4><p>这种方法只要在定义Schema的时候，将事件时间指定，并指定成rowtime就可以了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.connect(</span><br><span class="line">  <span class="keyword">new</span> <span class="type">FileSystem</span>().path(<span class="string">"sensor.txt"</span>))</span><br><span class="line">  .withFormat(<span class="keyword">new</span> <span class="type">Csv</span>())</span><br><span class="line">  .withSchema(<span class="keyword">new</span> <span class="type">Schema</span>()</span><br><span class="line">    .field(<span class="string">"id"</span>, <span class="type">DataTypes</span>.<span class="type">STRING</span>())</span><br><span class="line">    .field(<span class="string">"timestamp"</span>, <span class="type">DataTypes</span>.<span class="type">BIGINT</span>())</span><br><span class="line">      .rowtime(</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Rowtime</span>()</span><br><span class="line">          .timestampsFromField(<span class="string">"timestamp"</span>)    <span class="comment">// 从字段中提取时间戳</span></span><br><span class="line">          .watermarksPeriodicBounded(<span class="number">1000</span>)    <span class="comment">// watermark延迟1秒</span></span><br><span class="line">      )</span><br><span class="line">    .field(<span class="string">"temperature"</span>, <span class="type">DataTypes</span>.<span class="type">DOUBLE</span>())</span><br><span class="line">  ) <span class="comment">// 定义表结构</span></span><br><span class="line">  .createTemporaryTable(<span class="string">"inputTable"</span>) <span class="comment">// 创建临时表</span></span><br></pre></td></tr></table></figure><h4 id="创建表的DDL中指定-1"><a href="#创建表的DDL中指定-1" class="headerlink" title="创建表的DDL中指定"></a>创建表的DDL中指定</h4><p>事件时间属性，是使用CREATE TABLE DDL中的WARDMARK语句定义的。watermark语句，定义现有事件时间字段上的watermark生成表达式，该表达式将事件时间字段标记为事件时间属性。</p><p>代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sinkDDL: <span class="type">String</span> =</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    |create table dataTable (</span></span><br><span class="line"><span class="string">    |  id varchar(20) not null,</span></span><br><span class="line"><span class="string">    |  ts bigint,</span></span><br><span class="line"><span class="string">    |  temperature double,</span></span><br><span class="line"><span class="string">    |  rt AS TO_TIMESTAMP( FROM_UNIXTIME(ts) ),</span></span><br><span class="line"><span class="string">    |  watermark for rt as rt - interval '1' second</span></span><br><span class="line"><span class="string">    |) with (</span></span><br><span class="line"><span class="string">    |  'connector.type' = 'filesystem',</span></span><br><span class="line"><span class="string">    |  'connector.path' = 'file:///D:\\..\\sensor.txt',</span></span><br><span class="line"><span class="string">    |  'format.type' = 'csv'</span></span><br><span class="line"><span class="string">    |)</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span>.stripMargin</span><br><span class="line"></span><br><span class="line">tableEnv.sqlUpdate(sinkDDL) <span class="comment">// 执行 DDL</span></span><br></pre></td></tr></table></figure><p>这里<em>FROM_UNIXTIME</em>是系统内置的时间函数，用来将一个整数（秒数）转换成“YYYY-MM-DD hh:mm:ss”格式（默认，也可以作为第二个String参数传入）的日期时间字符串（date time string）；然后再用<em>TO_TIMESTAMP</em>将其转换成Timestamp。</p><h2 id="窗口（Windows）"><a href="#窗口（Windows）" class="headerlink" title="窗口（Windows）"></a>窗口（Windows）</h2><p>时间语义，要配合窗口操作才能发挥作用。最主要的用途，当然就是开窗口、根据时间段做计算了。下面我们就来看看Table API和SQL中，怎么利用时间字段做窗口操作。</p><p>在Table API和SQL中，主要有两种窗口：Group Windows和Over Windows</p><h4 id="分组窗口"><a href="#分组窗口" class="headerlink" title="分组窗口"></a>分组窗口</h4><p>分组窗口（Group Windows）会根据时间或行计数间隔，将行聚合到有限的组（Group）中，并对每个组的数据执行一次聚合函数。</p><p>Table API中的Group Windows都是使用.window（w:GroupWindow）子句定义的，并且必须由as子句指定一个别名。为了按窗口对表进行分组，窗口的别名必须在group by子句中，像常规的分组字段一样引用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> table = input</span><br><span class="line">  .window([w: <span class="type">GroupWindow</span>] as <span class="symbol">'w</span>) <span class="comment">// 定义窗口，别名 w</span></span><br><span class="line">  .groupBy(<span class="symbol">'w</span>, <span class="symbol">'a</span>)  <span class="comment">// 以属性a和窗口w作为分组的key </span></span><br><span class="line">  .select(<span class="symbol">'a</span>, <span class="symbol">'b</span>.sum)  <span class="comment">// 聚合字段b的值，求和</span></span><br></pre></td></tr></table></figure><p>或者，还可以把窗口的相关信息，作为字段添加到结果表中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> table = input</span><br><span class="line">  .window([w: <span class="type">GroupWindow</span>] as <span class="symbol">'w</span>) </span><br><span class="line">  .groupBy(<span class="symbol">'w</span>, <span class="symbol">'a</span>) </span><br><span class="line">  .select(<span class="symbol">'a</span>, <span class="symbol">'w</span>.start, <span class="symbol">'w</span>.end, <span class="symbol">'w</span>.rowtime, <span class="symbol">'b</span>.count)</span><br></pre></td></tr></table></figure><p>Table API提供了一组具有特定语义的预定义Window类，这些类会被转换为底层DataStream或DataSet的窗口操作。</p><p>Table API支持的窗口定义，和我们熟悉的一样，主要也是三种：滚动（Tumbling）、滑动（Sliding）和会话（Session）。</p><h4 id="滚动窗口"><a href="#滚动窗口" class="headerlink" title="滚动窗口"></a>滚动窗口</h4><p>滚动窗口（Tumbling windows）要用Tumble类来定义，另外还有三个方法：</p><p>over：定义窗口长度</p><p>on：用来分组（按时间间隔）或者排序（按行数）的时间字段</p><p>as：别名，必须出现在后面的groupBy中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tumbling Event-time Window（事件时间字段rowtime）</span></span><br><span class="line">.window(<span class="type">Tumble</span> over <span class="number">10.</span>minutes on <span class="symbol">'rowtime</span> as <span class="symbol">'w</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tumbling Processing-time Window（处理时间字段proctime）</span></span><br><span class="line">.window(<span class="type">Tumble</span> over <span class="number">10.</span>minutes on <span class="symbol">'proctime</span> as <span class="symbol">'w</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tumbling Row-count Window (类似于计数窗口，按处理时间排序，10行一组)</span></span><br><span class="line">.window(<span class="type">Tumble</span> over <span class="number">10.</span>rows on <span class="symbol">'proctime</span> as <span class="symbol">'w</span>)</span><br></pre></td></tr></table></figure><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>滑动窗口（Sliding windows）要用Slide类来定义，另外还有四个方法：</p><p>over：定义窗口长度</p><p>every：定义滑动步长</p><p>on：用来分组（按时间间隔）或者排序（按行数）的时间字段</p><p>as：别名，必须出现在后面的groupBy中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sliding Event-time Window</span></span><br><span class="line">.window(Slide over <span class="number">10</span>.minutes every <span class="number">5</span>.minutes on <span class="string">'rowtime as '</span>w)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sliding Processing-time window </span></span><br><span class="line">.window(Slide over <span class="number">10</span>.minutes every <span class="number">5</span>.minutes on <span class="string">'proctime as '</span>w)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sliding Row-count window</span></span><br><span class="line">.window(Slide over <span class="number">10</span>.rows every <span class="number">5</span>.rows on <span class="string">'proctime as '</span>w)</span><br></pre></td></tr></table></figure><h4 id="会话窗口"><a href="#会话窗口" class="headerlink" title="会话窗口"></a>会话窗口</h4><p>会话窗口（Session windows）要用Session类来定义，另外还有三个方法：</p><ul><li><p>withGap：会话时间间隔</p></li><li><p>on：用来分组（按时间间隔）或者排序（按行数）的时间字段</p></li><li><p>as：别名，必须出现在后面的groupBy中</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Session Event-time Window</span></span><br><span class="line">.window(Session withGap <span class="number">10</span>.minutes on <span class="string">'rowtime as '</span>w)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Session Processing-time Window </span></span><br><span class="line">.window(Session withGap <span class="number">10</span>.minutes on <span class="string">'proctime as '</span>w)</span><br></pre></td></tr></table></figure><h4 id="Over-Windows"><a href="#Over-Windows" class="headerlink" title="Over Windows"></a>Over Windows</h4><p>Over window聚合是标准SQL中已有的（Over子句），可以在查询的SELECT子句中定义。Over window 聚合，会针对每个输入行，计算相邻行范围内的聚合。Over windows<br>使用.window（w:overwindows*）子句定义，并在select（）方法中通过别名来引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val table = input</span><br><span class="line">  .window([w: OverWindow] as <span class="string">'w)</span></span><br><span class="line"><span class="string">  .select('</span>a, <span class="string">'b.sum over '</span>w, <span class="string">'c.min over '</span>w)</span><br></pre></td></tr></table></figure><p>Table API提供了Over类，来配置Over窗口的属性。可以在事件时间或处理时间，以及指定为时间间隔、或行计数的范围内，定义Over windows。</p><p>无界的over window是使用常量指定的。也就是说，时间间隔要指定UNBOUNDED_RANGE，或者行计数间隔要指定UNBOUNDED_ROW。而有界的over window是用间隔的大小指定的。</p><p>实际代码应用如下：</p><p>1） 无界的 over window</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无界的事件时间over window (时间字段 "rowtime")</span></span><br><span class="line">.window(Over partitionBy <span class="string">'a orderBy '</span>rowtime preceding UNBOUNDED_RANGE as <span class="string">'w)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//无界的处理时间over window (时间字段"proctime")</span></span><br><span class="line"><span class="string">.window(Over partitionBy '</span>a orderBy <span class="string">'proctime preceding UNBOUNDED_RANGE as '</span>w)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无界的事件时间Row-count over window (时间字段 "rowtime")</span></span><br><span class="line">.window(Over partitionBy <span class="string">'a orderBy '</span>rowtime preceding UNBOUNDED_ROW as <span class="string">'w)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//无界的处理时间Row-count over window (时间字段 "rowtime")</span></span><br><span class="line"><span class="string">.window(Over partitionBy '</span>a orderBy <span class="string">'proctime preceding UNBOUNDED_ROW as '</span>w)</span><br></pre></td></tr></table></figure><p>2） 有界的over window</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有界的事件时间over window (时间字段 "rowtime"，之前1分钟)</span></span><br><span class="line">.window(Over partitionBy <span class="string">'a orderBy '</span>rowtime preceding <span class="number">1</span>.minutes as <span class="string">'w)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 有界的处理时间over window (时间字段 "rowtime"，之前1分钟)</span></span><br><span class="line"><span class="string">.window(Over partitionBy '</span>a orderBy <span class="string">'proctime preceding 1.minutes as '</span>w)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有界的事件时间Row-count over window (时间字段 "rowtime"，之前10行)</span></span><br><span class="line">.window(Over partitionBy <span class="string">'a orderBy '</span>rowtime preceding <span class="number">10</span>.rows as <span class="string">'w)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 有界的处理时间Row-count over window (时间字段 "rowtime"，之前10行)</span></span><br><span class="line"><span class="string">.window(Over partitionBy '</span>a orderBy <span class="string">'proctime preceding 10.rows as '</span>w)</span><br></pre></td></tr></table></figure><h3 id="SQL中窗口的定义"><a href="#SQL中窗口的定义" class="headerlink" title="SQL中窗口的定义"></a>SQL中窗口的定义</h3><p>我们已经了解了在Table API里window的调用方式，同样，我们也可以在SQL中直接加入窗口的定义和使用。</p><h4 id="Group-Windows"><a href="#Group-Windows" class="headerlink" title="Group Windows"></a>Group Windows</h4><p>Group Windows在SQL查询的Group BY子句中定义。与使用常规GROUP BY子句的查询一样，使用GROUP BY子句的查询会计算每个组的单个结果行。</p><p>SQL支持以下Group窗口函数:</p><ul><li>TUMBLE(time_attr, interval)</li></ul><p>定义一个滚动窗口，第一个参数是时间字段，第二个参数是窗口长度。</p><ul><li>HOP(time_attr, interval, interval)</li></ul><p>定义一个滑动窗口，第一个参数是时间字段，第二个参数是窗口滑动步长，第三个是窗口长度。</p><ul><li>SESSION(time_attr, interval)</li></ul><p>定义一个会话窗口，第一个参数是时间字段，第二个参数是窗口间隔（Gap）。</p><p>另外还有一些辅助函数，可以用来选择Group Window的开始和结束时间戳，以及时间属性。</p><p>这里只写TUMBLE_<em>，滑动和会话窗口是类似的（HOP_</em>，SESSION_*）。</p><ul><li>TUMBLE_START(time_attr, interval)</li><li>TUMBLE_END(time_attr, interval)</li><li>TUMBLE_ROWTIME(time_attr, interval)</li><li>TUMBLE_PROCTIME(time_attr, interval)</li></ul><h4 id="Over-Windows-1"><a href="#Over-Windows-1" class="headerlink" title="Over Windows"></a>Over Windows</h4><p>由于Over本来就是SQL内置支持的语法，所以这在SQL中属于基本的聚合操作。所有聚合必须在同一窗口上定义，也就是说，必须是相同的分区、排序和范围。目前仅支持在当前行范围之前的窗口（无边界和有边界）。</p><p>注意，ORDER BY必须在单一的时间属性上指定。</p><p>代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(amount) <span class="keyword">OVER</span> (</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">user</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> proctime</span><br><span class="line">  <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span>)</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"></span><br><span class="line">// 也可以做多个聚合</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(amount) <span class="keyword">OVER</span> w, <span class="keyword">SUM</span>(amount) <span class="keyword">OVER</span> w</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">user</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> proctime</span><br><span class="line">  <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span>)</span><br></pre></td></tr></table></figure><h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><p>开一个滚动窗口，统计10秒内出现的每个sensor的个数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setParallelism(<span class="number">1</span>)</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> streamFromFile: <span class="type">DataStream</span>[<span class="type">String</span>] = env.readTextFile(<span class="string">"sensor.txt"</span>)</span><br><span class="line"><span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = streamFromFile</span><br><span class="line">.map( data =&gt; </span><br><span class="line">     &#123;</span><br><span class="line"><span class="keyword">val</span> dataArray = data.split(<span class="string">","</span>)</span><br><span class="line"><span class="type">SensorReading</span>(dataArray(<span class="number">0</span>).trim, dataArray(<span class="number">1</span>).trim.toLong, dataArray(<span class="number">2</span>).trim.toDouble)</span><br><span class="line">&#125; )</span><br><span class="line">.assignTimestampsAndWatermarks( <span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">SensorReading</span>](<span class="type">Time</span>.seconds(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">SensorReading</span>): <span class="type">Long</span> = element.timestamp * <span class="number">1000</span>L</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> settings: <span class="type">EnvironmentSettings</span> = <span class="type">EnvironmentSettings</span></span><br><span class="line">.newInstance()</span><br><span class="line">                                        .useOldPlanner()</span><br><span class="line">                                        .inStreamingMode()</span><br><span class="line">                                        .build()</span><br><span class="line"><span class="keyword">val</span> tableEnv: <span class="type">StreamTableEnvironment</span> = </span><br><span class="line"><span class="type">StreamTableEnvironment</span>.create(env, settings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dataTable: <span class="type">Table</span> = tableEnv</span><br><span class="line">.fromDataStream(dataStream, <span class="symbol">'id</span>, <span class="symbol">'temperature</span>, <span class="symbol">'timestamp</span>.rowtime)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> resultTable: <span class="type">Table</span> = dataTable</span><br><span class="line">                                .window(<span class="type">Tumble</span> over <span class="number">10.</span>seconds on <span class="symbol">'timestamp</span> as <span class="symbol">'tw</span>)</span><br><span class="line">                                .groupBy(<span class="symbol">'id</span>, <span class="symbol">'tw</span>)</span><br><span class="line">                                .select(<span class="symbol">'id</span>, <span class="symbol">'id</span>.count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sqlDataTable: <span class="type">Table</span> = dataTable</span><br><span class="line">.select(<span class="symbol">'id</span>, <span class="symbol">'temperature</span>, <span class="symbol">'timestamp</span> as <span class="symbol">'ts</span>)</span><br><span class="line"><span class="keyword">val</span> resultSqlTable: <span class="type">Table</span> = tableEnv</span><br><span class="line">.sqlQuery(<span class="string">"select id, count(id) from "</span> </span><br><span class="line">+ sqlDataTable </span><br><span class="line">+ <span class="string">" group by id,tumble(ts,interval '10' second)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 Table转化成数据流</span></span><br><span class="line"><span class="keyword">val</span> resultDstream: <span class="type">DataStream</span>[(<span class="type">Boolean</span>, (<span class="type">String</span>, <span class="type">Long</span>))] = resultSqlTable.toRetractStream[(<span class="type">String</span>, <span class="type">Long</span>)]</span><br><span class="line"></span><br><span class="line">resultDstream.filter(_._1).print()</span><br><span class="line">env.execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Flink Table 和 SQL内置了很多SQL中支持的函数；如果有无法满足的需要，则可以实现用户自定义的函数（UDF）来解决。</p><h3 id="系统内置函数"><a href="#系统内置函数" class="headerlink" title="系统内置函数"></a>系统内置函数</h3><p>Flink Table API 和 SQL为用户提供了一组用于数据转换的内置函数。SQL中支持的很多函数，Table API和SQL都已经做了实现，其它还在快速开发扩展中。</p><p>以下是一些典型函数的举例，全部的内置函数，可以参考官网介绍。</p><table><thead><tr><th>内置函数</th><th>SQL</th><th>Table API</th></tr></thead><tbody><tr><td>判断比较</td><td>value1 = value2</td><td>ANY1 === ANY2</td></tr><tr><td></td><td>value1 &gt; value2</td><td>ANY1 &gt; ANY2</td></tr><tr><td>逻辑函数</td><td>boolean1 OR boolean2</td><td>BOOLEAN1</td></tr><tr><td></td><td>boolean IS FALSE</td><td>BOOLEAN.isFalse</td></tr><tr><td></td><td>NOT boolean</td><td>!BOOLEAN</td></tr><tr><td>算数函数</td><td>numeric1 + numeric2</td><td>NUMERIC1 + NUMERIC2</td></tr><tr><td></td><td>POWER(numeric1, numeric2)</td><td>NUMERIC1.power(NUMERIC2)</td></tr><tr><td>字符串函数</td><td>string1 丨丨 string2</td><td>string1 + string2</td></tr><tr><td></td><td>UPPER(string)</td><td>String.upperCase()</td></tr><tr><td></td><td>CHAR_LENGTH(string)</td><td>STRING.charLength()</td></tr><tr><td>时间函数</td><td>DATE string</td><td>STRING.toDate</td></tr><tr><td></td><td>TIMESTAMP string</td><td>STRING.toTimestamp</td></tr><tr><td></td><td>CURRENT_TIME</td><td>currentTime()</td></tr><tr><td></td><td>INTERVAL string range</td><td>NUMERIC.days</td></tr><tr><td></td><td></td><td>NUMERIC.minutes</td></tr><tr><td>聚合函数</td><td>COUNT(*)</td><td>FIELD.count</td></tr><tr><td></td><td>SUM([ALL丨DISTINCT] expression)</td><td>FIELD.sum0</td></tr><tr><td></td><td>RANK()</td><td></td></tr><tr><td></td><td>ROW_NUMBER()</td></tr></tbody></table><h3 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h3><p>在大多数情况下，用户定义的函数必须先注册，然后才能在查询中使用。不需要专门为Scala 的Table API注册函数。</p><p>函数通过调用registerFunction（）方法在TableEnvironment中注册。当用户定义的函数被注册时，它被插入到TableEnvironment的函数目录中，这样Table API或SQL解析器就可以识别并正确地解释它。</p><h4 id="标量函数"><a href="#标量函数" class="headerlink" title="标量函数"></a>标量函数</h4><p>用户定义的标量函数，可以将0、1或多个标量值，映射到新的标量值。</p><p>为了定义标量函数，必须在org.apache.flink.table.functions中扩展基类Scalar Function，并实现（一个或多个）求值（evaluation，eval）方法。标量函数的行为由求值方法决定，求值方法必须公开声明并命名为eval（直接def声明，没有override）。求值方法的参数类型和返回类型，确定了标量函数的参数和返回类型。</p><p>在下面的代码中，我们定义自己的HashCode函数，在TableEnvironment中注册它，并在查询中调用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义一个标量函数</span></span><br><span class="line">class HashCode( factor: Int ) extends ScalarFunction &#123;</span><br><span class="line">  <span class="function">def <span class="title">eval</span><span class="params">( s: String )</span>: Int </span>= &#123;</span><br><span class="line">    s.hashCode * factor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数中调用，计算sensor id的哈希值（前面部分照抄，流环境、表环境、读取source、建表）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">  env.setParallelism(<span class="number">1</span>)</span><br><span class="line">  env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> settings = <span class="type">EnvironmentSettings</span></span><br><span class="line">    .newInstance()</span><br><span class="line">    .useOldPlanner()</span><br><span class="line">    .inStreamingMode()</span><br><span class="line">    .build()</span><br><span class="line">  <span class="keyword">val</span> tableEnv = <span class="type">StreamTableEnvironment</span>.create( env, settings )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义好 DataStream</span></span><br><span class="line">  <span class="keyword">val</span> inputStream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.readTextFile(<span class="string">"..\\sensor.txt"</span>)</span><br><span class="line">  <span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = inputStream</span><br><span class="line">    .map(data =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> dataArray = data.split(<span class="string">","</span>)</span><br><span class="line">      <span class="type">SensorReading</span>(dataArray(<span class="number">0</span>), dataArray(<span class="number">1</span>).toLong, dataArray(<span class="number">2</span>).toDouble)</span><br><span class="line">    &#125;)</span><br><span class="line">    .assignAscendingTimestamps(_.timestamp * <span class="number">1000</span>L)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 DataStream转换为 Table，并指定时间字段</span></span><br><span class="line">  <span class="keyword">val</span> sensorTable = tableEnv.fromDataStream(dataStream, <span class="symbol">'id</span>, <span class="symbol">'timestamp</span>.rowtime, <span class="symbol">'temperature</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Table API中使用</span></span><br><span class="line">  <span class="keyword">val</span> hashCode = <span class="keyword">new</span> <span class="type">HashCode</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> resultTable = sensorTable</span><br><span class="line">    .select( <span class="symbol">'id</span>, hashCode(<span class="symbol">'id</span>) )</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// SQL 中使用</span></span><br><span class="line">  tableEnv.createTemporaryView(<span class="string">"sensor"</span>, sensorTable)</span><br><span class="line">  tableEnv.registerFunction(<span class="string">"hashCode"</span>, hashCode)</span><br><span class="line">  <span class="keyword">val</span> resultSqlTable = tableEnv.sqlQuery(<span class="string">"select id, hashCode(id) from sensor"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转换成流，打印输出</span></span><br><span class="line">  resultTable.toAppendStream[<span class="type">Row</span>].print(<span class="string">"table"</span>)</span><br><span class="line">  resultSqlTable.toAppendStream[<span class="type">Row</span>].print(<span class="string">"sql"</span>)</span><br><span class="line"> </span><br><span class="line">  env.execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表函数（Table-Functions）"><a href="#表函数（Table-Functions）" class="headerlink" title="表函数（Table Functions）"></a>表函数（Table Functions）</h4><p>与用户定义的标量函数类似，用户定义的表函数，可以将0、1或多个标量值作为输入参数；与标量函数不同的是，它可以返回任意数量的行作为输出，而不是单个值。</p><p>为了定义一个表函数，必须扩展org.apache.flink.table.functions中的基类TableFunction并实现（一个或多个）求值方法。表函数的行为由其求值方法决定，求值方法必须是public的，并命名为eval。求值方法的参数类型，决定表函数的所有有效参数。</p><p>返回表的类型由TableFunction的泛型类型确定。求值方法使用protected collect（T）方法发出输出行。</p><p>在Table API中，Table函数需要与.joinLateral或.leftOuterJoinLateral一起使用。</p><p>joinLateral算子，会将外部表中的每一行，与表函数（TableFunction，算子的参数是它的表达式）计算得到的所有行连接起来。</p><p>而leftOuterJoinLateral算子，则是左外连接，它同样会将外部表中的每一行与表函数计算生成的所有行连接起来；并且，对于表函数返回的是空表的外部行，也要保留下来。</p><p>在SQL中，则需要使用Lateral Table（<tablefunction>），或者带有ON TRUE条件的左连接。</tablefunction></p><p>下面的代码中，我们将定义一个表函数，在表环境中注册它，并在查询中调用它。</p><p>自定义TableFunction：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义TableFunction</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Split</span>(<span class="params">separator: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">TableFunction</span>[(<span class="type">String</span>, <span class="type">Int</span>)]</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(str: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    str.split(separator).foreach(</span><br><span class="line">      word =&gt; collect((word, word.length))</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是在代码中调用。首先是Table API的方式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Table API中调用，需要用joinLateral</span></span><br><span class="line">    <span class="keyword">val</span> resultTable = sensorTable</span><br><span class="line">      .joinLateral(split(<span class="symbol">'id</span>) as (<span class="symbol">'word</span>, <span class="symbol">'length</span>))   <span class="comment">// as对输出行的字段重命名</span></span><br><span class="line">      .select(<span class="symbol">'id</span>, <span class="symbol">'word</span>, <span class="symbol">'length</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 或者用leftOuterJoinLateral</span></span><br><span class="line">    <span class="keyword">val</span> resultTable2 = sensorTable</span><br><span class="line">      .leftOuterJoinLateral(split(<span class="symbol">'id</span>) as (<span class="symbol">'word</span>, <span class="symbol">'length</span>))</span><br><span class="line">      .select(<span class="symbol">'id</span>, <span class="symbol">'word</span>, <span class="symbol">'length</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换成流打印输出</span></span><br><span class="line">    resultTable.toAppendStream[<span class="type">Row</span>].print(<span class="string">"1"</span>)</span><br><span class="line">    resultTable2.toAppendStream[<span class="type">Row</span>].print(<span class="string">"2"</span>)</span><br></pre></td></tr></table></figure><p>然后是SQL的方式</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">"sensor"</span>, sensorTable)</span><br><span class="line">tableEnv.registerFunction(<span class="string">"split"</span>, split)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> resultSqlTable = tableEnv.sqlQuery(</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    |select id, word, length</span></span><br><span class="line"><span class="string">    |from</span></span><br><span class="line"><span class="string">    |sensor, LATERAL TABLE(split(id)) AS newsensor(word, length)</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span>.stripMargin)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者用左连接的方式</span></span><br><span class="line"><span class="keyword">val</span> resultSqlTable2 = tableEnv.sqlQuery(</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    |SELECT id, word, length</span></span><br><span class="line"><span class="string">    |FROM</span></span><br><span class="line"><span class="string">    |sensor</span></span><br><span class="line"><span class="string">    |LEFT JOIN </span></span><br><span class="line"><span class="string">    |LATERAL TABLE(split(id)) AS newsensor(word, length) </span></span><br><span class="line"><span class="string">    |ON TRUE</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span>.stripMargin</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成流打印输出</span></span><br><span class="line">resultSqlTable.toAppendStream[<span class="type">Row</span>].print(<span class="string">"1"</span>)</span><br><span class="line">resultSqlTable2.toAppendStream[<span class="type">Row</span>].print(<span class="string">"2"</span>)</span><br></pre></td></tr></table></figure><h4 id="聚合函数-aggregate-Function"><a href="#聚合函数-aggregate-Function" class="headerlink" title="聚合函数(aggregate Function)"></a>聚合函数(aggregate Function)</h4><p>用户自定义聚合函数（User-Defined Aggregate Functions，UDAGGs）可以把一个表中的数据，聚合成一个标量值。用户定义的聚合函数，是通过继承AggregateFunction抽象类实现的。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gejnzvbpitj20jf0b6jsm.jpg" alt="1.png"></p><p>上图中显示了一个聚合的例子。</p><p>假设现在有一张表，包含了各种饮料的数据。该表由三列（id、name和price）、五行组成数据。现在我们需要找到表中所有饮料的最高价格，即执行max（）聚合，结果将是一个数值。</p><p>AggregateFunction的工作原理如下。</p><ul><li><p>首先，它需要一个累加器，用来保存聚合中间结果的数据结构（状态）。可以通过调用AggregateFunction的createAccumulator（）方法创建空累加器。</p></li><li><p>随后，对每个输入行调用函数的accumulate（）方法来更新累加器。</p></li><li><p>处理完所有行后，将调用函数的getValue（）方法来计算并返回最终结果。</p></li></ul><p>AggregationFunction要求必须实现的方法：</p><ul><li><p>createAccumulator()</p></li><li><p>accumulate()</p></li><li><p>getValue()</p></li></ul><p>除了上述方法之外，还有一些可选择实现的方法。其中一些方法，可以让系统执行查询更有效率，而另一些方法，对于某些场景是必需的。例如，如果聚合函数应用在会话窗口（session group window）的上下文中，则merge（）方法是必需的。</p><ul><li><p>retract() </p></li><li><p>merge() </p></li><li><p>resetAccumulator()</p></li></ul><p>除了上述方法之外，还有一些可选择实现的方法。其中一些方法，可以让系统执行查询更有效率，而另一些方法，对于某些场景是必需的。例如，如果聚合函数应用在会话窗口（session group window）的上下文中，则merge（）方法是必需的。</p><ul><li>retract()</li><li>merge()</li><li>resetAccumulator()</li></ul><p>接下来自定义AggregateFunction,计算一下每个sensor的平均温度值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义AggregateFunction的Accumulator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvgTempAcc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum: <span class="type">Double</span> = <span class="number">0.0</span></span><br><span class="line">  <span class="keyword">var</span> count: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvgTemp</span> <span class="keyword">extends</span> <span class="title">AggregateFunction</span>[<span class="type">Double</span>, <span class="type">AvgTempAcc</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getValue</span></span>(accumulator: <span class="type">AvgTempAcc</span>): <span class="type">Double</span> =</span><br><span class="line">    accumulator.sum / accumulator.count</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createAccumulator</span></span>(): <span class="type">AvgTempAcc</span> = <span class="keyword">new</span> <span class="type">AvgTempAcc</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accumulate</span></span>(accumulator: <span class="type">AvgTempAcc</span>, temp: <span class="type">Double</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">    accumulator.sum += temp</span><br><span class="line">    accumulator.count += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以在代码中调用了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个聚合函数实例</span></span><br><span class="line"><span class="keyword">val</span> avgTemp = <span class="keyword">new</span> <span class="type">AvgTemp</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Table API的调用 </span></span><br><span class="line"><span class="keyword">val</span> resultTable = sensorTable.groupBy(<span class="symbol">'id</span>)</span><br><span class="line">  .aggregate(avgTemp(<span class="symbol">'temperature</span>) as <span class="symbol">'avgTemp</span>)</span><br><span class="line">  .select(<span class="symbol">'id</span>, <span class="symbol">'avgTemp</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQL的实现</span></span><br><span class="line">tableEnv.createTemporaryView(<span class="string">"sensor"</span>, sensorTable)</span><br><span class="line">tableEnv.registerFunction(<span class="string">"avgTemp"</span>, avgTemp)</span><br><span class="line"><span class="keyword">val</span> resultSqlTable = tableEnv.sqlQuery(</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    |SELECT</span></span><br><span class="line"><span class="string">    |id, avgTemp(temperature)</span></span><br><span class="line"><span class="string">    |FROM</span></span><br><span class="line"><span class="string">    |sensor</span></span><br><span class="line"><span class="string">    |GROUP BY id</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span>.stripMargin)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成流打印输出</span></span><br><span class="line">resultTable.toRetractStream[(<span class="type">String</span>, <span class="type">Double</span>)].print(<span class="string">"agg temp"</span>)</span><br><span class="line">resultSqlTable.toRetractStream[<span class="type">Row</span>].print(<span class="string">"agg temp sql"</span>)</span><br></pre></td></tr></table></figure><h3 id="表聚合函数（Table-Aggregate-Functions）"><a href="#表聚合函数（Table-Aggregate-Functions）" class="headerlink" title="表聚合函数（Table Aggregate Functions）"></a>表聚合函数（Table Aggregate Functions）</h3><p>用户定义的表聚合函数（User-Defined Table Aggregate Functions，UDTAGGs），可以把一个表中数据，聚合为具有多行和多列的结果表。这跟AggregateFunction非常类似，只是之前聚合结果是一个标量值，现在变成了一张表。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gejo6fdbb4j20je09cta0.jpg" alt="2.png"></p><p>比如现在我们需要找到表中所有饮料的前2个最高价格，即执行top2（）表聚合。我们需要检查5行中的每一行，得到的结果将是一个具有排序后前2个值的表。</p><p>用户定义的表聚合函数，是通过继承TableAggregateFunction抽象类来实现的。</p><p>TableAggregateFunction的工作原理如下。</p><ul><li><p>首先，它同样需要一个累加器（Accumulator），它是保存聚合中间结果的数据结构。通过调用TableAggregateFunction的createAccumulator（）方法可以创建空累加器。</p></li><li><p>随后，对每个输入行调用函数的accumulate（）方法来更新累加器。</p></li><li><p>处理完所有行后，将调用函数的emitValue（）方法来计算并返回最终结果。</p></li></ul><p>AggregationFunction要求必须实现的方法：</p><ul><li><p>createAccumulator()</p></li><li><p>accumulate()</p></li></ul><p>除了上述方法之外，还有一些可选择实现的方法。</p><ul><li>retract() </li><li>merge()  </li><li>resetAccumulator() </li><li>emitValue() </li><li>emitUpdateWithRetract()</li></ul><p>接下来我们写一个自定义TableAggregateFunction，用来提取每个sensor最高的两个温度值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个 Accumulator </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top2TempAcc</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> highestTemp: <span class="type">Double</span> = <span class="type">Int</span>.<span class="type">MinValue</span></span><br><span class="line">  <span class="keyword">var</span> secondHighestTemp: <span class="type">Double</span> = <span class="type">Int</span>.<span class="type">MinValue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 TableAggregateFunction</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top2Temp</span> <span class="keyword">extends</span> <span class="title">TableAggregateFunction</span>[(<span class="type">Double</span>, <span class="type">Int</span>), <span class="type">Top2TempAcc</span>]</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createAccumulator</span></span>(): <span class="type">Top2TempAcc</span> = <span class="keyword">new</span> <span class="type">Top2TempAcc</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accumulate</span></span>(acc: <span class="type">Top2TempAcc</span>, temp: <span class="type">Double</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="keyword">if</span>( temp &gt; acc.highestTemp )&#123;</span><br><span class="line">      acc.secondHighestTemp = acc.highestTemp</span><br><span class="line">      acc.highestTemp = temp</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( temp &gt; acc.secondHighestTemp )&#123;</span><br><span class="line">      acc.secondHighestTemp = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">emitValue</span></span>(acc: <span class="type">Top2TempAcc</span>, out: <span class="type">Collector</span>[(<span class="type">Double</span>, <span class="type">Int</span>)]): <span class="type">Unit</span> =&#123;</span><br><span class="line">    out.collect(acc.highestTemp, <span class="number">1</span>)</span><br><span class="line">    out.collect(acc.secondHighestTemp, <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以在代码中调用了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个表聚合函数实例</span></span><br><span class="line"><span class="keyword">val</span> top2Temp = <span class="keyword">new</span> <span class="type">Top2Temp</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Table API的调用</span></span><br><span class="line"><span class="keyword">val</span> resultTable = sensorTable.groupBy(<span class="symbol">'id</span>)</span><br><span class="line">  .flatAggregate( top2Temp(<span class="symbol">'temperature</span>) as (<span class="symbol">'temp</span>, <span class="symbol">'rank</span>) )</span><br><span class="line">  .select(<span class="symbol">'id</span>, <span class="symbol">'temp</span>, <span class="symbol">'rank</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成流打印输出</span></span><br><span class="line">resultTable.toRetractStream[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>)].print(<span class="string">"agg temp"</span>)</span><br><span class="line">resultSqlTable.toRetractStream[<span class="type">Row</span>].print(<span class="string">"agg temp sql"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Flink Table 和 SQL 整体的脉络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gejppurwd5j20ib046t9h.jpg&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://yoursite.com/categories/Apache/"/>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Apache/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink State</title>
    <link href="http://yoursite.com/2020/04/27/Flink%20State/"/>
    <id>http://yoursite.com/2020/04/27/Flink State/</id>
    <published>2020-04-27T08:48:18.811Z</published>
    <updated>2020-04-26T03:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Flink State的使用经验和平时一些注意不到的属性</p></blockquote><a id="more"></a> <h1 id="Flink-State"><a href="#Flink-State" class="headerlink" title="Flink State"></a>Flink State</h1><h2 id="Flink-State-的种类"><a href="#Flink-State-的种类" class="headerlink" title="Flink State 的种类"></a>Flink State 的种类</h2><p>定义：流式计算中持久化来的状态</p><p>两种不同的 state：operator state 以及 keyed state。</p><p>区别：</p><p><strong>是否存在当前处理的 key</strong>（current key）：operator state 是没有当前 key 的概念，而 keyed state 的数值总是与一个 current key 对应。</p><p><strong>是否存在当前处理的 key</strong>（current key）：operator state 是没有当前 key 的概念，而 keyed state 的数值总是与一个 current key 对应。</p><p><strong>是否需要手动声明快照</strong>（snapshot）<strong>和恢复</strong> (restore) <strong>方法</strong>：operator state 需要手动实现 snapshot 和 restore 方法；而 keyed state 则由 backend 自行实现，对用户透明。</p><p><strong>数据大小</strong>：一般而言，我们认为 operator state 的数据规模是比较小的；认为 keyed state 规模是相对比较大的。需要注意的是，这是一个经验判断，不是一个绝对的判断区分标准。</p><p>生产中，我们会在 FsStateBackend 和 RocksDBStateBackend 间选择：</p><ul><li><strong>FsStateBackend</strong>：性能更好；日常存储是在堆内存中，面临着 OOM 的风险，不支持增量 checkpoint。</li><li><strong>RocksDBStateBackend</strong>：无需担心 OOM 风险，是大部分时候的选择。</li></ul><p><strong>RocksDB StateBackend 概览和相关配置讨论</strong></p><p>RocksDB 是 Facebook 开源的 LSM 的键值存储数据库，被广泛应用于大数据系统的单机组件中。Flink 的 keyed state 本质上来说就是一个键值对，所以与 RocksDB 的数据模型是吻合的。下图分别是 “window state” 和 “value state” 在 RocksDB 中的存储格式，所有存储的 key，value 均被序列化成 bytes 进行存储。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ge6ze2rcs8j20oz09sglx.jpg" alt="undefined"></p><p>在 RocksDB 中，每个 state 独享一个 Column Family，而每个 Column family 使用各自独享的 write buffer 和 block cache，上图中的 window state 和 value state实际上分属不同的 column family。</p><p>下面介绍一些对 RocksDB 性能比较有影响的参数，并整理了一些相关的推荐配置，至于其他配置项，可以参阅社区相关文档。</p><table><thead><tr><th>state.backend.rocksdb.thread.num</th><th>后台 flush 和 compaction 的线程数. 默认值 ‘1‘. 建议调大</th></tr></thead><tbody><tr><td>state.backend.rocksdb.writebuffer.count</td><td>每个 column family 的 write buffer 数目，默认值 ‘2‘. 如果有需要可以适当调大</td></tr><tr><td>state.backend.rocksdb.writebuffer.size</td><td>每个 write buffer 的 size，默认值‘64MB‘. 对于写频繁的场景，建议调大</td></tr><tr><td>state.backend.rocksdb.block.cache-size</td><td>每个 column family 的 block cache大小，默认值‘8MB’，如果存在重复读的场景，建议调大</td></tr></tbody></table><h2 id="State-best-practice"><a href="#State-best-practice" class="headerlink" title="State best practice"></a>State best practice</h2><p>■ <strong>慎重使用长 list</strong></p><p>下图展示的是目前 task 端 operator state 在执行完 checkpoint 返回给 job master 端的 StateMetaInfo 的代码片段。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ge6zual0gdj20oz0a0jrv.jpg" alt="undefined"></p><p>由于 operator state 没有 key group 的概念，所以为了实现改并发恢复的功能，需要对 operator state 中的每一个序列化后的元素存储一个位置偏移 offset，也就是构成了上图红框中的 offset 数组。</p><p>那么如果你的 operator state 中的 list 长度达到一定规模时，这个 offset 数组就可能会有几十 MB 的规模，关键这个数组是会返回给 job master，当 operator 的并发数目很大时，很容易触发 job master 的内存超用问题。我们遇到过用户把 operator state 当做黑名单存储，结果这个黑名单规模很大，导致一旦开始执行 checkpoint，job master 就会因为收到 task 发来的“巨大”的 offset 数组，而内存不断增长直到超用无法正常响应。</p><p>■ <strong>正确使用 UnionListState</strong></p><p>union list state 目前被广泛使用在 kafka connector 中，不过可能用户日常开发中较少遇到，他的语义是从检查点恢复之后每个并发 task 内拿到的是原先所有operator 上的 state，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ge6zuxdx96j20nl0930sn.jpg" alt="undefined"></p><p>kafka connector 使用该功能，为的是从检查点恢复时，可以拿到之前的全局信息，如果用户需要使用该功能，需要切记恢复的 task 只取其中的一部分进行处理和用于下一次 snapshot，否则有可能随着作业不断的重启而导致 state 规模不断增长。</p><h2 id="Keyed-state-使用建议"><a href="#Keyed-state-使用建议" class="headerlink" title="Keyed state 使用建议"></a>Keyed state 使用建议</h2><p>■ <strong>如何正确清空当前的 state</strong></p><p>state.clear() 实际上只能清理当前 key 对应的 value 值，如果想要清空整个 state，需要借助于 applyToAllKeys 方法，具体代码片段如下：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ge6zvn0chzj20oz04odfx.jpg" alt="undefined"></p><p>如果你的需求中只是对 state 有过期需求，借助于 state TTL 功能来清理会是一个性能更好的方案。</p><p><strong>■ RocksDB 中考虑 value 值很大的极限场景</strong></p><p>受限于 JNI bridge API 的限制，单个 value 只支持 2^31 bytes 大小，如果存在很极限的情况，可以考虑使用 MapState 来替代 ListState 或者 ValueState，因为RocksDB 的 map state 并不是将整个 map 作为 value 进行存储，而是将 map 中的一个条目作为键值对进行存储。</p><p><strong>■ 如何知道当前 RocksDB 的运行情况</strong></p><p>比较直观的方式是打开 RocksDB 的 native metrics ，在默认使用 Flink managed memory 方式的情况下，state.backend.rocksdb.metrics.block-cache-usage ，state.backend.rocksdb.metrics.mem-table-flush-pending，state.backend.rocksdb.metrics.num-running-compactions 以及 state.backend.rocksdb.metrics.num-running-flushes 是比较重要的相关 metrics。</p><p>下面这张图是 Flink-1.10 之后，打开相关 metrics 的示例图：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ge6zw28irmj20oz0e2aaq.jpg" alt="undefined"></p><p>而下面这张是 Flink-1.10 之前或者关闭 state.backend.rocksdb.memory.managed  的效果：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ge6zwe0hczj20oz0e0aas.jpg" alt="undefined"></p><p>■ <strong>容器内运行的 RocksDB 的内存超用问题</strong></p><p>在 Flink-1.10 之前，由于一个 state 独占若干 write buffer 和一块 block cache，所以我们会建议用户不要在一个 operator 内创建过多的 state，否则需要考虑到相应的额外内存使用量，否则容易造成在容器内运行时，相关进程被容器环境所杀。对于用户来说，需要考虑一个 slot 内有多少 RocksDB 实例在运行，一个 RocksDB 中有多少 state，整体的计算规则就很复杂，很难真得落地实施。</p><p>Flink-1.10 之后，由于引入了 RocksDB 的内存托管机制，在绝大部分情况下， RocksDB 的这一部分 native 内存是可控的，不过受限于 RocksDB 的相关 cache 实现限制（这里暂不展开，后续会有文章讨论），在某些场景下，无法做到完美控制，这时候建议打开上文提到的 native metrics，观察相关 block cache 内存使用是否存在超用情况，可以将相关内存添加到 taskmanager.memory.task.off-heap.size 中，使得 Flink 有更多的空间给 native 内存使用。</p><p>■ <strong>Checkpoint 间隔不要太短</strong></p><p>虽然理论上 Flink 支持很短的 checkpoint 间隔，但是在实际生产中，过短的间隔对于底层分布式文件系统而言，会带来很大的压力。另一方面，由于检查点的语义，所以实际上 Flink 作业处理 record 与执行 checkpoint 存在互斥锁，过于频繁的 checkpoint，可能会影响整体的性能。当然，这个建议的出发点是底层分布式文件系统的压力考虑。</p><p>■ <strong>合理设置超时时间</strong></p><p>默认的超时时间是 10min，如果 state 规模大，则需要合理配置。最坏情况是分布式地创建速度大于单点（job master 端）的删除速度，导致整体存储集群可用空间压力较大。建议当检查点频繁因为超时而失败时，增大超时时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Flink State的使用经验和平时一些注意不到的属性&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://yoursite.com/categories/Apache/"/>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Apache/Flink/"/>
    
    
      <category term="Flink" scheme="http://yoursite.com/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Git详解</title>
    <link href="http://yoursite.com/2020/04/13/Git%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/04/13/Git详解/</id>
    <published>2020-04-13T06:48:28.139Z</published>
    <updated>2020-05-07T06:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>讨论了许多种git的情况，非常详细的git报告</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gds54g3odrj206402kmwz.jpg" alt="undefined"><br><a id="more"></a> </p><h1 id="Git超详细"><a href="#Git超详细" class="headerlink" title="Git超详细"></a>Git超详细</h1><h4 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h4><p>Git是目前世界上最先进的分布式版本控制系统。</p><h4 id="SVN与Git的最主要的区别"><a href="#SVN与Git的最主要的区别" class="headerlink" title="SVN与Git的最主要的区别"></a><strong>SVN与Git的最主要的区别</strong></h4><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p><p>   Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><p>   什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p><p>  所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p><p>pwd 命令是用于显示当前的目录。</p><p>   \1. 通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p><p><a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyr2rpcnj20en025mx9.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyr2rpcnj20en025mx9.jpg" alt="img"></a></p><p>   这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p><p>  <a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyr1x3lzj20h004tgm1.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyr1x3lzj20h004tgm1.jpg" alt="img"></a></p><h4 id="把文件添加到版本库中"><a href="#把文件添加到版本库中" class="headerlink" title="把文件添加到版本库中"></a>把文件添加到版本库中</h4><p>​     首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p>  <strong>下面先看下**</strong>demo<strong>**如下演示：</strong></p><p>   我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p>   第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：</p><p>  <a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyr0wkxbj20ch028dfu.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyr0wkxbj20ch028dfu.jpg" alt="img"></a></p><p>  如果和上面一样，没有任何提示，说明已经添加成功了。</p><p>  第二步：用命令 git commit告诉Git，把文件提交到仓库。</p><p>  <a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyqz56axj20dp03djrr.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyqz56axj20dp03djrr.jpg" alt="img"></a></p><p> 现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：</p><p><a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyqrg067j20d102zwen.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyqrg067j20d102zwen.jpg" alt="img"></a></p><p> 说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：</p><p> <a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyqq7ts6j20h504r74x.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyqq7ts6j20h504r74x.jpg" alt="img"></a></p><p>上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。</p><p>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：</p><p>git diff readme.txt 如下：</p><p> <a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyqnrvxgj20ds05maal.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyqnrvxgj20ds05maal.jpg" alt="img"></a></p><p>如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。</p><p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。</p><p>如下：</p><p> <a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyqmcupsj20h609i402.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyqmcupsj20h609i402.jpg" alt="img"></a></p><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>   如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行</p><p>内容为33333333333333.继续执行命令如下：</p><p>  <a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyql1473j20cp03vdga.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyql1473j20cp03vdga.jpg" alt="img"></a></p><p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：</p><p> <a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyqd9m1dj20gt08ggn8.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyqd9m1dj20gt08ggn8.jpg" alt="img"></a></p><p>  git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：</p><p> <a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyqc3ziwj20gs02paai.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyqc3ziwj20gs02paai.jpg" alt="img"></a></p><p>  现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。未回退之前的readme.txt内容如下：</p><p><a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyqavyf7j20ch04laap.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyqavyf7j20ch04laap.jpg" alt="img"></a></p><p>如果想回退到上一个版本的命令如下操作：</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyqa5xjfj20ct02xaad.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyqa5xjfj20ct02xaad.jpg" alt="img"></a></p><p>再来查看下 readme.txt内容如下：通过命令cat readme.txt查看</p><p><a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq9fck2j20c402d74c.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq9fck2j20c402d74c.jpg" alt="img"></a></p><p>可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyq6bhrlj20dc063dgk.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyq6bhrlj20dc063dgk.jpg" alt="img"></a></p><p>我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：</p><p>git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyq5dtfrj20e603e0t5.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyq5dtfrj20e603e0t5.jpg" alt="img"></a></p><p>通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令</p><p>git reset –hard 6fcfc89来恢复了。演示如下：</p><p><a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq4m3oqj20e104974t.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq4m3oqj20e104974t.jpg" alt="img"></a></p><p>可以看到 目前已经是最新的版本了。</p><h4 id="理解工作区与暂存区的区别"><a href="#理解工作区与暂存区的区别" class="headerlink" title="理解工作区与暂存区的区别"></a>理解工作区与暂存区的区别</h4><p><strong>工作区：</strong>就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</p><p>   <strong>版本库**</strong>(Repository)<strong>**：</strong>工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</p><p>我们前面说过使用Git提交文件到版本库有两步：</p><p> 第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</p><p> 第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p><p>我们继续使用demo来演示下：</p><p>我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：</p><p><a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyq3ykzsj20hv06pwfi.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyq3ykzsj20hv06pwfi.jpg" alt="img"></a></p><p>现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：</p><p><a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq2gn7sj20d206p0t8.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq2gn7sj20d206p0t8.jpg" alt="img"></a></p><p>接着我们可以使用git commit一次性提交到分支上，如下：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyq1gpk0j20h704mdgm.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyq1gpk0j20h704mdgm.jpg" alt="img"></a></p><h4 id="Git撤销修改和删除文件操作"><a href="#Git撤销修改和删除文件操作" class="headerlink" title="Git撤销修改和删除文件操作"></a>Git撤销修改和删除文件操作</h4><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a><strong>撤销修改</strong></h4><p>  比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：</p><p><a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq0rzrcj20ax03vaaa.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq0rzrcj20ax03vaaa.jpg" alt="img"></a></p><p>在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p><p>第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。</p><p>第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^</p><p>但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyq034qhj20hs04oaam.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyq034qhj20hs04oaam.jpg" alt="img"></a></p><p>可以发现，Git会告诉你，git checkout — file 可以丢弃工作区的修改，如下命令：</p><p>git checkout — readme.txt,如下所示：</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypz44y5j20eh03w0t4.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypz44y5j20eh03w0t4.jpg" alt="img"></a></p><p>命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：</p><ol><li>readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</li><li>另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</li></ol><p>对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p><p> <a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloypybh8pj20h40deq52.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloypybh8pj20h40deq52.jpg" alt="img"></a></p><p><strong>注意：</strong>命令git checkout — readme.txt 中的 — 很重要，如果没有 — 的话，那么命令变成创建分支了。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a><strong>删除文件</strong></h4><p> 假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：</p><p> <a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypxcttej20hr0awmzc.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypxcttej20hr0awmzc.jpg" alt="img"></a></p><p>如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，</p><p> <a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypvtweyj20jj05cwf4.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypvtweyj20jj05cwf4.jpg" alt="img"></a></p><p>只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？</p><p>可以使用如下命令 git checkout — b.txt，如下所示：</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyput1l8j20fh06s0tr.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyput1l8j20fh06s0tr.jpg" alt="img"></a></p><p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p> 在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：</p><p>   第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p><p>ssh-keygen -t rsa –C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>”, 由于我本地此前运行过一次，所以本地有，如下所示：</p><p> <a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypq7esij20kx04pt9c.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypq7esij20kx04pt9c.jpg" alt="img"></a></p><p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。</p><p><a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyppfdu3j20vh0nwdl0.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyppfdu3j20vh0nwdl0.jpg" alt="img"></a></p><p>点击 Add Key，你就应该可以看到已经添加的key。</p><p><a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloypnrj0cj20l60ad75p.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloypnrj0cj20l60ad75p.jpg" alt="img"></a></p><ol><li>如何添加远程库？</li></ol><p>​     现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</p><p>  首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypmocbsj20u40gttbc.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypmocbsj20u40gttbc.jpg" alt="img"></a></p><p>在Repository name填入<code>testgit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypm6o2gj20si0idwh4.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypm6o2gj20si0idwh4.jpg" alt="img"></a></p><p>  目前，在GitHub上的这个<code>testgit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的<code>testgit</code>仓库下运行命令：</p><p>git remote add origin <a href="https://github.com/tugenhua0707/testgit.git" target="_blank" rel="noopener">https://github.com/tugenhua0707/testgit.git</a></p><p>所有的如下：</p><p> <a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypk8b34j20hk070764.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypk8b34j20hk070764.jpg" alt="img"></a></p><p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypjhn5ij20t40i7mzp.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypjhn5ij20t40i7mzp.jpg" alt="img"></a></p><p>从现在起，只要本地作了提交，就可以通过如下命令：</p><p>git push origin master</p><p>把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。</p><p>\2. 如何从远程库克隆？</p><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。</p><p>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？</p><p>首先，登录github，创建一个新的仓库，名字叫testgit2.如下：</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyphv15sj20t10gs775.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyphv15sj20t10gs775.jpg" alt="img"></a></p><p>如下，我们看到：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypexzvuj20ss0dgabs.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypexzvuj20ss0dgabs.jpg" alt="img"></a></p><p>现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypec5t0j20hp03jwf6.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypec5t0j20hp03jwf6.jpg" alt="img"></a></p><p>接着在我本地目录下 生成testgit2目录了，如下所示：</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypdbpwnj20jt05hmxr.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypdbpwnj20jt05hmxr.jpg" alt="img"></a></p><p>六：创建与合并分支。</p><p>在  版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p><p>首先，我们来创建dev分支，然后切换到dev分支上。如下操作：</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypab36sj20bc04nweu.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypab36sj20bc04nweu.jpg" alt="img"></a></p><p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令</p><p>git branch dev</p><p>git checkout dev</p><p>git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p><p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p><p><a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyp9es90j20at0awjsq.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyp9es90j20at0awjsq.jpg" alt="img"></a></p><p>现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：</p><p><a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyp8mng3j20hm05qaav.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyp8mng3j20hm05qaav.jpg" alt="img"></a></p><p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：</p><p><a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyp83uksj20es073gmi.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyp83uksj20es073gmi.jpg" alt="img"></a></p><p>git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。</p><p>注意到上面的<em>Fast-forward</em>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>合并完成后，我们可以接着删除dev分支了，操作如下：</p><p>总结创建与合并分支命令如下：</p><p>  查看分支：git branch</p><p>  创建分支：git branch name</p><p>  切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><h4 id="如何解决冲突"><a href="#如何解决冲突" class="headerlink" title="如何解决冲突"></a>如何解决冲突</h4><p>下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyp4jq8yj20ft0cu40a.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyp4jq8yj20ft0cu40a.jpg" alt="img"></a></p><p>同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：</p><p><a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyp3w0l1j20g80dwmz7.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyp3w0l1j20g80dwmz7.jpg" alt="img"></a></p><p>现在我们需要在master分支上来合并fenzhi1，如下操作：</p><p><a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyp1wo2ij20hm0gddi9.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyp1wo2ij20hm0gddi9.jpg" alt="img"></a></p><p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyp11x4zj20g107e3zd.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyp11x4zj20g107e3zd.jpg" alt="img"></a></p><p>如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyp0aj6uj20dt0o5gph.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyp0aj6uj20dt0o5gph.jpg" alt="img"></a></p><h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：</p><ol><li>创建一个dev分支。</li><li>修改readme.txt内容。</li><li>添加到暂存区。</li><li>切换回主分支(master)。</li><li>合并dev分支，使用命令 git merge –no-ff -m “注释” dev</li><li>查看历史记录</li></ol><p>截图如下：</p><p> <a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoz5m31j20gr0lon0y.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoz5m31j20gr0lon0y.jpg" alt="img"></a></p><p><strong>分支策略：</strong>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p>七：bug分支：</p><p>   在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p><p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</p><p> <a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoy0x5yj20he04m74v.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoy0x5yj20he04m74v.jpg" alt="img"></a></p><p>  并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p><p> <a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoxn4t8j20i3058dgo.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoxn4t8j20i3058dgo.jpg" alt="img"></a></p><p>  所以现在我可以通过创建issue-404分支来修复bug了。</p><p>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：</p><p> <a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyowmdooj20gp0etq55.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyowmdooj20gp0etq55.jpg" alt="img"></a></p><p>修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：</p><p>现在，我们回到dev分支上干活了。</p><p><a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyou5898j20bq03s0t6.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyou5898j20bq03s0t6.jpg" alt="img"></a></p><p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyot6ny2j20c202lmxg.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyot6ny2j20c202lmxg.jpg" alt="img"></a></p><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p><ol><li>git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。</li><li>另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。</li></ol><p>​     演示如下</p><p> <a href="https://images2015.cnblogs.com/blog/762349/201610/762349-20161026134059296-2019917854.png" target="_blank" rel="noopener"><img src="https://images2015.cnblogs.com/blog/762349/201610/762349-20161026134059296-2019917854.png" alt="img"></a></p><h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><p>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</p><ol><li>要查看远程库的信息 使用 git remote</li><li>要查看远程库的详细信息 使用 git remote –v</li></ol><p>如下演示：</p><p> <a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyor8ayjj20h704pt9e.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyor8ayjj20h704pt9e.jpg" alt="img"></a></p><p><strong>一：推送分支：</strong></p><p>   推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><p>   使用命令 git push origin master</p><p>比如我现在的github上的readme.txt代码如下：</p><p><a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyoolky9j20n00crt9x.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyoolky9j20n00crt9x.jpg" alt="img"></a></p><p>本地的readme.txt代码如下：</p><p> <a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoljbdoj20bp05p74u.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoljbdoj20bp05p74u.jpg" alt="img"></a></p><p>现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoklccxj20f105nmy8.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoklccxj20f105nmy8.jpg" alt="img"></a></p><p>我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyojp2l7j20mi0dgdh4.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyojp2l7j20mi0dgdh4.jpg" alt="img"></a></p><p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev</p><p>那么一般情况下，那些分支要推送呢？</p><ol><li><p>master分支是主分支，因此要时刻与远程同步。</p></li><li><p>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</p></li><li><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4></li><li><p>多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2</p><p>但是我首先要把dev分支也要推送到远程去，如下</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoilae8j20dz047jrw.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoilae8j20dz047jrw.jpg" alt="img"></a></p><p>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</p><p> <a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyofwtkzj20e404qdgn.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyofwtkzj20e404qdgn.jpg" alt="img"></a></p><p>现在目录下生成有如下所示：</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoerppxj20jy07475a.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoerppxj20jy07475a.jpg" alt="img"></a></p><p>现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout –b dev origin/dev</p><p>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。</p><p>如下：</p><p><a href="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyodj3j4j20gq0katc9.jpg" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyodj3j4j20gq0katc9.jpg" alt="img"></a></p><p>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyocm8nlj20hz0l3jvp.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyocm8nlj20hz0l3jvp.jpg" alt="img"></a></p><p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p><p><a href="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoblpvij20gi07ugmx.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoblpvij20gi07ugmx.jpg" alt="img"></a></p><p><em>git pull</em>也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：</p><p><a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyoab9gfj20hy05j0tu.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyoab9gfj20hy05j0tu.jpg" alt="img"></a></p><p>这回<em>git pull</em>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：</p><p>我们可以先来看看readme.txt内容了。</p><p><a href="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyo7l3o6j20ef07p74y.jpg" target="_blank" rel="noopener"><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyo7l3o6j20ef07p74y.jpg" alt="img"></a></p><p>现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：<br><a href="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyo5em1aj20gt0dcwgv.jpg" target="_blank" rel="noopener"><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyo5em1aj20gt0dcwgv.jpg" alt="img"></a></p><p>因此：多人协作工作模式一般是这样的：</p><ol><li><p>首先，可以试图用git push origin branch-name推送自己的修改.</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</p></li><li><p>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</p></li><li><p>Git基本常用命令如下</p></li><li><p>mkdir：     XX (创建一个空目录 XX指目录名)</p><p>pwd：     显示当前目录的路径。</p><p>git init     把当前的目录变成可以管理的git仓库，生成隐藏.git文件。</p><p>git add XX    把xx文件添加到暂存区去。</p><p>git commit –m “XX” 提交文件 –m 后面的是注释。</p><p>git status    查看仓库状态</p><p>git diff XX   查看XX文件修改了那些内容</p><p>git log     查看历史记录</p><p>git reset –hard HEAD^ 或者 git reset –hard HEAD~ 回退到上一个版本</p><p>​            (如果想回退到100个版本，使用git reset –hard HEAD~100 )</p><p>cat XX     查看XX文件内容</p><p>git reflog    查看历史记录的版本号id</p><p>git checkout — XX 把XX文件在工作区的修改全部撤销。</p><p>git rm XX     删除XX文件</p><p>git remote add origin <a href="https://github.com/ev-power/XiaoYong" target="_blank" rel="noopener">https://github.com/ev-power/XiaoYong</a> 关联一个远程库</p><p>git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库</p><p>git clone <a href="https://github.com/ev-power/XiaoYong" target="_blank" rel="noopener">https://github.com/ev-power/XiaoYong</a> 从远程库中克隆</p><p>git checkout –b dev 创建dev分支 并切换到dev分支上</p><p>git branch 查看当前所有的分支</p><p>git checkout master 切换回master分支</p><p>git merge dev  在当前的分支上合并dev分支</p><p>git branch –d dev 删除dev分支</p><p>git branch name 创建分支</p><p>git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作</p><p>git stash list 查看所有被隐藏的文件列表</p><p>git stash apply 恢复被隐藏的文件，但是内容不删除</p><p>git stash drop 删除文件</p><p>git stash pop 恢复文件的同时 也删除文件</p><p>git remote 查看远程库的信息</p><p>git remote –v 查看远程库的详细信息</p><p>git push origin master Git会把master分支推送到远程库对应的远程分支上   </p></li><li><p>本文非原创博客，部分内容有所更改，原文出自：<a href="http://www.cnblogs.com/tugenhua0707/p/4050072.html" target="_blank" rel="noopener">http://www.cnblogs.com/tugenhua0707/p/4050072.html</a></p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;讨论了许多种git的情况，非常详细的git报告&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2gy1gds54g3odrj206402kmwz.jpg&quot; alt=&quot;undefined&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>朝花夕拾</title>
    <link href="http://yoursite.com/2020/04/09/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    <id>http://yoursite.com/2020/04/09/朝花夕拾/</id>
    <published>2020-04-09T13:54:15.038Z</published>
    <updated>2020-07-13T16:11:13.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>资质低下 三心二意 昨日知识 朝花夕拾</p></blockquote><a id="more"></a> <h3 id="更友好的创建对象方式"><a href="#更友好的创建对象方式" class="headerlink" title="更友好的创建对象方式"></a>更友好的创建对象方式</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gdnjra9kkrj20sk0c6myf.jpg" alt="3d5024b55687373af54fcb9ef4e0eb4.png"></p><p>上面的方式，对JVM来说是更友好的，因为堆内存的调用无法避免，所以从栈内存这边入手解决内存问题是一个不错的解决的方式</p><hr><h3 id="下面代码是否线程安全"><a href="#下面代码是否线程安全" class="headerlink" title="下面代码是否线程安全"></a>下面代码是否线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看类似饿汉式的单例，线程安全，其实是有问题的</p><p>虽然只有一个线程能够获得锁，并且这个锁还是类锁，所有对象共享的</p><p>关键在于 jvm 对 new 的优化，这个变量没有声明 volatile，new 不是一个线程安全的操作，</p><p>对于 new 这个指令，一般的顺序是申请内存空间，初始化内存空间，然后把内存地址赋给 instance 对象，但是 jvm 会对这段指令进行优化，优化之后变成 申请内存空间，内存地址赋给 instance 对象，初始化内存空间，这就导致 第二层检查可能会出错，标准写法只需要在变量前声明 volatile 即可。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gdnkbsp9sij20pp0gy75i.jpg" alt="677701574e4f69f35e226ed6bc9a380.png"></p><hr><h3 id="volatile利用了什么协议来实现可见性"><a href="#volatile利用了什么协议来实现可见性" class="headerlink" title="volatile利用了什么协议来实现可见性"></a>volatile利用了什么协议来实现可见性</h3><p>volatile 是通过内存屏障实现的，MESI协议，缓存一致性协议</p><p>JVM推荐书《The Java Language Specification》<br>volatile 修饰的变量如果值发生变化 发现线程的高速缓存与主存数据不一致时候 由于缓存一致性协议 则总线将高速缓存中的值清空 其他线程只能通过访问主存来获取最新的值 并缓存到告诉缓存上。</p><hr><h3 id="Java-Trainsient-关键字"><a href="#Java-Trainsient-关键字" class="headerlink" title="Java Trainsient 关键字"></a>Java Trainsient 关键字</h3><p>1.一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 </p><p>2.transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 </p><p>3.一个静态变量不管是否被transient修饰，均不能被序列化。 </p><p>使用总结和场景：某个类的有些属性需要序列化，其他属性不需要被序列化，比如：敏感信息（如密码，银行卡号等），java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><h3 id="多线程中Random的使用"><a href="#多线程中Random的使用" class="headerlink" title="多线程中Random的使用"></a>多线程中Random的使用</h3><p>1.不要在多个线程间共享一个java.util.Random实例，而该把它放入ThreadLocal之中。</p><p>2.Java7以上我们更推荐使用java.util.concurrent.ThreadLocalRandom。</p><p>下面两条建议是 IDEA给的:</p><p>1.不要将将随机数放大10的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法</p><p>2.Math.random()应避免在多线程环境下使用</p><h3 id="为什么阿里禁止使用Executor创建线程池"><a href="#为什么阿里禁止使用Executor创建线程池" class="headerlink" title="为什么阿里禁止使用Executor创建线程池"></a>为什么阿里禁止使用Executor创建线程池</h3><p>阿里规约之所以强制要求手动创建线程池，也是和这些参数有关。具体为什么不允许，规约是这么说的：</p><p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>Executor提供的四个静态方法创建线程池，但是阿里规约却并不建议使用它。</p><p>Executors各个方法的弊端：<br>1）newFixedThreadPool和newSingleThreadExecutor:<br>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。<br>2）newCachedThreadPool和newScheduledThreadPool:<br>  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p><p>看一下这两种弊端怎么导致的。</p><p>第一种，newFixedThreadPool和newSingleThreadExecutor分别获得 FixedThreadPool 类型的线程池 和  SingleThreadExecutor 类型的线程池。　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">       return new FinalizableDelegatedExecutorService</span><br><span class="line">           (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                   0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为，创建了一个无界队列LinkedBlockingQueuesize，是一个最大值为Integer.MAX_VALUE的线程阻塞队列，当添加任务的速度大于线程池处理任务的速度，可能会在队列堆积大量的请求，消耗很大的内存，甚至导致OOM。</p><h3 id="阿里开发手册上不推荐（禁止）使用Double的根本原因"><a href="#阿里开发手册上不推荐（禁止）使用Double的根本原因" class="headerlink" title="阿里开发手册上不推荐（禁止）使用Double的根本原因"></a>阿里开发手册上不推荐（禁止）使用Double的根本原因</h3><p>精度丢失就不谈了，稍微深入一下为什么精度会丢失，分为一些不同情况</p><p><strong>典型现象（一）：条件判断超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.9999999f</span> );   <span class="comment">// 打印：false</span></span><br><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.99999999f</span> );  <span class="comment">// 打印：true    纳尼？</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.0</span>（十进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">00111111</span> <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span>（二进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">0x3F800000</span>（十六进制）</span><br><span class="line">    </span><br><span class="line"><span class="number">0.99999999</span>（十进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">00111111</span> <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span>（二进制）</span><br><span class="line">    ↓</span><br><span class="line"><span class="number">0x3F800000</span>（十六进制）</span><br><span class="line">    </span><br><span class="line">果不其然，这两个十进制浮点数的底层二进制表示是一毛一样的，怪不得==的判断结果返回<span class="keyword">true</span>！</span><br><span class="line"></span><br><span class="line">浮点数的精度问题。</span><br><span class="line">    </span><br><span class="line">浮点数在计算机中的存储方式遵循IEEE <span class="number">754</span> 浮点数计数标准，可以用科学计数法表示为：</span><br><span class="line">    <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、符号部分（S）</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>-正  <span class="number">1</span>-负</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、阶码部分（E）（指数部分）：</span><br><span class="line"></span><br><span class="line">对于<span class="keyword">float</span>型浮点数，指数部分<span class="number">8</span>位，考虑可正可负，因此可以表示的指数范围为-<span class="number">127</span> ~ <span class="number">128</span></span><br><span class="line">对于<span class="keyword">double</span>型浮点数，指数部分<span class="number">11</span>位，考虑可正可负，因此可以表示的指数范围为-<span class="number">1023</span> ~ <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、尾数部分（M）：</span><br><span class="line"></span><br><span class="line">浮点数的精度是由尾数的位数来决定的：</span><br><span class="line"></span><br><span class="line">对于<span class="keyword">float</span>型浮点数，尾数部分<span class="number">23</span>位，换算成十进制就是 <span class="number">2</span>^<span class="number">23</span>=<span class="number">8388608</span>，所以十进制精度只有<span class="number">6</span> ~ <span class="number">7</span>位；</span><br><span class="line">对于<span class="keyword">double</span>型浮点数，尾数部分<span class="number">52</span>位，换算成十进制就是 <span class="number">2</span>^<span class="number">52</span> = <span class="number">4503599627370496</span>，所以十进制精度只有<span class="number">15</span> ~ <span class="number">16</span>位</span><br><span class="line"></span><br><span class="line">所以对于上面的数值<span class="number">0.99999999f</span>，很明显已经超过了<span class="keyword">float</span>型浮点数据的精度范围，出问题也是在所难免的。</span><br></pre></td></tr></table></figure><p><strong>典型现象（二）：数据转换超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span>;</span><br><span class="line"><span class="keyword">double</span> d = (<span class="keyword">double</span>) f;</span><br><span class="line">System.out.println(f);  <span class="comment">// 打印：1.1</span></span><br><span class="line">System.out.println(d);  <span class="comment">// 打印：1.100000023841858  纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>典型现象（三）：基本运算超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">0.2</span> + <span class="number">0.7</span> );  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：0.8999999999999999   纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>典型现象（四）：数据自增超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = <span class="number">8455263f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(f1);</span><br><span class="line">    f1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印：8455263.0</span></span><br><span class="line"><span class="comment">// 打印：8455264.0</span></span><br><span class="line"><span class="comment">// 打印：8455265.0</span></span><br><span class="line"><span class="comment">// 打印：8455266.0</span></span><br><span class="line"><span class="comment">// 打印：8455267.0</span></span><br><span class="line"><span class="comment">// 打印：8455268.0</span></span><br><span class="line"><span class="comment">// 打印：8455269.0</span></span><br><span class="line"><span class="comment">// 打印：8455270.0</span></span><br><span class="line"><span class="comment">// 打印：8455271.0</span></span><br><span class="line"><span class="comment">// 打印：8455272.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">84552631f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(f2);</span><br><span class="line">    f2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br></pre></td></tr></table></figure><p>解决办法：</p><p>1.我们我们可以用字符串或者数组来表示这种大数，然后按照四则运算的规则来手动模拟出具体计算过程，中间还需要考虑各种诸如：<strong>进位、借位、符号</strong>等等问题的处理，有点复杂。</p><ol start="2"><li>JDK早已为我们考虑到了浮点数的计算精度问题，因此提供了专用于高精度数值计算的<strong>大数类</strong>来方便我们使用。</li></ol><h3 id="mac-清理maven仓库的脚本"><a href="#mac-清理maven仓库的脚本" class="headerlink" title="mac 清理maven仓库的脚本"></a>mac 清理maven仓库的脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这里写你的仓库路径</span><br><span class="line">REPOSITORY_PATH=~/Documents/tools/apache-maven-3.0.3/repository</span><br><span class="line">echo 正在搜索...</span><br><span class="line">find $REPOSITORY_PATH -name &quot;*lastUpdated*&quot; | xargs rm -fr</span><br><span class="line">echo 删除完毕</span><br><span class="line"></span><br><span class="line">mac（linux）系统-创建.sh文件脚本执行（mac用.command终端也可以）</span><br></pre></td></tr></table></figure><h3 id="idea目录较多，文件名较长产生的错误"><a href="#idea目录较多，文件名较长产生的错误" class="headerlink" title="idea目录较多，文件名较长产生的错误"></a>idea目录较多，文件名较长产生的错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error running &apos;ServiceStarter&apos;: Command line is too long. Shorten command line for ServiceStarter or also for Application default configuration.</span><br><span class="line"></span><br><span class="line">修改项目下 .idea\workspace.xml，找到标签 &lt;component name=&quot;PropertiesComponent&quot;&gt; ， 在标签里加一行 &lt;property name=&quot;dynamic.classpath&quot; value=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="Log4J-指定屏蔽某些特定报警信息"><a href="#Log4J-指定屏蔽某些特定报警信息" class="headerlink" title="Log4J 指定屏蔽某些特定报警信息"></a>Log4J 指定屏蔽某些特定报警信息</h3><p>Logger.getLogger(“org.apache.library”).setLevel(Level.OFF)</p><h3 id="Flink-Source并行度为1的意义"><a href="#Flink-Source并行度为1的意义" class="headerlink" title="Flink Source并行度为1的意义"></a>Flink Source并行度为1的意义</h3><p>对于需要设置EventTime的流来说，我们的TimestampAssigner应该在Source之后立即调用，原因是时间戳分配器看到的元素的顺序应该和source操作符产生数据的顺序是一样的，否则就乱了，也就是说，任何分区操作都会将元素的顺序打乱，例如：改变并行度 keyBy操作等等。，所以最佳实践是：</p><p>在尽量接近数据源source操作符的地方分配时间戳和产生水位线，甚至最好在SourceFunction中分配时间戳和产生水位线。当然在分配时间戳和产生水位线之前可以对流进行map和filter操作是没问题的，也就是说必须是窄依赖。</p><h3 id="JB套件的一个实用功能"><a href="#JB套件的一个实用功能" class="headerlink" title="JB套件的一个实用功能"></a>JB套件的一个实用功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前没注意，更改变量名字的时候直接使用refactor就可以了，真的实用</span><br></pre></td></tr></table></figure><h3 id="zk使用的分布式协议并不是paxos"><a href="#zk使用的分布式协议并不是paxos" class="headerlink" title="zk使用的分布式协议并不是paxos"></a>zk使用的分布式协议并不是paxos</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而是zab协议</span><br></pre></td></tr></table></figure><h3 id="为什么说NULL是计算机科学中最大的错误，至少值十亿美金"><a href="#为什么说NULL是计算机科学中最大的错误，至少值十亿美金" class="headerlink" title="为什么说NULL是计算机科学中最大的错误，至少值十亿美金"></a>为什么说NULL是计算机科学中最大的错误，至少值十亿美金</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.覆类型</span><br><span class="line">2.是凌乱的</span><br><span class="line">3.是一个特例</span><br><span class="line">4.使 API 变得糟糕</span><br><span class="line">5.使错误的语言决策更加恶化</span><br><span class="line">6.难以调试</span><br><span class="line">7.是不可组合的</span><br></pre></td></tr></table></figure><h4 id="1-NULL-颠覆类型"><a href="#1-NULL-颠覆类型" class="headerlink" title="1. NULL 颠覆类型"></a>1. NULL 颠覆类型</h4><p>静态类型语言不需要实际去执行程序，就可以检查程序中类型的使用，并且提供一定的程序行为保证。</p><p>例如，在 Java 中，如果我编写 <code>x.toUppercase()</code>，编译器会检查 <code>x</code> 的类型。如果 <code>x</code> 是一个 <code>String</code>，那么类型检查成功；如果 <code>x</code> 是一个 <code>Socket</code>，那么类型检查失败。</p><p>在编写庞大的、复杂的软件时，静态类型检查是一个强大的工具。但是对于 Java，这些很棒的编译时检查存在一个致命缺陷：任何引用都可以是 null，而调用一个 null 对象的方法会产生一个 <code>NullPointerException</code>。所以，</p><ul><li><code>toUppercase()</code> 可以被任意 <code>String</code> 对象调用。除非 <code>String</code> 是 null。</li><li><code>read()</code> 可以被任意 <code>InputStream</code> 对象调用。除非 <code>InputStream</code> 是 null。</li><li><code>toString()</code> 可以被任意 <code>Object</code> 对象调用。除非 <code>Object</code> 是 null。</li></ul><p>Java 不是唯一引起这个问题的语言；很多其它的类型系统也有同样的缺点，当然包括 AGOL W 语言。</p><p>在这些语言中，NULL 超出了类型检查的范围。它悄悄地越过类型检查，等待运行时，最后一下子释放出一大批错误。NULL 什么也不是，同时又什么都是。</p><h4 id="2-NULL-是凌乱的"><a href="#2-NULL-是凌乱的" class="headerlink" title="2. NULL 是凌乱的"></a>2. NULL 是凌乱的</h4><p>在很多情况下 null 是没有意义的。不幸的是，如果一种语言允许任何东西为 null，好吧，那么任何东西都可以是 null。</p><p>Java 程序员冒着患腕管综合症的风险写下</p><p>Java</p><p> <code>if (str == null 丨丨 str.equals(&quot;&quot;)) {}</code> </p><p>而在 C# 中添加 <code>String.IsNullOrEmpty</code> 是一个常见的语法</p><p>C#</p><p> <code>if (string.IsNullOrEmpty(str)) {}</code> </p><p>真可恶！</p><p>每次你写代码，将 null 字符串和空字符串混为一谈时，Guava 团队都要哭了。– <a href="https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="noopener">Google Guava</a></p><p>说得好。但是当你的类型系统（例如，Java 或者 C#）到处都允许 NULL 时，你就不能可靠地排除 NULL 的可能性，并且不可避免的会在某个地方混淆。</p><p>null 无处不在的可能性造成了这样一个问题，Java 8 添加了 <code>@NonNull</code> 标注，尝试着在它的类型系统中以追溯方式解决这个缺陷。</p><h4 id="3-NULL-是一个特例"><a href="#3-NULL-是一个特例" class="headerlink" title="3. NULL 是一个特例"></a>3. NULL 是一个特例</h4><p>考虑到 NULL 不是一个值却又起到一个值的作用，NULL 自然地成为各种特别处理方法的课题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char c = &apos;A&apos;;</span><br><span class="line">char *myChar = &amp;c;</span><br><span class="line">std::cout &lt;&lt; *myChar &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>单个 NUL 字符的例外已经导致无数的错误：API 的怪异行为、安全漏洞和缓冲区溢出。</p><p>NULL 是 C 字符串中最糟糕的错误；更确切地说，以 NUL 结尾的字符串是<a href="http://queue.acm.org/detail.cfm?id=2010365" target="_blank" rel="noopener">最昂贵的<strong>一字节</strong>错误</a>。</p><h4 id="4-NULL-使-API-变得糟糕"><a href="#4-NULL-使-API-变得糟糕" class="headerlink" title="4.NULL 使 API 变得糟糕"></a>4.NULL 使 API 变得糟糕</h4><p>我们可以想象在很多语言中类似的类（Python、JavaScript、Java、C# 等）。</p><p>现在假设我们的程序有一个慢的或者占用大量资源的方法，来找到某个人的电话号码——可能通过连通一个网络服务。</p><p>为了提高性能，我们将会使用本地存储作为缓存，将一个人名映射到他的电话号码上。</p><p>然而，一些人没有电话号码（即他们的电话号码是 nil）。我们仍然会缓存那些信息，所以我们不需要在后面重新填充那些信息。</p><p>但是现在意味着我们的结果模棱两可！它可能表示：</p><ol><li>这个人不存在于缓存中（Alice）</li><li>这个人存在于缓存中，但是没有电话号码（Tom）</li></ol><p>一种情形要求昂贵的重新计算，另一种需要即时的答复。但是我们的代码不够精密来区分这两种情况。</p><p>在实际的代码中，像这样的情况经常会以复杂且不易察觉的方式出现。因此，简单通用的 API 可以马上变成特例，迷惑了 null 凌乱行为的来源。</p><p>用一个 <code>contains()</code> 方法来修补 <code>Store</code> 类可能会有帮助。但是这引入重复的查找，导致降低性能和竞争条件。</p><h4 id="5-NULL-使错误的语言决策更加恶化"><a href="#5-NULL-使错误的语言决策更加恶化" class="headerlink" title="5.NULL 使错误的语言决策更加恶化"></a>5.NULL 使错误的语言决策更加恶化</h4><h4 id="6-NULL-难以调试"><a href="#6-NULL-难以调试" class="headerlink" title="6.NULL 难以调试"></a>6.NULL 难以调试</h4><p>来解释 NULL 是多么的麻烦，C++ 是一个很好的例子。调用成员函数指向一个 NULL 指针不一定会导致程序崩溃。更糟糕的是：它可能会导致程序崩溃。</p><h4 id="7-NULL不可组合"><a href="#7-NULL不可组合" class="headerlink" title="7.NULL不可组合"></a>7.NULL不可组合</h4><h3 id="IDEA-maven修改pom文件，导致jdk版本重置问题"><a href="#IDEA-maven修改pom文件，导致jdk版本重置问题" class="headerlink" title="IDEA maven修改pom文件，导致jdk版本重置问题"></a>IDEA maven修改pom文件，导致jdk版本重置问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><h3 id="EXCEL一点小技巧"><a href="#EXCEL一点小技巧" class="headerlink" title="EXCEL一点小技巧"></a>EXCEL一点小技巧</h3><p>正好最近用来有点小用处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.从固定的单元格里随机取一个值</span><br><span class="line">=INDEX($G$2:$M$2, RANDBETWEEN(1,7))</span><br><span class="line">$G$2：下拉的时候不会自动延伸</span><br><span class="line"></span><br><span class="line">2.从固定列取值用在本单元格里</span><br><span class="line">=&quot;INSERT INTO `event_mapping` VALUES (&apos;&quot;&amp;B2&amp;&quot;&apos;,&quot;&amp;C2&amp;&quot;,&quot;&amp;D2&amp;&quot;);&quot;</span><br><span class="line"></span><br><span class="line">3.下拉到某行</span><br><span class="line">在有第一行的情况下，直接双击右下角小箭头即可</span><br></pre></td></tr></table></figure><h3 id="Flink-On-Zeppelin上传Jar包的位置"><a href="#Flink-On-Zeppelin上传Jar包的位置" class="headerlink" title="Flink On Zeppelin上传Jar包的位置"></a>Flink On Zeppelin上传Jar包的位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/opt/flink-1.10/flink-1.10.0/lib</span><br><span class="line"></span><br><span class="line">目前看来应该是放在flink包里面的，会稳定上传，已经确定</span><br><span class="line"></span><br><span class="line">在interpreter 依赖里面设置了路劲</span><br><span class="line">/opt/flink-1.10/flink-1.10.0/lib/jimipojo-1.0.jar</span><br></pre></td></tr></table></figure><h3 id="Flink系列深度好文，等待细读"><a href="#Flink系列深度好文，等待细读" class="headerlink" title="Flink系列深度好文，等待细读"></a>Flink系列深度好文，等待细读</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.jianshu.com/c/b6089c70072f</span><br><span class="line">flink的apply和process方法有什么区别呢</span><br></pre></td></tr></table></figure><h3 id="FastJson直接解析"><a href="#FastJson直接解析" class="headerlink" title="FastJson直接解析"></a>FastJson直接解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.map(</span><br><span class="line">a -&gt; JSON</span><br><span class="line">.parseObject(</span><br><span class="line">a,</span><br><span class="line">Pojo.class)</span><br><span class="line">).returns(</span><br><span class="line">Pojo.class</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>具体的还要试一下，我故意写的很难看来督促自己。。。</p><h3 id="FastJson很多坑-准备放弃"><a href="#FastJson很多坑-准备放弃" class="headerlink" title="FastJson很多坑 准备放弃"></a>FastJson很多坑 准备放弃</h3><h3 id="配置框架无法访问的问题"><a href="#配置框架无法访问的问题" class="headerlink" title="配置框架无法访问的问题"></a>配置框架无法访问的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有点脑残了，今天在mac上配置了zeppelin win无法访问，其原因是配置文件中的网络地址写死了 172.0.0.1, 如果想要别尔德位置能够访问的话，必须改变配置为其局域网id</span><br><span class="line"></span><br><span class="line">更好的选择是更改为0.0.0.0</span><br></pre></td></tr></table></figure><h3 id="解决GitHub提交历史头像不显示问题-以及首页没有绿色方块的问题"><a href="#解决GitHub提交历史头像不显示问题-以及首页没有绿色方块的问题" class="headerlink" title="解决GitHub提交历史头像不显示问题,以及首页没有绿色方块的问题"></a>解决GitHub提交历史头像不显示问题,以及首页没有绿色方块的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">最近把本地的一个项目提交推送到GitHub的时候发现有两个问题, </span><br><span class="line">1.在commit提交历史里面</span><br><span class="line"></span><br><span class="line">提交内容的旁边,显示的不是原本github主页的头像,而是默认的灰色章鱼头像</span><br><span class="line"></span><br><span class="line">2.我的contributions里面提交的历史(绿色方块)也没有了</span><br><span class="line"></span><br><span class="line">怎么解决呢？</span><br><span class="line"></span><br><span class="line">1.首先在终端里切到项目所在目录</span><br><span class="line"></span><br><span class="line">2.输入git show命令,你会发现 有一行写着Author: Apple &lt;邮箱&gt;,这个邮箱肯定不是你绑定到github的邮箱</span><br><span class="line"></span><br><span class="line">3.输入git config user.email &quot;你的邮箱地址&quot;,修改邮箱</span><br><span class="line"></span><br><span class="line">4.修改完以后输入git config user.email 检查是否修改成了你的邮箱</span><br><span class="line"></span><br><span class="line">5.到目前为止现在只是修改这个项目的邮箱,重新推送一个新的改动,在查看该项目的提交历史和contributions里面提交的历史(绿色方块),问题已经解决了(之前的依旧不显示)</span><br><span class="line"></span><br><span class="line">6.如果你想其他项目提交时,也避免此类情况,把上面的两条命令改成 （1） git config --global user.email &quot;your_email@example.com&quot;</span><br><span class="line"></span><br><span class="line">（2）git config --global user.email 就可以了</span><br></pre></td></tr></table></figure><h3 id="解决anaconda无法连接的问题"><a href="#解决anaconda无法连接的问题" class="headerlink" title="解决anaconda无法连接的问题"></a>解决anaconda无法连接的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win10下更换清华镜像后无法连接 是因为win10里面无法解析https协议，修改‪~\.condarc文件，把https换成http</span><br></pre></td></tr></table></figure><h3 id="排查挖矿程序中会用到的一些追踪某个进程的命令"><a href="#排查挖矿程序中会用到的一些追踪某个进程的命令" class="headerlink" title="排查挖矿程序中会用到的一些追踪某个进程的命令"></a>排查挖矿程序中会用到的一些追踪某个进程的命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>查看PID启动文件的路径</span><br><span class="line">ls -l /proc/$PID/exe</span><br><span class="line"><span class="meta">#</span>查看PID执行目录的路径</span><br><span class="line">ls -l /proc/$PID/cwd</span><br><span class="line"><span class="meta">#</span>在定时器配置目录查看是否存在异常定时器配置</span><br><span class="line">/var/spool/cron/root 和/etc/crontab 和/etc/rc.lcoal</span><br><span class="line"><span class="meta">#</span>查看定时器启动日志,跟踪自启动程序</span><br><span class="line">tail -f /var/log/cron</span><br><span class="line"><span class="meta">#</span>查看各个进程的cpu使用情况，默认按cpu使用率排序</span><br><span class="line">top</span><br><span class="line"><span class="meta">#</span>显示所有运行中的进程，q退出</span><br><span class="line">ps aux | less</span><br><span class="line"><span class="meta">#</span>查看test.jar进程号</span><br><span class="line">ps -aux|grep test.jar | grep -v grep</span><br><span class="line"><span class="meta">#</span>查看test.jar进程号</span><br><span class="line">ps -ef|grep test.jar | grep -v grep</span><br><span class="line"><span class="meta">#</span>查看该进程下各个线程的cpu使用情况</span><br><span class="line">top -Hp pid</span><br><span class="line"><span class="meta">#</span>将线程pid转换为十六进制 8f7</span><br><span class="line">printf "%x\n" pid</span><br><span class="line"><span class="meta">#</span>查看pid进程里面的线程信息,线程Id为十六进制</span><br><span class="line">jstack pid | grep 8f7</span><br><span class="line"><span class="meta">#</span>查看该进程打开的文件</span><br><span class="line">lsof -p pid</span><br><span class="line"><span class="meta">#</span>查看pid线程内存分配</span><br><span class="line">cat /proc/pid/maps </span><br><span class="line"><span class="meta">#</span>查看PID启动文件的路径</span><br><span class="line">ls -l /proc/$PID/exe </span><br><span class="line"><span class="meta">#</span>查看PID执行目录的路径</span><br><span class="line">ls -l /proc/$PID/cwd </span><br><span class="line"><span class="meta">#</span>查看PID详细的内存占比</span><br><span class="line">cat /proc/$PID/status</span><br></pre></td></tr></table></figure><h3 id="Kerberos缺点"><a href="#Kerberos缺点" class="headerlink" title="Kerberos缺点"></a>Kerberos缺点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、KDC 有单点风险，除非设置HA系统(Aictive Directory 可以做到这一点，目前apache directoryserver 也可以做到这一点)；</span><br><span class="line"></span><br><span class="line">2、访问压力可能使KDC过载；分布式服务使用Kerberos 必须做到这一点，KDC无法承受高负载请求；为什么Hadoop 要使用代理tokens的原因也是如此；</span><br><span class="line"></span><br><span class="line">3、服务之间的通信通道也需要安全认证，kerberos不保证数据加密；如果通信通道不安全，tickets 可能会被拦截或者通信伪造；</span><br><span class="line"></span><br><span class="line">4、机器之前需要保证时间的精确一致性，不然具备时限的tockens不会正常工作；这个在分布式领域是一个典型的问题，Paxos &amp;Raft协议也必须保证时间的一致性；</span><br><span class="line"></span><br><span class="line">5、如果机器间的时间没有被安全管理，理论上可能延长被盗token的使用时间；</span><br><span class="line"></span><br><span class="line">6、被盗用的token可以拿来直接访问服务，在KDC是没有访问日志的。每一个application需要拥有自己的以用户为单位的审计日志，这样才能保证被盗的ticket可被追踪，比如在Hadoop里面HDFS审计日志；</span><br><span class="line"></span><br><span class="line">7、这是一个仅仅认证服务：验证caller的合法性并准许给caller传递认证信息，他不处理任何授权信息；</span><br></pre></td></tr></table></figure><h3 id="mac无法运行-sh文件的解决办法"><a href="#mac无法运行-sh文件的解决办法" class="headerlink" title="mac无法运行.sh文件的解决办法"></a>mac无法运行.sh文件的解决办法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">今天解决了一下内网穿透的问题，</span><br><span class="line">轻量级的选择有frp，</span><br><span class="line">重量级的有goproxy</span><br><span class="line"></span><br><span class="line">几个问题记录一下，第一点：</span><br><span class="line">zsh无法运行.sh文件，要进行切换</span><br><span class="line">chsh -s /bin/bash</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h3 id="解决git下载速度慢的终极方法"><a href="#解决git下载速度慢的终极方法" class="headerlink" title="解决git下载速度慢的终极方法"></a>解决git下载速度慢的终极方法</h3><p>因为本地的网络始终有一些问题，再忍受了很久很久的龟速下载之后，终于找了个一个非常顶的方法</p><p>前提是现有一个vpn，但是vpn不会自动代理git的流量，不管是在windows下面还是在mac下面都不会自动代理git，这点一直让我十分苦恼，现在终于找到了一劳永逸的办法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos; </span><br><span class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br></pre></td></tr></table></figure><p>简单说明：vpn一般都是走的1080端口，通过这个端口转发git的流量，跳过本地运营商。</p><h3 id="给win10商店设置代理"><a href="#给win10商店设置代理" class="headerlink" title="给win10商店设置代理"></a>给win10商店设置代理</h3><p>最近发现。。。只要有一个好的代理服务器，win10的商店原来也是能随便打开的，这里介绍一下win10的商店的流量怎么走代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先通过 Win + R 快捷键打开「运行」窗口，输入「Regedit」打开注册表编辑器，然后定位到 HKEY_CURRENT_USER\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings，接着在左边的注册表项中找到你想解除网络隔离的应用，右边的 DisplayName 就是应用名称，而左边那一大串字符就是应用的 SID 值了。</span><br></pre></td></tr></table></figure><p>找到这个值之后，然后在cmd命令行中输入：</p><p><code>CheckNetIsolation.exe loopbackexempt -a -p=SID</code></p><p>这ID就是上面搜索到的，这样就行</p><h3 id="Maven代理配置"><a href="#Maven代理配置" class="headerlink" title="Maven代理配置"></a>Maven代理配置</h3><p>不需要配置什么https或者http模式，在有代理的前提下，只要配置一个代理即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>ss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>socks5<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">host</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span>&gt;</span>1080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要注意的是监控一下端口，如果代理没开的话那肯定是无法连接上的，mirror就不用设置了，直接从中央仓库拉去数据。</p><h3 id="npm更换源"><a href="#npm更换源" class="headerlink" title="npm更换源"></a>npm更换源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//设置淘宝源</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">//设置公司的源</span><br><span class="line">npm config set registry http://127.0.0.1:4873</span><br><span class="line"></span><br><span class="line">//查看源，可以看到设置过的所有的源</span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>其实感觉应该把Mac管理node的brew n弄一下</p><h3 id="HDFS的某个错误"><a href="#HDFS的某个错误" class="headerlink" title="HDFS的某个错误"></a>HDFS的某个错误</h3><p>HBase和Flink在运行的时候报错</p><p>hbase启动后region自动挂了，Flink任务失败，文件丢失，然后查看hdfs日志</p><p>错误原因 dfs.datanode.max.transfer.threads 的参数4096，已经不足以支持现在的Thread，修改为2倍或者4倍或者更多</p><h3 id="IDEA-MAVEN停止加载"><a href="#IDEA-MAVEN停止加载" class="headerlink" title="IDEA MAVEN停止加载"></a>IDEA MAVEN停止加载</h3><p>经常遇到大型项目idea 停止加载mvn，然后就没办法了。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maven -&gt; maven goal idea的maven第六个按钮</span><br><span class="line">点击 然后</span><br><span class="line">mvn -U idea:idea</span><br><span class="line">即可</span><br></pre></td></tr></table></figure><h3 id="窗口触发的一些问题"><a href="#窗口触发的一些问题" class="headerlink" title="窗口触发的一些问题"></a>窗口触发的一些问题</h3><p>窗口是按 watermark 触发的，watermark 如果没有前进到 window end ， window 是不会触发的。</p><p>Flink的窗口触发具体机制需要去源码里面探寻</p><h3 id="Flink-SQL中的爆炸函数"><a href="#Flink-SQL中的爆炸函数" class="headerlink" title="Flink SQL中的爆炸函数"></a>Flink SQL中的爆炸函数</h3><p>Lateral View() 在Flink SQL中是unnest</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">users</span>, tag <span class="keyword">FROM</span> Orders <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> <span class="keyword">UNNEST</span>(tags) <span class="keyword">AS</span> t (tag)</span><br></pre></td></tr></table></figure><h3 id="Flink-UI在Yarn下"><a href="#Flink-UI在Yarn下" class="headerlink" title="Flink UI在Yarn下"></a>Flink UI在Yarn下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flink UI 在 Yarn下很多选线卡看不到详细信息，很正常，因为Yarn这个运行模式有的消息只能在Yarn上管理控制</span><br></pre></td></tr></table></figure><h3 id="Flink的时区问题"><a href="#Flink的时区问题" class="headerlink" title="Flink的时区问题"></a>Flink的时区问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flink的时间戳差了8个小时，可以用时间减去八个小时时差，生成一个减去8小时的列，作为watermark的时间戳。</span><br></pre></td></tr></table></figure><h3 id="Flink的心跳需求问题"><a href="#Flink的心跳需求问题" class="headerlink" title="Flink的心跳需求问题"></a>Flink的心跳需求问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用flink sql在实时计算当天凌晨截止到现在的累计数据的时候，计算步长是10分钟，如果这10分钟内没有新数据达到的话，现在的情况是这10分钟没有写记录，这就会造成业务查这个数据的时候需要找last value这种情形，设计一条方案让没有数据到达的时候也生成一条记录，这条记录的值就是last value。</span><br><span class="line"></span><br><span class="line">方案：</span><br><span class="line">往数据源发心跳数据。</span><br><span class="line">发送的数据格式和普通数据一样，只是这些数据不影响你的 agg 计算，比如 null 值。发送频率就根据需求去确定。</span><br></pre></td></tr></table></figure><h3 id="Flink避免重复劳动的一些方法"><a href="#Flink避免重复劳动的一些方法" class="headerlink" title="Flink避免重复劳动的一些方法"></a>Flink避免重复劳动的一些方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.写DDL+DML分别声明数据源和进行数据处理。</span><br><span class="line">2.groovy+ 规则引擎</span><br></pre></td></tr></table></figure><p>oppo：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gg3fk4uvm2j20j50b1wgo.jpg" alt="微信截图_20200624155221.png"></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gg3floj82tj20go0bw0v5.jpg" alt="FF36AEE6-1E6D-44da-80BB-9BD2FE8142D6.png"></p><h3 id="Flink配置参数"><a href="#Flink配置参数" class="headerlink" title="Flink配置参数"></a>Flink配置参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 开启 distinct agg 切分 </span><br><span class="line">table.optimizer.distinct-agg.split.enabled=true</span><br><span class="line"># 开启两阶段 即local-global 􏰝优化</span><br><span class="line">table.optimizer.agg-phase-strategy=TWO_PHASE</span><br><span class="line"># mini-batch 开启微批操作 </span><br><span class="line">table.exec.mini-batch.enabled=true</span><br><span class="line"># mini-batch的时间间隔，即作业需要额外忍受的延迟</span><br><span class="line">table.exec.mini-batch.allow-latency=5s</span><br><span class="line"># 一个节点中允许最多缓存的数据</span><br><span class="line">table.exec.mini-batch.size=5000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TableEnvironment tEnv = ...</span><br><span class="line"></span><br><span class="line">// access flink configuration</span><br><span class="line">Configuration configuration = tEnv.getConfig().getConfiguration();</span><br><span class="line">// set low-level key-value options</span><br><span class="line">configuration.setString(&quot;table.exec.mini-batch.enabled&quot;, &quot;true&quot;);</span><br><span class="line">configuration.setString(&quot;table.exec.mini-batch.allow-latency&quot;, &quot;5 s&quot;);</span><br><span class="line">configuration.setString(&quot;table.exec.mini-batch.size&quot;, &quot;5000&quot;);</span><br></pre></td></tr></table></figure><h3 id="Flink-GlobalWindow"><a href="#Flink-GlobalWindow" class="headerlink" title="Flink GlobalWindow"></a>Flink GlobalWindow</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function">def <span class="title">testJoin</span><span class="params">()</span>: Unit </span>=&#123;</span><br><span class="line">   val env = StreamExecutionEnvironment.getExecutionEnvironment</span><br><span class="line">   env.setParallelism(<span class="number">3</span>)</span><br><span class="line">   val person = env.fromElements((<span class="string">"1"</span>,<span class="string">"小张"</span>),(<span class="string">"2"</span>,<span class="string">"小刘"</span>),(<span class="string">"3"</span>,<span class="string">"小力"</span>),(<span class="string">"4"</span>,<span class="string">"小心"</span>))</span><br><span class="line">   val money = env.fromElements((<span class="string">"1"</span>,<span class="number">100</span>),(<span class="string">"2"</span>,<span class="number">200</span>),(<span class="string">"3"</span>,<span class="number">300</span>))</span><br><span class="line">   person.join(money)</span><br><span class="line">     .where(_._1)</span><br><span class="line">     .equalTo(_._1)</span><br><span class="line">     .window(GlobalWindows.create())</span><br><span class="line">     .apply((x,y) =&gt;&#123;</span><br><span class="line">       println( x+<span class="string">"==="</span>+y)</span><br><span class="line">       <span class="string">"xxx"</span></span><br><span class="line">      &#125;).print()</span><br><span class="line">   env.execute()</span><br><span class="line">   println(<span class="string">"end"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>无法运行，加个triggle(xxx)解决，默认是NeverTrigger</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">.window....</span><br><span class="line">.trigger(CountTrigger.of(1))</span><br><span class="line">.apply...</span><br></pre></td></tr></table></figure><h3 id="如何排查Kafka消息的异常"><a href="#如何排查Kafka消息的异常" class="headerlink" title="如何排查Kafka消息的异常"></a>如何排查Kafka消息的异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录住报错时的kafka offset，然后分阶段打印到控制台，再对比一下，把输出的格式分别调为Row.class 以前pojo类，或注释下一阶段代码，回放kafka 故障的offset数据，各个stream排查</span><br></pre></td></tr></table></figure><h3 id="MySQL的迁移"><a href="#MySQL的迁移" class="headerlink" title="MySQL的迁移"></a>MySQL的迁移</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--涉及到MySQL的迁移，我这边推荐少量数据的话使用MySQLDump.</span><br><span class="line">--还涉及到mysql安装在docker里的情况</span><br><span class="line">--mysqldump的用法</span><br><span class="line">    --备份所有数据库：</span><br><span class="line"></span><br><span class="line">    mysqldump -uroot -p --all-databases &gt; /backup/mysqldump/all.db</span><br><span class="line">    --备份指定数据库：</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p test &gt; /backup/mysqldump/test.db</span><br><span class="line">    --备份指定数据库指定表(多个表以空格间隔)</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p  mysql db event &gt; /backup/mysqldump/2table.db</span><br><span class="line">    --备份指定数据库排除某些表</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p test --ignore-table=test.t1 --ignore-table=test.t2 &gt; /backup/mysqldump/test2.db</span><br><span class="line">    --Docker进入mysql容器</span><br><span class="line">docker exec -it mysql1 bash //mysql1是我启动的mysql服务的name</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">--带docker的命令</span><br><span class="line">1.查看当前启动的mysql运行容器</span><br><span class="line"></span><br><span class="line">docker ps </span><br><span class="line"></span><br><span class="line">2.使用以下命令备份导出数据库中的所有表结构和数据</span><br><span class="line"></span><br><span class="line">docker exec -it  mysql mysqldump -uroot -p123456 paas_portal &gt; /cloud/sql/paas_portal.sql</span><br><span class="line">3.只导数据不导结构</span><br><span class="line"></span><br><span class="line">    mysqldump　-t　数据库名　-uroot　-p　&gt;　xxx.sql　</span><br><span class="line"></span><br><span class="line">docker exec -it mysql mysqldump -t -uroot -p123456 paas_portal &gt;/cloud/sql/paas_portal_dml.sql</span><br><span class="line">4.只导结构不导数据</span><br><span class="line"></span><br><span class="line">mysqldump　--opt　-d　数据库名　-u　root　-p　&gt;　xxx.sql　</span><br><span class="line"></span><br><span class="line">docker exec -it mysql mysqldump  --opt -d   -uroot -p123456 paas_portal &gt;/cloud/sql/paas_portal_ddl.sql</span><br><span class="line"></span><br><span class="line">5.导出特定表的结构</span><br><span class="line"></span><br><span class="line">mysqldump　-uroot　-p　-B　数据库名　--table　表名　&gt;　xxx.sql</span><br><span class="line"></span><br><span class="line">docker exec -it mysql mysqldump -uroot -p -B paas_portal --table user &gt; user.sql</span><br></pre></td></tr></table></figure><h3 id="远程调试Flink"><a href="#远程调试Flink" class="headerlink" title="远程调试Flink"></a>远程调试Flink</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1gghbc3d8shj20le0jvtab.jpg" alt="TIM截图20200706160357.png"></p><p><a href="https://stackoverflow.com/questions/34816847/debugging-on-the-remote-cluster" target="_blank" rel="noopener">https://stackoverflow.com/questions/34816847/debugging-on-the-remote-cluster</a></p><h3 id="Log4J2的使用"><a href="#Log4J2的使用" class="headerlink" title="Log4J2的使用"></a>Log4J2的使用</h3><h4 id="Log4J2和Log4J1的比较"><a href="#Log4J2和Log4J1的比较" class="headerlink" title="Log4J2和Log4J1的比较"></a>Log4J2和Log4J1的比较</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>log4j是通过一个<strong>.properties</strong>的文件作为主配置文件的，而现在的log4j 2则已经弃用了这种方式，采用的是<strong>.xml，.json或者.jsn</strong>这种方式。</p><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>log4j只需要引入一个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>log4j 2则是需要2个核心</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><p>log4J.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#此句为定义名为stdout的输出端是哪种类型，可以是</span><br><span class="line">#org.apache.log4j.ConsoleAppender（控制台），</span><br><span class="line">#org.apache.log4j.FileAppender（文件），</span><br><span class="line">#org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span><br><span class="line">#org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</span><br><span class="line">#org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line"></span><br><span class="line">#此句为定义名为stdout的输出端的layout是哪种类型，可以是</span><br><span class="line">#org.apache.log4j.HTMLLayout（以HTML表格形式布局），</span><br><span class="line">#org.apache.log4j.PatternLayout（可以灵活地指定布局模式），</span><br><span class="line">#org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），</span><br><span class="line">#org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line"></span><br><span class="line">#如果使用pattern布局就要指定的打印信息的具体格式ConversionPattern，打印参数如下：</span><br><span class="line">#%m 输出代码中指定的消息</span><br><span class="line">#%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</span><br><span class="line">#%r 输出自应用启动到输出该log信息耗费的毫秒数</span><br><span class="line">#%c 输出所属的类目，通常就是所在类的全名</span><br><span class="line">#%t 输出产生该日志事件的线程名</span><br><span class="line">#%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”</span><br><span class="line">#%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式</span><br><span class="line">#比如：%d&#123;yyyy MMM dd HH:mm:ss,SSS&#125; 输出类似：2002年10月18日 22：10：28，921</span><br><span class="line">#%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。</span><br><span class="line">#[Log4JDemo]是log信息的开头，可以为任意字符，一般为项目简称。</span><br><span class="line">#log4j.appender.stdout.layout.ConversionPattern=[Log4JDemo] %p [%t] %C.%M(%L) | %m%n</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=[Log4JDemo] %p [%t] %C.%M(%L) | %m%n</span><br><span class="line"></span><br><span class="line">#设置日志文件</span><br><span class="line">log4j.appender.LogFile=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.LogFile.File=log4j.log</span><br><span class="line">log4j.appender.LogFile.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.LogFile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l  %m%n</span><br><span class="line"></span><br><span class="line">#此句为将等级为ALL的日志信息输出到stdout和LogFile这两个目的地</span><br><span class="line">#stdout和R的定义在下面的代码，可以任意起名</span><br><span class="line">#等级可分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</span><br><span class="line">#如果配置OFF则不打出任何信息</span><br><span class="line">#如果配置为INFO这样只显示INFO, WARN, ERROR的log信息，而DEBUG信息不会被显示，</span><br><span class="line">#log4j.rootCategory=ERROR,stdout,LogFile</span><br><span class="line">#log4j.rootCategory=ERROR,LogFile</span><br><span class="line">log4j.rootCategory=ERROR,stdout</span><br></pre></td></tr></table></figure><p>log4j2.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--先定义所有的appender--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--这个输出控制台的配置--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--输出日志的格式--&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"log"</span> <span class="attr">fileName</span>=<span class="string">"log/test.log"</span> <span class="attr">append</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileInfo"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/info.log"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">filePattern</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log"</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>        </span><br><span class="line">             <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100 MB"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileWarn"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/warn.log"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">filePattern</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"warn"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100 MB"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileError"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/error.log"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">filePattern</span>=<span class="string">"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"error"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100 MB"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.springframework"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.mybatis"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"all"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileInfo"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileWarn"</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileError"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>log4j</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger LOGGER = Logger.getLogger(Test.class.getName());</span><br></pre></td></tr></table></figure><p>log4j2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Level;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger(Test.class.getName());</span><br></pre></td></tr></table></figure><h3 id="Spark-On-Yarn-结束任务的方式"><a href="#Spark-On-Yarn-结束任务的方式" class="headerlink" title="Spark On Yarn 结束任务的方式"></a>Spark On Yarn 结束任务的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、yarn app -kill  appid 丢数据或者多数据</span><br><span class="line">2、kill -15  pid        丢数据或者多数据</span><br><span class="line">3、监听http或hdfs目录方式     ok</span><br><span class="line">建议大家用第三种方式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们用的第一种 针对丢数据或者多数据 我们代码里把实时过来的数据checkpoint 下一次再跑的时候会去mysql里修改offset Kafka再读进来的数据和上次checkpoint的数据对比一下 去重</span><br></pre></td></tr></table></figure><h3 id="CharSequence"><a href="#CharSequence" class="headerlink" title="CharSequence"></a>CharSequence</h3><p>第一次见到这个CharSequence的时候感觉挺疑惑的，不知道为什么要有这个东西。这个CharSequence是String和Stringbuilder共同实现的接口类，在下面这种应用场景中，只有CharSequence是适用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">StringBuilder strbu = <span class="keyword">new</span> StringBuilder(<span class="string">"def"</span>);</span><br><span class="line"><span class="keyword">boolean</span> boo = <span class="keyword">true</span>;</span><br><span class="line">CharSequence cs = boo?str:strbu;</span><br></pre></td></tr></table></figure><h3 id="并发编程，创建多少个线程合适"><a href="#并发编程，创建多少个线程合适" class="headerlink" title="并发编程，创建多少个线程合适"></a>并发编程，创建多少个线程合适</h3><p>分为两种情况讨论，CPU密集型和 I/O密集型</p><p>在CPU密集型的程序中，理论上 线程数量 = CPU 核数（逻辑）就可以了，但是实际上，数量一般会设置为 CPU 核数（逻辑）+ 1，</p><blockquote><p>计算(CPU)密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。</p></blockquote><p>在I/O密集型程序的程序中，单核心线程数一般来说是这么设置的：</p><blockquote><p>最佳线程数 = (1/CPU利用率) = 1 + (I/O耗时/CPU耗时)</p></blockquote><p>多核心的线程数为：</p><blockquote><p>最佳线程数 = CPU核心数 <em> (1/CPU利用率) = CPU核心数 </em> (1 + (I/O耗时/CPU耗时))</p></blockquote><p>如果都是IO耗时的话，可以从纯理论上直接回答是2N或者2N+1</p><p>还有很多APM（Application Performance Manager）工具可以帮我们得到具体的数据比如 SkyWalking、CAT、zipkin</p><blockquote><p>假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s</p></blockquote><p>如何设计线程个数，使得可以在1s内处理完20个Transaction？</p><p>但是，但是，这是因为没有考虑到CPU数目。家里又没矿，一般服务器的CPU核数为16或者32，如果有80个线程，那么肯定会带来太多不必要的线程上下文切换开销（希望这句话你可以主动说出来），这就需要调优了，来做到最佳 balance</p><blockquote><p>计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？</p></blockquote><p>线程数 = 8 * (1 + 100/5) = 168 (个)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;资质低下 三心二意 昨日知识 朝花夕拾&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/categories/Interview/"/>
    
    
      <category term="PICKS" scheme="http://yoursite.com/tags/PICKS/"/>
    
  </entry>
  
  <entry>
    <title>clearLastUpdated</title>
    <link href="http://yoursite.com/2020/03/17/clearLastUpdated/"/>
    <id>http://yoursite.com/2020/03/17/clearLastUpdated/</id>
    <published>2020-03-17T02:47:19.939Z</published>
    <updated>2020-05-23T12:15:02.043Z</updated>
    
    <content type="html"><![CDATA[<p>mvn库 windows清理脚本<br>需要把mvn的位置改成自己的<br><a id="more"></a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">  </span><br><span class="line">rem 这里写你的仓库路径</span><br><span class="line">set REPOSITORY_PATH=C:\Users\flyho\.m2\repository</span><br><span class="line">rem 正在搜索...</span><br><span class="line">for /f &quot;delims=&quot; %%i in (&apos;dir /b /s &quot;%REPOSITORY_PATH%\*lastUpdated*&quot;&apos;) do (</span><br><span class="line">    echo %%i</span><br><span class="line">    del /s /q &quot;%%i&quot;</span><br><span class="line">)</span><br><span class="line">rem 搜索完毕</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>另一个版本：因为有中文显示，所以编码格式不能用UTF-8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">cls </span><br><span class="line">@ECHO OFF </span><br><span class="line">SET CLEAR_PATH=C: </span><br><span class="line">SET CLEAR_DIR=C:\Users\flyho\.m2\repository</span><br><span class="line">color 0a </span><br><span class="line">TITLE ClearLastUpdated For Windows </span><br><span class="line">GOTO MENU </span><br><span class="line">:MENU </span><br><span class="line">CLS</span><br><span class="line">ECHO. </span><br><span class="line">ECHO. * * * *  ClearLastUpdated For Windows  * * * * </span><br><span class="line">ECHO. * * </span><br><span class="line">ECHO. * 1 清理*.lastUpdated * </span><br><span class="line">ECHO. * * </span><br><span class="line">ECHO. * 2 查看*.lastUpdated * </span><br><span class="line">ECHO. * * </span><br><span class="line">ECHO. * 3 退 出 * </span><br><span class="line">ECHO. * * </span><br><span class="line">ECHO. * * * * * * * * * * * * * * * * * * * * * * * * </span><br><span class="line">ECHO. </span><br><span class="line">ECHO.请输入选择项目的序号： </span><br><span class="line">set /p ID= </span><br><span class="line">IF &quot;%id%&quot;==&quot;1&quot; GOTO cmd1 </span><br><span class="line">IF &quot;%id%&quot;==&quot;2&quot; GOTO cmd2 </span><br><span class="line">IF &quot;%id%&quot;==&quot;3&quot; EXIT </span><br><span class="line">PAUSE </span><br><span class="line">:cmd1 </span><br><span class="line">ECHO. 开始清理</span><br><span class="line">%CLEAR_PATH%</span><br><span class="line">cd %CLEAR_DIR%</span><br><span class="line">for /r %%i in (*.lastUpdated) do del %%i</span><br><span class="line">ECHO.OK </span><br><span class="line">PAUSE </span><br><span class="line">GOTO MENU </span><br><span class="line">:cmd2 </span><br><span class="line">ECHO. 查看*.lastUpdated文件</span><br><span class="line">%CLEAR_PATH%</span><br><span class="line">cd %CLEAR_DIR%</span><br><span class="line">for /r %%i in (*.lastUpdated) do echo %%i</span><br><span class="line">ECHO.OK </span><br><span class="line">PAUSE </span><br><span class="line">GOTO MENU</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mvn库 windows清理脚本&lt;br&gt;需要把mvn的位置改成自己的&lt;br&gt;
    
    </summary>
    
      <category term="Script" scheme="http://yoursite.com/categories/Script/"/>
    
    
      <category term="Script" scheme="http://yoursite.com/tags/Script/"/>
    
  </entry>
  
  <entry>
    <title>SQL 从入门到精通</title>
    <link href="http://yoursite.com/2019/11/27/GitChat%20SQL%E8%AF%BE%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/27/GitChat SQL课程/</id>
    <published>2019-11-27T12:30:04.217Z</published>
    <updated>2019-11-28T01:02:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>SQL是一项重要的技能，可能是普通程序员在工作中最常用的。面试的时候造飞机大炮，最后可能还是得实实在在得写SQL。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cm9vd6brj20sg09hq9w.jpg" alt="SQL-1024x341.png"></p><a id="more"></a> <h1 id="Structured-Query-Language"><a href="#Structured-Query-Language" class="headerlink" title="Structured Query Language"></a>Structured Query Language</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1970 年 IBM 的 E.F. Codd 博士发表了论文《A Relational Model of Data for Large Shared Data Banks》并创建了关系模型，通过一个简单的数据结构（关系，也就是二维表）来实现数据的存储。 </p><p>1979 年 Relational Software, Inc.（后来改名为 Oracle）发布了第一个商用的关系数据库产品。随后出现了大量的关系数据库管理系统，包括 MySQL、SQL Server、PostgreSQL 以及大数据分析平台 Apache Hive、Spark SQL、Presto 等。至今，关系数据库仍然是数据库领域的主流。 </p><p>以下是著名的数据库系统排名网站 <a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">DB-Engines</a> 上各种数据库的排名情况，关系数据库占据了绝对的优势。 </p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cmdeqm4cj20rl0abq43.jpg" alt="undefined"></p><p>SQL（Structured Query Language，结构化查询语言）是访问和操作关系数据库的标准语言。只要是关系数据库，都可以使用 SQL 进行访问和控制。SQL 同样由 IBM 在 1970 年代开发，1986 年成为 ANSI 标准，并且在 1987 年成为 ISO 标准。SQL 标准随后经历了多次修订，最新的版本为 SQL:2019，增加了多维数组（MDA）的支持。下图是 SQL 标准的发展历程和主要的新增功能。 </p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cmdrn7cdj21ln0ml46x.jpg" alt="undefined"></p><p>对于 SQL 标准，人们最熟悉的就是 SQL92 或者 SQL99。但实际上经过多次修改，SQL 早已不是 40 年前的 SQL；如今它已经相当完备，功能强大，并且能够同时支持关系模型和非关系（XML、JSON）模型。具体来说，最新的 SQL 标准包含 10 个部分：</p><ul><li>ISO/IEC 9075-1 信息技术 – 数据库语言 – SQL – 第1部分：框架（SQL/框架）</li><li>ISO/IEC 9075-2 信息技术 – 数据库语言 – SQL – 第2部分：基本原则（SQL/基本原则）</li><li>ISO/IEC 9075-3 信息技术 – 数据库语言 – SQL – 第3部分：调用级接口（SQL/CLI）</li><li>ISO/IEC 9075-4 信息技术 – 数据库语言 – SQL – 第4部分：持久存储模块（SQL/PSM）</li><li>ISO/IEC 9075-9 信息技术 – 数据库语言 – SQL – 第9部分：外部数据管理（SQL/MED）</li><li>ISO/IEC 9075-10 信息技术 – 数据库语言 – SQL – 第10部分：对象语言绑定（SQL/OLB）</li><li>ISO/IEC 9075-11 信息技术 – 数据库语言 – SQL – 第11部分：信息与定义概要（SQL/Schemata）</li><li>ISO/IEC 9075-13 信息技术 – 数据库语言 – SQL – 第13部分：使用 Java 编程语言的 SQL 程序与类型（SQL/JRT）</li><li>ISO/IEC 9075-14 信息技术 – 数据库语言 – SQL – 第14部分：XML 相关规范（SQL/XML）</li><li>ISO/IEC 9075-15 信息技术 – 数据库语言 – SQL – 第15部分：多维数组（SQL/MDA）</li></ul><p>为了便于学习，通常将主要的 SQL 语句分为以下几个类别：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cme6q6syj21ir0k5gs0.jpg" alt="undefined"></p><ul><li><strong>DQL</strong>（data query language），<strong>数据查询语言</strong>；也就是 SELECT 语句，用于查询数据库中的数据和信息。</li><li><strong>DML</strong>（data manipulation language），<strong>数据操作语言</strong>；用于对表中的数据进行增加（INSERT）、修改（UPDATE）、删除（DELETE）以及合并（MERGE）操作。</li><li><strong>DDL</strong>（data definition language），<strong>数据定义语言</strong>；主要用于定义数据库中的对象（例如表或索引），包括创建对象（CREATE）、修改对象（ALTER）和删除对象（DROP）等。</li><li><strong>TCL</strong>（transaction control language），<strong>事务控制语言</strong>；用于管理数据库的事务，主要包括启动一个事务（BEGIN TRANSACTION）、提交事务（COMMIT）、回退事务（ROLLBACK）和事务保存点（SAVEPOINT）。</li><li><strong>DCL</strong>（data control language），<strong>数据控制语言</strong>；用于控制数据的访问权限，主要有授权（GRANT）和撤销（REVOKE）。</li></ul><p>SQL 是一种标准，不同厂商基于 SQL 标准实现了自己的数据库产品，例如 Oracle、MySQL 等。这些数据库都在一定程度上兼容 SQL 标准，具有一定的可移植性。但另一方面，它们都存在许多专有的扩展，没有任何一种产品完全遵循标准。 </p><h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><p>随着互联网的发展和大数据的兴起，出现了各种各样的非关系（NoSQL）数据库。NoSQL 代表 <strong>Not only SQL</strong>，表明它是针对传统关系数据库的补充和升级，而不是为了替代关系数据库。</p><p>NoSQL 数据库主要用于解决关系数据库在某些特定场景下的局限性，比如海量存储和水平扩展；但同时也会为此牺牲某些关系数据库的特性，例如对事务强一致性的支持和标准 SQL 接口。因此，这类数据库主要用于对一致性要求不是非常严格的互联网业务。常见的 NoSQL 数据库可以分为以下几类：</p><ul><li>文档数据库，例如 <a href="https://www.mongodb.com/" target="_blank" rel="noopener">MongoDB</a>（MongoDB 4.0 增加了多文档事务的特性）；</li><li>键值存储，例如 <a href="https://redis.io/" target="_blank" rel="noopener">Redis</a>；</li><li>全文搜索引擎，例如 <a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a>；</li><li>宽列存储数据库，例如 <a href="http://cassandra.apache.org/" target="_blank" rel="noopener">Cassandra</a>；</li><li>图形数据库，例如 <a href="https://neo4j.com/" target="_blank" rel="noopener">Neo4J</a>。</li></ul><p>另一方面，关系数据库也在积极拥抱变化，添加了许多非关系模型（XML 和 JSON）支持。以最流行的开源关系数据库 MySQL 为例，最新的 MySQL 8.0 版本增加了 JSON 文档存储的支持，并且推出了一个新的概念：NoSQL + SQL = MySQL。以下是 MySQL 官方的宣传图。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cmfau87wj20c80el74n.jpg" alt="undefined"></p><p>Oracle、SQL Server 以及 PostgreSQL 同样也进行了类似的扩展，可以支持原生的 XML 和 JSON 数据，并且提供了许多标准的 SQL 接口。</p><h4 id="NewSQL"><a href="#NewSQL" class="headerlink" title="NewSQL"></a>NewSQL</h4><p>中国有句古话：<strong>天下大势，合久必分，分久必合</strong>。数据库领域的发展也印证了这一规律，为了同时获得关系数据库对于事务的支持和标准的 SQL 接口，以及非关系数据库的高度扩展性和高性能。如今市场上已经出现了一类新型关系型数据库系统：NewSQL 数据库。</p><p>比较有代表性的 NewSQL 数据库包括 Google Spanner、VoltDB、PostgreSQL-XL 以及国产的 TiDB。这类新型数据库是数据库领域最新的发展方向，有志于在数据库行业发展的同学可以加以关注。</p><h4 id="为什么要学习-SQL？"><a href="#为什么要学习-SQL？" class="headerlink" title="为什么要学习 SQL？"></a>为什么要学习 SQL？</h4><p>让我们回到专栏的主题，为什么要学习 SQL 呢？简单来说，因为有用。下图是 Stack Overflow 在 2019 年关于最流行编程技术的调查结果。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cmfl8agzj20nc0ict9f.jpg" alt="undefined"></p><p>作为数据处理领域的专用语言，SQL 排在了第三位，超过 50% 的开发者都需要使用到 SQL。那么，具体什么职位需要使用 SQL，用 SQL 来做什么？</p><ul><li><strong>数据分析师</strong>：显然这是一群依靠分析数据为生的人，必不可少需要与数据库打交道，SQL 是他们必备技能之一。</li><li><strong>数据科学家</strong>：与数据分析师一样，数据科学家的日常工作也离不开数据的处理，不可避免需要使用 SQL。</li><li><strong>数据库开发工程师</strong>：这个职位基本就是写 SQL 代码，实现业务逻辑。</li><li><strong>数据库管理员</strong>：也就是 DBA，主要职责是管理和维护数据库，除了会写 SQL，还需要负责审核开发人员编写的 SQL 代码。</li><li><strong>后端工程师</strong>：后端开发必然需要涉及数据的处理，需要通过 SQL 与数据库进行交互。</li><li><strong>全栈工程师</strong>：既然是全栈，自然包括后端数据的处理。</li><li><strong>移动开发工程师</strong>：作为一名移动开发工程师，一定对 SQLite 数据库不会陌生，它是在移动设备中普遍存在的嵌入式数据库。</li><li><strong>产品经理</strong>：产品经理需要了解产品的情况，而数据是最好的说明方式，了解 SQL 非常有利于对产品的把握。</li></ul><p>SQL 不但应用广泛，而且简单易学。因为它在设计之初就考虑了非技术人员的使用需求，SQL 语句全都是由简单的英语单词组成，使用者只需要声明自己想要的结果，而将具体的实现过程交给数据库管理系统。</p><p>学习编程，你可能会犹豫选择 C++ 还是 Java；入门数据科学，你可能会纠结于选择 Python 还是 R；但无论如何，SQL 都是 IT 从业人员不可或缺的一项技能！</p><p>本专栏主要讨论 SQL 编程技术和思想，分为四个部分：基础篇、进阶篇、开发篇以及扩展篇。 </p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cmg49ezgj20qx0k575o.jpg" alt="undefined"></p><p><strong>第一部分：基础篇</strong>。首先介绍数据库领域的最新发展，回顾数据库和 SQL 的核心概念；然后讨论如何使用 SELECT 语句查询数据，过滤数据、对结果进行排序、实现排行榜与分页效果；同时还会介绍常见的 SQL 函数、CASE 表达式以及数据的分组汇总；最后是一个分析世界银行全球 GDP 数据的实战案例。</p><p><strong>第二部分：进阶篇</strong>。主要包括 SQL 数据分析的一些高级功能：空值的问题、多表连接查询、子查询、集合运算、通用表表达式与递归查询、高级分组与多维度交叉分析、窗口函数与高级报表以及基于行模式识别的数据流分析等。</p><p><strong>第三部分：开发篇</strong>。讲述数据库设计与开发过程中涉及到的一些实用知识。包括如何设计规范化的数据库、如何管理数据库对象、如何对数据进行增删改、数据库事务的概念、索引的原理；同时还会介绍视图的概念、如何使用存储过程实现业务逻辑以及如何利用触发器实现用户操作的审计。</p><p><strong>第四部分：扩展篇</strong>。我们将分析 SQL 语句的执行计划与查询语句的优化、使用 SQL 处理 JSON 数据、在 Python 和 Java 中执行 SQL 语句，并介绍动态语句和 SQL 注入攻击的预防。在专栏的最后，我们将探讨一下 SQL 编程中的道与术。</p><h2 id="SQL的世界里一切都是关系"><a href="#SQL的世界里一切都是关系" class="headerlink" title="SQL的世界里一切都是关系"></a>SQL的世界里一切都是关系</h2><p>本篇我们将会介绍 SQL 的基本特性以及最重要的一个编程思想：<strong>一切都是关系</strong>。让我们先来回顾一下关系数据库的几个基本概念。 </p><p>关系数据库<br>关系数据库（Relational database）是指基于关系模型的数据库。关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。<br>数据结构<br>在关系模型中，用于存储数据的逻辑结构称为关系（Relation）；对于使用者而言，关系就是二维表（Table）。<br>以下是一个员工信息表，它和 Excel 表格非常类似，由行（Row）和列（Column）组成。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cmm39ukfj20gi061q37.jpg" alt="undefined"></p><p>在不同的场景下，大家可能会听到关于同一个概念的不同说法。在此，我们列出了关系数据库中的一些常见概念：</p><ul><li><strong>关系</strong>，也称为<strong>表</strong>，用于表示现实世界中的实体（Entity）或者实体之间的联系（Relationship）。举例来说，一个公司的员工、部门和职位都是实体，分别对应员工信息表、部门信息表和职位信息表；销售的产品和订单都是实体，同时它们之间存在联系，对应订单明细表。</li><li><strong>行</strong>，也称为<strong>记录</strong>（Record），代表了关系中的单个实体。上图中工号为 4 的数据行存储了“诸葛亮”的相关信息。关系（表）可以看作是由行组成的集合。</li><li><strong>列</strong>，也称为<strong>字段</strong>（Field），表示实体的某个属性。上图中的第二列包含了员工的姓名。表中的每个列都有一个对应的数据类型，常见的数据类型包括字符类型、数字类型、日期时间类型等。</li></ul><p>有了关系结构之后，就需要定义基于关系的数据操作。</p><p>操作集合</p><p>常见的数据操作包括<strong>增加</strong>（Create）、<strong>查询</strong>（Retrieve）、<strong>更新</strong>（Update）以及<strong>删除</strong>（Delete），或者统称为<strong>增删改查</strong>（CRUD）。</p><p>其中，使用最多、也最复杂的操作就是查询，具体来说包括<strong>选择</strong>（Selection）、<strong>投影</strong>（Projection）、<strong>并集</strong>（Union）、<strong>交集</strong>（Intersection）、<strong>差集</strong>（exception）以及<strong>笛卡儿积</strong>（Cartesian product）等。我们将会介绍如何使用 SQL 语句完成以上各种数据操作。</p><p>为了维护数据的完整性或者满足业务需求，关系模型还定义了完整性约束。</p><p>关系性约束</p><p>关系模型中定义了三种完整性约束：<strong>实体完整性</strong>、<strong>参照完整性</strong>以及<strong>用户定义完整性</strong>。</p><ul><li><strong>实体完整性</strong>是指表的主键字段不能为空。现实中的每个实体都具有唯一性，比如每个人都有唯一的身份证号；在关系数据库中，这种唯一标识每一行数据的字段称为主键（Primary Key），主键字段不能为空。每个表可以有且只能有一个主键。</li><li><strong>参照完整性</strong>是指外键参照的完整性。外键（Foreign Key）代表了两个表之间的关联关系，比如员工属于某个部门；因此员工表中存在部门编号字段，引用了部门表中的部门编号字段。对于外键引用，被引用的数据必须存在，员工不可能属于一个不存在的部门；删除某个部门之前，也需要对部门中的员工进行相应的处理。</li><li><p><strong>用户定义完整性</strong>是指基于业务需要自定义的约束。非空约束（NOT NULL）确保了相应的字段不会出现空值，例如员工一定要有姓名；唯一约束（UNIQUE）用于确保字段中的值不会重复，每个员工的电子邮箱必须唯一；检查约束（CHECK）可以定义更多的业务规则。例如，薪水必须大于 0 ，字符必须大写等；默认值（DEFAULT）用于向字段中插入默认的数据。</p><p>本专栏涉及的 4 种数据库对于这些完整性约束的支持情况如下： </p></li></ul><table><thead><tr><th style="text-align:left">数据库</th><th style="text-align:left">非空约束</th><th style="text-align:left">唯一约束</th><th style="text-align:left">主键约束</th><th style="text-align:left">外键约束</th><th style="text-align:left">检查约束</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><strong>Oracle</strong></td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left"><strong>MySQL</strong></td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持*</td><td style="text-align:left">支持*</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left"><strong>SQL Server</strong></td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left"><strong>PostgreSQL</strong></td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td></tr></tbody></table><p>MySQL 中只有 InnoDB 存储引擎支持外键约束；MySQL 8.0.16 增加了对检查约束的支持。</p><blockquote><p>存储引擎（Storage Engine）是 MySQL 中用于管理、访问和修改物理数据的组件，不同的存储引擎提供了不同的功能和特性。从 MySQL 5.5 开始默认使用 InnoDB 存储引擎，支持事务处理（ACID）、行级锁定、故障恢复、多版本并发控制（MVCC）以及外键约束等。</p></blockquote><p>关系数据库使用 SQL 作为访问和操作数据的标准语言。现在，让我们来直观感受一下 SQL 语句的特点。</p><p>SQL：一种面向集合的编程语言</p><blockquote><p>本节会出现几个示例，我们还没有正式开始学习 SQL 语句，可以暂时不必理会细节。</p></blockquote><p>语法特性</p><p>SQL 是一种声明性的编程语言，语法接近于自然语言（英语）。通过几个简单的英文单词，例如 SELECT、INSERT、UPDATE、CREATE、DROP 等，完成大部分的数据库操作。以下是一个简单的查询示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_id, emp_name, salary</span><br><span class="line">  <span class="keyword">FROM</span> employee</span><br><span class="line"> <span class="keyword">WHERE</span> salary &gt; <span class="number">10000</span></span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> emp_id;</span><br></pre></td></tr></table></figure><p>即使没有学过 SQL 语句，但只要知道几个单词的意思，就能明白该语句的作用。它查询员工表（employee）中月薪（salary）大于 10000 的员工，返回工号、姓名以及月薪，并且按照工号进行排序。可以看出，SQL 语句非常简单直观。</p><p>以上查询中的 SELECT、FROM 等称为关键字（也称为子句），一般大写；表名、列名等内容一般小写；分号（;）表示语句的结束。SQL 语句不区分大小写，但是遵循一定的规则可以让代码更容易阅读。</p><blockquote><p>SQL 是一种声明式的语言，声明式语言的主要思想是告诉计算机想要什么结果（what），但不指定具体怎么做。这类语言还包括 HTML、正则表达式以及函数式编程等。</p></blockquote><p>面向集合</p><p>对于 SQL 语句而言，它所操作的对象是一个集合（表），操作的结果也是一个集合（表）。例如以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_id, emp_name, salary</span><br><span class="line">  <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure><p>其中 employee 是一个表，它是该语句查询的对象；同时，查询的结果也是一个表。所以，我们可以继续扩展该查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_id, emp_name, salary</span><br><span class="line">  <span class="keyword">FROM</span> (</span><br><span class="line">       <span class="keyword">SELECT</span> emp_id, emp_name, salary</span><br><span class="line">         <span class="keyword">FROM</span> employee</span><br><span class="line">       ) dt;</span><br></pre></td></tr></table></figure><p>我们将括号中的查询结果（取名为 dt）作为输入值，传递给了外面的查询；最终整个语句的结果仍然是一个表。在第 17 篇中，我们将会介绍这种嵌套在其他语句中的查询就是子查询（Subquery）。</p><p>SQL 中的查询可以完成各种数据操作，例如过滤转换、分组汇总、排序显示等；但是它们本质上都是针对表的操作，结果也是表。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cmy2e08yj217a093wf1.jpg" alt="undefined"></p><p>不仅仅是查询语句，SQL 中的插入、更新和删除都以集合为操作对象。我们再看一个插入数据的示例： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(<span class="keyword">id</span> <span class="built_in">INTEGER</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 适用于 MySQL、SQL Server 以及 PostgreSQL</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>), (<span class="number">2</span>), (<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>我们首先使用 CREATE TABLE 语句创建了一个表，然后使用 INSERT INTO 语句插入数据。在执行插入操作之前，会在内存中创建一个包含 3 条数据的临时集合（表），然后将该集合插入目标表中。由于我们通常一次插入一条数据，以为是按照数据行进行插入；实际上，一条数据也是一个集合，只不过它只有一个元素而已。</p><p>Oracle 不支持以上插入<strong>多行数据</strong>的语法，可以使用下面的插入语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 适用于 Oracle</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> DUAL</span><br><span class="line"> <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">2</span> <span class="keyword">FROM</span> DUAL</span><br><span class="line"> <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">3</span> <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><p>UNION ALL 是 SQL 中的并集运算，用于将两个集合组成一个更大的集合。此外，SQL 还支持交集运算（INTERSECT）、差集运算（EXCEPT）以及笛卡儿积（Cartesian product）。我们会在第 18 篇中介绍这些内容，它们也都是以集合为对象的操作。</p><p>我们已经介绍了 SQL 语言的声明性和面向集合的编程思想。在正式学习编写 SQL 语句之前，还需要进行一些准备工作，主要就是安装示例数据库。</p><p>示例数据库</p><p>在本专栏的学习过程中，我们主要使用一个虚构的公司数据模型。该示例数据库包含 3 个表：员工表（employee）、部门表（department）和职位表（job）。以下是它们的结构图，也称为<strong>实体-关系图</strong>（Entity-Relational Diagram）：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cnhvzfk5j20e908y0sw.jpg" alt="undefined"></p><ul><li><strong>部门表</strong>（department），包含部门编号（dept<em>id）和部门名称（dept</em>name）字段，主键为部门编号。该表共计 6 条数据。</li><li><strong>职位表</strong>（job），包含职位编号（job<em>id）和职位名称（job</em>title）字段，主键为职位编号。该表共计 10 条数据。</li><li><strong>员工表</strong>（employee），包含员工编号（emp<em>id）和员工姓名（emp</em>name）等字段，主键为员工编号，部门编号（dept<em>id）字段是引用部门表的外键，职位编号（job</em>id）字段是引用职位表的外键，经理编号（manager）字段是引用员工表自身的外键。该表共计 25 条数据。</li></ul><p>我们在 GitHub 上为大家提供了示例表和初始数据的创建脚本和安装说明，支持 Oracle、MySQL、SQL Server 以及 PostgreSQL。点击<a href="https://github.com/dongxuyang1985/thinking_in_sql" target="_blank" rel="noopener">链接</a>进行下载。</p><p>运行这些脚本之前，需要先安装数据库软件。网络上有很多这类安装教程可以参考；如果无法安装数据库，也可以使用这个免费的在线 SQL 开发环境：<a href="http://sqlfiddle.com/" target="_blank" rel="noopener">http://sqlfiddle.com</a>，它提供了各种常见的关系数据库服务。下图是使用 MySQL 运行示例脚本的结果：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cnigeozjj20zk0gbdhp.jpg" alt="undefined"></p><p>选择数据库之后，将创建表和插入数据的脚本复制到左边窗口，点击“Build Schema”进行初始化；点击“Browser”可以查看表结构；在右侧窗口输入 SQL 语句，点击“Run SQL”运行并查看结果。该工具提供的数据库不是最新版本，但是可以运行大部分的示例。</p><p>本专栏中所有的示例都在以下数据库版本中进行了验证：</p><ul><li>Oracle database 18c</li><li>MySQL 8.0</li><li>SQL Server 2017</li><li>PostgreSQL 12</li></ul><p>我们使用 <a href="https://dbeaver.io/" target="_blank" rel="noopener">DBeaver</a> 开发工具编写所有的 SQL 语句，该工具的安装和使用可以参考我的<a href="https://tonydong.blog.csdn.net/article/details/89683422" target="_blank" rel="noopener">博客文章</a>。当然，你也可以使用自己喜欢的开发工具。</p><p>小结</p><p>关系模型中定义了一个简单的数据结构，即关系（表），用于存储数据。SQL 是关系数据库的通用标准语言，它使用接近于自然语言（英语）的语法，通过声明的方式执行数据定义、数据操作、访问控制等。对于 SQL 而言，一切都是关系（表）。</p><p>参考文献</p><ul><li>[美] Abraham Silberschatz，Henry F.Korth，S.Sudarshan 著，杨冬青，李红燕，唐世渭 译 ，《数据库系统概念（原书第6版）》，机械工业出版社，2012</li></ul><h2 id="SELECT-初步探索"><a href="#SELECT-初步探索" class="headerlink" title="SELECT 初步探索"></a>SELECT 初步探索</h2><p>在 employee 表中，存储了关于员工的信息。假设现在打算群发邮件，需要找出所有员工的姓名、性别和电子邮箱。在 SQL 中可以通过一个简单的查询语句来实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_name, sex, email</span><br><span class="line">  <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure><p>其中 SELECT 表示查询，随后列出需要返回的字段，多个字段使用逗号分隔；FROM 表示要从哪个表中进行查询；分号表示 SQL 语句的结束。该语句执行的结果如下（显示部分数据）：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9coidg6c2j20ae06mweo.jpg" alt="undefined"></p><p>这种查询表中指定字段的操作在关系运算中被称为<strong>投影</strong>（Projection），使用 SELECT 子句进行表示。投影是针对表进行的垂直选择，保留需要的字段用于生成新的表。以下是投影操作的示意图： </p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9coj8sb0sj20yd0ikmy4.jpg" alt="undefined"></p><p>投影操作中包含一个特殊的操作，就是查询表中所有的字段。</p><h3 id="查询全部字段"><a href="#查询全部字段" class="headerlink" title="查询全部字段"></a>查询全部字段</h3><p>查看表中的全部字段可以使用一个简单的写法，就是使用星号（*）表示全部字段。例如，以下语句查询员工表中的所有数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line">  <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure><p>数据库在解析该语句时，会使用表中的字段名进行扩展：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_id, emp_name, sex, dept_id, manager,</span><br><span class="line">       hire_date, job_id, salary, bonus, email</span><br><span class="line">  <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure><p>该语句执行的结果如下（显示部分数据）：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cojmu3vkj20th06m74w.jpg" alt="undefined"></p><blockquote><p><strong>注意</strong>：星号可以便于快速编写查询语句，但是在实际项目中不要使用这种写法。因为应用程序可能并不需要所有的字段，避免返回过多的无用数据；另外，当表结构发生变化时，星号返回的信息也会发生改变。 </p></blockquote><p>除了查询表的字段之外，SELECT 语句还支持扩展的投影操作，包括基于字段的算术运算、函数和表达式等。</p><p>扩展操作</p><p>以下示例返回了员工的姓名、一年的工资（12 个月的月薪）以及电子邮箱的大写形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_name,</span><br><span class="line">       salary * <span class="number">12</span>,</span><br><span class="line">       <span class="keyword">UPPER</span>(email)</span><br><span class="line">  <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure><p>其中 UPPER 是 SQL 中将字符串转换为大写的函数，函数将在第 8 篇中进行介绍。该语句的结果如下（显示部分数据）：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9cokqdusej20cl06mt91.jpg" alt="undefined"></p><p>在上面的结果中，返回字段的名称不是很好理解；能不能给它指定一个更明确的标题呢？这就需要使用到 SQL 中的别名（Alias）功能了。</p><h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>为了提高查询结果的可读性，可以使用别名为表或者字段指定一个临时的名称。SQL 中使用关键字 AS 指定别名。我们为上面的示例指定一些更好理解的标题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.emp_name <span class="keyword">AS</span> <span class="string">"姓名"</span>,</span><br><span class="line">       salary * <span class="number">12</span> <span class="keyword">AS</span> <span class="string">"工资"</span>,</span><br><span class="line">       <span class="keyword">UPPER</span>(email) <span class="string">"电子邮箱"</span></span><br><span class="line">  <span class="keyword">FROM</span> employee <span class="keyword">AS</span> e; <span class="comment">-- Oracle 需要去掉此处的 AS</span></span><br></pre></td></tr></table></figure><blockquote><p>别名中的关键字 AS 可以省略。对于 Oracle 而言，表别名不支持 AS 关键字，省略掉即可。</p></blockquote><p>首先，我们为 employee 表指定了一个表别名 e；然后为查询的结果字段指定了 3 个更明确的列别名（使用双引号）。在查询中为表指定别名之后，引用表中的字段时可以加上别名限定，例如 e.emp_name，表示要查看哪个表中的字段。以下是使用别名之后的效果：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9col02qedj20ah06m74l.jpg" alt="undefined"></p><p>在 SQL 语句中使用别名不会修改数据库中存储的表名或者列名，别名只在当前语句中生效。</p><p>在上面的示例中，我们还用到了 SQL 中的另一个功能：注释。</p><h3 id="SQL-注释"><a href="#SQL-注释" class="headerlink" title="SQL 注释"></a>SQL 注释</h3><p>在 SQL 中可以像其他编程语言一样使用注释；注释可以方便我们理解代码的作用，但不会被执行。</p><p>SQL中的注释分为单行注释和多行注释。单行注释以两个连字符（–）开始，直到这一行结束；上一节中的示例就使用了单行注释。SQL 使用 C 语言风格的多行注释（/<em> … </em>/），例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.emp_name <span class="keyword">AS</span> <span class="string">"姓名"</span>,</span><br><span class="line">       salary * <span class="number">12</span> <span class="keyword">AS</span> <span class="string">"工资"</span>,</span><br><span class="line">       <span class="keyword">UPPER</span>(email) <span class="string">"电子邮箱"</span></span><br><span class="line"><span class="comment">/* 备注：SQL 别名使用示例</span></span><br><span class="line"><span class="comment">   作者：TonyDong</span></span><br><span class="line"><span class="comment">   日期：2019-11-01</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">FROM</span> employee <span class="keyword">AS</span> e;</span><br></pre></td></tr></table></figure><blockquote><p>MySQL中的 # 也可以用于表示单行注释。</p></blockquote><p>在 SQL 中，SELECT … FROM … 是最基本的查询形式；但是，有时候我们会看到一种更简单的查询：只有 SELECT 子句，没有 FROM 子句的查询。</p><h3 id="无表查询"><a href="#无表查询" class="headerlink" title="无表查询"></a>无表查询</h3><p>以下查询没有 FROM 子句，用于计算一个表达式的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL、SQL Server 以及 PostgreSQL 实现</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">1+1|</span><br><span class="line"><span class="comment">---|</span></span><br><span class="line">  2|</span><br></pre></td></tr></table></figure><p>这种形式的查询语句通常用于快速查找信息，或者当作计算器使用。但是需要注意的是这种语法并不属于 SQL 标准，而是数据库产品自己的扩展。MySQL、SQL Server 以及 PostgreSQL 都支持无表查询；对于 Oracle 而言，可以使用以下等价的形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Oracle 实现</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>+<span class="number">1</span></span><br><span class="line">  <span class="keyword">FROM</span> dual;</span><br><span class="line"></span><br><span class="line">1+1|</span><br><span class="line"><span class="comment">---|</span></span><br><span class="line">  2|</span><br></pre></td></tr></table></figure><p>dual 是 Oracle 中的一个特殊的表；它只有一个字段且只包含一行数据，就是为了方便快速查询信息。另外，MySQL 也提供了 dual 表。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本篇我们学习了如何使用 SELECT 和 FROM 查询表中的数据，通过投影操作获取指定的字段信息。SQL 不仅仅能够查询表中的数据，还可以返回算术运算、函数和表达式的结果。在许多数据库中，不包含 FROM 子句的无表查询可以用于快速获取信息。另外，别名和注释都可以让我们编写的 SQL 语句更易阅读和理解。</p><p><strong>练习题</strong>：查询部门表（department）和职位表（job）中的数据，熟悉它们的字段结构和内容。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.sqlstyle.guide/zh/" target="_blank" rel="noopener">SQL 编程风格指南</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL是一项重要的技能，可能是普通程序员在工作中最常用的。面试的时候造飞机大炮，最后可能还是得实实在在得写SQL。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2ly1g9cm9vd6brj20sg09hq9w.jpg&quot; alt=&quot;SQL-1024x341.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="GitChat" scheme="http://yoursite.com/categories/GitChat/"/>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>数据中台是什么</title>
    <link href="http://yoursite.com/2019/11/14/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/11/14/数据中台是什么？/</id>
    <published>2019-11-13T22:59:43.863Z</published>
    <updated>2020-04-10T17:04:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据中台是什么？能发挥什么作用？</p><p>对最近很火的数据中台一些思考。</p></blockquote><a id="more"></a> <h1 id="数据中台是什么？"><a href="#数据中台是什么？" class="headerlink" title="数据中台是什么？"></a>数据中台是什么？</h1><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>2015年全年产生的数据量等于历史上所有人类产生数据的总和，人类的数据增长正式从乘法型增长变成了指数型增长，海量数据处理成为了全人类的挑战。</p><p>阿里提出了DT时代已经到来：DataTech替代ITTech，强调数据驱动的重要性。</p><p>阿里走在了前面，阿里用几百人的团队支撑了几万亿的GMV，其中60%-70%来源于数据支持的机器决策，机器智能赋能业务，用更低的成本，更高的效率去服务顾客，提供个性化推荐。</p><p>阿里的数据处理经理了四个阶段，分别是：</p><p>一、数据库阶段，主要是OLTP（联机事务处理）的需求；</p><p>二、数据仓库阶段，OLAP（联机分析处理）成为主要需求；</p><p>三、数据平台阶段，主要解决BI和报表需求的技术问题；</p><p>四、数据中台阶段，通过系统来对接OLTP（事务处理）和OLAP（报表分析）的需求，强调数据业务化的能力。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8v3ih8b6lj22ii1qi7aa.jpg" alt="undefined"></p><p>第一个阶段到第二阶段很好理解，数据库阶段，简单的OLTP（OLTP强调高并发，单条数据简单提取和战士，后者对并发的要求并不高，后者是地并发，大批量，面向分析。）</p><p>第一次转型就是从数据库阶段走到了数据仓库的阶段。互联网数据里面数据量最大的是网页日志，90%以上的数据是非结构化数据，数据量已经到了TB界别，针对分析需求，诞生了数据仓库（DW），阿里的第一个DW是Oracle RAC搭建了DW，这个阶段DW支持的主要久食BI和报表需求。数据库这是也在从传统CB转向分布式DB。</p><p>第二次转型就是从数据仓库阶段到数据平台阶段，这个阶段解决的 还是BI和报表需求，但是主要是在解决底层的技术问题。也即是数据库架构设计问题。</p><p>第二次转型是数据从TB阶段走向了PB级别， Oracle RAC是基于IOE架构的，所有数据用同一个EMC存储。在海量数据处理上，IOE架构有天然的限制，不适合未来的发展。阿里巴巴的第一个数据仓库就是建立在Oracle RAC上，由于数据量增长太快，所以很快就到达20个节点，当时是全亚洲最大的Oracle RAC集群，但阿里巴巴早年算过一笔账，如果仍然沿用IOE架构，那么几年后，阿里的预计营收还远远赶不上服务器的支出费用，就是说，如果不去IOE，阿里会破产。  Shared Nothing的代表就是Hadoop。Hadoop的各个处理单元都有自己私有的存储单元和处理单元， Shared Everything一般是针对单个主机，完全透明共享CPU/MEMORY/IO，并行处理能力是最差的，典型的代表SQLServer。</p><p>所以第二次转型关键词就是去IOE，建立Shared Nothing的海量数据平台来解决数据存储成本增长过快的问题，在阿里巴巴，前期是Hadoop，后期转向自研的ODPS。</p><p>第四阶段就是数据中台服务，这个阶段的特征是数据量的指数级增长，从PB级别到了EB级别，未来会到什么级别，还不好说。</p><p>目前互联网是主力，15年之后，视图声数据指数级增长，未来90%的数据可能都是非结构化数据，这些数据需要CV等技术的解析，5G技术发展，可能会进一步方法数据的体量。</p><p>另一方面，从业务来看，数据也好，数据分析也好，最终都是要为了业务服务，也就是说，要在系统层面能把OLAP和OLTP去做对接，这个对接不能靠人来完成，要靠智能算法。</p><p>目前的数据中台，最底下的数据平台还是偏技术，是中台技术方案中的一个组件，主要解决数据存储和计算，上面是数据服务层，数据服务层通过服务化API能够把数据平台和前台的业务层对接；数据中台里面就没有人的事情，直接系统去做对接，通过智能算法，能把前台的分析需求和交易需求去做对接，最终赋能业务。 </p><p>未来的数据中台，一定是「AI驱动的数据中台」，这个中台包括「计算平台+算法模型+智能硬件」，不仅要在端上具备视觉数据的收集和分析能力，而且还要能通过Face ID，帮助企业去打通业务数据，最终建立线上线下触达和服务消费者的能力。</p><p>真正做到「一切业务数据化，一切数据业务化」。</p><p>数据中台需要三种能力：</p><p>数据模型能力，AI算法模型能力，行业的应用能力。</p><h2 id="Ex"><a href="#Ex" class="headerlink" title="Ex."></a>Ex.</h2><p><strong>阿里中台全景图</strong></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8v7cv7jsfj21b50ka121.jpg" alt="1.png"></p><p><strong>基础设施服务</strong>，即IAAS层，提供硬件底层支持。</p><p><strong>基础服务层</strong>，即PAAS层，包括分布式服务框架、分布式数据库、分布式消息、分布式存储、分布式事务、实时监控服务等等。</p><p><strong>互联网业务中台</strong>，包括各服务中心的抽象出来的各种业务能力，包括交易中心、支付中心、营销中心、结算中心、用户中心、账户中心等等。也包括非业务类服务，如日志分析中心、配置中心、序列中心、基础中心。</p><p><strong>业务应用</strong>，经过调取业务中台，组装形成独立业务服务能力的业务应用。</p><p><strong>交易来源</strong>，就是前台用户使用的各个端，如淘宝App、PC站等。</p><p>数据量超EB，表数量超过百万。</p><p>PPT小结：</p><p><strong>1、阿里业务中台架构图。</strong>阿里完整前后中台技术架构图。</p><p><strong>2、业务中台化-产品形态。</strong>将商业基础形态和逻辑梳理出来，解构成业务“积木块”。</p><p><strong>3、业务中台化-全局架构。</strong>建立中台的中心化控制单元，对中台有一个纵观全局的视图。</p><p><strong>4、业务中台化 - 业务创新和智能化。</strong>业务中台化，汇集和沉淀业务逻辑和数据，对快速创新提供支持。</p><p><strong>5、阿里核心业务架构。</strong>小前台、大中台、轻后台的相互支撑体系。</p><p><strong>6、阿里数据中台架构。</strong>数据中台建设理论、方法和实践。</p><p><strong>7、阿里技术全栈全景图。</strong>阿里的移动中台、业务中台、数据中台、技术中台。</p><p><strong>8、阿里技术平台底座。</strong>阿里多年技术积累和沉淀，构建在阿里云之上。</p><p><strong>9、阿里中台组织架构。</strong>阿里的中台战略，相匹配的组织架构升级。</p><p><strong>10、业务中台建设路径。</strong>企业中台建设应遵循的3个步骤：决心变革、成功试点、持续融合。</p><p><strong>11、企业中台战略4个升级。</strong>从战略、组织、流程、技术四个方面进行升级。</p><p><strong>12、阿里中台的能力开放。</strong>基于阿里云、ET大脑、业务&amp;数据双中台的能力开放。</p><p><strong>13、阿里业务中台建设方法论。</strong>中台建设和基础协议、中心化操控单元。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>中台这个概念被炒作的恨火，然而究竟什么是中台，似乎并没有人给出一个明确的定义。</p><p>有的人把技术集成平台叫中台，都感觉很片面。</p><p>我查阅了很多资料，中台像业务发展遇到某一瓶颈的时候，为了解决实际问题提出的解决方案。</p><p>2018年9月，腾讯宣布组织架构调整，在原有七大事业部重新组织机构， 新成立了云与智慧产业事业群（CSIG）、平台与内容事业群（PCG），调整为新的6大事业群。而6大事业群紧紧围绕的，正是技术委员会充当“技术中台”角色。 </p><p> 同年12月18日，百度集团进行了一次大的架构调整，由百度创始人、董事长李彦宏发信宣布：”百度将打造AI时代最领先的技术平台，实现前端业务和技术平台的资源高效统筹及组织全面协同。” </p><p> 3天后的12月21日，京东集团人力资源部发布关于京东商城组织架构调整的公告，公告内容称：“在新的组织架构下，京东商城将围绕以客户为中心，划分为前中后台。中台为前台业务运营和创新提供专业能力的共享平台职能。” </p><p>建设方法：</p><p>阿里：业务数据双中台；移动中台；技术中台。</p><p>腾讯：业务中台和数据中台。</p><p>百度：搜索中台</p><p>京东：数据中台</p><p>阿里数据中台概念提出这么久了，我看了这么多资料，对中台的定义大多是一家之言，我个人观点：中台是阿里为了两个目的提出来的概念，第一个目标是大企业的尾大不掉，第二点是数据驱动价值。</p><p>第二点在电商领域的价值已经不用多提，第一点可能是他觉得阿里必须要克服的问题。</p><p>说实话，具体的落地可能都还在摸索之中，先把这个概念拿出来炒作挺离谱的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;数据中台是什么？能发挥什么作用？&lt;/p&gt;
&lt;p&gt;对最近很火的数据中台一些思考。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Reading Note" scheme="http://yoursite.com/categories/Reading-Note/"/>
    
    
      <category term="中台" scheme="http://yoursite.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Apache Kylin</title>
    <link href="http://yoursite.com/2019/11/14/Kylin/"/>
    <id>http://yoursite.com/2019/11/14/Kylin/</id>
    <published>2019-11-13T22:59:43.427Z</published>
    <updated>2019-11-22T10:21:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kylin是在Hadoop上的SQL层，最近对Phoenix调研完成之后，对Kylin产生了兴趣。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8v1qog93xj209d08laa6.jpg" alt="undefined"></p><a id="more"></a> <h1 id="Kylin"><a href="#Kylin" class="headerlink" title="Kylin"></a>Kylin</h1><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="1-1-Kylin定义"><a href="#1-1-Kylin定义" class="headerlink" title="1.1 Kylin定义"></a>1.1 Kylin定义</h3><p>Apache Kylin是一个开源的分布式分析引擎，提供Hadoop/Spark之上的SQL查询接口及多维分析（OLAP）能力以支持超大规模数据，最初由eBay Inc开发并贡献至开源社区。它能在亚秒内查询巨大的Hive表。</p><h3 id="1-2-Kylin特点"><a href="#1-2-Kylin特点" class="headerlink" title="1.2 Kylin特点"></a>1.2 Kylin特点</h3><p>Kylin的主要特点包括支持SQL接口、支持超大规模数据集、亚秒级响应、可伸缩性、高吞吐率、BI工具集成等。</p><p>1）标准SQL接口：Kylin是以标准的SQL作为对外服务的接口。</p><p>2）支持超大数据集：Kylin对于大数据的支撑能力可能是目前所有技术中最为领先的。早在2015年eBay的生产环境中就能支持百亿记录的秒级查询，之后在移动的应用场景中又有了千亿记录秒级查询的案例。</p><p>3）亚秒级响应：Kylin拥有优异的查询相应速度，这点得益于预计算，很多复杂的计算，比如连接、聚合，在离线的预计算过程中就已经完成，这大大降低了查询时刻所需的计算量，提高了响应速度。</p><p>4）可伸缩性和高吞吐率：单节点Kylin可实现每秒70个查询，还可以搭建Kylin的集群。</p><p>5）BI工具集成</p><p>Kylin可以与现有的BI工具集成，具体包括如下内容。</p><p>ODBC：与Tableau、Excel、PowerBI等工具集成</p><p>JDBC：与Saiku、BIRT等Java工具集成</p><p>Restate：与JavaScript、Web网页集成</p><p>Kylin开发团队还贡献了<strong>Stippling</strong>的插件，也可以使用Stippling来访问Kylin服务。</p><h3 id="1-3-Kylin架构"><a href="#1-3-Kylin架构" class="headerlink" title="1.3 Kylin架构"></a>1.3 Kylin架构</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8v1uuzn2pj215o0k5ta3.jpg" alt="undefined"></p><p>1）REST Server</p><p>REST Server是一套面向应用程序开发的入口点，旨在实现针对Kylin平台的应用开发工作。 此类应用程序可以提供查询、获取结果、触发cube构建任务、获取元数据以及获取用户权限等等。另外可以通过Restful接口实现SQL查询。</p><p>2）查询引擎（Query Engine）</p><p>当cube准备就绪后，查询引擎就能够获取并解析用户查询。它随后会与系统中的其它组件进行交互，从而向用户返回对应的结果。 </p><p>3）Routing</p><p>负责将解析的SQL生成的执行计划转换成cube缓存的查询，cube是通过预计算缓存在hbase中，这部分查询可以在秒级设置毫秒级完成，而且还有一些操作使用过的查询原始数据（存储在Hadoop的hdfs中通过hive查询）。这部分查询延迟较高。</p><p>4）元数据管理工具（Metadata）</p><p>Kylin是一款元数据驱动型应用程序。元数据管理工具是一大关键性组件，用于对保存在Kylin当中的所有元数据进行管理，其中包括最为重要的cube元数据。其它全部组件的正常运作都需以元数据管理工具为基础。 Kylin的元数据存储在hbase中。 </p><p>5）任务引擎（Cube Build Engine）</p><p>这套引擎的设计目的在于处理所有离线任务，其中包括shell脚本、Java API以及Map Reduce任务等等。任务引擎对Kylin当中的全部任务加以管理与协调，从而确保每一项任务都能得到切实执行并解决其间出现的故障。</p><h3 id="1-4-Kylin工作原理"><a href="#1-4-Kylin工作原理" class="headerlink" title="1.4 Kylin工作原理"></a>1.4 Kylin工作原理</h3><p>Apache Kylin的工作原理本质上是MOLAP（Multidimension On-Line Analysis Processing）Cube，也就是多维立方体分析。是数据分析中非常经典的理论，下面对其做简要介绍。</p><h4 id="1-4-1-纬度和度量"><a href="#1-4-1-纬度和度量" class="headerlink" title="1.4.1 纬度和度量"></a>1.4.1 纬度和度量</h4><p>维度：即观察数据的角度。比如员工数据，可以从性别角度来分析，也可以更加细化，从入职时间或者地区的维度来观察。维度是一组离散的值，比如说性别中的男和女，或者时间维度上的每一个独立的日期。因此在统计时可以将维度值相同的记录聚合在一起，然后应用聚合函数做累加、平均、最大和最小值等聚合计算。</p><p>度量：即被聚合（观察）的统计值，也就是聚合运算的结果。比如说员工数据中不同性别员工的人数，又或者说在同一年入职的员工有多少。</p><p>基数：某个维度的种类数。比如说性别维度，基数为2（男和女）。按照某个维度进行聚合，结果数据的大小主要取决于该维度的基数。</p><h4 id="1-4-2-Cube和Cuboid"><a href="#1-4-2-Cube和Cuboid" class="headerlink" title="1.4.2 Cube和Cuboid"></a>1.4.2 Cube和Cuboid</h4><p>有了维度跟度量，一个数据或数据模型上的所有字段就可以分类了，他们要么是纬度要么是度量（可以被聚合）。于是就有了根据维度和度量做预计算的理论。</p><p>给定一个数据模型，我们可以对其上的所有维度进行聚合，对于N个维度来说，组合的所有可能性共有2^n种。对于每一种维度的组合，将度量值做聚合计算，然后将结果保存为一个物化视图，称为Cuboid。所有维度组合的Cuboid作为一个整体，称为Cube。</p><p>下面举一个简单的例子说明，假设有一个电商的销售数据集，其中维度包括时间[time]、商品[item]、地区[location]和供应商[supplier]，度量为销售额。那么所有维度的组合就有2^4 = 16种，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8v2nn4skoj20hq0db75f.jpg" alt="undefined"></p><p>一维度（1D）的组合有：[time]、[item]、[location]和[supplier]4种；</p><p>二维度（2D）的组合有：[time, item]、[time, location]、[time, supplier]、[item, location]、[item, supplier]、[location, supplier]3种；</p><p>三维度（3D）的组合也有4种；</p><p>最后还有零维度（0D）和四维度（4D）各有一种，总共16种。</p><p>注意：每一种维度组合就是一个Cuboid，16个Cuboid整体就是一个Cube。</p><h4 id="1-4-3-核心算法"><a href="#1-4-3-核心算法" class="headerlink" title="1.4.3 核心算法"></a>1.4.3 核心算法</h4><p>Kylin的工作原理就是对数据模型做Cube预计算，并利用计算的结果加速查询：</p><p>1）指定数据模型，定义维度和度量；</p><p>2）预计算Cube，计算所有Cuboid并保存为物化视图；</p><p>预计算过程是Kylin从Hive中读取原始数据，按照我们选定的维度进行计算，并将结果集保存到Hbase中，默认的计算引擎为MapReduce，可以选择Spark作为计算引擎。一次build的结果，我们称为一个Segment。构建过程中会涉及多个Cuboid的创建，具体创建过程由kylin.cube.algorithm参数决定，参数值可选 auto，layer 和 inmem， 默认值为 auto，即 Kylin 会通过采集数据动态地选择一个算法 (layer or inmem)，如果用户很了解 Kylin 和自身的数据、集群，可以直接设置喜欢的算法。</p><p>3）执行查询，读取Cuboid，运行，产生查询结果。</p><h5 id="1-4-3-1-逐层构建算法"><a href="#1-4-3-1-逐层构建算法" class="headerlink" title="1.4.3.1 逐层构建算法"></a>1.4.3.1 逐层构建算法</h5><p>我们知道，一个N维的Cube，是由1个N维子立方体、N个(N-1)维子立方体、N*(N-1)/2个(N-2)维子立方体、……、N个1维子立方体和1个0维子立方体构成，总共有2^N个子立方体组成，在逐层算法中，按维度数逐层减少来计算，每个层级的计算（除了第一层，它是从原始数据聚合而来），是基于它上一层级的结果来计算的。比如，[Group by A, B]的结果，可以基于[Group by A, B, C]的结果，通过去掉C后聚合得来的；这样可以减少重复计算；当 0维度Cuboid计算出来的时候，整个Cube的计算也就完成了。每一轮的计算都是一个MapReduce任务，且串行执行；一个N维的Cube，至少需要N+1次MapReduce Job。</p><p><strong>算法优点</strong>：</p><p>每一轮的计算都是一个MapReduce任务，且串行执行；一个N维的Cube，至少需要N+1次MapReduce Job。2）受益于Hadoop的日趋成熟，此算法对集群要求低，运行稳定；在内部维护Kylin的过程中，很少遇到在这几步出错的情况；即便是在Hadoop集群比较繁忙的时候，任务也能完成。</p><p>算法缺点</p><p>2）受益于Hadoo    p的日趋成熟，此算法对集群要求低，运行稳定；在内部维护Kylin的过程中，很少遇到在这几步出错的情况；即便是在Hadoop集群比较繁忙的时候，任务也能完成。</p><p><strong>算法缺点：</strong></p><p>1）当Cube有比较多维度的时候，所需要的MapReduce任务也相应增加；由于Hadoop的任务调度需要耗费额外资源，特别是集群较庞大的时候，反复递交任务造成的额外开销会相当可观；</p><p>2）此算法会对Hadoop MapReduce输出较多数据; 虽然已经使用了Combiner来减少从Mapper端到Reducer端的数据传输，所有数据依然需要通过Hadoop MapReduce来排序和组合才能被聚合，无形之中增加了集群的压力;</p><p>3）对HDFS的读写操作较多：由于每一层计算的输出会用做下一层计算的输入，这些Key-Value需要写到HDFS上；当所有计算都完成后，Kylin还需要额外的一轮任务将这些文件转成HBase的HFile格式，以导入到HBase中去；</p><p>总体而言，该算法的效率较低，尤其是当Cube维度数较大的时候。</p><h4 id="1-4-3-2-快速构建算法（inmem）"><a href="#1-4-3-2-快速构建算法（inmem）" class="headerlink" title="1.4.3.2 快速构建算法（inmem）"></a>1.4.3.2 快速构建算法（inmem）</h4><p>也被称作“逐段”(By Segment) 或“逐块”(By Split) 算法，从1.5.x开始引入该算法，利用Mapper端计算先完成大部分聚合，再将聚合后的结果交给Reducer，从而降低对网络瓶颈的压力。该算法的主要思想是，对Mapper所分配的数据块，将它计算成一个完整的小Cube 段（包含所有Cuboid）；每个Mapper将计算完的Cube段输出给Reducer做合并，生成大Cube，也就是最终结果；如图所示解释了此流程。</p><p>与旧算法相比，快速算法主要有两点不同：</p><p>1） Mapper会利用内存做预聚合，算出所有组合；Mapper输出的每个Key都是不同的，这样会减少输出到Hadoop MapReduce的数据量；</p><p>2）一轮MapReduce便会完成所有层次的计算，减少Hadoop任务的调配。</p><h2 id="第二章：Kylin安装指南"><a href="#第二章：Kylin安装指南" class="headerlink" title="第二章：Kylin安装指南"></a>第二章：Kylin安装指南</h2><h3 id="2-1安装地址"><a href="#2-1安装地址" class="headerlink" title="2.1安装地址"></a>2.1安装地址</h3><p>1.官网地址：</p><p><a href="http://kylin.apache.org/cn/" target="_blank" rel="noopener">http://kylin.apache.org/cn/</a></p><p>2.官方文档</p><p><a href="http://kylin.apache.org/cn/docs/" target="_blank" rel="noopener">http://kylin.apache.org/cn/docs/</a></p><p>3.下载地址</p><p><a href="http://kylin.apache.org/cn/download/" target="_blank" rel="noopener">http://kylin.apache.org/cn/download/</a></p><h3 id="2-2-软件要求"><a href="#2-2-软件要求" class="headerlink" title="2.2 软件要求"></a>2.2 软件要求</h3><ul><li><p>Hadoop: 2.7+, 3.1+ (since v2.5)</p></li><li><p>Hive: 0.13 - 1.2.1+</p></li><li><p>HBase: 1.1+, 2.0 (since v2.5)</p></li><li><p>Spark (可选) 2.3.0+</p></li><li><p>Kafka (可选) 1.0.0+ (since v2.5)</p></li><li><p>JDK: 1.8+ (since v2.5)</p></li><li><p>OS: Linux only, CentOS 6.5+ or Ubuntu 16.0.4+</p></li></ul><p>官网提示：在 Hortonworks HDP 2.2-2.6 and 3.0, Cloudera CDH 5.7-5.11 and 6.0, AWS EMR 5.7-5.10, Azure HDInsight 3.5-3.6 上测试通过。</p><h3 id="2-3-硬件要求："><a href="#2-3-硬件要求：" class="headerlink" title="2.3 硬件要求："></a>2.3 硬件要求：</h3><p>运行 Kylin 的服务器的最低配置为 4 core CPU，16 GB 内存和 100 GB 磁盘。 对于高负载的场景，建议使用 24 core CPU，64 GB 内存或更高的配置。</p><h3 id="2-4-Hadoop环境"><a href="#2-4-Hadoop环境" class="headerlink" title="2.4 Hadoop环境"></a>2.4 Hadoop环境</h3><p>Kylin依赖于Hadoop集群处理大量的数据集。需要准备一个配置好HDFS，YARN，MapReduce,，Hive，HBase，Zookeeper和其他服务的Hadoop 集群供 Kylin 运行。<br>   Kylin可以在 Hadoop 集群的任意节点上启动。方便起见，可以在master节点上运行Kylin。但为了更好的稳定性，官网建议将Kylin部署在一个干净的Hadoop client节点上，该节点上 Hive，HBase，HDFS 等命令行已安装好且client 配置（如 <code>core-site.xml</code>，<code>hive-site.xml</code>，<code>hbase-site.xml</code>及其他）也已经合理的配置且其可以自动和其它节点同步。</p><p>运行Kylin的Linux账户要有访问 Hadoop 集群的权限，包括创建/写入 HDFS 文件夹，Hive表，HBase 表和提交MapReduce任务的权限。</p><h3 id="2-5-Kylin安装"><a href="#2-5-Kylin安装" class="headerlink" title="2.5 Kylin安装"></a>2.5 Kylin安装</h3><ol><li>从 <a href="https://kylin.apache.org/download/" target="_blank" rel="noopener">Apache Kylin下载网站</a> 下载一个适用于您 Hadoop 版本的二进制文件。例如，适用于 HBase 1.x 的 Kylin 2.5.0 可通过如下命令行下载得到：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">wget http://mirror.bit.edu.cn/apache/kylin/apache-kylin-2.5.0/apache-kylin-2.5.0-bin-hbase1x.tar.gz</span><br></pre></td></tr></table></figure><ol><li>解压 tar 包，配置环境变量 <code>$KYLIN_HOME</code> 指向 Kylin 文件夹。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-kylin-2.5.0-bin-hbase1x.tar.gzcd apache-kylin-2.5.0-bin-hbase1xexport KYLIN_HOME=`pwd`</span><br></pre></td></tr></table></figure><p>从 v2.6.1 开始， Kylin 不再包含 Spark 二进制包; 您需要另外下载 Spark，然后设置 <code>SPARK_HOME</code> 系统变量到 Spark 安装目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HOME=/path/to/spark</span><br></pre></td></tr></table></figure><p>或者使用脚本下载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$KYLIN_HOME/bin/download-spark.sh</span><br></pre></td></tr></table></figure><h4 id="Kylin-tarball-目录"><a href="#Kylin-tarball-目录" class="headerlink" title="Kylin tarball 目录"></a>Kylin tarball 目录</h4><ul><li><code>bin</code>: shell 脚本，用于启动/停止 Kylin，备份/恢复 Kylin 元数据，以及一些检查端口、获取 Hive/HBase 依赖的方法等；</li><li><code>conf</code>: Hadoop 任务的 XML 配置文件</li><li><code>lib</code>: 供外面应用使用的 jar 文件，例如 Hadoop 任务 jar, JDBC 驱动, HBase coprocessor 等.</li><li><code>meta_backups</code>: 执行 <code>bin/metastore.sh     backup</code> 后的默认的备份目录;</li><li><code>sample_cube</code> 用于创建样例 Cube 和表的文件。</li><li><code>spark</code>: 自带的 spark。</li><li><code>tomcat</code>: 自带的 tomcat，用于启动 Kylin 服务。</li><li><code>tool</code>: 用于执行一些命令行的jar文件。</li></ul><h4 id="检查运行环境"><a href="#检查运行环境" class="headerlink" title="检查运行环境"></a>检查运行环境</h4><p>Kylin 运行在 Hadoop 集群上，对各个组件的版本、访问权限及 CLASSPATH 等都有一定的要求，为了避免遇到各种环境问题，您可以运行 <code>$KYLIN_HOME/bin/check-env.sh</code> 脚本来进行环境检测，如果您的环境存在任何的问题，脚本将打印出详细报错信息。如果没有报错信息，代表您的环境适合 Kylin 运行。</p><h4 id="启动-Kylin"><a href="#启动-Kylin" class="headerlink" title="启动 Kylin"></a>启动 Kylin</h4><p>运行 <code>$KYLIN_HOME/bin/kylin.sh start</code> 脚本来启动 Kylin，界面输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrieving hadoop conf dir...</span><br><span class="line">KYLIN_HOME is set to /usr/local/apache-kylin-2.5.0-bin-hbase1x</span><br><span class="line">......</span><br><span class="line">A new Kylin instance is started by root. To stop it, run &apos;kylin.sh stop&apos;</span><br><span class="line">Check the log at /usr/local/apache-kylin-2.5.0-bin-hbase1x/logs/kylin.log</span><br><span class="line">Web UI is at http://&lt;hostname&gt;:7070/kylin</span><br></pre></td></tr></table></figure><h4 id="使用-Kylin"><a href="#使用-Kylin" class="headerlink" title="使用 Kylin"></a>使用 Kylin</h4><p>Kylin 启动后您可以通过浏览器 <code>http://:7070/kylin</code> 进行访问。<br> 其中 <code></code> 为具体的机器名、IP 地址或域名，默认端口为 7070。<br> 初始用户名和密码是 <code>ADMIN/KYLIN</code>。<br> 服务器启动后，您可以通过查看 <code>$KYLIN_HOME/logs/kylin.log</code> 获得运行时日志。</p><h4 id="停止-Kylin"><a href="#停止-Kylin" class="headerlink" title="停止 Kylin"></a>停止 Kylin</h4><p>运行 <code>$KYLIN_HOME/bin/kylin.sh stop</code> 脚本来停止 Kylin，界面输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Retrieving hadoop conf dir...</span><br><span class="line">KYLIN_HOME is set to /usr/local/apache-kylin-2.5.0-bin-hbase1x</span><br><span class="line">Stopping Kylin: 25964</span><br><span class="line">Stopping in progress. Will check after 2 secs again...</span><br><span class="line">Kylin with pid 25964 has been stopped.</span><br></pre></td></tr></table></figure><p>您可以运行 <code>ps -ef | grep kylin</code> 来查看 Kylin 进程是否已停止。</p><h4 id="HDFS-目录结构"><a href="#HDFS-目录结构" class="headerlink" title="HDFS 目录结构"></a>HDFS 目录结构</h4><p>Kylin 会在 HDFS 上生成文件，根目录是 “/kylin/”, 然后会使用 Kylin 集群的元数据表名作为第二层目录名，默认为 “kylin_metadata” (可以在<code>conf/kylin.properties</code>中定制).</p><p>通常, <code>/kylin/kylin_metadata</code> 目录下会有这么几种子目录：<code>cardinality</code>, <code>coprocessor</code>, <code>kylin-job_id</code>, <code>resources</code>, <code>jdbc-resources</code>.<br> \1. <code>cardinality</code>: Kylin 加载 Hive 表时，会启动一个 MR 任务来计算各个列的基数，输出结果会暂存在此目录。此目录可以安全清除。<br> \2. <code>coprocessor</code>: Kylin 用于存放 HBase coprocessor jar 的目录；请勿删除。<br> \3. <code>kylin-job_id</code>: Cube 计算过程的数据存储目录，请勿删除。 如需要清理，请遵循 <a href="http://kylin.apache.org/docs/howto/howto_cleanup_storage.html" target="_blank" rel="noopener">storage cleanup guide</a>.<br> \4. <code>resources</code>: Kylin 默认会将元数据存放在 HBase，但对于太大的文件（如字典或快照），会转存到 HDFS 的该目录下，请勿删除。</p><p>\5. <code>jdbc-resources</code>：性质同上，只在使用 MySQL 做元数据存储时候出现。</p><h3 id="2-6-集群模式部署"><a href="#2-6-集群模式部署" class="headerlink" title="2.6 集群模式部署"></a>2.6 集群模式部署</h3><p>Kylin 实例是无状态的服务，运行时的状态信息存储在 HBase metastore 中。 出于负载均衡的考虑，可以启用多个共享一个 metastore 的 Kylin 实例，使得各个节点分担查询压力且互为备份，从而提高服务的可用性。</p><p>下图描绘了 Kylin 集群模式部署的一个典型场景：</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8vblwtlk5j20iu0bltdn.jpg" alt="2.png"></p><p>将多个 Kylin 节点组成集群，先确保他们使用同一个 Hadoop 集群、HBase 集群。然后在每个节点的配置文件 <code>$KYLIN_HOME/conf/kylin.properties</code> 中执行下述操作：</p><ol><li>配置相同的 <code>kylin.metadata.url</code> 值，即配置所有的 Kylin 节点使用同一个 HBase metastore。</li><li>配置 Kylin 节点列表 <code>kylin.server.cluster-servers</code>，包括所有节点（包括当前节点），当事件变化时，接收变化的节点需要通知其他所有节点（包括当前节点）。</li><li>配置 Kylin 节点的运行模式 <code>kylin.server.mode</code>，参数值可选 <code>all</code>, <code>job</code>, <code>query</code> 中的一个，默认值为 <code>all</code>。<pre><code>`job` 模式代表该服务仅用于任务调度，不用于查询；`query` 模式代表该服务仅用于查询，不用于构建任务的调度；`all` 模式代表该服务同时用于任务调度和 SQL 查询。</code></pre></li></ol><p><strong>注意：</strong>默认情况下只有<strong>一个实例</strong>用于构建任务的调度 （即 <code>kylin.server.mode</code>设置为 <code>all</code> 或者 <code>job</code> 模式）。</p><h4 id="任务引擎高可用"><a href="#任务引擎高可用" class="headerlink" title="任务引擎高可用"></a>任务引擎高可用</h4><p>从 v2.0 开始, Kylin 支持多个任务引擎一起运行，相比于默认单任务引擎的配置，多引擎可以保证任务构建的高可用。</p><p>使用多任务引擎，可以在多个 Kylin 节点上配置它的角色为 <code>job</code> 或 <code>all</code>。为了避免它们之间产生竞争，需要启用分布式任务锁，需在 <code>kylin.properties</code> 里配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kylin.job.scheduler.default=2</span><br><span class="line">kylin.job.lock=org.apache.kylin.storage.hbase.util.ZookeeperJobLock</span><br></pre></td></tr></table></figure><p>并记得将所有任务和查询节点的地址注册到 <code>kylin.server.cluster-servers</code>。</p><h4 id="安装负载均衡器"><a href="#安装负载均衡器" class="headerlink" title="安装负载均衡器"></a>安装负载均衡器</h4><p>为了将查询请求发送给集群而非单个节点，可以部署一个负载均衡器，如<a href="http://nginx.org/en/" target="_blank" rel="noopener">Nginx</a>等，使得客户端和负载均衡器通信代替和特定的 Kylin 实例通信。</p><p>1.安装依赖包</p><p>yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</p><p>2.下载并解压安装包</p><p>mkdir -p /usr/local/nginx</p><p>//下载tar包</p><p>wget <a href="http://nginx.org/download/nginx-1.13.7.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.13.7.tar.gz</a></p><p>tar -zxvf nginx-1.13.7.tar.g</p><p>3.安装nginx</p><p>//进入nginx-1.13.7目录</p><p>//执行命令</p><p>./configure –prefix=/usr/local/nginx</p><p>//执行make命令</p><p>make</p><p>//执行make install命令</p><p>make install</p><p>4.配置nginx.conf</p><p># 打开配置文件</p><p>vi /usr/local/nginx/conf/nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#gzip  on;</span><br><span class="line">   upstream kylinserver &#123;</span><br><span class="line">     server 172.16.0.125:7070 weight=5 max_fails=5 fail_timeout=600s;</span><br><span class="line">     server 172.16.0.127:7070 weight=5 max_fails=5 fail_timeout=600s;</span><br><span class="line">     server 172.16.0.128:7070 weight=5 max_fails=5 fail_timeout=600s;</span><br><span class="line">   &#125;</span><br><span class="line">   server &#123;</span><br><span class="line">       listen       8087;</span><br><span class="line">       server_name  172.16.0.125;</span><br><span class="line"></span><br><span class="line">       #charset koi8-r;</span><br><span class="line"></span><br><span class="line">       #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">       location / &#123;</span><br><span class="line">           #root   html;</span><br><span class="line">           #index  index.html index.htm;</span><br><span class="line">          proxy_pass http://kylinserver;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       location /kylin &#123;</span><br><span class="line">           proxy_pass http://kylinserver;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/bec9bff2ly1g8vcz4iabpj20e20ckt8q.jpg" alt="3"></p><p>检查配置文件是否正确：/usr/local/nginx/sbin/nginx -t</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动：/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>重启：/usr/local/nginx/sbin/nginx -s reload</p><p>查看进程：ps -ef | grep nginx</p><p>从容停止：kill -QUIT 进程号</p><p>快速停止：kill -TERM 进程号</p><p>强制停止：pkill -9 nginx</p><h2 id="第三章-快速入门"><a href="#第三章-快速入门" class="headerlink" title="第三章 快速入门"></a>第三章 快速入门</h2><p><a href="https://www.jianshu.com/p/c49c61b654da" target="_blank" rel="noopener">参考链接</a></p><h2 id="第四章-Kylin实例调研"><a href="#第四章-Kylin实例调研" class="headerlink" title="第四章 Kylin实例调研"></a>第四章 Kylin实例调研</h2><p>从业务层面来讲，OLAP一般分为两个种类。</p><p><strong>即席查询</strong>： 即席查询（Ad Hoc）是用户根据自己的需求，灵活的选择查询条件，系统能够根据用户的选择生成相应的统计报表。即席查询与普通应用查询最大的不同是普通的应用查询是定制开发的，而即席查询是由用户自定义查询条件的。 </p><p>就是用户通过手写SQL来完成一些临时的数据分析需求，这类需求的SQL形式多变，逻辑复杂，对相应时间没有严格的眼球。</p><p><strong>固化查询</strong>：对一些固化下来的取数，看数的需求，通过数据产品的形式提供给用户，从而提高数据分析和运行效率。这类SQL有固定的模式，对相应时间有较高要求。</p><h3 id="美团大规模使用Kylin的例子："><a href="#美团大规模使用Kylin的例子：" class="headerlink" title="美团大规模使用Kylin的例子："></a>美团大规模使用Kylin的例子：</h3><p>随着公司业务数据量和复杂度的不断提升 ，第二种方案会出现几个突出的问题：</p><ol><li><p>随着维度的不断增加，在数仓中维护各种维度组合的聚合表的成本越来越高，数据开发效率明显下降; </p></li><li><p>数据量超过千万行后，MySQL的导入和查询变得非常慢，经常把MySQL搞崩，DBA的抱怨很大;</p></li><li><p>由于大数据平台缺乏更高效率的查询引擎，查询需求都跑在Hive/Presto上，导致集群的计算压力大，跟不上业务需求的增长。</p></li></ol><p>目前OLAP引擎种类还有挺多，目前还没有一个西永能够满足各种场景的查询需求，本质是：没有一个能在数据量、性能、灵活性三个方面做到完美，每个西永在设计时都需要在这三者间做出取舍。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8we03d0ryj20hh06r41n.jpg" alt="1.png"></p><p>例如:</p><p>MPP架构的系统（Presto/Impala/SparkSQL/Drill等）有很好的数据量和灵活性支持，但是对响应时间是没有保证的。当数据量和计算复杂度增加后，响应时间会变慢，从秒级到分钟级，甚至小时级都有可能。</p><p>搜索引擎架构的系统（Elasticsearch等）相对比MPP系统，在入库时将数据转换为倒排索引，采用Scatter-Gather计算模型，牺牲了灵活性换取很好的性能，在搜索类查询上能做到亚秒级响应。但是对于扫描聚合为主的查询，随着处理数据量的增加，响应时间也会退化到分钟级。 </p><p>预计算系统 （Druid/Kylin等）则在入库时对数据进行预聚合，进一步牺牲灵活性换取性能，以实现对超大数据集的秒级响应。<br>对这些特点有了了解，针对不用的场合才知道选择什么。</p><p>典型的使用场景：</p><ul><li>数据以离线生产为主，数据量在千万到百亿之间级别。</li><li>需要多维度任意组合的。</li><li>指标中包含大量去重主表，要求结果精确的。</li><li>相应时间要求：3s内</li><li>可以提供SQL接口</li></ul><p>Kylin在生产环境经过了考研，2016年初美团开始推广Kylin解决方案。一年后覆盖了所有业务线，成为OLAP首选。</p><p>截止16年底，一年时间产生了214个Cube，包含的数据总行数2853亿行，Cube在HBase中的存储有59TB。日查询次数超过了50w次，TP50查询延迟87ms，TP99延迟1266ms，很好满足性能需求。</p><p>美团的硬件环境是：30个节点的Kylin专属Hbase集群，2台用于Cube构建的物理机，和8台8核16GVM用作Kylin的查询机。Cube的构建是运行在主计算机群的MR作业，各业务线的构建任务拆分到了他们各自的资源队列上。</p><p>Kylin对外是REST接口，我们接入了公司统一的http服务治理框架来实现负载均衡和平滑重启。 </p><p>调研的时候，看到Cube这个概念，一般都会担心“维度爆炸这个问题”，就是每增加一个维度，由于维度组合翻倍，可能会产生纬度爆炸，对预计算的算力和磁盘空间都产生很大考验，后来发现这个问题并没有想象的严重。这主要是因为：</p><p>Kylin支持Partial Cube，不需要对所有维度组合都进行预计算。</p><p>实际业务中，纬度之间往往存在衍生关系，而Kylin可以把衍生纬度的计算从预计算推迟到查询处理阶段。</p><p>以事实表上的衍生维度为例，业务中的很多维度都是(ID, NAME)成对出现的。查询时需要对ID列进行过滤，但显示时只需要取对应的NAME列。如果把这两列都作为维度，维度个数会翻倍。而在Kylin中，可以把NAME作为ID列的extendedcolumn指标，这样Cube中的维度个数就减半了。 </p><p>美团在采用衍生维度后，90%的场景可以把Cube中的维度个数（Rowkey列数）控制在20个以内。指标个数呈现长尾分布，小于10个指标的Cube是最多的，不过也有近一半的Cube指标数超过20。总共有382个去重指标，占到了总指标数的10%，绝大多数都是精确去重指标。49%的Cube膨胀率小于100%，即Cube存储量不超过上游Hive表。68%的Cube能够在1小时内完成构建，92%在2小时内完成构建。 </p><p>从美团的实践中能看出美团投入Kylin是看重的Kylin的海量数据超高查询性能的特点，虽然在磁盘空间上做了一部分牺牲，实践证明Kylin的空间换时间是可行的。</p><h3 id="斗鱼大规模使用Kylin的例子"><a href="#斗鱼大规模使用Kylin的例子" class="headerlink" title="斗鱼大规模使用Kylin的例子"></a>斗鱼大规模使用Kylin的例子</h3><p>斗鱼的这个例子，更有代表性，斗鱼随着业务的增长，在2019年Q2，平均MAU，达到1.6亿MAU，每天，超大量的用户使用斗鱼各客户端参与线上互动，斗鱼需要对客户端采集到的的性能数据进行统计和分析，开发出具有多维度分析图标和数据监控的APM（ Application Performance Monitoring，应用性能监控 ）平台。 最初，斗鱼采用了市面上非常流行的 Elasticsearch （简称 ES）实时聚合实现。运行一段时间后，基于 ES 的方案面临用户查询时间长、数据精度丢失等问题，斗鱼采用 Apache Kylin 替换 Elasticsearch， 对 APM 平台中存在的问题进行优化。不试不知道，一试吓一跳。</p><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>斗鱼是一家面向大众用户的在线直播平台，每天都有超大量的终端用户在使用斗鱼各客户端参与线上互动。伴随业务的迅猛发展，斗鱼需要对客户端采集到的性能数据进行统计和分析，开发出具有多维度分析图表和数据监控的 APM （Application Performance Monitoring，应用性能监控） 平台。 </p><p>针对不同的客户端采集的不同数据，我们需要将各种维度之间相互组合并聚合，最终产出的数据变成指标在图表中展示。例如：对在时间、地域、网络环境、客户端以及 CDN 厂商等维度聚合下的各项指标情况进行<strong>多维度分析</strong>，包括客户端网络性能（包含完整请求耗时，请求耗时，响应耗时，DNS 耗时，TCP 耗时，TLS 耗时等等指标）各类错误时间段内的占比以及详细数量、状态码分布等等。图一和图二分别是两个示例： </p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8xbb72l6hj20q607u0tt.jpg" alt="undefined"></p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8xbbe37fxj20sg0aw43o.jpg" alt="undefined"></p><p>最初使用ES实施聚合，配合字眼多数据源统一接口（REST多数据源统一接口平台）框架，能够实现纬度指标的自由组合查询。数据采用strom实时消费kafka写入ES，醉倒了数据的事实展示，告警采用定时查询ES的方式。</p><p>运行一段时间后，ES的方案存在问题： <strong>采用 ES 实时聚合的方式，大多数时候对单个字段的聚合查询是非常快的，一旦遇到较为复杂的多维度组合查询并且聚合的数据量比较大（如数十亿），就可能会产生大量的分组，对 ES 的性能压力很大，查询时间很长（几十秒到数分钟）导致用户难以等待，还可能会遇到数据精度丢失的问题。</strong> 因此为了支撑业务， 考虑再三我们决定寻找替代方案，注意到 Apache Kylin 在大数据 OLAP 分析方面非常有优势，于是决定采用 <strong>Kylin 替换 Elasticsearch</strong>， 对斗鱼 APM 平台中存在的问题进行优化。不试不知道，一试吓一跳，效果还真的不错。 </p><h4 id="二、使用Kylin的挑战和解决方案"><a href="#二、使用Kylin的挑战和解决方案" class="headerlink" title="二、使用Kylin的挑战和解决方案"></a>二、使用Kylin的挑战和解决方案</h4><h5 id="Kylin集群的搭建"><a href="#Kylin集群的搭建" class="headerlink" title="Kylin集群的搭建"></a>Kylin集群的搭建</h5><p>斗鱼的这个需求是独立业务，所以搭建了独立集群，目前为止集群共17台机器，其中 CM 节点3台，角色包含 HDFS，YARN，Zookeeper，Hive，HBase，Kafka（主要是消费使用），Spark 2 等。其中 4 台机器上部署了 Kylin 服务，采用了 1 个 “all“ 节点，1 个 “job“ 节点，2个 “query“ 节点的模式，确保了查询节点和任务节点都互有备份，满足服务的高可用。</p><p>斗鱼客户端收集到的 APM 数据会先暂存于 Kafka 消息队列中，Kylin 支持直接从 Kafka topic 中摄入数据而不用先落 Hive，于是我们选择了这种直连 Kafka 的方式来构建实时 Cube。 </p><h5 id="构建实时Cube的问题"><a href="#构建实时Cube的问题" class="headerlink" title="构建实时Cube的问题"></a>构建实时Cube的问题</h5><p>斗鱼客户端收集到的 APM 数据会先暂存于 Kafka 消息队列中，Kylin 支持直接从 Kafka topic 中摄入数据而不用先落 Hive，于是我们选择了这种直连 Kafka 的方式来构建实时 Cube。 </p><p>1) Kafka数据格式要求：</p><p> Kylin 的实时 Cube 需要配置基于 Kafka topic 的 Streaming Table (将 Kafka topic 映射成一张普通表）。这一步不同于基于 Hive 的数据表（Kylin 可以直接从 Hive metastore 获取表的字段信息），需要管理员进行一定的手工配置，才能将 Kafka 中的 JSON 消息映射成表格中的行。这一步对 Kafka 中的数据格式和字段有一定的要求，起初因为不了解这些要求，配置的 Cube 在构建时经常失败，只有少数 Cube 构建成功。也有的 Cube 很多次都构建成功，但偶尔会有失败。针对这些问题我们进行了一系列的排查和改进。现总结如下：</p><p> a. 由于我们原始数据在 kafka 中的存放格式为数组格式（JSON 字符串），所以在创建 Streaming Table 的时候会遇到下面的问题： </p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8xktgl70sj20sg0bjn0p.jpg" alt="undefined"></p><p>Kylin 会将数组中识别的字段默认加上数组下标，例如图中的 0_a，0_b 等，与我们的预期不符，所以需要对数组数据进行拆分。也就是说，Kylin 期望一条消息就是一个 JSON 对象（而非数组）。</p><p>b. 我们原始数据中还有嵌套的对象类型的字段，这种类型在 Kylin Streaming Table 识别的时候也可能会有问题，同样需要规整。如 Kylin 会把嵌套格式如 “{A: {B: value}}” 识别为 A_B 的字段，如下图，所以使用起来同样也可以，这个根据业务的不同可以自由选择，可以采用将嵌套字段铺平来规避后面可能出现的问题。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8xl9j5qrcj20sg06ywfg.jpg" alt="undefined"></p><p>c. 这个是比较难发现的一个问题，就是在设计好 Cube 之后，有时会有 Cube 构建失败的情况，经过排查之后发现，是由于公司业务数据来源的特殊性（来自于客户端上报），所以可能会出现 Kafka 中字段不一致的情况。一旦出现极少数字段不一样的数据混在 Kafka 中，便极有可能让这一次的 Cube 构建失败。 </p><p>基于以上几点，我们总结，<strong>Kylin 在接入 Kafka 实时数据构建之前，一定要做好数据清洗和规整</strong>，这也是我们前期耗费大量时间踩坑的代价。数据的清洗和规整我们采用的是流处理（Storm/Flink）对 Kafka 中的数据进行对应的处理，再写入一个新的 Kafka topic 中供 Kylin 消费。 </p><p>2) 任务的定时调度</p><p>Cube 的构建任务需要调用 API，如何定时消费 kafka 的数据进行构建，以及消费 kafka 的机制究竟如何。由于对 Kylin 理解的不够，一开始建出来的 Cube 消耗性能十分严重，需要对所建的 Cube 配合业务进行剪枝和优化。</p><p>构建实时 Cube 和构建基于 Hive 的离线 Cube 有很多不一样的地方，我们在使用和摸索的过程中踩了很多坑，也有了一定的经验。</p><p>由于是近实时 Cube 构建，需要每隔一小段时间就要构建一次，采用服务器中 Kylin 主节点上部署 Crontab-job 的模式来实现。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8xlqat61cj20jf05qt8z.jpg" alt="undefined"></p><p> 调度的时间间隔也经过了多次试验，调度的时间短了，上一个任务还没有执行完，下一个就开始了，容易产生堆积，在高峰时期容易造成滚雪球式的崩塌；调度的时间长了，一次处理的数据量就会特别大，导致任务执行的时间和消耗的资源也随之增长（Kylin 取 Kafka的数据，是比较简单粗暴的从上一次调度记录的 offset 直接取到当前最新的 offset，所以间隔时间越长，数据量越多），这是一个需要平衡的事情。经过反复测试使用，以及官方相应的介绍下，我们发现任务执行时间在 10~20 分钟为最优解，当然根据数据量的不同会有不同的调整。 </p><p> 3）Kylin 的剪枝与优化 </p><p>由于业务比较复杂，每个 Cube 的维度可能特别的多，随着维度数目的增加 Cuboid 的数量会爆炸式的增长。例如 WEB 端网络性能分析的 Cube 维度可能达到 47 个，如果采用全量构建，每一个可能情况都需要的话，最多可能构建 2 的 47 次方，也就是1.4 * 10^14 种组合，这肯定是不能接受的。所以在 Cube 设计的时候一定要结合业务进行优化和剪枝。</p><p>首先是筛选，将原始数据中根据不同的业务，选择不同的字段进行设计，以Ajax性能分析为例，选择出需要使用的 25 种维度。<strong>（2^47 -&gt; 2^25）</strong></p><p>接下来是分组，将 25 种维度按照不同的场景进行分组，例如，地域相关的可以放在一起，浏览器相关的也能分为一组。我们将场景分为了 4 组，将指数增长拆分为多个维度组之和。<strong>好的分组可以有效的减少计算复杂度，但是没有设计好的分组，很可能会由于设计问题没有覆盖好各种场景，导致查询的时候需要二次聚合，导致查询的性能很差，这里需要重点注意。（2^25 -&gt; 2^12 + 2^13 + 2^14 + 2^13）</strong></p><p> 然后是层级维度（Hierarchy Dimensions）、联合维度（Joint Dimensions）和必要维度（Mandatory Dimensions）的设置。这三个官网和网上都有大量的说明，这里不加赘述。最终实现 Kylin 的剪枝，来减少计算的成本。 </p><p>最后是 Kylin 本身一系列的配置上的优化，这些针对各自业务和集群可以参照官方文档进行调参优化。</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8xlrfg7plj20sg0b6ahm.jpg" alt="undefined"></p><h5 id="Kylin集群优化"><a href="#Kylin集群优化" class="headerlink" title="Kylin集群优化"></a>Kylin集群优化</h5><p>起初我们为 Kylin 集群申请的机器类型是计算密集型，没有足够的本地存储空间。Kylin 在运行的过程中磁盘经常满了，常常需要手动清理机器。同时在前期运行的过程中时不时会出现「Kylin 服务挂了（或者管理端登不上）」，「HBase 挂了」等等情况，针对遇到的这几个问题，我们有一些解决的措施。</p><p>1）<strong>磁盘不足。</strong>因为 Kylin 在构建 Cube 的时候，会产生大量的临时文件，而且其中有部分临时文件 Kylin 是不会主动删除的，所以机器经常会出现磁盘空间不足的问题（也跟我们计算型机器磁盘空间小有关）。</p><p>解决办法：采用定时自动清除，和手动调动 API 清除临时文件，扩容 2 台大容量机器调整 Reblance 比例（这才彻底解决这个问题）。</p><p>2）<strong>服务不稳定。</strong>刚开始的时候集群部分角色总是挂起（例如 HDFS、HBase 和 Kylin 等），排查发现是由于每台机器存在多个角色，角色分配的内存之和大于机器的可用内存，当构建任务多时，可能导致角色由于内存问题挂掉。</p><p>解决办法：对集群中各个角色重新分配，通过扩容可以解决一切资源问题。添加及时的监控，由于 Kylin 不在 CM 中管理，需要添加单独的监控来判断 Kylin 进程是否挂掉或者卡住，一旦发现需要重启 Kylin。要注意有 job 的节点重启时需要设置好 kafka 安装路径。</p><h5 id="HBase超时优化"><a href="#HBase超时优化" class="headerlink" title="HBase超时优化"></a>HBase超时优化</h5><p> Kylin 在后期维护中，经常会有任务由于 operationTimeout 导致任务失败。如图： </p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8xlxz8a4ej20sg06taf5.jpg" alt="undefined"></p><p> 这个报错让 Cube 构建常常失败，且一旦构建失败超过一定的次数，该 Cube 就不会继续构建了，影响到了业务的使用，针对此问题也进行了相应的排查，发现是构建的时候，可能会由于 HBase 连接超时或者是连接数不够造成任务失败。需要在 CM 中调整 HBase 相关参数。包括调整 hbase.rpc.timeout 和 hbase.client.operation.timeout 到 50000 等（之前是 30000，可以根据业务不不同自行调整，如果还有超时可以优化或者继续调整）。 </p><h5 id="已有-Cube-的修改"><a href="#已有-Cube-的修改" class="headerlink" title="已有 Cube 的修改"></a>已有 Cube 的修改</h5><p>由于业务的迭代，新增了几个维度和指标需要增加在已存在的Cube上，又例如原先 Cube 设计上有一些不足需要修改。在这方面例如 DataSource 没有修改功能，新旧 Cube 如何切换，修改经常没有响应等等问题让我们十分为难。</p><p>已有 Cube 的修改是目前使用 Kylin 最为头疼的地方。虽然 Kylin 支持 Hybrid model 来支持一定程度的修改，但是在使用的过程中因为</p><p>各种各样的原因，例如 Streaming Table 无法修改来新增字段等，还是未能修改成功。</p><p>目前采用的修改模式为，重新设计一整套从 DataSource 到 Model 再到 Cube，停止之前 Cube 的构建任务，开始新 Cube 的构建调度。使用修改我们 Java 代码的方式动态的选择查询新 Cube 还是旧 Cube，等到一定的时间周期之后再废弃旧 Cube。目前这种方式的弊端在于查询时间段包含新旧时，需要在程序中拼接数据，十分麻烦且会造成统计数据不准。所以在设计之初就要多考虑一下后面的扩展，可以先预留几个扩展字段。</p><p>用SPA如今稳进死                                                                                                                                                                                                                                           </p><h4 id="三、效果对比"><a href="#三、效果对比" class="headerlink" title="三、效果对比"></a>三、效果对比</h4><h5 id="对比表格"><a href="#对比表格" class="headerlink" title="对比表格"></a>对比表格</h5><table><thead><tr><th>条件</th><th>Apache Kylin</th><th>ES实时聚合</th><th><strong>Hive</strong> 离线任务再入  MySQL</th></tr></thead><tbody><tr><td>查询速度</td><td>较快，一般在亚秒级别。从HBase中选择适合的纬度，Cube设计的好的话不存在二次聚合，也不会有速度方面的问题。</td><td><strong>慢，可能有几分钟。</strong>实时聚合，在复杂的情况下有严重的性能问题，查询的时间可能到几分钟。</td><td><strong>快，一般在毫秒级。</strong>计算好的数据基于  MySQL 查询，一般不会有性能问题。</td></tr><tr><td>时效性</td><td>近实时，一般在30分钟以内。延迟主要取决于任务调度的时间，但是一般都会在10~30分钟左右。</td><td><strong>实时，一般延迟在秒级。</strong>ES的延迟是取决于上游数据的写入延迟和数据刷新的时间，一般可以控制在秒级。</td><td><strong>离线，一般是T+1延迟。</strong>离线数据由于同步和计算的关系，一般都是+1小时延迟或者是+1天延迟。</td></tr><tr><td>开发难度</td><td>较简单。实时数据需要先进行一系列的清洗和规整，后面只需要配置即可，不过 Cube 设计有一定的难度。</td><td><strong>简单。</strong>只需要写入数据即可，配合已有的EST框架可以任意组合满足业务需要。</td><td><strong>工作量极大。</strong>针对每一种维度组合，都需要手动开发任务来进行计算和存储。</td></tr><tr><td>资源消耗</td><td>一般。单独搭建的集群，不会对其他业务造成影响，但是集群资源需求还是比较大。</td><td><strong>一般。</strong>查询和写入一旦量大复杂后对集群上其他的查询会带来影响。</td><td><strong>一般。</strong>在大集群上跑  YARN 任务，对集群整体影响不大。</td></tr><tr><td>可拓展性</td><td><strong>不太好扩展。</strong>针对已经建好的  DataSource、Model 和 Cube 的修改比较不友好，但是有解决的办法。</td><td><strong>可扩展性较强。</strong>所有的修改只需修改Index模板，下一周期生效即可。</td><td><strong>基本无法扩展。</strong>每次有新的业务需求需要重新开发任务。</td></tr><tr><td>容错性</td><td><strong>较差。</strong>对数据的格式和类型要求较为严格，容易导致构建失败。</td><td><strong>较差。</strong>字段不一致会带来冲突，导致字段无法聚合，且冲突一旦在索引中生成，该索引将无法解决，只有等待下一周期或删除索引。</td><td><strong>较好。</strong>对字段类型和数据字段有一定的容错性。</td></tr><tr><td>数据查询复杂度</td><td><strong>十分简单。</strong>Kylin 会根据条件自动识别就是在哪一个 Cuboid 中查询数据，只需要使用 SQL 即可，跨 Cuboid 的查询也可以自动二次聚合，SQL 也可以直接配合 EST 框架。</td><td><strong>较为容易。</strong>配合 EST 框架查询十分容易，但是由于索引有小时和天后缀，需要在程序中进行判断，才能有效降低查询量。</td><td><strong>十分困难。</strong>由于每个维度存储组合存储的表都不一样，导致存储结构十分复杂，查询的时候需要自己判断在那张表里面，难度很大。</td></tr></tbody></table><h5 id="Tips-Impala速度快的原因"><a href="#Tips-Impala速度快的原因" class="headerlink" title="Tips: Impala速度快的原因"></a>Tips: Impala速度快的原因</h5><p>impala采用了MPP查询引擎(Massively Parallel Processor)， 在数据库非共享集群中，每个节点都有独立的磁盘存储系统和内存系统，业务数据根据数据库模型和应用特点划分到各个节点上，每台数据节点通过专用网络或者商业通用网络互相连接，彼此协同计算，作为整体提供数据 库服务。非共享数据库集群有完全的可伸缩性、高可用、高性能、优秀的性价比、资源共享等优势。 </p><p>Elasticsearch也是一种MPP架构的数据库，Presto、Impala等都是MPP engine，各节点不共享资源，每个executor可以独自完成数据的读取和计算，缺点在于怕stragglers，遇到后整个engine的性能下降到该straggler的能力，所谓木桶的短板，这也是为什么MPP架构不适合异构的机器，要求各节点配置一样。 </p><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>之前ES需要90s完成的查询，使用Kylin只需要2-3s，原来需要加载几分钟的仪表盘，现在只需要几秒钟就能加载完成，速度提升30多倍。</p><p>在开发效率上，切换至 Kylin 在前期不熟悉的情况下的确走了一些弯路，踩了不少坑（跟数据质量、对 Kylin 原理的掌握等都有关）。但是后面在熟悉之后便可以有不逊色于 ES 的开发效率，用起来非常不错。</p><p>目前版本的 Kylin 也有一些不足，例如数据的时效性，因为 Kylin 2.x 的流数据源只能达到准实时（Near Real-time），准实时延迟通常在十几到几十分钟的，对 APM 系统中的实时告警模块还不能满足业务要求。所以目前实时告警这一块走的还是ES，由于告警只需要对上个短暂周期（1~5 分钟）内的数据做聚合，数据量较小，ES 对此没有性能问题倒能承受。对于海量历史数据，通过 Kylin 来查询的效果更好。</p><p>新系统于 2018 年 11 月正式上线，目前已经稳定运行近一年。我们也注意到 Kylin 3.0 已经在实时统计上开始发力，能够做到 ES 这样的秒级延迟，我们会持续关注，希望 Kylin 可以发展的越来越好。</p><h2 id="第五章-Kylin在腾讯的平台化及Flink引擎实践"><a href="#第五章-Kylin在腾讯的平台化及Flink引擎实践" class="headerlink" title="第五章 Kylin在腾讯的平台化及Flink引擎实践"></a>第五章 Kylin在腾讯的平台化及Flink引擎实践</h2><p>Kylin 现有的用户管理、资源隔离机制并不能满足我们需求，基于此，腾讯对 Kylin 进行了平台化改造。希望平台化改造完成后，在下面这些层面，能够有一些改进：</p><ul><li>用户管理</li><li>资源隔离</li><li>易用性提升</li><li>方便运维</li></ul><h3 id="用户管理："><a href="#用户管理：" class="headerlink" title="用户管理："></a>用户管理：</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92byqbpinj20sg0enq3v.jpg" alt="undefined"></p><p>为了便于系统的管理及安全，公司内部有一套自己的认证系统，而且需要用个人账号去验证，所以 Kylin 作为一个平台对外提供服务的话，也需要接入到该系统。所以，我们新增了一个用户管理界面，该界面展示了 Kylin 平台内的所有用户。管理员可以新增任一用户到 Kylin 平台，新增用户时会填写企业微信名、用户角色以及是否激活用户。当用户登录系统时，会自动检测用户账号以及该账号是否在平台内注册，如果没有注册则无权限，反之自动登录系统。 </p><h3 id="内部Hive兼容"><a href="#内部Hive兼容" class="headerlink" title="内部Hive兼容"></a>内部Hive兼容</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92bzc39h9j20g60ajmxc.jpg" alt="undefined"></p><p>由于历史原因，我们部门内的 Hive 版本（THive）与 Kylin 不兼容，这就导致 Kylin 无法正常访问 Kylin 集群，所以我们采用了上图所示的兼容方案。首先，我们使用社区 Hive 版本搭建一个全新的 Hive，并作为 Kylin 的默认 Hive；其次，当 kylin 加载源表时，我们是通过内部的 UPS 系统读取 THive 的元数据信息；最后，在 Load 源表到 Kylin 时，我们根据表的元数据信息在 Kylin 的 Hive 上创建一张相同的表，但该表的存储路径依旧指向 THive 的路径，而用户在构建 cube 时，则访问新创建的表，至此就解决了 Kylin 访问 THive 的问题。 </p><h3 id="计算资源可配置化"><a href="#计算资源可配置化" class="headerlink" title="计算资源可配置化"></a>计算资源可配置化</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92bzqjxlmj20sg0b00td.jpg" alt="undefined"></p><p> 目前，Kylin 配置计算资源信息有两种方式：一是在 Kylin 配置文件中配置一个全局的计算集群及队列；二是在创建工程或者 Cube 时，在扩展参数中指定集群配置。这两种配置方式在灵活性及便捷性方面都比较差，而在我们内部是有接口可以获取到某一个用户有计算资源的计算集群及计算队列的，所以，在创建工程或者 Cube 时，我们使用了下拉框选择式的方式，让用户选择提交任务的计算资源及队列，从而大大简化了用户的使用流程。 </p><h3 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92c01zg2dj20sg0cijs8.jpg" alt="undefined"></p><p>Kylin 只提供了发邮件通知的功能，而作为目前使用最广泛的工具，微信、企业微信在实时性及便捷性方面都远远胜于邮件，所以，我们提供了邮件、微信、企业微信三种方式，供用户选择。 </p><h3 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92c0ds7dij20sg0augmf.jpg" alt="undefined"></p><p>Kylin 系统自身并没有提供定时调度功能，但基本上每家公司都有自己的统一调度平台，我们也不例外。我们通过 Kylin 提供的API接口，将 Cube 定时构建的功能作为一个插件集成到了公司内部的统一调度平台上。 </p><h3 id="业务接入"><a href="#业务接入" class="headerlink" title="业务接入"></a>业务接入</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92c0z1koyj20sg0bjjs2.jpg" alt="undefined"></p><p>做完以上平台化改造后，Kylin 平台基本具备了接入不同类型业务的能力，用户申请接入流程如上图所示。</p><p>业务使用情况：</p><p>我们团队是在今年初才开始引入 Kylin，目前已经在使用的业务主要有 QQ 音乐、腾讯视频、广点通、财付通等，Cube 的数量有 10 个，单份数据存储总量是 5 T，数据规模在 30 亿条左右。</p><h3 id="Flink-Cube-Engion："><a href="#Flink-Cube-Engion：" class="headerlink" title="Flink Cube Engion："></a>Flink Cube Engion：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">目前，Kylin 已经支持使用 MapReduce 和 Spark 作为构建引擎，而作为目前比较火的流批一体的大数据计算引擎怎能缺席？所以我使用 Flink 开发了一个高性能的构建引擎：Flink Cube Engine。</span><br><span class="line"></span><br><span class="line">Flink Cube Engine 是腾讯基于 Kylin 插件化的 Cube Engine 架构开发的一个高性能构建引擎，目前已具备了上线使用的能力，感兴趣的同学可以体验一下，目前该引擎已经在腾讯生产环境上线 1 个月+，非常稳定而且效果不错。</span><br><span class="line"></span><br><span class="line">Umbrella issue: </span><br><span class="line"></span><br><span class="line">Umbrella issue: </span><br><span class="line"></span><br><span class="line">https://issues.apache.org/jira/browse/KYLIN-3758</span><br><span class="line"></span><br><span class="line">分支：</span><br><span class="line"></span><br><span class="line">https://github.com/apache/kylin/tree/engine-flink</span><br></pre></td></tr></table></figure><p>上面</p><p>第一个链接可以看到flink cube的完成情况</p><p>第二个链接可以看到flink cube在github的代码</p><p>使用：<img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92cvbklxij20sg0bf0t6.jpg" alt="undefined"></p><p>Kylin 的一次 Cube 构建任务，包含了很多个子任务，而最重要的莫过于 Cube 构建这一步骤，所以，我们在 build 和 merge Cube 这两种任务中，优先实现了Cube 构建这一步骤，其他计算步骤依旧通过使用 MapReduce 来实现。 </p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92cwad8r9j20m50f1aaq.jpg" alt="undefined"></p><p>选择使用 Flink Cube Engine 的方式也和选择 Map Reduce 和 Spark 任务类似，我们提供了前台可视化的界面，供用户选择。 </p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92cwti90pj20sg0bygmq.jpg" alt="undefined"></p><p>上图是我们内部业务上线 Flink Cube Engine 之后的性能对比，从图中可见，该步骤的构建耗时从 49 分钟降到了 13 分钟，优化效果比较明显。两种情况的资源配置如下：</p><p>Flink 配置为：</p><p>-ytm 4G -yjm 2G -ys 1 -p 100 -yn 100</p><p>Spark 采用的动态分配资源如下：</p><p>kylin.engine.spark-conf.spark.dynamicAllocation.enabled=true</p><p>kylin.engine.spark-conf.spark.dynamicAllocation.minExecutors=2</p><p>kylin.engine.spark-conf.spark.dynamicAllocation.maxExecutors=1000</p><p>kylin.engine.spark-conf.spark.dynamicAllocation.executorIdleTimeout=300</p><p>kylin.engine.spark-conf.spark.shuffle.service.enabled=true</p><p>kylin.engine.spark-conf.spark.shuffle.service.port=7337</p><p>虽然，Spark 采用的是动态分配资源，但在任务执行过程中，我们观察到 Spark实际分配的资源远比 Flink 要多的多。</p><p>那为什么性能提升会那么明显呢？</p><ol start="4"><li>Flink Cube Engine 的优化</li></ol><p>性能的提升，无非有两方面的原因，一是参数的优化，二是代码的优化。</p><p>1) 调参</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92d1xm7dbj20sg04qt9j.jpg" alt="undefined"></p><p>影响 Flink 任务性能主要有几个核心参数：并行度、单个 TM slot 数目、TM container 数目，其中单个 TM container 数目=并行度/单个 TM slot 数目。</p><p>我们调优的过程采用了控制变量法，即：固定并行度不变、固定 Job 总内存数不变。通过不断的调整单个 TM 的 slot 数目，我们发现如果单个 TM 的 slot 数目减少，拉起更多的 TM container 性能会更好。</p><p>此外，我们还使用了对象复用、内存预分配等方法，发现没有对性能提升起到太大的效果。</p><p>2) 代码优化(合并计算)</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92d2ii64cj20sg0bimyh.jpg" alt="undefined"></p><p> 在实现 Flink Cube Engine 的时候，一开始我们使用了 Map/Reduce 两个算子，发现性能很差，比 Spark 的性能还要差很多，后来我们通过调整使用了 Flink 的 mapPartition/reduceGroup 两个算子，性能就有了明显的提升。 </p><p>Flink Cube Engine 下一步的计划：</p><ol><li>全链路 Flink</li></ol><p>如上所述，目前 Cube 构建过程中，只有最关键的 cube 构建这一子任务使用了 Flink，而其他子任务仍然使用的是 MapReduce，我们下一步会继续完善 Flink Cube Engine，将所有的子任务都使用 Flink 来构建。</p><ol start="2"><li>Flink 升级到 1.9</li></ol><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g92d55mrpgj20sg09bdgg.jpg" alt="undefined"></p><p>Flink 最近发布了 1.9.0，该版本包含了很多重要特性且性能也有了一定提升，所以，我们会把 Flink Cube Engine 使用的 Flink 版本升级到1.9.0。 </p><h2 id="第六章-Kylin实操"><a href="#第六章-Kylin实操" class="headerlink" title="第六章 Kylin实操"></a>第六章 Kylin实操</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Kylin的安装相对简单，我们使用的Kylin是2.6.3版本的，安装并没有多少复杂的步骤，按照官网的步骤安装即可：</p><p><a href="http://kylin.apache.org/docs/install/index.html" target="_blank" rel="noopener">官方文档安装步骤</a></p><p>安装完成后，在bin目录下面执行check-env.sh，这个脚本会执行检查，如果仅仅显示KYLIN_HOME is set to… 说明一切配置正常，就可以启动了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>回到Kylin的bin目录下执行sample.sh，成功执行后会有如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Retrieving hadoop conf dir...</span><br><span class="line">KYLIN_HOME is set to /data1/CM/kylin-2.6.3</span><br></pre></td></tr></table></figure><p>出现这个提示，就说明已经成功了。</p><p>根据日志提示信息，重新加载元数据，使kylin能读取到创建好的project “learn_kylin”.跳转至system ,点击reload metadata</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g94igifi2xj20zk0gxtc3.jpg" alt="undefined"></p><p> 然后buil cube</p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g94ih39tw6j20zk0gxq4q.jpg" alt="undefined"></p><p>此时cube正在创建，可以在Monitor中监控到整个cube构造的过程以及可以查看到每一步构建的过程和日志。 </p><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g94ihodonej20zk0gx0un.jpg" alt="undefined"></p><p>然后就可以在SQL输入框输入相关的SQL，就可以做简单的可视化。</p><h2 id="第七章-Kylin的优化"><a href="#第七章-Kylin的优化" class="headerlink" title="第七章 Kylin的优化"></a>第七章 Kylin的优化</h2><h3 id="查询时间优化"><a href="#查询时间优化" class="headerlink" title="查询时间优化"></a>查询时间优化</h3><p>Kylin 的查询过程主要包含四个步骤：解析 SQL，从 HBase 获取数据，二次聚合运算，返回结果。显然优化的重点就落在如何加快 HBase 获取数据的速度和减少二次聚合预算。</p><ul><li>提高 HBase 响应时间：修改配置，修改 Cache 的策略，增加 Block Cache 的容量</li><li>减少二次聚合运算：合理设计纬度，使查询时尽量能精确命中 Cuboid。去重值使用有损算法。</li></ul><h3 id="预计算优化"><a href="#预计算优化" class="headerlink" title="预计算优化"></a>预计算优化</h3><p>预计算的优化，主要考虑有何缩短构建花费的时间，以及中间结果和最终结果占用的空间。每个业务单独一个 Cube，避免每个 Cube 大而全，减少不必要的计算。</p><h4 id="Cube优化"><a href="#Cube优化" class="headerlink" title="Cube优化"></a>Cube优化</h4><p>随着维度数目的增加，Cuboid 的数量成指数级增长。为了缓解 Cube 的构建压力，Kylin 提供了 Cube 的高级设置。这些高级设置包括聚合组（Aggregation Group）、联合维度（Joint Dimension）、层级维度（Hierarchy Dimension）和必要维度（Mandatory Dimension）等。</p><p>合理调整纬度配置，对需构建的 Cuboid 进行剪枝，刷选出真正需要的 Cuboid，优化构建性能，降低构建时间，大大提高了集群资源的利用效率。</p><p>如果Cube优化的好，效果可以非常明显。</p><h5 id="优化方法："><a href="#优化方法：" class="headerlink" title="优化方法："></a>优化方法：</h5><p>1.必须维度</p><p>查询时，经常使用的维度，以及低基数纬度。如该维度基数&lt;10，可以考虑作为必须维度。 </p><p>2.层级维度</p><p> 维度关系有一定层级性、基数有小到大情况可以使用层级维度。 </p><p>3.Joint维度</p><p>维度之间是同时出现的关系，及查询时，绝大部分情况都是同时出现的。可以使用 joint 维。 </p><p>4.维度组合组</p><p>将为维度进行分组，查询时组与组之间的维度不会同时出现。 </p><h5 id="配置优化："><a href="#配置优化：" class="headerlink" title="配置优化："></a>配置优化：</h5><p> 配置优化，包括 Kylin 资源的配置以及 Hadoop 集群配置相关修改。 </p><ol><li>构建资源</li></ol><p>每个 Cube 构建时，所需的资源不太一样，需要进行相应的资源调整。</p><ol start="2"><li>调整副本</li></ol><p>集群默认的文件副本数为 3，Cube 构建时，将副本数调为 2，个别中间任务还可以调整为 1，这样可以降低构建任务时集群 IO。为了保证查询的稳定性，HBase 副本数依然为 3。</p><ol start="3"><li>压缩格式</li></ol><p>在实验中发现，如果Hive和Hbase都设置了snappy格式，那么集群IO交互会小很多。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Kylin在复杂业务的查询中可以用预计算的方式提前计算好预期结果存在Hive临时表中，然后写入Hbase，优点显而易见：</p><p>1.可以合理配置集群资源，预计算的时间可以提前设定。</p><p>2.对海量数据的提前预计算意味着用户查询时不用重复计算，直接从Hbase中获取结果即可。</p><p>缺点：</p><p>Kylin仅支持星型模型的数据集，对原数据提出了要求。</p><p>并且作为空间换时间的OLAP应用，需要占用HBase集群大量的空间。</p><p>维度的膨胀需要结合业务控制，不同的业务还需要研究不同Cube的优化，使用成本会比IMPALA 这种使用SQL语言的高不少。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Kylin是在Hadoop上的SQL层，最近对Phoenix调研完成之后，对Kylin产生了兴趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/bec9bff2ly1g8v1qog93xj209d08laa6.jpg&quot; alt=&quot;undefined&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://yoursite.com/categories/Apache/"/>
    
      <category term="Kylin" scheme="http://yoursite.com/categories/Apache/Kylin/"/>
    
    
      <category term="Kylin" scheme="http://yoursite.com/tags/Kylin/"/>
    
  </entry>
  
</feed>
