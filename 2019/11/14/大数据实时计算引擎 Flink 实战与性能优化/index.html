<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/xingqiushangcheng.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/xingqiushangcheng.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Flink,">





  <link rel="alternate" href="/atom.xml" title="Mars" type="application/atom+xml">



  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "bfb40164"
    });
  daovoice('update');
  </script>





<meta name="description" content="大数据实时计算引擎 Flink 实战与性能优化 Flink作为流处理方案的最佳选择，还有流处理 批处理大一统之势，可谓必知必会">
<meta name="keywords" content="Flink">
<meta property="og:type" content="article">
<meta property="og:title" content="大数据实时计算引擎 Flink 实战与性能优化">
<meta property="og:url" content="http://yoursite.com/2019/11/14/大数据实时计算引擎 Flink 实战与性能优化/index.html">
<meta property="og:site_name" content="Mars">
<meta property="og:description" content="大数据实时计算引擎 Flink 实战与性能优化 Flink作为流处理方案的最佳选择，还有流处理 批处理大一统之势，可谓必知必会">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g9a0z5j7i6j20bp04tdgk.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plho80ksj20z50u042l.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plhzw2umj210c0dsdh7.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pli7o9s7j20gm12540a.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plijpowcj214o0u0jv0.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plio676aj21em0u0gqt.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pliw2d21j217f0u0tdh.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plj8y8wdj20p00goacz.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pljh92jpj216l0u00wg.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plkbpo1mj20u00ymq6n.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plkidal4j21as0ps0va.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pllqzkewj219e0q0gnf.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plm1lerpj219s0e6759.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plm92vsuj219m0fudgu.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plmoolb2j219s0ts41e.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plr0788dj214a0gy755.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plr9ox1fj21gt0u0gp2.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plrjlud5j20lp0cuabw.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pls0gqd0j22vw17qn0l.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plt1pm8wj21880kot9g.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pltiz3r3j20ph0lbwfh.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plu1ecy0j20op0fpad9.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plud1dkhj218i0iw78b.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pluob9z7j21a00us11g.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plutdjgyj21q20h6q3c.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plv10mhgj215218utau.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plwkg73tj21li0u075w.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plx9wf35j22kg1bs0uc.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plxlthw1j20jb0crace.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plzy3s4ej215e1g045u.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm0elnw7j20mn0d7t9i.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm107pqzj217k104jw6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm2ghwbrj20sg0g0gmg.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm2mmmyoj20wk0c6js2.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm2t6k21j20tr06naad.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm30f5cqj20ub06nweq.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm3b0i1qj20ub0asmxp.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm3imkjuj20rm0asdg9.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm3y2va0j214w0m03zf.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm5gkz7aj21810r9dgp.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm5nafczj21980n940t.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pn93djtcj20g205umx6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pn9bggknj21qo0yc407.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pn9ibun2j21fe0u040j.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pn9pgxz7j21nm0qwq48.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pn9wb7zgj22y81eedne.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pndeozfuj20u0130dll.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pne4yctlj24m02d04qp.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pnejkllpj20t60qsdhg.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pnl2lqdzj21y417i0wa.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pnmiv3uoj21fi106q8b.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pnneh4l3j228o1j6myu.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0un83lnzj21r20tqk0e.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0unee0gmj21c00u0dn8.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uocicqoj21xw1aatf4.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uokn3kbj227w0pawfm.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uosbkccj22640mq3zx.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uoz4xbmj226w12e0zj.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0up8brt7j20p20k0dg6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0upjwdhnj20yw080q2z.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0upq3ibrj21n8188dia.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uq05u0wj21pc0vy74y.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uq6lppkj226o1awdhc.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uqcmgspj224u1ewq50.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0ur4cqi4j21b60aeq36.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0urc5j0wj21ni14egno.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0urirdxgj21s20legma.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0urqumhzj22760mqgmr.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0ury0iq8j225w1au3zz.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0us5qqsej227819wgnp.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uwc85x5j21li0u075w.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uwqobe4j227414ogn1.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uzyaa4aj21mm08mmx1.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0v0en8wuj21m80hudfw.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0v0wadrcj21my0gmaa6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0v1b9o6jj21mu0o2wet.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0v50qmevj21sc0w2wgo.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0v9hcl5wj21sa0xq410.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vazxmyfj21ek0ny769.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vbqi86ej225m0wmac7.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vcsdq1kj22gu0xaq5w.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vdsn6xyj21nc12qq3x.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vi0o960j20y20as3yg.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vlvjsgdj22ro0p0wey.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vpz366lj20iv08gn0z.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vqk5hxnj22ua0is3ys.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vqqwlzej227017sdnt.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vrfwkxpj215m0f8q30.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vro7oi3j225y0ts0vk.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vsgous8j21ri0dcmxj.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0xjwko8fj21200aqaa3.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0xkegqp2j213s0ju3yu.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0y9pd8g3j210u0heq35.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0ybr9m9lj212e0h4mxg.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0yg0tundj21gg0ggq3e.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0yi4jstvj215m17ejss.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0yppinynj21cy0fodfz.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0yvb90dej21em0rygnv.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0yvm1xntj21hq0hujsj.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zf4f9lvj217e0om74r.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zfc2xczj20s20hsaaj.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zfu71ysj21e20p0dgv.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zqks7btj21ik0pqdgr.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zqrrk6kj21bi0nkgmc.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zqyn66nj21cm0lsq46.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zrpl1ivj21xk0i674j.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zrx0blbj21hs1gsaci.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zs9dj5oj20r10a8t9f.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga1164fu1kj21ri0dcmxj.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga116diy51j21ji16aads.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga117rgkt8j21kw0yeakr.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga1181fv12j20w20ri42r.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga118a05luj21kw0xgtk0.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1ga118gxfh0j22tc0mijrw.jpg">
<meta property="og:updated_time" content="2019-12-18T10:04:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大数据实时计算引擎 Flink 实战与性能优化">
<meta name="twitter:description" content="大数据实时计算引擎 Flink 实战与性能优化 Flink作为流处理方案的最佳选择，还有流处理 批处理大一统之势，可谓必知必会">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g9a0z5j7i6j20bp04tdgk.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/14/大数据实时计算引擎 Flink 实战与性能优化/">





  <title>大数据实时计算引擎 Flink 实战与性能优化 | Mars</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'f6a8160e9467bb9adc80f36030e1c37b', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mars</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/14/大数据实时计算引擎 Flink 实战与性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fly Hugh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">大数据实时计算引擎 Flink 实战与性能优化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-14T06:52:03+08:00">
                2019-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flink/" itemprop="url" rel="index">
                    <span itemprop="name">Flink</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/11/14/大数据实时计算引擎 Flink 实战与性能优化/" class="leancloud_visitors" data-flag-title="大数据实时计算引擎 Flink 实战与性能优化">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  40k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  163
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="大数据实时计算引擎-Flink-实战与性能优化"><a href="#大数据实时计算引擎-Flink-实战与性能优化" class="headerlink" title="大数据实时计算引擎 Flink 实战与性能优化"></a>大数据实时计算引擎 Flink 实战与性能优化</h1><blockquote>
<p>Flink作为流处理方案的最佳选择，还有流处理 批处理大一统之势，可谓必知必会</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g9a0z5j7i6j20bp04tdgk.jpg" alt="undefined"></p>
<a id="more"></a> 
<h2 id="一、公司到底需不需要引入实时计算引擎？"><a href="#一、公司到底需不需要引入实时计算引擎？" class="headerlink" title="一、公司到底需不需要引入实时计算引擎？"></a>一、公司到底需不需要引入实时计算引擎？</h2><h3 id="实时计算需求"><a href="#实时计算需求" class="headerlink" title="实时计算需求"></a>实时计算需求</h3><p>大数据发展至今，数据呈指数倍的增长，对实效性的要求也越来越高，所以你可能接触到下面这类需求会越来越多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">小田，你看能不能做个监控大屏实时查看促销活动销售额（GMV）？</span><br><span class="line"></span><br><span class="line">小朱，搞促销活动的时候能不能实时统计下网站的 PV/UV 啊？</span><br><span class="line"></span><br><span class="line">小鹏，我们现在搞促销活动能不能实时统计销量 Top5 啊？</span><br><span class="line"></span><br><span class="line">小李，怎么回事啊？现在搞促销活动结果服务器宕机了都没告警，能不能加一个？</span><br><span class="line"></span><br><span class="line">小刘，服务器这会好卡，是不是出了什么问题啊，你看能不能做个监控大屏实时查看机器的运行情况？</span><br><span class="line"></span><br><span class="line">小赵，我们线上的应用频繁出现 Error 日志，但是只有靠人肉上机器查看才知道情况，能不能在出现错误的时候及时告警通知？</span><br><span class="line"></span><br><span class="line">小夏，我们 1 元秒杀促销活动中有件商品被某个用户薅了 100 件，怎么都没有风控啊？</span><br><span class="line"></span><br><span class="line">小宋，你看我们搞促销活动能不能根据每个顾客的浏览记录实时推荐不同的商品啊？</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>那这些场景对应着什么业务需求呢？我们来总结下，大概如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plho80ksj20z50u042l.jpg" alt="undefined"></p>
<p>初看这些需求，是不是感觉很难？那么我们接下来来分析一下该怎么去实现？</p>
<p>从这些需求来看，最根本的业务都是需要<strong>实时查看数据信息</strong>，那么首先我们得想想如何去采集这些实时数据，然后将采集的实时数据进行实时的计算，最后将计算后的结果下发到第三方。</p>
<h3 id="数据实时采集"><a href="#数据实时采集" class="headerlink" title="数据实时采集"></a>数据实时采集</h3><p>就上面这些需求，我们需要采集些什么数据呢？</p>
<ol>
<li>买家搜索记录信息</li>
<li>买家浏览的商品信息</li>
<li>买家下单订单信息</li>
<li>网站的所有浏览记录</li>
<li>机器 CPU/MEM/IO 信息</li>
<li>应用日志信息</li>
</ol>
<h3 id="数据实时计算"><a href="#数据实时计算" class="headerlink" title="数据实时计算"></a>数据实时计算</h3><p>采集后的数据实时上报后，需要做实时的计算，那我们怎么实现计算呢？</p>
<ol>
<li>计算所有商品的总销售额</li>
<li>统计单个商品的销量，最后求 Top5</li>
<li>关联用户信息和浏览信息、下单信息</li>
<li>统计网站所有的请求 IP 并统计每个 IP 的请求数量</li>
<li>计算一分钟内机器 CPU/MEM/IO 的平均值、75 分位数值</li>
<li>过滤出 Error 级别的日志信息</li>
</ol>
<h3 id="数据实时下发"><a href="#数据实时下发" class="headerlink" title="数据实时下发"></a>数据实时下发</h3><p>实时计算后的数据，需要及时的下发到下游，这里说的下游代表可能是：</p>
<ol>
<li>告警方式（邮件、短信、钉钉、微信）</li>
</ol>
<p>在计算层会将计算结果与阈值进行比较，超过阈值触发告警，让运维提前收到通知，及时做好应对措施，减少故障的损失大小。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plhzw2umj210c0dsdh7.jpg" alt="undefined"></p>
<ol>
<li>存储（消息队列、DB、文件系统等）</li>
</ol>
<p>数据存储后，监控大盘（Dashboard）从存储（ElasticSearch、HBase 等）里面查询对应指标的数据就可以查看实时的监控信息，做到对促销活动的商品销量、销售额，机器 CPU、MEM 等有实时监控，运营、运维、开发、领导都可以实时查看并作出对应的措施。</p>
<ul>
<li>让运营知道哪些商品是爆款，哪些店铺成交额最多，哪些商品成交额最高，哪些商品浏览量最多；</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pli7o9s7j20gm12540a.jpg" alt="undefined"></p>
<ul>
<li>让运维可以时刻了解机器的运行状况，出现宕机或者其他不稳定情况可以及时处理；</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plijpowcj214o0u0jv0.jpg" alt="undefined"></p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plio676aj21em0u0gqt.jpg" alt="undefined"></p>
<ul>
<li>让开发知道自己项目运行的情况，从 Error 日志知道出现了哪些 Bug；</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pliw2d21j217f0u0tdh.jpg" alt="undefined"></p>
<ul>
<li>让领导知道这次促销赚了多少 money。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plj8y8wdj20p00goacz.jpg" alt="undefined"></p>
<p><strong>从数据采集到数据计算再到数据下发，整个流程在上面的场景对实时性要求还是很高的，任何一个地方出现问题都将影响最后的效果！</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pljh92jpj216l0u00wg.jpg" alt="undefined"></p>
<h3 id="实时计算场景"><a href="#实时计算场景" class="headerlink" title="实时计算场景"></a>实时计算场景</h3><p>前面说了这么多场景，这里我们总结一下实时计算常用的场景有哪些呢？</p>
<ol>
<li>交通信号灯数据</li>
<li>道路上车流量统计（拥堵状况）</li>
<li>公安视频监控</li>
<li>服务器运行状态监控</li>
<li>金融证券公司实时跟踪股市波动，计算风险价值</li>
<li>数据实时 ETL</li>
<li>银行或者支付公司涉及金融盗窃的预警</li>
</ol>
<p>……</p>
<p>另外自己还做过调研，实时计算框架的使用场景有如下这些：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plkbpo1mj20u00ymq6n.jpg" alt="undefined"></p>
<p>总结一下大概有下面这四类：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plkidal4j21as0ps0va.jpg" alt="undefined"></p>
<ol>
<li>实时数据存储</li>
</ol>
<p>实时数据存储的时候做一些微聚合、过滤某些字段、数据脱敏，组建数据仓库，实时 ETL。</p>
<ol start="2">
<li>实时数据分析</li>
</ol>
<p>实时数据接入机器学习框架（TensorFlow）或者一些算法进行数据建模、分析，然后动态的给出商品推荐、广告推荐</p>
<ol start="3">
<li>实时监控告警</li>
</ol>
<p>金融相关涉及交易、实时风控、车流量预警、服务器监控告警、应用日志告警</p>
<ol start="4">
<li>实时数据报表</li>
</ol>
<p>活动营销时销售额/销售量大屏，TopN 商品</p>
<p>说到实时计算，这里不得不讲一下和传统的离线计算的区别！</p>
<h3 id="离线计算-vs-实时计算"><a href="#离线计算-vs-实时计算" class="headerlink" title="离线计算 vs 实时计算"></a>离线计算 vs 实时计算</h3><p>再讲这两个区别之前，我们先来看看流处理和批处理的区别：</p>
<h4 id="流处理与批处理"><a href="#流处理与批处理" class="headerlink" title="流处理与批处理"></a>流处理与批处理</h4><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pllqzkewj219e0q0gnf.jpg" alt="undefined"></p>
<p>看完流处理与批处理这两者的区别之后，我们来抽象一下前面文章的场景需求（<strong>实时计算</strong>）：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plm1lerpj219s0e6759.jpg" alt="undefined"></p>
<p>实时计算需要不断的从 MQ 中读取采集的数据，然后处理计算后往 DB 里存储，在计算这层你无法感知到会有多少数据量过来、要做一些简单的操作（过滤、聚合等）、及时将数据下发。</p>
<p>相比传统的<strong>离线计算</strong>，它却是这样的：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plm92vsuj219m0fudgu.jpg" alt="undefined"></p>
<p>在计算这层，它从 DB（不限 MySQL，还有其他的存储介质）里面读取数据，该数据一般就是固定的（前一天、前一星期、前一个月），然后再做一些复杂的计算或者统计分析，最后生成可供直观查看的报表（dashboard）。</p>
<h4 id="离线计算的特点"><a href="#离线计算的特点" class="headerlink" title="离线计算的特点"></a>离线计算的特点</h4><ol>
<li>数据量大且时间周期长（一天、一星期、一个月、半年、一年）</li>
<li>在大量数据上进行复杂的批量运算</li>
<li>数据在计算之前已经固定，不再会发生变化</li>
<li>能够方便的查询批量计算的结果</li>
</ol>
<h4 id="实时计算的特点"><a href="#实时计算的特点" class="headerlink" title="实时计算的特点"></a>实时计算的特点</h4><p>在大数据中与离线计算对应的则是实时计算，那么实时计算有什么特点呢？由于应用场景的各不相同，所以这两种计算引擎接收数据的方式也不太一样：离线计算的数据是固定的（不再会发生变化），通常离线计算的任务都是定时的，如：每天晚上 0 点的时候定时计算前一天的数据，生成报表；然而实时计算的数据源却是流式的。</p>
<p>这里我不得不讲讲什么是流式数据呢？我的理解是比如你在淘宝上下单了某个商品或者点击浏览了某件商品，你就会发现你的页面立马就会给你推荐这种商品的广告和类似商品的店铺，这种就是属于实时数据处理然后作出相关推荐，这类数据需要不断的从你在网页上的点击动作中获取数据，之后进行实时分析然后给出推荐。</p>
<h4 id="流式数据的特点"><a href="#流式数据的特点" class="headerlink" title="流式数据的特点"></a>流式数据的特点</h4><ol>
<li>数据实时到达</li>
<li>数据到达次序独立，不受应用系统所控制</li>
<li>数据规模大且无法预知容量</li>
<li>原始数据一经处理，除非特意保存，否则不能被再次取出处理，或者再次提取数据代价昂贵</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plmoolb2j219s0ts41e.jpg" alt="undefined"></p>
<h4 id="实时计算的优势"><a href="#实时计算的优势" class="headerlink" title="实时计算的优势"></a>实时计算的优势</h4><p><strong>实时计算一时爽，一直实时计算一直爽</strong>，对于持续生成最新数据的场景，采用流数据处理是非常有利的。例如，再监控服务器的一些运行指标的时候，能根据采集上来的实时数据进行判断，当超出一定阈值的时候发出警报，进行提醒作用。再如通过处理流数据生成简单的报告，如五分钟的窗口聚合数据平均值。复杂的事情还有在流数据中进行数据多维度关联、聚合、塞选，从而找到复杂事件中的根因。更为复杂的是做一些复杂的数据分析操作，如应用机器学习算法，然后根据算法处理后的数据结果提取出有效的信息，作出、给出不一样的推荐内容，让不同的人可以看见不同的网页（千人千面）。</p>
<h3 id="实时计算面临的挑战"><a href="#实时计算面临的挑战" class="headerlink" title="实时计算面临的挑战"></a>实时计算面临的挑战</h3><ol>
<li>数据处理唯一性（如何保证数据只处理一次？至少一次？最多一次？）</li>
<li>数据处理的及时性（采集的实时数据量太大的话可能会导致短时间内处理不过来，如何保证数据能够及时的处理，不出现数据堆积？）</li>
<li>数据处理层和存储层的可扩展性（如何根据采集的实时数据量的大小提供动态扩缩容？）</li>
<li>数据处理层和存储层的容错性（如何保证数据处理层和存储层高可用，出现故障时数据处理层和存储层服务依旧可用？）</li>
</ol>
<p>因为各种需求，也就造就了现在不断出现实时计算框架，在 1.2 节中将重磅介绍如今最火的实时计算框架 —— Flink，在 1.3 节中会对比介绍 Spark Streaming、Structured Streaming 和 Storm 之间的区别。</p>
<h3 id="小结与反思"><a href="#小结与反思" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>本节从实时计算的需求作为切入点，然后分析该如何去完成这种实时计算的需求，从而得知整个过程包括数据采集、数据计算、数据存储等，接着总结了实时计算场景的类型。最后开始介绍离线计算与实时计算的区别，并提出了实时计算可能带来的挑战。你们公司有文中所讲的类似需求吗？你是怎么解决的呢？</p>
<hr>
<h2 id="二、彻底了解大数据实时计算框架-Flink"><a href="#二、彻底了解大数据实时计算框架-Flink" class="headerlink" title="二、彻底了解大数据实时计算框架 Flink"></a>二、彻底了解大数据实时计算框架 Flink</h2><p>在 1.1 节中讲解了日常开发常见的实时需求，然后分析了这些需求的实现方式，接着对比了实时计算和离线计算。随着这些年大数据的飞速发展，也出现了不少计算的框架（Hadoop、Storm、Spark、Flink）。在网上有人将大数据计算引擎的发展分为四个阶段。</p>
<ul>
<li>第一代：Hadoop 承载的 MapReduce</li>
<li>第二代：支持 DAG（有向无环图）框架的计算引擎 Tez 和 Oozie，主要还是批处理任务</li>
<li>第三代：支持 Job 内部的 DAG（有向无环图），以 Spark 为代表</li>
<li>第四代：大数据统一计算引擎，包括流处理、批处理、AI、Machine Learning、图计算等，以 Flink 为代表</li>
</ul>
<p>或许会有人不同意以上的分类，笔者觉得其实这并不重要的，重要的是体会各个框架的差异，以及更适合的场景。并进行理解，没有哪一个框架可以完美的支持所有的场景，也就不可能有任何一个框架能完全取代另一个。</p>
<p>本文将对 Flink 的整体架构和 Flink 的多种特性做个详细的介绍！在讲 Flink 之前的话，我们先来看看<strong>数据集类型</strong>和<strong>数据运算模型</strong>的种类。</p>
<h4 id="数据集类型"><a href="#数据集类型" class="headerlink" title="数据集类型"></a>数据集类型</h4><ul>
<li>无穷数据集：无穷的持续集成的数据集合</li>
<li>有界数据集：有限不会改变的数据集合</li>
</ul>
<p>那么那些常见的无穷数据集有哪些呢？</p>
<ul>
<li>用户与客户端的实时交互数据</li>
<li>应用实时产生的日志</li>
<li>金融市场的实时交易记录</li>
<li>…</li>
</ul>
<h4 id="数据运算模型"><a href="#数据运算模型" class="headerlink" title="数据运算模型"></a>数据运算模型</h4><ul>
<li>流式：只要数据一直在产生，计算就持续地进行</li>
<li>批处理：在预先定义的时间内运行计算，当计算完成时释放计算机资源</li>
</ul>
<p>那么我们再来看看 Flink 它是什么呢？</p>
<h3 id="Flink-是什么？"><a href="#Flink-是什么？" class="headerlink" title="Flink 是什么？"></a>Flink 是什么？</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plr0788dj214a0gy755.jpg" alt="undefined"></p>
<p>Flink 是一个针对流数据和批数据的分布式处理引擎，代码主要是由 Java 实现，部分代码是 Scala。它可以处理有界的批量数据集、也可以处理无界的实时数据集。对 Flink 而言，其所要处理的主要场景就是流数据，批数据只是流数据的一个极限特例而已，所以 Flink 也是一款真正的流批统一的计算引擎。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plr9ox1fj21gt0u0gp2.jpg" alt="undefined"></p>
<p>Flink 提供了 State、Checkpoint、Time、Window 等，它们为 Flink 提供了基石，本篇文章下面会稍作讲解，具体深度分析后面会有专门的文章来讲解。</p>
<h3 id="Flink-整体架构"><a href="#Flink-整体架构" class="headerlink" title="Flink 整体架构"></a>Flink 整体架构</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plrjlud5j20lp0cuabw.jpg" alt="undefined"></p>
<p>从下至上：</p>
<ol>
<li>部署：Flink 支持本地运行（IDE 中直接运行程序）、能在独立集群（Standalone 模式）或者在被 YARN、Mesos、K8s 管理的集群上运行，也能部署在云上。</li>
<li>运行：Flink 的核心是分布式流式数据引擎，意味着数据以一次一个事件的形式被处理。</li>
<li>API：DataStream、DataSet、Table、SQL API。</li>
<li>扩展库：Flink 还包括用于 CEP（复杂事件处理）、机器学习、图形处理等场景。</li>
</ol>
<h3 id="Flink-支持多种方式部署"><a href="#Flink-支持多种方式部署" class="headerlink" title="Flink 支持多种方式部署"></a>Flink 支持多种方式部署</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pls0gqd0j22vw17qn0l.jpg" alt="undefined"></p>
<p>作为一个计算引擎，如果要做的足够完善，除了它自身的各种特点要包含，还得支持各种生态圈，比如部署的情况，Flink 是支持以 Standalone、YARN、Kubernetes、Mesos 等形式部署的。</p>
<ul>
<li>Local：直接在 IDE 中运行 Flink Job 时则会在本地启动一个 mini Flink 集群</li>
<li>Standalone：在 Flink 目录下执行 <code>bin/start-cluster.sh</code> 脚本则会启动一个 Standalone 模式的集群</li>
<li>YARN：YARN 是 Hadoop 集群的资源管理系统，它可以在群集上运行各种分布式应用程序，Flink 可与其他应用并行于 YARN 中，Flink on YARN 的架构如下：</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plt1pm8wj21880kot9g.jpg" alt="undefined"></p>
<ul>
<li>Kubernetes：Kubernetes 是 Google 开源的容器集群管理系统，在 Docker 技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性，Flink 也支持部署在 Kubernetes 上，在 <a href="https://github.com/Aleksandr-Filichkin/flink-k8s/blob/master/flow.jpg" target="_blank" rel="noopener">GitHub</a> 看到有下面这种运行架构的。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pltiz3r3j20ph0lbwfh.jpg" alt="undefined"></p>
<p>通常上面四种居多，另外还支持 AWS、MapR、Aliyun OSS 等。</p>
<h3 id="Flink-分布式运行"><a href="#Flink-分布式运行" class="headerlink" title="Flink 分布式运行"></a>Flink 分布式运行</h3><p>Flink 作业提交架构流程可见下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plu1ecy0j20op0fpad9.jpg" alt="undefined"></p>
<p>1、Program Code：我们编写的 Flink 应用程序代码</p>
<p>2、Job Client：Job Client 不是 Flink 程序执行的内部部分，但它是任务执行的起点。 Job Client 负责接受用户的程序代码，然后创建数据流，将数据流提交给 Job Manager 以便进一步执行。 执行完成后，Job Client 将结果返回给用户</p>
<p>3、Job Manager：主进程（也称为作业管理器）协调和管理程序的执行。 它的主要职责包括安排任务，管理 checkpoint ，故障恢复等。机器集群中至少要有一个 master，master 负责调度 task，协调 checkpoints 和容灾，高可用设置的话可以有多个 master，但要保证一个是 leader, 其他是 standby; Job Manager 包含 Actor system、Scheduler、Check pointing 三个重要的组件</p>
<p>4、Task Manager：从 Job Manager 处接收需要部署的 Task。Task Manager 是在 JVM 中的一个或多个线程中执行任务的工作节点。 任务执行的并行性由每个 Task Manager 上可用的任务槽（Slot 个数）决定。 每个任务代表分配给任务槽的一组资源。 例如，如果 Task Manager 有四个插槽，那么它将为每个插槽分配 25％ 的内存。 可以在任务槽中运行一个或多个线程。 同一插槽中的线程共享相同的 JVM。 同一 JVM 中的任务共享 TCP 连接和心跳消息。Task Manager 的一个 Slot 代表一个可用线程，该线程具有固定的内存，注意 Slot 只对内存隔离，没有对 CPU 隔离。默认情况下，Flink 允许子任务共享 Slot，即使它们是不同 task 的 subtask，只要它们来自相同的 job。这种共享可以有更好的资源利用率。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plud1dkhj218i0iw78b.jpg" alt="undefined"></p>
<p>Flink 提供了不同的抽象级别的 API 以开发流式或批处理应用。</p>
<ul>
<li>最底层提供了有状态流。它将通过 Process Function 嵌入到 DataStream API 中。它允许用户可以自由地处理来自一个或多个流数据的事件，并使用一致性、容错的状态。除此之外，用户可以注册事件时间和处理事件回调，从而使程序可以实现复杂的计算。</li>
<li>DataStream / DataSet API 是 Flink 提供的核心 API ，DataSet 处理有界的数据集，DataStream 处理有界或者无界的数据流。用户可以通过各种方法（map / flatmap / window / keyby / sum / max / min / avg / join 等）将数据进行转换或者计算。</li>
<li>Table API 是以表为中心的声明式 DSL，其中表可能会动态变化（在表达流数据时）。Table API 提供了例如 select、project、join、group-by、aggregate 等操作，使用起来却更加简洁（代码量更少）。 你可以在表与 DataStream/DataSet 之间无缝切换，也允许程序将 Table API 与 DataStream 以及 DataSet 混合使用。</li>
<li>Flink 提供的最高层级的抽象是 SQL 。这一层抽象在语法与表达能力上与 Table API 类似，但是是以 SQL查询表达式的形式表现程序。SQL 抽象与 Table API 交互密切，同时 SQL 查询可以直接在 Table API 定义的表上执行。</li>
</ul>
<p>Flink 除了 DataStream 和 DataSet API，它还支持 Table/SQL API，Flink 也将通过 SQL API 来构建统一的大数据流批处理引擎，因为在公司中通常会有那种每天定时生成报表的需求（批处理的场景，每晚定时跑一遍昨天的数据生成一个结果报表），但是也是会有流处理的场景（比如采用 Flink 来做实时性要求很高的需求），于是慢慢的整个公司的技术选型就变得越来越多了，这样开发人员也就要面临着学习两套不一样的技术框架，运维人员也需要对两种不一样的框架进行环境搭建和作业部署，平时还要维护作业的稳定性。</p>
<p>当我们的系统变得越来越复杂了，作业越来越多了，这对于开发人员和运维来说简直就是噩梦，没准哪天凌晨晚上就被生产环境的告警电话给叫醒。所以 Flink 系统能通过 SQL API 来解决批流统一的痛点，这样不管是开发还是运维，他们只需要关注一个计算框架就行，从而减少企业的用人成本和后期开发运维成本。</p>
<h3 id="Flink-程序与数据流结构"><a href="#Flink-程序与数据流结构" class="headerlink" title="Flink 程序与数据流结构"></a>Flink 程序与数据流结构</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pluob9z7j21a00us11g.jpg" alt="undefined"></p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plutdjgyj21q20h6q3c.jpg" alt="undefined"></p>
<p>一个完整的 Flink 应用程序结构就是如上两图所示：</p>
<p>1、Source：数据输入，Flink 在流处理和批处理上的 source 大概有 4 类：基于本地集合的 source、基于文件的 source、基于网络套接字的 source、自定义的 source。自定义的 source 常见的有 Apache kafka、Amazon Kinesis Streams、RabbitMQ、Twitter Streaming API、Apache NiFi 等，当然你也可以定义自己的 source。</p>
<p>2、Transformation：数据转换的各种操作，有 Map / FlatMap / Filter / KeyBy / Reduce / Fold / Aggregations / Window / WindowAll / Union / Window join / Split / Select / Project 等，操作很多，可以将数据转换计算成你想要的数据。</p>
<p>3、Sink：数据输出，Flink 将转换计算后的数据发送的地点 ，你可能需要存储下来，Flink 常见的 Sink 大概有如下几类：写入文件、打印出来、写入 socket 、自定义的 sink 。自定义的 sink 常见的有 Apache kafka、RabbitMQ、MySQL、ElasticSearch、Apache Cassandra、Hadoop FileSystem 等，同理你也可以定义自己的 sink。</p>
<h3 id="Flink-支持丰富的-Connector"><a href="#Flink-支持丰富的-Connector" class="headerlink" title="Flink 支持丰富的 Connector"></a>Flink 支持丰富的 Connector</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plv10mhgj215218utau.jpg" alt="undefined"></p>
<p>通过源码可以发现不同版本的 Kafka、不同版本的 ElasticSearch、Cassandra、HBase、Hive、HDFS、RabbitMQ 都是支持的，除了流应用的 Connector 是支持的，另外还支持 SQL。</p>
<p>再就是要考虑计算的数据来源和数据最终存储，因为 Flink 在大数据领域的的定位就是实时计算，它不做存储（虽然 Flink 中也有 State 去存储状态数据，这里说的存储类似于 MySQL、ElasticSearch 等存储），所以在计算的时候其实你需要考虑的是数据源来自哪里，计算后的结果又存储到哪里去。庆幸的是 Flink 目前已经支持大部分常用的组件了，比如在 Flink 中已经支持了如下这些 Connector：</p>
<ul>
<li>不同版本的 Kafka</li>
<li>不同版本的 ElasticSearch</li>
<li>Redis</li>
<li>MySQL</li>
<li>Cassandra</li>
<li>RabbitMQ</li>
<li>HBase</li>
<li>HDFS</li>
<li>…</li>
</ul>
<p>这些 Connector 除了支持流作业外，目前还有还有支持 SQL 作业的，除了这些自带的 Connector 外，还可以通过 Flink 提供的接口做自定义 Source 和 Sink（在 3.8 节中）。</p>
<h3 id="Flink-提供事件时间-amp-处理时间语义"><a href="#Flink-提供事件时间-amp-处理时间语义" class="headerlink" title="Flink 提供事件时间&amp;处理时间语义"></a>Flink 提供事件时间&amp;处理时间语义</h3><p>Flink 支持多种 Time，比如 Event time、Ingestion Time、Processing Time，后面的文章 <a href="https://gitbook.cn/gitchat/column/5dad4a20669f843a1a37cb4f/topic/5db69938f6a6211cb96164da" target="_blank" rel="noopener">Flink 中 Processing Time、Event Time、Ingestion Time 对比及其使用场景分析</a> 中会很详细的讲解 Flink 中 Time 的概念。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plwkg73tj21li0u075w.jpg" alt="undefined"></p>
<h3 id="Flink-提供灵活的窗口机制"><a href="#Flink-提供灵活的窗口机制" class="headerlink" title="Flink 提供灵活的窗口机制"></a>Flink 提供灵活的窗口机制</h3><p>Flink 支持多种 Window，比如 Time Window、Count Window、Session Window，还支持自定义 Window。后面的文章 <a href="https://gitbook.cn/gitchat/column/5dad4a20669f843a1a37cb4f/topic/5db69938f6a6211cb96164da" target="_blank" rel="noopener">如何使用 Flink Window 及 Window 基本概念与实现原理</a> 中会很详细的讲解 Flink 中 Window 的概念。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plx9wf35j22kg1bs0uc.jpg" alt="undefined"></p>
<h3 id="Flink-并行的执行任务"><a href="#Flink-并行的执行任务" class="headerlink" title="Flink 并行的执行任务"></a>Flink 并行的执行任务</h3><p>Flink 的程序内在是并行和分布式的，数据流可以被分区成 stream partitions，operators 被划分为 operator subtasks; 这些 subtasks 在不同的机器或容器中分不同的线程独立运行； operator subtasks 的数量在具体的 operator 就是并行计算数，程序不同的 operator 阶段可能有不同的并行数；如下图所示，source operator 的并行数为 2，但最后的 sink operator 为 1：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plxlthw1j20jb0crace.jpg" alt="undefined"></p>
<h3 id="Flink-支持状态存储和容错"><a href="#Flink-支持状态存储和容错" class="headerlink" title="Flink 支持状态存储和容错"></a>Flink 支持状态存储和容错</h3><p>Flink 是一款有状态的流处理框架，它提供了丰富的状态访问接口，按照数据的划分方式，可以分为 Keyed State 和 Operator State，在 Keyed State 中又提供了多种数据结构：</p>
<ul>
<li>ValueState</li>
<li>MapState</li>
<li>ListState</li>
<li>ReducingState</li>
<li>AggregatingState</li>
</ul>
<p>另外状态存储也支持多种方式：</p>
<ul>
<li>MemoryStateBackend：存储在内存中</li>
<li>FsStateBackend：存储在文件中</li>
<li>RocksDBStateBackend：存储在 RocksDB 中</li>
</ul>
<p>Flink 中支持使用 Checkpoint 来提高程序的可靠性，开启了 Checkpoint 之后，Flink 会按照一定的时间间隔对程序的运行状态进行备份，当发生故障时，Flink 会将所有任务的状态恢复至最后一次发生 Checkpoint 中的状态，并从那里开始重新开始执行。</p>
<p>另外 Flink 还支持根据 Savepoint 从已停止作业的运行状态进行恢复，这种方式需要通过命令进行触发。</p>
<h3 id="Flink-实现了自己的内存管理机制"><a href="#Flink-实现了自己的内存管理机制" class="headerlink" title="Flink 实现了自己的内存管理机制"></a>Flink 实现了自己的内存管理机制</h3><p>//todo:深入内存到底要不要在第九章讲？ Flink 在 JVM 中提供了自己的内存管理，使其独立于 Java 的默认垃圾收集器。 它通过使用散列，索引，缓存和排序有效地进行内存管理。我们在后面的文章 <a href="https://gitbook.cn/gitchat/column/5dad4a20669f843a1a37cb4f/topic/5db69938f6a6211cb96164da" target="_blank" rel="noopener">深入探索 Flink 内存管理机制</a> 会深入讲解 Flink 里面的内存管理机制。</p>
<h3 id="Flink-支持多种扩展库"><a href="#Flink-支持多种扩展库" class="headerlink" title="Flink 支持多种扩展库"></a>Flink 支持多种扩展库</h3><p>Flink 扩展库中含有机器学习、Gelly 图形处理、CEP 复杂事件处理、State Processing API 等，关于这块内容可以在第六章查看。</p>
<h3 id="小结与反思-1"><a href="#小结与反思-1" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>本节在开始介绍 Flink 之前先讲解了下数据集类型和数据运算模型，接着开始介绍 Flink 的各种特性，</p>
<hr>
<h2 id="三、大数据框架-Flink、Blink、Spark-Streaming、Structured-Streaming和-Storm-的区别。"><a href="#三、大数据框架-Flink、Blink、Spark-Streaming、Structured-Streaming和-Storm-的区别。" class="headerlink" title="三、大数据框架 Flink、Blink、Spark Streaming、Structured Streaming和 Storm 的区别。"></a>三、大数据框架 Flink、Blink、Spark Streaming、Structured Streaming和 Storm 的区别。</h2><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><p>Flink 是一个针对流数据和批数据分布式处理的引擎，在某些对实时性要求非常高的场景，基本上都是采用 Flink 来作为计算引擎，它不仅可以处理有界的批数据，还可以处理无界的流数据，在 Flink 的设计愿想就是将批处理当成是流处理的一种特例。</p>
<p>在 Flink 的母公司 <a href="https://www.eu-startups.com/2019/01/alibaba-takes-over-berlin-based-streaming-analytics-startup-data-artisans/" target="_blank" rel="noopener">Data Artisans 被阿里收购</a>之后，阿里也在开始逐步将内部的 Blink 代码开源出来并合并在 Flink 主分支上。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8plzy3s4ej215e1g045u.jpg" alt="undefined"></p>
<p>而 Blink 一个很强大的特点就是它的 SQL API 很强大，社区也在 Flink 1.9 版本将 Blink 开源版本大部分代码合进了 Flink 主分支。</p>
<h3 id="Blink"><a href="#Blink" class="headerlink" title="Blink"></a>Blink</h3><p>Blink 是早期阿里在 Flink 的基础上开始修改和完善后在内部创建的分支，然后 Blink 目前在阿里服务于阿里集团内部搜索、推荐、广告、菜鸟物流等大量核心实时业务。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm0elnw7j20mn0d7t9i.jpg" alt="undefined"></p>
<p>Blink 在阿里内部错综复杂的业务场景中锻炼成长着，经历了内部这么多用户的反馈（各种性能、资源使用率、易用性等诸多方面的问题），Blink 都做了针对性的改进。在 Flink Forward China 峰会上，阿里巴巴集团副总裁周靖人宣布 Blink 在 2019 年 1 月正式开源，同时阿里也希望 Blink 开源后能进一步加深与 Flink 社区的联动，</p>
<p>Blink 开源地址：<a href="https://github.com/apache/flink/tree/blink" target="_blank" rel="noopener">https://github.com/apache/flink/tree/blink</a></p>
<p>开源版本 Blink 的主要功能和优化点：</p>
<p>1、Runtime 层引入 Pluggable Shuffle Architecture，开发者可以根据不同的计算模型或者新硬件的需要实现不同的 shuffle 策略进行适配；为了性能优化，Blink 可以让算子更加灵活的 chain 在一起，避免了不必要的数据传输开销；在 BroadCast Shuffle 模式中，Blink 优化掉了大量的不必要的序列化和反序列化开销；Blink 提供了全新的 JM FailOver 机制，JM 发生错误之后，新的 JM 会重新接管整个 JOB 而不是重启 JOB，从而大大减少了 JM FailOver 对 JOB 的影响；Blink 支持运行在 Kubernetes 上。</p>
<p>2、SQL/Table API 架构上的重构和性能的优化是 Blink 开源版本的一个重大贡献。</p>
<p>3、Hive 的兼容性，可以直接用 Flink SQL 去查询 Hive 的数据，Blink 重构了 Flink catalog 的实现，并且增加了两种 catalog，一个是基于内存存储的 FlinkInMemoryCatalog，另外一个是能够桥接 Hive metaStore 的 HiveCatalog。</p>
<p>4、Zeppelin for Flink</p>
<p>5、Flink Web，更美观的 UI 界面，查看日志和监控 Job 都变得更加方便</p>
<p>对于开源那会看到一个对话让笔者感到很震撼：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Blink 开源后，两个开源项目之间的关系会是怎样的？未来 Flink 和 Blink 也会由不同的团队各自维护吗？</span><br><span class="line"></span><br><span class="line">Blink 永远不会成为另外一个项目，如果后续进入 Apache 一定是成为 Flink 的一部分</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm107pqzj217k104jw6.jpg" alt="undefined"></p>
<p>在 Blink 开源那会，笔者就将源码自己编译了一份，然后自己在本地一直运行着，感兴趣的可以看看文章 <a href="http://www.54tianzhisheng.cn/2019/02/28/blink/" target="_blank" rel="noopener">阿里巴巴开源的 Blink 实时计算框架真香</a> ，你会发现 Blink 的 UI 还是比较美观和实用的。</p>
<p>如果你还对 Blink 有什么疑问，可以看看下面两篇文章：</p>
<p><a href="https://www.infoq.cn/article/wZ_b7Hw9polQWp3mTwVh" target="_blank" rel="noopener">阿里重磅开源 Blink：为什么我们等了这么久？</a></p>
<p><a href="https://www.infoq.cn/article/ZkOGAl6_vkZDTk8tfbbg" target="_blank" rel="noopener">重磅！阿里巴巴 Blink 正式开源，重要优化点解读</a></p>
<h3 id="1-3-3-Spark"><a href="#1-3-3-Spark" class="headerlink" title="1.3.3 Spark"></a>1.3.3 Spark</h3><p>Apache Spark 是一种包含流处理能力的下一代批处理框架。与 Hadoop 的 MapReduce 引擎基于各种相同原则开发而来的 Spark 主要侧重于通过完善的内存计算和处理优化机制加快批处理工作负载的运行速度。</p>
<p>Spark 可作为独立集群部署（需要相应存储层的配合），或可与 Hadoop 集成并取代 MapReduce 引擎。</p>
<h3 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm2ghwbrj20sg0g0gmg.jpg" alt="undefined"></p>
<p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html" target="_blank" rel="noopener">Spark Streaming</a> 是 Spark API 核心的扩展，可实现实时数据的快速扩展，高吞吐量，容错处理。数据可以从很多来源（如 Kafka、Flume、Kinesis 等）中提取，并且可以通过很多函数来处理这些数据，处理完后的数据可以直接存入数据库或者 Dashboard 等。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm2mmmyoj20wk0c6js2.jpg" alt="undefined"></p>
<p><strong>Spark Streaming 的内部实现原理</strong>是接收实时输入数据流并将数据分成批处理，然后由 Spark 引擎处理以批量生成最终结果流，也就是常说的 micro-batch 模式。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm2t6k21j20tr06naad.jpg" alt="undefined"></p>
<p>DStreams 是 Spark Streaming 提供的基本的抽象，它代表一个连续的数据流。。它要么是从源中获取的输入流，要么是输入流通过转换算子生成的处理后的数据流。在内部实现上，DStream 由连续的序列化 RDD 来表示，每个 RDD 含有一段时间间隔内的数据：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm30f5cqj20ub06nweq.jpg" alt="undefined"></p>
<p>任何对 DStreams 的操作都转换成了对 DStreams 隐含的 RDD 的操作。例如 flatMap 操作应用于 lines 这个 DStreams 的每个 RDD，生成 words 这个 DStreams 的 RDD 过程如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm3b0i1qj20ub0asmxp.jpg" alt="undefined"></p>
<p>通过 Spark 引擎计算这些隐含 RDD 的转换算子。DStreams 操作隐藏了大部分的细节，并且为了更便捷，为开发者提供了更高层的 API。</p>
<p><strong>Spark 支持的滑动窗口</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm3imkjuj20rm0asdg9.jpg" alt="undefined"></p>
<p>它和 Flink 的滑动窗口类似，支持传入两个参数，一个代表窗口长度，一个代表滑动间隔。</p>
<p><strong>Spark 支持更多的 API</strong></p>
<p>因为 Spark 是使用 Scala 开发的居多，所以从官方文档就可以看得到对 Scala 的 API 支持的很好，而 Flink 源码实现主要以 Java 为主，因此也对 Java API 更友好，从两者目前支持的 API 友好程度，应该是 Spark 更好，它目前也支持 Python API，但是 Flink 新版本也在不断的支持 Python API。</p>
<p><strong>Spark 支持更多的 Machine Learning Lib</strong></p>
<p>你可以很轻松的使用 Spark MLlib 提供的机器学习算法，然后将这些这些机器学习算法模型应用在流数据中，目前 Flink Machine Learning 这块的内容还较少，不过阿里宣称会开源些 Flink Machine Learning 算法，保持和 Spark 目前已有的算法一致，我自己在 GitHub 上看到一个阿里开源的仓库，感兴趣的可以看看 <a href="https://github.com/alibaba/flink-ai-extended" target="_blank" rel="noopener">flink-ai-extended</a>。</p>
<p><strong>Spark Checkpoint</strong></p>
<p>Spark 和 Flink 一样都支持 Checkpoint，但是 Flink 还支持 Savepoint，你可以在停止 Flink 作业的时候使用 Savepoint 将作业的状态保存下来，当作业重启的时候再从 Savepoint 中将停止作业那个时刻的状态恢复起来，保持作业的状态和之前一致。</p>
<p><strong>Spark SQL</strong></p>
<p>Spark 除了 DataFrames 和 Datasets 外，也还有 SQL API，这样你就可以通过 SQL 查询数据，另外 Spark SQL 还可以用于从 Hive 中读取数据。</p>
<p>从 Spark 官网也可以看到很多比较好的特性，这里就不一一介绍了，如果对 Spark 感兴趣的话也可以去<a href="https://spark.apache.org/docs/latest/index.html" target="_blank" rel="noopener">官网</a>了解一下具体的使用方法和实现原理。</p>
<p><strong>Spark Streaming 优缺点</strong></p>
<p>1、优点</p>
<ul>
<li>Spark Streaming 内部的实现和调度方式高度依赖 Spark 的 DAG 调度器和 RDD，这就决定了 Spark Streaming 的设计初衷必须是粗粒度方式的，也就无法做到真正的实时处理</li>
<li>Spark Streaming 的粗粒度执行方式使其确保“处理且仅处理一次”的特性，同时也可以更方便地实现容错恢复机制。</li>
<li>由于 Spark Streaming 的 DStream 本质是 RDD 在流式数据上的抽象，因此基于 RDD 的各种操作也有相应的基于 DStream 的版本，这样就大大降低了用户对于新框架的学习成本，在了解 Spark 的情况下用户将很容易使用 Spark Streaming。</li>
</ul>
<p>2、缺点</p>
<ul>
<li>Spark Streaming 的粗粒度处理方式也造成了不可避免的数据延迟。在细粒度处理方式下，理想情况下每一条记录都会被实时处理，而在 Spark Streaming 中，数据需要汇总到一定的量后再一次性处理，这就增加了数据处理的延迟，这种延迟是由框架的设计引入的，并不是由网络或其他情况造成的。</li>
<li>使用的是 Processing Time 而不是 Event Time</li>
</ul>
<h3 id="Structured-Streaming"><a href="#Structured-Streaming" class="headerlink" title="Structured Streaming"></a>Structured Streaming</h3><p><a href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html" target="_blank" rel="noopener">Structured Streaming</a> 是一种基于 Spark SQL 引擎的可扩展且容错的流处理引擎，它最关键的思想是将实时数据流视为一个不断增加的表，从而就可以像操作批的静态数据一样来操作流数据了。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm3y2va0j214w0m03zf.jpg" alt="undefined"></p>
<p>会对输入的查询生成“结果表”，每个触发间隔（例如，每 1 秒）新行将附加到输入表，最终更新结果表，每当结果表更新时，我们希望能够将更改后的结果写入外部接收器去。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm5gkz7aj21810r9dgp.jpg" alt="undefined"></p>
<p>终于支持事件时间的窗口操作：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pm5nafczj21980n940t.jpg" alt="undefined"></p>
<p>对比你会发现这个 Structured Streaming 怎么和 Flink 这么像，哈哈哈哈，不过这确实是未来的正确之路，两者的功能也会越来越相像的，期待它们出现更加令人兴奋的功能。</p>
<p>如果你对 Structured Streaming 感兴趣的话，可以去<a href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html" target="_blank" rel="noopener">官网</a>做更深一步的了解，顺带附上 <a href="https://cs.stanford.edu/~matei/papers/2018/sigmod_structured_streaming.pdf" target="_blank" rel="noopener">Structured Streaming</a> 的 Paper，同时也附上一位阿里小哥的 PPT —— <a href="https://www.slidestalk.com/s/FromSparkStreamingtoStructuredStreaming58639" target="_blank" rel="noopener">From Spark Streaming to Structured Streaming</a>。</p>
<h3 id="Flink-VS-Spark"><a href="#Flink-VS-Spark" class="headerlink" title="Flink VS Spark"></a>Flink VS Spark</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pn93djtcj20g205umx6.jpg" alt="undefined"></p>
<p>通过上面你应该可以了解到 Flink 对比 Spark Streaming 的微批处理来说是有一定的优势，并且 Flink 还有一些特别的优点，比如灵活的时间语义、多种时间窗口、结合水印处理延迟数据等，但是 Spark 也有自己的一些优势，功能在早期来说是很完善的，并且新版本的 Spark 还添加了 Structured Streaming，它和 Flink 的功能很相近，两个还是值得更深入的对比，期待后面官方的测试对比报告。</p>
<h3 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h3><p>Storm 是一个开源的分布式实时计算系统，可以简单、可靠的处理大量的数据流。Storm 支持水平扩展，具有高容错性，保证每个消息都会得到处理，Strom 本身是无状态的，通过 ZooKeeper 管理分布式集群环境和集群状态。</p>
<h4 id="Storm-核心组件"><a href="#Storm-核心组件" class="headerlink" title="Storm 核心组件"></a>Storm 核心组件</h4><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pn9bggknj21qo0yc407.jpg" alt="undefined"></p>
<p>Nimbus：负责资源分配和任务调度，Nimbus 对任务的分配信息会存储在 Zookeeper 上面的目录下。</p>
<p>Supervisor：负责去 Zookeeper 上的指定目录接受 Nimbus 分配的任务，启动和停止属于自己管理的 Worker 进程。它是当前物理机器上的管理者 —— 通过配置文件设置当前 Supervisor 上启动多少个 Worker。</p>
<p>Worker：运行具体处理组件逻辑的进程，Worker 运行的任务类型只有两种，一种是 Spout 任务，一种是 Bolt 任务。</p>
<p>Task：Worker 中每一个 Spout/Bolt 的线程称为一个 Task. 在 Storm0.8 之后，Task 不再与物理线程对应，不同 Spout/Bolt 的 Task 可能会共享一个物理线程，该线程称为 Executor。</p>
<p>Worker、Task、Executor 三者之间的关系:</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pn9ibun2j21fe0u040j.jpg" alt="undefined"></p>
<h4 id="Storm-核心概念"><a href="#Storm-核心概念" class="headerlink" title="Storm 核心概念"></a>Storm 核心概念</h4><ul>
<li>Nimbus：Storm 集群主节点，负责资源分配和任务调度，任务的提交和停止都是在 Nimbus 上操作的，一个 Storm 集群只有一个 Nimbus 节点。</li>
<li>Supervisor：Storm 集群工作节点，接受 Nimbus 分配任务，管理所有 Worker。</li>
<li>Worker：工作进程，每个工作进程中都有多个 Task。</li>
<li>Executor：产生于 Worker 进程内部的线程，会执行同一个组件的一个或者多个 Task。</li>
<li>Task：任务，每个 Spout 和 Bolt 都是一个任务，每个任务都是一个线程。</li>
<li>Topology：计算拓扑，包含了应用程序的逻辑。</li>
<li>Stream：消息流，关键抽象，是没有边界的 Tuple 序列。</li>
<li>Spout：消息流的源头，Topology 的消息生产者。</li>
<li>Bolt：消息处理单元，可以过滤、聚合、查询数据库。</li>
<li>Tuple：数据单元，数据流中就是一个个 Tuple。</li>
<li>Stream grouping：消息分发策略，一共 6 种，控制 Tuple 的路由，定义 Tuple 在 Topology 中如何流动。</li>
<li>Reliability：可靠性，Storm 保证每个 Tuple 都会被处理。</li>
</ul>
<h4 id="Storm-数据处理流程图"><a href="#Storm-数据处理流程图" class="headerlink" title="Storm 数据处理流程图"></a>Storm 数据处理流程图</h4><p>Storm 处理数据的特点：数据源源不断，不断处理，数据都是 Tuple。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pn9pgxz7j21nm0qwq48.jpg" alt="undefined"></p>
<h3 id="Flink-VS-Storm"><a href="#Flink-VS-Storm" class="headerlink" title="Flink VS Storm"></a>Flink VS Storm</h3><p>可以参考的文章有：</p>
<p><a href="https://tech.meituan.com/2017/11/17/flink-benchmark.html" target="_blank" rel="noopener">流计算框架 Flink 与 Storm 的性能对比</a></p>
<p><a href="https://mp.weixin.qq.com/s/E7pM5XKb_QH225nl0JKFkg" target="_blank" rel="noopener">360 深度实践：Flink 与 Storm 协议级对比</a></p>
<p>两篇文章都从不同场景、不同数据压力下对比 Flink 和 Storm 两个实时计算框架的性能表现，最终结果都表明 Flink 比 Storm 的吞吐量和性能远超 Storm。</p>
<h3 id="全部对比结果"><a href="#全部对比结果" class="headerlink" title="全部对比结果"></a>全部对比结果</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pn9wb7zgj22y81eedne.jpg" alt="undefined"></p>
<p>如果对延迟要求不高的情况下，可以使用 Spark Streaming，它拥有丰富的高级 API，使用简单，并且 Spark 生态也比较成熟，吞吐量大，部署简单，社区活跃度较高，从 GitHub 的 star 数量也可以看得出来现在公司用 Spark 还是居多的，并且在新版本还引入了 Structured Streaming，这也会让 Spark 的体系更加完善。</p>
<p>如果对延迟性要求非常高的话，可以使用当下最火的流处理框架 Flink，采用原生的流处理系统，保证了低延迟性，在 API 和容错性方面做的也比较完善，使用和部署相对来说也是比较简单的，加上国内阿里贡献的 Blink，相信接下来 Flink 的功能将会更加完善，发展也会更加好，社区问题的响应速度也是非常快的，另外还有专门的钉钉大群和中文列表供大家提问，每周还会有专家进行直播讲解和答疑。</p>
<h3 id="小结与反思-2"><a href="#小结与反思-2" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>因在 1.2 节中已经对 Flink 的特性做了很详细的讲解，所以本篇主要介绍其他几种计算框架（Blink、Spark、Spark Streaming、Structured Streaming、Storm），并对比分析了这几种框架的特点与不同。你对这几种计算框架中的哪个最熟悉呢？了解过它们之间的差异吗？你有压测过它们的处理数据的性能吗？</p>
<hr>
<h2 id="四、Flink-环境准备"><a href="#四、Flink-环境准备" class="headerlink" title="四、Flink 环境准备"></a>四、Flink 环境准备</h2><p>通过前面几篇文章，相信你已经对 Flink 的基础概念等知识已经有一定了解，现在是不是迫切的想把 Flink 给用起来？先别急，我们先把电脑的准备环境给安装好，这样后面才能更愉快地玩耍。</p>
<p>废话不多说了，直奔主题。因为后面可能用到的有：Kafka、MySQL、ElasticSearch 等，另外像 Flink 编写程序还需要依赖 Java，还有就是我们项目是用 Maven 来管理依赖的，所以这篇文章我们先来安装下这个几个，准备好本地的环境，后面如果还要安装其他的组件我们到时在新文章中补充，如果你的操作系统已经中已经安装过 JDK、Maven、MySQL、IDEA 等，那么你可以跳过对应的内容，直接看你未安装过的。</p>
<p>这里我再说下我自己电脑的系统环境：macOS High Sierra 10.13.5，后面文章的演示环境不作特别说明的话就是都在这个系统环境中。</p>
<h3 id="JDK-安装与配置"><a href="#JDK-安装与配置" class="headerlink" title="JDK 安装与配置"></a>JDK 安装与配置</h3><p>虽然现在 JDK 已经更新到 12 了，但是为了稳定我们还是安装 JDK 8，如果没有安装过的话，可以去<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">官网</a> 的<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">下载页面</a>下载对应自己操作系统的最新 JDK8 就行。</p>
<p>Mac 系统的是 jdk-8u211-macosx-x64.dmg 格式、Linux 系统的是 jdk-8u211-linux-x64.tar.gz 格式。</p>
<p>Mac 系统安装的话直接双击然后一直按照提示就行了，最后 JDK 的安装目录在 <code>/Library/Java/JavaVirtualMachines/</code> ，然后在 <code>/etc/hosts</code> 中配置好环境变量（注意：替换你自己电脑本地的路径）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>Linux 系统的话就是在某个目录下直接解压就行了，然后在 <code>/etc/profile</code> 添加一下上面的环境变量（注意：替换你自己电脑的路径）。</p>
<p>然后执行 <code>java -version</code> 命令可以查看是否安装成功！</p>
<p> zhisheng@zhisheng ~  java -version<br>java version “1.8.0_152”<br>Java(TM) SE Runtime Environment (build 1.8.0_152-b16)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</p>
<h3 id="Maven-安装与配置"><a href="#Maven-安装与配置" class="headerlink" title="Maven 安装与配置"></a>Maven 安装与配置</h3><p>安装好 JDK 后我们就可以安装 Maven 了，我们在<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">官网</a>下载二进制包就行，然后在自己本地软件安装目录解压压缩包就行。</p>
<p>接下来你需要配置一下环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export M2_HOME=/Users/zhisheng/Documents/maven-3.5.2</span><br><span class="line">export PATH=$PATH:$M2_HOME/bin</span><br></pre></td></tr></table></figure>
<p>然后执行命令 <code>mvn -v</code> 可以验证是否安装成功，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zhisheng@zhisheng ~ /Users  mvn -v</span><br><span class="line">Apache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T15:58:13+08:00)</span><br><span class="line">Maven home: /Users/zhisheng/Documents/maven-3.5.2</span><br><span class="line">Java version: 1.8.0_152, vendor: Oracle Corporation</span><br><span class="line">Java home: /Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;mac os x&quot;, version: &quot;10.13.5&quot;, arch: &quot;x86_64&quot;, family: &quot;mac&quot;</span><br></pre></td></tr></table></figure>
<h3 id="IDE-安装与配置"><a href="#IDE-安装与配置" class="headerlink" title="IDE 安装与配置"></a>IDE 安装与配置</h3><p>安装完 JDK 和 Maven 后，就可以安装 IDE 了，大家可以选择你熟练的 IDE 就行，我后面演示的代码都是在 IDEA 中运行的，如果想为了后面不出其他的 问题的话，建议尽量和我的环境保持一致。</p>
<p>IDEA 官网下载地址：<a href="https://www.jetbrains.com/idea/download/#section=mac" target="_blank" rel="noopener">下载页面的地址</a></p>
<p>下载后可以双击后然后按照提示一步步安装，安装完成后需要在 IDEA 中配置 JDK 路径和 Maven 的路径，后面我们开发也都是靠 Maven 来管理项目的依赖。</p>
<h3 id="MySQL-安装与配置"><a href="#MySQL-安装与配置" class="headerlink" title="MySQL 安装与配置"></a>MySQL 安装与配置</h3><p>因为后面文章有用到 MySQL，所以这里也讲一下如何安装与配置，首先去官网下载 MySQL 5.7，<a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads" target="_blank" rel="noopener">下载页面的地址</a>，根据你们到系统安装对应的版本，Mac 的话双击 dmg 安装包就可以按照提示一步步执行到安装成功。</p>
<p>启动 MySQL，如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pndeozfuj20u0130dll.jpg" alt="undefined"></p>
<p>出现绿色就证明 MySQL 服务启动成功了。后面我们操作数据库不会通过本地命令行来，而是会通过图形化软件，比如：Navicat、Sequel pro，这些图形化软件可比命令行的效率高太多，读者可以自行下载安装一下。</p>
<h3 id="Kafka-安装与配置"><a href="#Kafka-安装与配置" class="headerlink" title="Kafka 安装与配置"></a>Kafka 安装与配置</h3><p>后面我们文章中会大量用到 Kafka，所以 Kakfa 一定要安装好。官网下载地址：<a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener">下载页面的地址</a></p>
<p>同样，我自己下载的版本是 1.1.0 （保持和我公司的生产环境一致），如果你对 Kafka 还不太熟悉，可以参考我以前写的一篇入门文章：<a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a>。</p>
<p>在这篇文章里面教大家怎么安装 Kafka、启动 Zookeeper、启动 Kafka 服务、创建 Topic、使用 producer 创建消息、使用 consumer 消费消息、查看 Topic 的信息，另外还有提供集群配置的方案。</p>
<h3 id="ElasticSearch-安装与配置"><a href="#ElasticSearch-安装与配置" class="headerlink" title="ElasticSearch 安装与配置"></a>ElasticSearch 安装与配置</h3><p>因为后面有文章介绍连接器 (connector) —— Elasticsearch 介绍和整和使用，并且最后面的案例文章也会把数据存储在 Elasticsearch 中的，所以这里就简单的讲解一下 Elasticsearch 的安装，在我以前的博客中写过一篇搭建 Elasticsearch 集群的：<a href="http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/" target="_blank" rel="noopener">Elasticsearch 系列文章（二）：全文搜索引擎 Elasticsearch 集群搭建入门教程</a>。</p>
<p>这里我在本地安装个单机的 Elasticsearch 就行了，首先在官网 <a href="https://www.elastic.co/cn/downloads/past-releases" target="_blank" rel="noopener">下载页面</a> 找到 Elasticsearch 产品，我下载的版本是 elasticsearch-6.3.2 版本，同样和我们公司的线上环境版本保持一致，因为 Flink Elasticsearch connector 有分好几个版本：2.x、5.x、6.x 版本，不同版本到时候写数据存入到 Elasticsearch 的 Job 代码也是有点区别的，如果你们公司的 Elasticsearch 版本比较低的话，到时候后面版本的学习代码还得找官网的资料对比学习一下。</p>
<p>另外就是写这篇文章的时候 Elasticsearch 7.x 就早已经发布了，Flink 我暂时还没看到支持 Elasticsearch 7 的连接器，自己也没测试过，所以暂不清楚如果用 6.x 版本的 connector 去连接 7.x 的 Elasticsearch 会不会出现问题？建议还是跟着我的安装版本来操作！</p>
<p>除了这样下载 Elasticsearch 的话，你如果电脑安装了 Homebrew，也可以通过 Homebrew 来安装 Elasticsearch，都还挺方便的，包括你还可以通过 Docker 的方式快速启动一个 Elasticsearch 来。</p>
<p>下载好了 Elasticsearch 的压缩包，在你的安装目录下解压就行了，然后进入 Elasticsearch 的安装目录执行下面命令就可以启动 Elasticsearch 了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure>
<p>执行命令后的结果：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pne4yctlj24m02d04qp.jpg" alt="undefined"></p>
<p>从浏览器端打开地址：<code>http://localhost:9200/</code> 即可验证是否安装成功：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pnejkllpj20t60qsdhg.jpg" alt="undefined"></p>
<p>如果出现了如上图这样就代表 Elasticsearch 环境已经安装好了。</p>
<h3 id="小结与反思-3"><a href="#小结与反思-3" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>本节讲解了下 JDK、Maven、IDE、MySQL、Kafka、ElasticSearch 的安装与配置，因为这些都是后面要用的，所以这里单独抽一篇文章来讲解环境准备的安装步骤，当然这里还并不涉及全，因为后面我们还可能会涉及到 HBase、HDFS 等知识，后面我们用到再看，我们本系列的文章更多的还是讲解 Flink，所以更多的环境准备还是得靠大家自己独立完成。</p>
<p>这里我说下笔者自己一般安装环境的选择：</p>
<ol>
<li>组件尽量和公司的生产环境保持版本一致，不追求太新，够用就行，这样如果生产出现问题，本机还可以看是否可以复现出来</li>
<li>安装环境的时候先搜下类似的安装教程，提前知道要踩的坑，避免自己再次踩到</li>
</ol>
<p>下面文章我们就正式进入 Flink 专题了！</p>
<h2 id="五、Flink环境搭建"><a href="#五、Flink环境搭建" class="headerlink" title="五、Flink环境搭建"></a>五、Flink环境搭建</h2><p>在 2.1 节中已经将 Flink 的准备环境已经讲完了，本篇文章将带大家正式开始接触 Flink，那么我们得先安装一下 Flink。Flink 是可以在多个平台（Windows、Linux、Mac）上安装的。在开始写本书的时候最新版本是 1.8 版本，但是写到一半后更新到 1.9 了（合并了大量 Blink 的新特性），所以笔者又全部更新版本到 1.9，书籍后面也都是基于最新的版本讲解与演示。</p>
<p>Flink 的官网地址是：<a href="https://flink.apache.org/" target="_blank" rel="noopener">https://flink.apache.org/</a></p>
<h3 id="Flink-下载与安装"><a href="#Flink-下载与安装" class="headerlink" title="Flink 下载与安装"></a>Flink 下载与安装</h3><h4 id="Mac-amp-Linux-安装"><a href="#Mac-amp-Linux-安装" class="headerlink" title="Mac &amp; Linux 安装"></a>Mac &amp; Linux 安装</h4><p>你可以通过该地址 <a href="https://flink.apache.org/downloads.html" target="_blank" rel="noopener">https://flink.apache.org/downloads.html</a> 下载到最新版本的 Flink。</p>
<p>这里我们选择 <code>Apache Flink 1.9.0 for Scala 2.11</code> 版本，点击跳转到了一个镜像下载选择的地址，随便选择哪个就行，只是下载速度不一致而已。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pnl2lqdzj21y417i0wa.jpg" alt="undefined"></p>
<p>下载完后，你就可以直接解压下载的 Flink 压缩包了。</p>
<p>接下来我们可以启动一下 Flink，我们进入到 Flink 的安装目录下执行命令 <code>./bin/start-cluster.sh</code> 即可，产生的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhisheng@zhisheng /usr/local/flink-1.9.0  ./bin/start-cluster.sh</span><br><span class="line">Starting cluster.</span><br><span class="line">Starting standalonesession daemon on host zhisheng.</span><br><span class="line">Starting taskexecutor daemon on host zhisheng.</span><br></pre></td></tr></table></figure>
<p>如果你的电脑是 Mac 的话，那么你也可以通过 Homebrew 命令进行安装。先通过命令 <code>brew search flink</code> 查找一下包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> zhisheng@zhisheng  ~  brew search flink</span><br><span class="line">==&gt; Formulae</span><br><span class="line">apache-flink ✔       homebrew/linuxbrew-core/apache-flink</span><br></pre></td></tr></table></figure>
<p>可以发现找得到 Flink 的安装包，但是这样安装的版本可能不是最新的，如果你要安装的话，则使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install apache-flink</span><br></pre></td></tr></table></figure>
<p>那么它就会开始进行下载并安装好，安装后的目录应该是在 <code>/usr/local/Cellar/apache-flink</code> 下。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pnmiv3uoj21fi106q8b.jpg" alt="undefined"></p>
<p>你可以通过下面命令检查安装的 Flink 到底是什么版本的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flink --version</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Version: 1.9.0, Commit ID: ff472b4</span><br></pre></td></tr></table></figure>
<p>这种的话运行是得进入 <code>/usr/local/Cellar/apache-flink/1.9.0/libexec/bin</code> 目录下执行命令 <code>./start-cluster.sh</code> 才可以启动 Flink 的。</p>
<p>启动后产生的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting cluster.</span><br><span class="line">Starting standalonesession daemon on host zhisheng.</span><br><span class="line">Starting taskexecutor daemon on host zhisheng.</span><br></pre></td></tr></table></figure>
<h4 id="Windows-安装"><a href="#Windows-安装" class="headerlink" title="Windows 安装"></a>Windows 安装</h4><p>如果你的电脑系统是 Windows 的话，那么你就直接双击 Flink 安装目录下面 bin 文件夹里面的 <code>start-cluster.bat</code> 就行，同样可以将 Flink 起动成功。</p>
<h3 id="Flink-启动与运行"><a href="#Flink-启动与运行" class="headerlink" title="Flink 启动与运行"></a>Flink 启动与运行</h3><p>启动成功后的话，我们可以通过访问地址<code>http://localhost:8081/</code> 查看 UI 长啥样了，如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8pnneh4l3j228o1j6myu.jpg" alt="undefined"></p>
<p>你在通过 jps 命令可以查看到运行的进程有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zhisheng@zhisheng  /usr/local/flink-1.9.0  jps</span><br><span class="line">73937 StandaloneSessionClusterEntrypoint</span><br><span class="line">74391 Jps</span><br><span class="line">520</span><br><span class="line">74362 TaskManagerRunner</span><br></pre></td></tr></table></figure>
<h3 id="Flink-目录配置文件解读"><a href="#Flink-目录配置文件解读" class="headerlink" title="Flink 目录配置文件解读"></a>Flink 目录配置文件解读</h3><p>Flink 安装好后，我们也运行启动看了效果了，接下来我们来看下它的目录结构吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> ✘ zhisheng@zhisheng  /usr/local/flink-1.9.0  ll</span><br><span class="line">total 1200</span><br><span class="line">-rw-r--r--@  1 zhisheng  staff    11K  3  5 16:32 LICENSE</span><br><span class="line">-rw-r--r--@  1 zhisheng  staff   582K  4  4 00:01 NOTICE</span><br><span class="line">-rw-r--r--@  1 zhisheng  staff   1.3K  3  5 16:32 README.txt</span><br><span class="line">drwxr-xr-x@ 26 zhisheng  staff   832B  3  5 16:32 bin</span><br><span class="line">drwxr-xr-x@ 14 zhisheng  staff   448B  4  4 14:06 conf</span><br><span class="line">drwxr-xr-x@  6 zhisheng  staff   192B  4  4 14:06 examples</span><br><span class="line">drwxr-xr-x@  5 zhisheng  staff   160B  4  4 14:06 lib</span><br><span class="line">drwxr-xr-x@ 47 zhisheng  staff   1.5K  3  6 23:21 licenses</span><br><span class="line">drwxr-xr-x@  2 zhisheng  staff    64B  3  5 19:50 log</span><br><span class="line">drwxr-xr-x@ 22 zhisheng  staff   704B  4  4 14:06 opt</span><br></pre></td></tr></table></figure>
<p>上面目录：</p>
<ul>
<li><strong>bin</strong> 存放一些启动脚本</li>
<li><strong>conf</strong> 存放配置文件</li>
<li><strong>examples</strong> 存放一些案例的 Job Jar 包</li>
<li><strong>lib</strong> Flink 依赖的 Jar 包</li>
<li><strong>log</strong> 存放产生的日志文件</li>
<li><strong>opt</strong> 存放的是一些可选择的 Jar 包，后面可能会用到</li>
</ul>
<p>在 bin 目录里面有如下这些脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">zhisheng@zhisheng  /usr/local/flink-1.9.0  ll bin</span><br><span class="line">total 256</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff    28K  3  5 16:32 config.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   2.2K  3  5 16:32 flink</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   2.7K  3  5 16:32 flink-console.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   6.2K  3  5 16:32 flink-daemon.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.2K  3  5 16:32 flink.bat</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.5K  3  5 16:32 historyserver.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   2.8K  3  5 16:32 jobmanager.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.8K  3  5 16:32 mesos-appmaster-job.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.8K  3  5 16:32 mesos-appmaster.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.8K  3  5 16:32 mesos-taskmanager.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.2K  3  5 16:32 pyflink-stream.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.1K  3  5 16:32 pyflink.bat</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.1K  3  5 16:32 pyflink.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   3.4K  3  5 16:32 sql-client.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   2.5K  3  5 16:32 standalone-job.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   3.3K  3  5 16:32 start-cluster.bat</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.8K  3  5 16:32 start-cluster.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   3.3K  3  5 16:32 start-scala-shell.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.8K  3  5 16:32 start-zookeeper-quorum.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.6K  3  5 16:32 stop-cluster.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.8K  3  5 16:32 stop-zookeeper-quorum.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   3.8K  3  5 16:32 taskmanager.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   1.6K  3  5 16:32 yarn-session.sh</span><br><span class="line">-rwxr-xr-x@ 1 zhisheng  staff   2.2K  3  5 16:32 zookeeper.sh</span><br></pre></td></tr></table></figure>
<p>脚本包括了配置启动脚本、historyserver、Job Manager、Task Manager、启动集群和停止集群等脚本。</p>
<p>在 conf 目录下面有如下这些配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">zhisheng@zhisheng  /usr/local/flink-1.9.0  ll conf</span><br><span class="line">total 112</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff   9.8K  4  4 00:01 flink-conf.yaml</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff   2.1K  3  5 16:32 log4j-cli.properties</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff   1.8K  3  5 16:32 log4j-console.properties</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff   1.7K  3  5 16:32 log4j-yarn-session.properties</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff   1.9K  3  5 16:32 log4j.properties</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff   2.2K  3  5 16:32 logback-console.xml</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff   1.5K  3  5 16:32 logback-yarn.xml</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff   2.3K  3  5 16:32 logback.xml</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff    15B  3  5 16:32 masters</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff    10B  3  5 16:32 slaves</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff   3.8K  3  5 16:32 sql-client-defaults.yaml</span><br><span class="line">-rw-r--r--@ 1 zhisheng  staff   1.4K  3  5 16:32 zoo.cfg</span><br></pre></td></tr></table></figure>
<p>配置包含了 Flink 的自身配置、日志配置、masters、slaves、sql-client、zoo 等配置。</p>
<p>在 examples 目录里面可以看到有如下这些案例的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhisheng@zhisheng  /usr/local/flink-1.9.0  ll examples</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x@ 10 zhisheng  staff   320B  4  4 14:06 batch</span><br><span class="line">drwxr-xr-x@  3 zhisheng  staff    96B  4  4 14:06 gelly</span><br><span class="line">drwxr-xr-x@  4 zhisheng  staff   128B  4  4 14:06 python</span><br><span class="line">drwxr-xr-x@ 11 zhisheng  staff   352B  4  4 14:06 streaming</span><br></pre></td></tr></table></figure>
<p>这个目录下面有批、gelly、python、流的 demo，后面我们可以直接用上面的案例做些简单的测试。</p>
<p>在 log 目录里面存着 Task Manager &amp; Job manager 的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhisheng@zhisheng  /usr/local/flink-1.9.0  ll log</span><br><span class="line">total 144</span><br><span class="line">-rw-r--r--  1 zhisheng  staff    11K  4 25 20:10 flink-zhisheng-standalonesession-0-zhisheng.log</span><br><span class="line">-rw-r--r--  1 zhisheng  staff     0B  4 25 20:10 flink-zhisheng-standalonesession-0-zhisheng.out</span><br><span class="line">-rw-r--r--  1 zhisheng  staff    11K  4 25 20:10 flink-zhisheng-taskexecutor-0-zhisheng.log</span><br><span class="line">-rw-r--r--  1 zhisheng  staff     0B  4 25 20:10 flink-zhisheng-taskexecutor-0-zhisheng.out</span><br></pre></td></tr></table></figure>
<p>一般我们如果要深入了解一个知识点，最根本的方法就是看其源码实现，源码下面无秘密，所以我这里也讲一下如何将源码下载编译并运行，然后将代码工程导入到 IDEA 中去，方便自己查阅和 debug 代码。</p>
<h3 id="Flink-源码下载"><a href="#Flink-源码下载" class="headerlink" title="Flink 源码下载"></a>Flink 源码下载</h3><p>Flink GitHub 仓库地址：<a href="https://github.com/apache/flink" target="_blank" rel="noopener">https://github.com/apache/flink</a></p>
<p>执行下面命令将源码下载到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:apache/flink.git</span><br></pre></td></tr></table></figure>
<p>拉取的时候找个网络好点的地方，这样速度可能会更快点。</p>
<p>然后你可以切换到项目的不同分支，比如 release-1.9、blink（阿里巴巴开源贡献的） ，执行下面命令将代码切换到 release-1.9 分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout release-1.9</span><br></pre></td></tr></table></figure>
<p>或者你也想去看看 Blink 的代码实现，你也可以执行下面命令切换到 blink 分支来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout blink</span><br></pre></td></tr></table></figure>
<h3 id="Flink-源码编译"><a href="#Flink-源码编译" class="headerlink" title="Flink 源码编译"></a>Flink 源码编译</h3><p>编译源码的话，你需要执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=true -Dmaven.javadoc.skip=true -Dcheckstyle.skip=true</span><br></pre></td></tr></table></figure>
<ul>
<li>-Dmaven.test.skip：跳过测试代码</li>
<li>-Dmaven.javadoc.skip：跳过 javadoc 检查</li>
<li>-Dcheckstyle.skip：跳过代码风格检查</li>
</ul>
<p>maven 编译的时候跳过这些检查，这样可以减少很多时间，还可能会减少错误的发生。</p>
<p>注意：你的 maven 的 settings.xml 文件的 mirror 添加下面这个(这样才能下载到某些下载不了的依赖)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">  &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">  &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots,!mapr-releases&lt;/mirrorOf&gt;</span><br><span class="line">  &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line"></span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">  &lt;id&gt;mapr-public&lt;/id&gt;</span><br><span class="line">  &lt;mirrorOf&gt;mapr-releases&lt;/mirrorOf&gt;</span><br><span class="line">  &lt;name&gt;mapr-releases&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;https://maven.aliyun.com/repository/mapr-public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>
<p>如果还遇到什么其他的问题的话，可以去看看我之前在我博客分享的一篇源码编译的文章（附视频）：<a href="http://www.54tianzhisheng.cn/2019/01/30/Flink-code-compile/" target="_blank" rel="noopener">Flink 源码解析 —— 源码编译运行</a>。</p>
<h3 id="Flink-源码导入到-IDE"><a href="#Flink-源码导入到-IDE" class="headerlink" title="Flink 源码导入到 IDE"></a>Flink 源码导入到 IDE</h3><p>看下图，因为我们已经下载好了源码，直接在 IDEA 里面 open 这个 maven 项目就行了：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0un83lnzj21r20tqk0e.jpg" alt="undefined"></p>
<p>导入后大概就是下面这样子：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0unee0gmj21c00u0dn8.jpg" alt="undefined"></p>
<p>很顺利，没多少报错，这里我已经把一些代码风格检查相关的 Maven 插件给注释掉了。</p>
<h3 id="小结与反思-4"><a href="#小结与反思-4" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>本节主要讲了 FLink 在不同系统下的安装和运行方法，然后讲了下怎么去下载源码和将源码导入到 IDE 中。不知道你在将源码导入到 IDE 中是否有遇到什么问题呢？</p>
<h2 id="六、FlinkWordCount"><a href="#六、FlinkWordCount" class="headerlink" title="六、FlinkWordCount"></a>六、FlinkWordCount</h2><p>在 2.2 中带大家讲解了下 Flink 的环境安装，这篇文章就开始我们的第一个 Flink 案例实战，也方便大家快速开始自己的第一个 Flink 应用。大数据里学习一门技术一般都是从 WordCount 开始入门的，那么我还是不打破常规了，所以这篇文章我也将带大家通过 WordCount 程序来初步了解 Flink。</p>
<h3 id="Maven-创建项目"><a href="#Maven-创建项目" class="headerlink" title="Maven 创建项目"></a>Maven 创建项目</h3><p>Flink 支持 Maven 直接构建模版项目，你在终端使用该命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate                               \</span><br><span class="line">      -DarchetypeGroupId=org.apache.flink              \</span><br><span class="line">      -DarchetypeArtifactId=flink-quickstart-java      \</span><br><span class="line">      -DarchetypeVersion=1.9.0</span><br></pre></td></tr></table></figure>
<p>在执行的过程中它会提示你输入 groupId、artifactId、和 package 名，你按照要求输入就行，最后就可以成功创建一个项目。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uocicqoj21xw1aatf4.jpg" alt="undefined"></p>
<p>进入到目录你就可以看到已经创建了项目，里面结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> zhisheng@zhisheng  ~/IdeaProjects/github/Flink-WordCount  tree</span><br><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── zhisheng</span><br><span class="line">        │           ├── BatchJob.java</span><br><span class="line">        │           └── StreamingJob.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── log4j.properties</span><br><span class="line"></span><br><span class="line">6 directories, 4 files</span><br></pre></td></tr></table></figure>
<p>该项目中包含了两个类 BatchJob 和 StreamingJob，另外还有一个 log4j.properties 配置文件，然后你就可以将该项目导入到 IDEA 了。</p>
<p>你可以在该目录下执行 <code>mvn clean package</code> 就可以编译该项目，编译成功后在 target 目录下会生成一个 Job 的 Jar 包，但是这个 Job 还不能执行，因为 StreamingJob 这个类中的 main 方法里面只是简单的创建了 StreamExecutionEnvironment 环境，然后就执行 execute 方法，这在 Flink 中是不算一个可执行的 Job 的，因此如果你提交到 Flink UI 上也是会报错的。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uokn3kbj227w0pawfm.jpg" alt="undefined"></p>
<p>运行报错：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uosbkccj22640mq3zx.jpg" alt="undefined"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server Response Message:</span><br><span class="line">Internal server error.</span><br></pre></td></tr></table></figure>
<p>我们查看 Flink Job Manager 的日志可以看到：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uoz4xbmj226w12e0zj.jpg" alt="undefined"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-04-26 17:27:33,706 ERROR org.apache.flink.runtime.webmonitor.handlers.JarRunHandler    - Unhandled exception.</span><br><span class="line">org.apache.flink.client.program.ProgramInvocationException: The main method caused an error: No operators defined in streaming topology. Cannot execute.</span><br></pre></td></tr></table></figure>
<p>因为 execute 方法之前我们是需要补充我们 Job 的一些算子操作的，所以报错还是很正常的，本文下面将会提供完整代码。</p>
<h3 id="IDEA-创建项目"><a href="#IDEA-创建项目" class="headerlink" title="IDEA 创建项目"></a>IDEA 创建项目</h3><p>一般我们项目可能是由多个 Job 组成，并且代码也都是在同一个工程下面进行管理，上面那种适合单个 Job 执行，但如果多人合作的时候还是得在同一个工程下面进行项目的创建，每个 Flink Job 一个 module，下面我们将来讲解下如何利用 IDEA 创建 Flink 项目。</p>
<p>我们利用 IDEA 创建 Maven 项目，工程如下图这样，项目下面分很多模块，每个模块负责不同的业务</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0up8brt7j20p20k0dg6.jpg" alt="undefined"></p>
<p>接下来我们需要在父工程的 pom.xml 中加入如下属性（含编码、Flink 版本、JDK 版本、Scala 版本、Maven 编译版本）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Flink 版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--JDK 版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Scala 2.11 版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scala.binary.version</span>&gt;</span>2.11<span class="tag">&lt;/<span class="name">scala.binary.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后加入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Apache Flink dependencies --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- These dependencies are provided, because they should not be packaged into the JAR file. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Add logging framework, to produce console output when running in the IDE. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- These dependencies are excluded from the application JAR by default. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面依赖中 flink-java 和 flink-streaming-java 是我们 Flink 必备的核心依赖，为什么设置 scope 为 provided 呢（默认是 compile）？</p>
<p>是因为 Flink 其实在自己的安装目录中 lib 文件夹里的 <code>lib/flink-dist_2.11-1.9.0.jar</code> 已经包含了这些必备的 Jar 了，所以我们在给自己的 Flink Job 添加依赖的时候最后打成的 Jar 包可不希望又将这些重复的依赖打进去。有两个好处：</p>
<ul>
<li>减小了我们打的 Flink Job Jar 包容量大小</li>
<li>不会因为打入不同版本的 Flink 核心依赖而导致类加载冲突等问题</li>
</ul>
<p>但是问题又来了，我们需要在 IDEA 中调试运行我们的 Job，如果将 scope 设置为 provided 的话，是会报错的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/flink/api/common/ExecutionConfig$GlobalJobParameters</span><br><span class="line">    at java.lang.Class.getDeclaredMethods0(Native Method)</span><br><span class="line">    at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)</span><br><span class="line">    at java.lang.Class.privateGetMethodRecursive(Class.java:3048)</span><br><span class="line">    at java.lang.Class.getMethod0(Class.java:3018)</span><br><span class="line">    at java.lang.Class.getMethod(Class.java:1784)</span><br><span class="line">    at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)</span><br><span class="line">    at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.apache.flink.api.common.ExecutionConfig$GlobalJobParameters</span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">    ... 7 more</span><br></pre></td></tr></table></figure>
<p>默认 scope 为 compile 的话，本地调试的话就不会出错了。</p>
<p>另外测试到底能够减小多少 Jar 包的大小呢？我这里先写了个 Job 测试。</p>
<p>当 scope 为 compile 时，编译后的 target 目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zhisheng@zhisheng  ~/Flink-WordCount/target   master ●✚  ll</span><br><span class="line">total 94384</span><br><span class="line">-rw-r--r--  1 zhisheng  staff    45M  4 26 21:23 Flink-WordCount-1.0-SNAPSHOT.jar</span><br><span class="line">drwxr-xr-x  4 zhisheng  staff   128B  4 26 21:23 classes</span><br><span class="line">drwxr-xr-x  3 zhisheng  staff    96B  4 26 21:23 generated-sources</span><br><span class="line">drwxr-xr-x  3 zhisheng  staff    96B  4 26 21:23 maven-archiver</span><br><span class="line">drwxr-xr-x  3 zhisheng  staff    96B  4 26 21:23 maven-status</span><br><span class="line">-rw-r--r--  1 zhisheng  staff   7.2K  4 26 21:23 original-Flink-WordCount-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>当 scope 为 provided 时，编译后的 target 目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zhisheng@zhisheng ~/Flink-WordCount/target   master ●✚  ll</span><br><span class="line">total 32</span><br><span class="line">-rw-r--r--  1 zhisheng  staff   7.5K  4 26 21:27 Flink-WordCount-1.0-SNAPSHOT.jar</span><br><span class="line">drwxr-xr-x  4 zhisheng  staff   128B  4 26 21:27 classes</span><br><span class="line">drwxr-xr-x  3 zhisheng  staff    96B  4 26 21:27 generated-sources</span><br><span class="line">drwxr-xr-x  3 zhisheng  staff    96B  4 26 21:27 maven-archiver</span><br><span class="line">drwxr-xr-x  3 zhisheng  staff    96B  4 26 21:27 maven-status</span><br><span class="line">-rw-r--r--  1 zhisheng  staff   7.2K  4 26 21:27 original-Flink-WordCount-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>可以发现：当 scope 为 provided 时 Jar 包才 7.5k，而为 compile 时 Jar 包就 45M 了，你要想想这才只是一个简单的 WordCount 程序呢，差别就这么大。当我们把 Flink Job 打成一个 fat Jar 时，上传到 UI 的时间就能够很明显的对比出来（Jar 包越小上传的时间越短），所以把 scope 设置为 provided 还是很有必要的。</p>
<p>有人就会想了，那这不是和上面有冲突了吗？假如我既想打出来的 Jar 包要小，又想能够在本地 IDEA 中进行运行和调试 Job ？这里我提供一种方法：在父工程中的 pom.xml 引入如下 profiles。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>add-dependencies-for-IDEA<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>idea.version<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当你在 IDEA 中运行 Job 的时候，它会给你引入 flink-java、flink-streaming-java，且 scope 设置为 compile，但是你是打成 Jar 包的时候它又不起作用。如果你加了这个 profile 还是报错的话，那么可能是 IDEA 中没有识别到，你可以在 IDEA 的中查看下面两个配置确定一下（配置其中一个即可以起作用）。</p>
<p>1、查看 Maven 中的该 profile 是否已经默认勾选上了，如果没有勾选上，则手动勾选一下才会起作用</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0upjwdhnj20yw080q2z.jpg" alt="undefined"></p>
<p>2、Include dependencies with “Provided” scope 是否勾选，如果未勾选，则手动勾选后才起作用</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0upq3ibrj21n8188dia.jpg" alt="undefined"></p>
<h3 id="流计算-WordCount-应用程序代码"><a href="#流计算-WordCount-应用程序代码" class="headerlink" title="流计算 WordCount 应用程序代码"></a>流计算 WordCount 应用程序代码</h3><p>回到正题，利用 IDEA 创建好 WordCount 应用后，我们开始编写代码。</p>
<p><strong>Main 类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建流运行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.getConfig().setGlobalJobParameters(ParameterTool.fromArgs(args));</span><br><span class="line">        env.fromElements(WORDS)</span><br><span class="line">                .flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        String[] splits = value.toLowerCase().split(<span class="string">"\\W+"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (String split : splits) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (split.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(split, <span class="number">1</span>));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Integer&gt; value1, Tuple2&lt;String, Integer&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(value1.f0, value1.f1 + value1.f1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .print();</span><br><span class="line">        <span class="comment">//Streaming 程序必须加这个才能启动程序，否则不会有结果</span></span><br><span class="line">        env.execute(<span class="string">"zhisheng —— word count streaming demo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] WORDS = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">            <span class="string">"To be, or not to be,--that is the question:--"</span>,</span><br><span class="line">            <span class="string">"Whether 'tis nobler in the mind to suffer"</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pom.xml</strong> 文件中引入 build 插件并且要替换成你自己项目里面的 mainClass：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Java Compiler --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 使用 maven-shade 插件创建一个包含所有必要的依赖项的 fat Jar --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.apache.flink:force-shading<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>com.google.code.findbugs:jsr305<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.slf4j:*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>log4j:*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.SF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.DSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.RSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--注意：这里一定要换成你自己的 Job main 方法的启动类--&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.zhisheng.wordcount.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：上面这个 build 插件要记得加，否则打出来的 jar 包是不完整的，提交运行会报 ClassNotFoundException，该问题是初学者很容易遇到的问题，很多人咨询过笔者这个问题。</p>
<h3 id="WordCount-应用程序运行"><a href="#WordCount-应用程序运行" class="headerlink" title="WordCount 应用程序运行"></a>WordCount 应用程序运行</h3><h4 id="本地-IDE-运行"><a href="#本地-IDE-运行" class="headerlink" title="本地 IDE 运行"></a>本地 IDE 运行</h4><p>编译好 WordCount 程序后，我们在 IDEA 中右键 run main 方法就可以把 Job 运行起来，结果如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uq05u0wj21pc0vy74y.jpg" alt="undefined"></p>
<p>图中的就是将每个 word 和对应的个数一行一行打印出来，在本地 IDEA 中运行没有问题，我们接下来使用命令 <code>mvn clean package</code> 打包成一个 Jar (flink-learning-examples-1.0-SNAPSHOT.jar) 然后将其上传到 Flink UI 上运行一下看下效果。</p>
<h4 id="UI-运行-Job"><a href="#UI-运行-Job" class="headerlink" title="UI 运行 Job"></a>UI 运行 Job</h4><p>在 <code>http://localhost:8081/#/submit</code> 页面上传 flink-learning-examples-1.0-SNAPSHOT.jar 后，然后点击 Submit 后就可以运行了。</p>
<p>运行 Job 的 UI 如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uq6lppkj226o1awdhc.jpg" alt="undefined"></p>
<p>Job 的结果在 Task Manager 的 Stdout 中：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uqcmgspj224u1ewq50.jpg" alt="undefined"></p>
<h3 id="WordCount-应用程序代码分析"><a href="#WordCount-应用程序代码分析" class="headerlink" title="WordCount 应用程序代码分析"></a>WordCount 应用程序代码分析</h3><p>我们已经将 WordCount 程序代码写好了并且也在 IDEA 中和 Flink UI 上运行了 Job，并且程序运行的结果都是正常的。</p>
<p>那么我们来分析一下这个 WordCount 程序代码：</p>
<p>1、创建好 StreamExecutionEnvironment（流程序的运行环境）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br></pre></td></tr></table></figure>
<p>2、给流程序的运行环境设置全局的配置（从参数 args 获取）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.getConfig().setGlobalJobParameters(ParameterTool.fromArgs(args));</span><br></pre></td></tr></table></figure>
<p>3、构建数据源，WORDS 是个字符串数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.fromElements(WORDS)</span><br></pre></td></tr></table></figure>
<p>4、将字符串进行分隔然后收集，组装后的数据格式是 (word、1)，1 代表 word 出现的次数为 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] splits = value.toLowerCase().split(<span class="string">"\\W+"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String split : splits) &#123;</span><br><span class="line">            <span class="keyword">if</span> (split.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(split, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>5、根据 word 关键字进行分组（0 代表对第一个字段分组，也就是对 word 进行分组）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyBy(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>6、对单个 word 进行计数操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Integer&gt; value1, Tuple2&lt;String, Integer&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(value1.f0, value1.f1 + value2.f1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>7、打印所有的数据流，格式是 (word，count)，count 代表 word 出现的次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print()</span><br></pre></td></tr></table></figure>
<p>8、开始执行 Job</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.execute(<span class="string">"zhisheng —— word count streaming demo"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="小结与反思-5"><a href="#小结与反思-5" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>本节给大家介绍了 Maven 创建 Flink Job、IDEA 中创建 Flink 项目（详细描述了里面要注意的事情）、编写 WordCount 程序、IDEA 运行程序、在 Flink UI 运行程序、对 WordCount 程序每个步骤进行分析。</p>
<p>通过本小节，你接触了第一个 Flink 应用程序，也开启了 Flink 实战之旅。你有自己运行本节的代码去测试吗？动手测试的过程中有遇到什么问题吗？</p>
<p>本节涉及的代码地址：<a href="https://github.com/zhisheng17/flink-learning/tree/master/flink-learning-examples/src/main/java/com/zhisheng/examples/streaming/wordcount" target="_blank" rel="noopener">https://github.com/zhisheng17/flink-learning/tree/master/flink-learning-examples/src/main/java/com/zhisheng/examples/streaming/wordcount</a></p>
<h2 id="七、Flink-实时处理-Socket-数据"><a href="#七、Flink-实时处理-Socket-数据" class="headerlink" title="七、Flink 实时处理 Socket 数据"></a>七、Flink 实时处理 Socket 数据</h2><p>在 2.3 中讲解了 Flink 最简单的 WordCount 程序的创建、运行结果查看和代码分析，这篇文章继续带大家来看一个入门上手的程序：Flink 处理 Socket 数据。</p>
<h3 id="IDEA-创建项目-1"><a href="#IDEA-创建项目-1" class="headerlink" title="IDEA 创建项目"></a>IDEA 创建项目</h3><p>使用 IDEA 创建新的 module，结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com</span><br><span class="line">    │   │       └── zhisheng</span><br><span class="line">    │   │           └── socket</span><br><span class="line">    │   │               └── Main.java</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       └── log4j.properties</span><br><span class="line">    └── test</span><br><span class="line">        └── java</span><br></pre></td></tr></table></figure>
<p>项目创建好了后，我们下一步开始编写 Flink Socket Job 的代码。</p>
<h3 id="Flink-Socket-应用程序代码"><a href="#Flink-Socket-应用程序代码" class="headerlink" title="Flink Socket 应用程序代码"></a>Flink Socket 应用程序代码</h3><p><strong>Main 类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//参数检查</span></span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"USAGE:\nSocketTextStreamWordCount &lt;hostname&gt; &lt;port&gt;"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String hostname = args[<span class="number">0</span>];</span><br><span class="line">        Integer port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; stream = env.socketTextStream(hostname, port);</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; sum = stream.flatMap(<span class="keyword">new</span> LineSplitter())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line">        sum.print();</span><br><span class="line">        env.execute(<span class="string">"Java WordCount from SocketText"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LineSplitter</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector)</span> </span>&#123;</span><br><span class="line">            String[] tokens = s.toLowerCase().split(<span class="string">"\\W+"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String token: tokens) &#123;</span><br><span class="line">                <span class="keyword">if</span> (token.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    collector.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(token, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pom.xml</strong> 添加 build：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.apache.flink:force-shading<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>com.google.code.findbugs:jsr305<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.slf4j:*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>log4j:*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.SF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.DSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.RSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--注意：这里一定要换成你自己的 Job main 方法的启动类--&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.zhisheng.socket.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Flink-Socket-应用程序运行"><a href="#Flink-Socket-应用程序运行" class="headerlink" title="Flink Socket 应用程序运行"></a>Flink Socket 应用程序运行</h3><h4 id="本地-IDE-运行-1"><a href="#本地-IDE-运行-1" class="headerlink" title="本地 IDE 运行"></a>本地 IDE 运行</h4><p>我们先在终端开启监听 9000 端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 9000</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0ur4cqi4j21b60aeq36.jpg" alt="undefined"></p>
<p>然后右键运行 Main 类的 main 方法 (注意：需要传入运行参数 <code>127.0.0.1 9000</code>)：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0urc5j0wj21ni14egno.jpg" alt="undefined"></p>
<p>运行结果如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0urirdxgj21s20legma.jpg" alt="undefined"></p>
<p>我在终端一个个输入下面的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">zhisheng</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">zhisheng</span><br><span class="line">zhisheng</span><br><span class="line">This is zhisheng‘s book</span><br></pre></td></tr></table></figure>
<p>然后在 IDEA 的运行结果会一个个输出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2&gt; (hello,1)</span><br><span class="line">2&gt; (zhisheng,1)</span><br><span class="line">2&gt; (hello,2)</span><br><span class="line">2&gt; (hello,3)</span><br><span class="line">2&gt; (zhisheng,2)</span><br><span class="line">2&gt; (zhisheng,3)</span><br><span class="line">3&gt; (s,1)</span><br><span class="line">1&gt; (this,1)</span><br><span class="line">4&gt; (is,1)</span><br><span class="line">2&gt; (zhisheng,4)</span><br><span class="line">3&gt; (book,1)</span><br></pre></td></tr></table></figure>
<p>在本地 IDEA 中运行没有问题，我们接下来使用命令 <code>mvn clean package</code> 打包成一个 Jar (flink-learning-examples-1.0-SNAPSHOT.jar) 然后将其上传到 Flink UI 上运行一下看下效果。</p>
<h4 id="UI-运行-Job-1"><a href="#UI-运行-Job-1" class="headerlink" title="UI 运行 Job"></a>UI 运行 Job</h4><p>依旧和上面那样开启监听本地端口 9200，然后在 <code>http://localhost:8081/#/submit</code> 页面上传 flink-learning-examples-1.0-SNAPSHOT.jar 后，接着在 Main Class 填写运行的主函数，Program Arguments 填写参数 <code>127.0.0.1 9000</code>，最后点击 Submit 后就可以运行了。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0urqumhzj22760mqgmr.jpg" alt="undefined"></p>
<p>UI 的运行详情如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0ury0iq8j225w1au3zz.jpg" alt="undefined"></p>
<p>我在终端一个个输入下面的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">zhisheng@zhisheng  ~  nc -l 9000</span><br><span class="line">zhisheng</span><br><span class="line">zhisheng&apos;s Book</span><br><span class="line">This is zhisheng&apos;s Book</span><br><span class="line">zhisheng</span><br><span class="line">This is zhisheng&apos;s Book</span><br><span class="line">This is zhisheng&apos;s Book</span><br><span class="line">This is zhisheng&apos;s Book</span><br><span class="line">This is zhisheng&apos;s Book</span><br><span class="line">This is zhisheng&apos;s Book</span><br><span class="line">This is zhisheng&apos;s Book</span><br><span class="line">zhisheng</span><br></pre></td></tr></table></figure>
<p>查看 Task Manager 的 Stdout 可以查看到输出：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0us5qqsej227819wgnp.jpg" alt="undefined"></p>
<h3 id="Flink-Socket-应用程序代码分析"><a href="#Flink-Socket-应用程序代码分析" class="headerlink" title="Flink Socket 应用程序代码分析"></a>Flink Socket 应用程序代码分析</h3><p>1、参数检查，需要传入两个参数（hostname 和 port），符合条件就赋值给 hostname 和 port</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">    System.err.println(<span class="string">"USAGE:\nSocketTextStreamWordCount &lt;hostname&gt; &lt;port&gt;"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String hostname = args[<span class="number">0</span>];</span><br><span class="line">Integer port = Integer.parseInt(args[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>2、创建好 StreamExecutionEnvironment（流程序的运行环境）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br></pre></td></tr></table></figure>
<p>3、构建数据源，获取 Socket 数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStreamSource&lt;String&gt; stream = env.socketTextStream(hostname, port);</span><br></pre></td></tr></table></figure>
<p>4、对 Socket 数据字符串分隔后收集在根据 word 分组后计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; sum = stream.flatMap(<span class="keyword">new</span> LineSplitter())</span><br><span class="line">        .keyBy(<span class="number">0</span>)</span><br><span class="line">        .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串进行分隔然后收集，组装后的数据格式是 (word、1)，1 代表 word 出现的次数为 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LineSplitter</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector)</span> </span>&#123;</span><br><span class="line">        String[] tokens = s.toLowerCase().split(<span class="string">"\\W+"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String token: tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (token.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                collector.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(token, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、打印所有的数据流，格式是 (word，count)，count 代表 word 出现的次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum.print();</span><br></pre></td></tr></table></figure>
<p>6、开始执行 Job</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.execute(<span class="string">"Java WordCount from SocketText"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Flink-中使用-Lambda-表达式"><a href="#Flink-中使用-Lambda-表达式" class="headerlink" title="Flink 中使用 Lambda 表达式"></a>Flink 中使用 Lambda 表达式</h3><p>因为 Lambda 表达式看起来简洁，所以有时候也是希望在这些 Flink 作业中也可以使用上它，虽然 Flink 中是支持 Lambda，但是个人感觉不太友好。比如上面的应用程序如果将 LineSplitter 该类之间用 Lambda 表达式完成的话则要像下面这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stream.flatMap((s, collector) -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (String token : s.toLowerCase().split(<span class="string">"\\W+"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (token.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            collector.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(token, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        .keyBy(<span class="number">0</span>)</span><br><span class="line">        .sum(<span class="number">1</span>)</span><br><span class="line">        .print();</span><br></pre></td></tr></table></figure>
<p>但是这样写完后，运行作业报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; org.apache.flink.api.common.functions.InvalidTypesException: The return type of function &apos;main(LambdaMain.java:34)&apos; could not be determined automatically, due to type erasure. You can give type information hints by using the returns(...) method on the result of the transformation call, or by letting your function implement the &apos;ResultTypeQueryable&apos; interface.</span><br><span class="line">    at org.apache.flink.api.dag.Transformation.getOutputType(Transformation.java:417)</span><br><span class="line">    at org.apache.flink.streaming.api.datastream.DataStream.getType(DataStream.java:175)</span><br><span class="line">    at org.apache.flink.streaming.api.datastream.DataStream.keyBy(DataStream.java:318)</span><br><span class="line">    at com.zhisheng.examples.streaming.socket.LambdaMain.main(LambdaMain.java:41)</span><br><span class="line">Caused by: org.apache.flink.api.common.functions.InvalidTypesException: The generic type parameters of &apos;Collector&apos; are missing. In many cases lambda methods don&apos;t provide enough information for automatic type extraction when Java generics are involved. An easy workaround is to use an (anonymous) class instead that implements the &apos;org.apache.flink.api.common.functions.FlatMapFunction&apos; interface. Otherwise the type has to be specified explicitly using type information.</span><br><span class="line">    at org.apache.flink.api.java.typeutils.TypeExtractionUtils.validateLambdaType(TypeExtractionUtils.java:350)</span><br><span class="line">    at org.apache.flink.api.java.typeutils.TypeExtractionUtils.extractTypeFromLambda(TypeExtractionUtils.java:176)</span><br><span class="line">    at org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(TypeExtractor.java:571)</span><br><span class="line">    at org.apache.flink.api.java.typeutils.TypeExtractor.getFlatMapReturnTypes(TypeExtractor.java:196)</span><br><span class="line">    at org.apache.flink.streaming.api.datastream.DataStream.flatMap(DataStream.java:611)</span><br><span class="line">    at com.zhisheng.examples.streaming.socket.LambdaMain.main(LambdaMain.java:34)</span><br></pre></td></tr></table></figure>
<p>根据上面的报错信息其实可以知道要怎么解决了，该错误是因为 Flink 在用户自定义的函数中会使用泛型来创建 serializer，当使用匿名函数时，类型信息会被保留。但 Lambda 表达式并不是匿名函数，所以 javac 编译的时候并不会把泛型保存到 class 文件里。</p>
<p>解决方法：使用 Flink 提供的 returns 方法来指定 flatMap 的返回类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 TupleTypeInfo 来指定 Tuple 的参数类型</span></span><br><span class="line">.returns((TypeInformation) TupleTypeInfo.getBasicTupleTypeInfo(String.class, Integer.class))</span><br></pre></td></tr></table></figure>
<p>在 flatMap 后面加上上面这个 returns 就行了，但是如果算子多了的话，每个都去加一个 returns，其实会很痛苦的，所以通常使用匿名函数或者自定义函数居多。</p>
<h3 id="小结与反思-6"><a href="#小结与反思-6" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>本节讲了 Flink 的第二个应用程序 —— 读取 Socket 数据，希望通过两个简单的程序可以让你对 Flink 有个简单的认识，然后讲解了下 Flink 应用程序中使用 Lambda 表达式的问题。</p>
<p>本节涉及的代码地址：<a href="https://github.com/zhisheng17/flink-learning/tree/master/flink-learning-examples/src/main/java/com/zhisheng/examples/streaming/socket" target="_blank" rel="noopener">https://github.com/zhisheng17/flink-learning/tree/master/flink-learning-examples/src/main/java/com/zhisheng/examples/streaming/socket</a></p>
<h2 id="八、Flink多种时间语义对比"><a href="#八、Flink多种时间语义对比" class="headerlink" title="八、Flink多种时间语义对比"></a>八、Flink多种时间语义对比</h2><p>Flink 在流应用程序中支持不同的 <strong>Time</strong> 概念，就比如有 Processing Time、Event Time 和 Ingestion Time。下面我们一起来看看这三个 Time。</p>
<h3 id="Processing-Time"><a href="#Processing-Time" class="headerlink" title="Processing Time"></a>Processing Time</h3><p>Processing Time 是指事件被处理时机器的系统时间。</p>
<p>如果我们 Flink Job 设置的时间策略是 Processing Time 的话，那么后面所有基于时间的操作（如时间窗口）都将会使用当时机器的系统时间。每小时 Processing Time 窗口将包括在系统时钟指示整个小时之间到达特定操作的所有事件。</p>
<p>例如，如果应用程序在上午 9:15 开始运行，则第一个每小时 Processing Time 窗口将包括在上午 9:15 到上午 10:00 之间处理的事件，下一个窗口将包括在上午 10:00 到 11:00 之间处理的事件。</p>
<p>Processing Time 是最简单的 “Time” 概念，不需要流和机器之间的协调，它提供了最好的性能和最低的延迟。但是，在分布式和异步的环境下，Processing Time 不能提供确定性，因为它容易受到事件到达系统的速度（例如从消息队列）、事件在系统内操作流动的速度以及中断的影响。</p>
<h3 id="Event-Time"><a href="#Event-Time" class="headerlink" title="Event Time"></a>Event Time</h3><p>Event Time 是指事件发生的时间，一般就是数据本身携带的时间。这个时间通常是在事件到达 Flink 之前就确定的，并且可以从每个事件中获取到事件时间戳。在 Event Time 中，时间取决于数据，而跟其他没什么关系。Event Time 程序必须指定如何生成 Event Time 水印，这是表示 Event Time 进度的机制。</p>
<p>完美的说，无论事件什么时候到达或者其怎么排序，最后处理 Event Time 将产生完全一致和确定的结果。但是，除非事件按照已知顺序（事件产生的时间顺序）到达，否则处理 Event Time 时将会因为要等待一些无序事件而产生一些延迟。由于只能等待一段有限的时间，因此就难以保证处理 Event Time 将产生完全一致和确定的结果。</p>
<p>假设所有数据都已到达，Event Time 操作将按照预期运行，即使在处理无序事件、延迟事件、重新处理历史数据时也会产生正确且一致的结果。 例如，每小时事件时间窗口将包含带有落入该小时的事件时间戳的所有记录，不管它们到达的顺序如何（是否按照事件产生的时间）。</p>
<h3 id="Ingestion-Time"><a href="#Ingestion-Time" class="headerlink" title="Ingestion Time"></a>Ingestion Time</h3><p>Ingestion Time 是事件进入 Flink 的时间。 在数据源操作处（进入 Flink source 时），每个事件将进入 Flink 时当时的时间作为时间戳，并且基于时间的操作（如时间窗口）会利用这个时间戳。</p>
<p>Ingestion Time 在概念上位于 Event Time 和 Processing Time 之间。 与 Processing Time 相比，成本可能会高一点，但结果更可预测。因为 Ingestion Time 使用稳定的时间戳（只在进入 Flink 的时候分配一次），所以对事件的不同窗口操作将使用相同的时间戳（第一次分配的时间戳），而在 Processing Time 中，每个窗口操作符可以将事件分配给不同的窗口（基于机器系统时间和到达延迟）。</p>
<p>与 Event Time 相比，Ingestion Time 程序无法处理任何无序事件或延迟数据，但程序中不必指定如何生成水印。</p>
<p>在 Flink 中，Ingestion Time 与 Event Time 非常相似，唯一区别就是 Ingestion Time 具有自动分配时间戳和自动生成水印功能。</p>
<h3 id="三种-Time-对比结果"><a href="#三种-Time-对比结果" class="headerlink" title="三种 Time 对比结果"></a>三种 Time 对比结果</h3><p>一张图概括上面说的三种 Time：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uwc85x5j21li0u075w.jpg" alt="undefined"></p>
<ul>
<li>Processing Time：事件被处理时机器的系统时间</li>
<li>Event Time：事件自身的时间</li>
<li>Ingestion Time：事件进入 Flink 的时间</li>
</ul>
<p>一张图形象描述上面说的三种 Time：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uwqobe4j227414ogn1.jpg" alt="undefined"></p>
<h3 id="使用场景分析"><a href="#使用场景分析" class="headerlink" title="使用场景分析"></a>使用场景分析</h3><p>通过上面两个图相信大家已经对 Flink 中的这三个 Time 有所了解了，那么我们实际生产环境中通常该如何选择哪种 Time 呢？</p>
<p>一般来说在生产环境中将 Event Time 与 Processing Time 对比的比较多，这两个也是我们常用的策略，Ingestion Time 一般用的较少。</p>
<p>用 Processing Time 的场景大多是用户不关心事件时间，它只需要关心这个时间窗口要有数据进来，只要有数据进来了，我就可以对进来窗口中的数据进行一系列的计算操作，然后再将计算后的数据发往下游。</p>
<p>而用 Event Time 的场景一般是业务需求需要时间这个字段（比如购物时是要先有下单事件、再有支付事件；借贷事件的风控是需要依赖时间来做判断的；机器异常检测触发的告警也是要具体的异常事件的时间展示出来；商品广告及时精准推荐给用户依赖的就是用户在浏览商品的时间段/频率/时长等信息），只能根据事件时间来处理数据，而且还要从事件中获取到事件的时间。</p>
<p>但是使用事件时间的话，就可能有这样的情况：数据源采集的数据往消息队列中发送时可能因为网络抖动、服务可用性、消息队列的分区数据堆积的影响而导致数据到达的不一定及时，可能会出现数据出现一定的乱序、延迟几分钟等，庆幸的是 Flink 支持通过 WaterMark 机制来处理这种延迟的数据。关于 WaterMark 的机制我会在后面的文章讲解。</p>
<h3 id="如何设置-Time-策略？"><a href="#如何设置-Time-策略？" class="headerlink" title="如何设置 Time 策略？"></a>如何设置 Time 策略？</h3><p>在创建完流运行环境的时候，然后就可以通过 <code>env.setStreamTimeCharacteristic</code> 设置时间策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他两种:</span></span><br><span class="line"><span class="comment">// env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime);</span></span><br><span class="line"><span class="comment">// env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime);</span></span><br></pre></td></tr></table></figure>
<h3 id="小结与反思-7"><a href="#小结与反思-7" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>本节介绍了 Flink 中的三种时间语义，相比较其他的流处理引擎来说支持的更多，你知道的流处理引擎支持哪些时间语义呢？</p>
<h2 id="九、Flink-Window-基础概念与实现原理"><a href="#九、Flink-Window-基础概念与实现原理" class="headerlink" title="九、Flink Window 基础概念与实现原理"></a>九、Flink Window 基础概念与实现原理</h2><p>目前有许多数据分析的场景从批处理到流处理的演变， 虽然可以将批处理作为流处理的特殊情况来处理，但是分析无穷集的流数据通常需要思维方式的转变并且具有其自己的术语，例如，“windowing（窗口化）”、“at-least-once（至少一次）”、“exactly-once（只有一次）” 。</p>
<p>对于刚刚接触流处理的人来说，这种转变和新术语可能会非常混乱。 Apache Flink 是一个为生产环境而生的流处理器，具有易于使用的 API，可以用于定义高级流分析程序。Flink 的 API 在数据流上具有非常灵活的窗口定义，使其在其他开源流处理框架中脱颖而出。</p>
<p>在本节将讨论用于流处理的窗口的概念，介绍 Flink 的内置窗口，并解释它对自定义窗口语义的支持。</p>
<h3 id="什么是-Window？"><a href="#什么是-Window？" class="headerlink" title="什么是 Window？"></a>什么是 Window？</h3><p>下面我们结合一个现实的例子来说明。</p>
<p>就拿交通传感器的示例：统计经过某红绿灯的汽车数量之和？</p>
<p>假设在一个红绿灯处，我们每隔 15 秒统计一次通过此红绿灯的汽车数量，如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0uzyaa4aj21mm08mmx1.jpg" alt="undefined"></p>
<p>可以把汽车的经过看成一个流，无穷的流，不断有汽车经过此红绿灯，因此无法统计总共的汽车数量。但是，我们可以换一种思路，每隔 15 秒，我们都将与上一次的结果进行 sum 操作（滑动聚合），如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0v0en8wuj21m80hudfw.jpg" alt="undefined"></p>
<p>这个结果似乎还是无法回答我们的问题，根本原因在于流是无界的，我们不能限制流，但可以在有一个有界的范围内处理无界的流数据。因此，我们需要换一个问题的提法：每分钟经过某红绿灯的汽车数量之和？</p>
<p>这个问题，就相当于一个定义了一个 Window（窗口），Window 的界限是 1 分钟，且每分钟内的数据互不干扰，因此也可以称为翻滚（不重合）窗口，如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0v0wadrcj21my0gmaa6.jpg" alt="undefined"></p>
<p>第一分钟的数量为 18，第二分钟是 28，第三分钟是 24……这样，1 个小时内会有 60 个 Window。</p>
<p>再考虑一种情况，每 30 秒统计一次过去 1 分钟的汽车数量之和：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0v1b9o6jj21mu0o2wet.jpg" alt="undefined"></p>
<p>此时，Window 出现了重合。这样，1 个小时内会有 120 个 Window。</p>
<h3 id="Window-有什么作用？"><a href="#Window-有什么作用？" class="headerlink" title="Window 有什么作用？"></a>Window 有什么作用？</h3><p>通常来讲，Window 就是用来对一个无限的流设置一个有限的集合，在有界的数据集上进行操作的一种机制。Window 又可以分为基于时间（Time-based）的 Window 以及基于数量（Count-based）的 window。</p>
<h3 id="Flink-自带的-Window"><a href="#Flink-自带的-Window" class="headerlink" title="Flink 自带的 Window"></a>Flink 自带的 Window</h3><p>Flink 在 KeyedStream（DataStream 的继承类） 中提供了下面几种 Window：</p>
<ul>
<li>以时间驱动的 Time Window</li>
<li>以事件数量驱动的 Count Window</li>
<li>以会话间隔驱动的 Session Window</li>
</ul>
<p>提供上面三种 Window 机制后，由于某些特殊的需要，DataStream API 也提供了定制化的 Window 操作，供用户自定义 Window。</p>
<p>下面将先围绕上面说的三种 Window 来进行分析并教大家如何使用，然后对其原理分析，最后在解析其源码实现。</p>
<h3 id="Time-Window-使用及源码分析"><a href="#Time-Window-使用及源码分析" class="headerlink" title="Time Window 使用及源码分析"></a>Time Window 使用及源码分析</h3><p>正如命名那样，Time Window 根据时间来聚合流数据。例如：一分钟的时间窗口就只会收集一分钟的元素，并在一分钟过后对窗口中的所有元素应用于下一个算子。</p>
<p>在 Flink 中使用 Time Window 非常简单，输入一个时间参数，这个时间参数可以利用 Time 这个类来控制，如果事前没指定 TimeCharacteristic 类型的话，则默认使用的是 ProcessingTime，如果对 Flink 中的 Time 还不了解的话，可以看前一篇文章 <a href="https://gitbook.cn/gitchat/column/5dad4a20669f843a1a37cb4f/topic/5db6a06bf6a6211cb96164ff" target="_blank" rel="noopener">Flink 中 Processing Time、Event Time、Ingestion Time 对比及其使用场景分析</a> 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataStream.keyBy(<span class="number">1</span>)</span><br><span class="line">    .timeWindow(Time.minutes(<span class="number">1</span>)) <span class="comment">//time Window 每分钟统计一次数量和</span></span><br><span class="line">    .sum(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>时间窗口的数据窗口聚合流程如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0v50qmevj21sc0w2wgo.jpg" alt="undefined"></p>
<p>在第一个窗口中（1 ～ 2 分钟）和为 7、第二个窗口中（2 ～ 3 分钟）和为 12、第三个窗口中（3 ～ 4 分钟）和为 7、第四个窗口中（4 ～ 5 分钟）和为 19。</p>
<p>该 timeWindow 方法在 KeyedStream 中对应的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, TimeWindow&gt; <span class="title">timeWindow</span><span class="params">(Time size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">        <span class="keyword">return</span> window(TumblingProcessingTimeWindows.of(size));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> window(TumblingEventTimeWindows.of(size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外在 Time Window 中还支持滑动的时间窗口，比如定义了一个每 30s 滑动一次的 1 分钟时间窗口，它会每隔 30s 去统计过去一分钟窗口内的数据，同样使用也很简单，输入两个时间参数，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataStream.keyBy(<span class="number">1</span>)</span><br><span class="line">    .timeWindow(Time.minutes(<span class="number">1</span>), Time.seconds(<span class="number">30</span>)) <span class="comment">//sliding time Window 每隔 30s 统计过去一分钟的数量和</span></span><br><span class="line">    .sum(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>滑动时间窗口的数据聚合流程如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0v9hcl5wj21sa0xq410.jpg" alt="undefined"></p>
<p>在该第一个时间窗口中（1 ～ 2 分钟）和为 7，第二个时间窗口中（1:30 ~ 2:30）和为 10，第三个时间窗口中（2 ~ 3 分钟）和为 12，第四个时间窗口中（2:30 ~ 3:30）和为 10，第五个时间窗口中（3 ~ 4 分钟）和为 7，第六个时间窗口中（3:30 ~ 4:30）和为 11，第七个时间窗口中（4 ~ 5 分钟）和为 19。</p>
<p>该 timeWindow 方法在 KeyedStream 中对应的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动时间窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, TimeWindow&gt; <span class="title">timeWindow</span><span class="params">(Time size, Time slide)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">        <span class="keyword">return</span> window(SlidingProcessingTimeWindows.of(size, slide));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> window(SlidingEventTimeWindows.of(size, slide));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Count-Window-使用及源码分析"><a href="#Count-Window-使用及源码分析" class="headerlink" title="Count Window 使用及源码分析"></a>Count Window 使用及源码分析</h3><p>Apache Flink 还提供计数窗口功能，如果计数窗口的值设置的为 3 ，那么将会在窗口中收集 3 个事件，并在添加第 3 个元素时才会计算窗口中所有事件的值。</p>
<p>在 Flink 中使用 Count Window 非常简单，输入一个 long 类型的参数，这个参数代表窗口中事件的数量，使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataStream.keyBy(<span class="number">1</span>)</span><br><span class="line">    .countWindow(<span class="number">3</span>) <span class="comment">//统计每 3 个元素的数量之和</span></span><br><span class="line">    .sum(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>计数窗口的数据窗口聚合流程如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vazxmyfj21ek0ny769.jpg" alt="undefined"></p>
<p>该 countWindow 方法在 KeyedStream 中对应的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title">countWindow</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create()).trigger(PurgingTrigger.of(CountTrigger.of(size)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外在 Count Window 中还支持滑动的计数窗口，比如定义了一个每 3 个事件滑动一次的 4 个事件的计数窗口，它会每隔 3 个事件去统计过去 4 个事件计数窗口内的数据，使用也很简单，输入两个 long 类型的参数，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataStream.keyBy(<span class="number">1</span>) </span><br><span class="line">    .countWindow(<span class="number">4</span>, <span class="number">3</span>) <span class="comment">//每隔 3 个元素统计过去 4 个元素的数量之和</span></span><br><span class="line">    .sum(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>滑动计数窗口的数据窗口聚合流程如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vbqi86ej225m0wmac7.jpg" alt="undefined"></p>
<p>该 countWindow 方法在 KeyedStream 中对应的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动计数窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title">countWindow</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">long</span> slide)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create()).evictor(CountEvictor.of(size)).trigger(CountTrigger.of(slide));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Session-Window-使用及源码分析"><a href="#Session-Window-使用及源码分析" class="headerlink" title="Session Window 使用及源码分析"></a>Session Window 使用及源码分析</h3><p>Apache Flink 还提供了会话窗口，是什么意思呢？使用该窗口的时候你可以传入一个时间参数（表示某种数据维持的会话持续时长），如果超过这个时间，就代表着超出会话时长。</p>
<p>在 Flink 中使用 Session Window 非常简单，你该使用 Flink KeyedStream 中的 window 方法，然后使用 ProcessingTimeSessionWindows.withGap()（不一定就是只使用这个），在该方法里面你需要做的是传入一个时间参数，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataStream.keyBy(<span class="number">1</span>)</span><br><span class="line">    .window(ProcessingTimeSessionWindows.withGap(Time.seconds(<span class="number">5</span>)))<span class="comment">//表示如果 5s 内没出现数据则认为超出会话时长，然后计算这个窗口的和</span></span><br><span class="line">    .sum(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>会话窗口的数据窗口聚合流程如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vcsdq1kj22gu0xaq5w.jpg" alt="undefined"></p>
<p>该 Window 方法在 KeyedStream 中对应的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供自定义 Window</span></span><br><span class="line"><span class="keyword">public</span> &lt;W extends Window&gt; <span class="function">WindowedStream&lt;T, KEY, W&gt; <span class="title">window</span><span class="params">(WindowAssigner&lt;? <span class="keyword">super</span> T, W&gt; assigner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowedStream&lt;&gt;(<span class="keyword">this</span>, assigner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何自定义-Window？"><a href="#如何自定义-Window？" class="headerlink" title="如何自定义 Window？"></a>如何自定义 Window？</h3><p>当然除了上面几种自带的 Window 外，Apache Flink 还提供了用户可自定义的 Window，那么该如何操作呢？其实细心的同学可能已经发现了上面我写的每种 Window 的实现方式了，它们有 assigner、 evictor、trigger。如果你没发现的话，也不要紧，这里我们就来了解一下实现 Window 的机制，这样我们才能够更好的学会如何自定义 Window。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vdsn6xyj21nc12qq3x.jpg" alt="undefined"></p>
<h3 id="3-2-8-Window-源码定义"><a href="#3-2-8-Window-源码定义" class="headerlink" title="3.2.8 Window 源码定义"></a>3.2.8 Window 源码定义</h3><p>上面说了 Flink 中自带的 Window，主要利用了 KeyedStream 的 API 来实现，我们这里来看下 Window 的源码定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取属于此窗口的最大时间戳</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">maxTimestamp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看源码可以看见 Window 这个抽象类有如下实现类：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vi0o960j20y20as3yg.jpg" alt="undefined"></p>
<p><strong>TimeWindow</strong> 源码定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="comment">//窗口开始时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="comment">//窗口结束时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GlobalWindow</strong> 源码定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> GlobalWindow INSTANCE = <span class="keyword">new</span> GlobalWindow();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GlobalWindow</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">//对外提供 get() 方法返回 GlobalWindow 实例，并且是个全局单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlobalWindow <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Window-组件之-WindowAssigner-使用及源码分析"><a href="#Window-组件之-WindowAssigner-使用及源码分析" class="headerlink" title="Window 组件之 WindowAssigner 使用及源码分析"></a>Window 组件之 WindowAssigner 使用及源码分析</h3><p>到达窗口操作符的元素被传递给 WindowAssigner。WindowAssigner 将元素分配给一个或多个窗口，可能会创建新的窗口。</p>
<p>窗口本身只是元素列表的标识符，它可能提供一些可选的元信息，例如 TimeWindow 中的开始和结束时间。注意，元素可以被添加到多个窗口，这也意味着一个元素可以同时在多个窗口存在。我们来看下 WindowAssigner 的代码的定义吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowAssigner</span>&lt;<span class="title">T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分配数据到窗口并返回窗口集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Collection&lt;W&gt; <span class="title">assignWindows</span><span class="params">(T element, <span class="keyword">long</span> timestamp, WindowAssignerContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看源码可以看见 WindowAssigner 这个抽象类有如下实现类：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vlvjsgdj22ro0p0wey.jpg" alt="undefined"></p>
<p>这些 WindowAssigner 实现类的作用介绍：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vpz366lj20iv08gn0z.jpg" alt="TIM截图20191218145154.png"></p>
<p>如果你细看了上面图中某个类的具体实现的话，你会发现一个规律，比如我拿 TumblingEventTimeWindows 的源码来分析，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TumblingEventTimeWindows</span> <span class="keyword">extends</span> <span class="title">WindowAssigner</span>&lt;<span class="title">Object</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TumblingEventTimeWindows</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(offset) &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"TumblingEventTimeWindows parameters must satisfy abs(offset) &lt; size"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写 WindowAssigner 抽象类中的抽象方法 assignWindows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;TimeWindow&gt; <span class="title">assignWindows</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, WindowAssignerContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实现该 TumblingEventTimeWindows 中的具体逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他方法，对外提供静态方法，供其他类调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面你就会发现<strong>套路</strong>：</p>
<p>1、定义好实现类的属性</p>
<p>2、根据定义的属性添加构造方法</p>
<p>3、重写 WindowAssigner 中的 assignWindows 等方法</p>
<p>4、定义其他的方法供外部调用</p>
<h3 id="Window-组件之-Trigger-使用及源码分析"><a href="#Window-组件之-Trigger-使用及源码分析" class="headerlink" title="Window 组件之 Trigger 使用及源码分析"></a>Window 组件之 Trigger 使用及源码分析</h3><p>Trigger 表示触发器，每个窗口都拥有一个 Trigger（触发器），该 Trigger 决定何时计算和清除窗口。当先前注册的计时器超时时，将为插入窗口的每个元素调用触发器。在每个事件上，触发器都可以决定触发，即清除（删除窗口并丢弃其内容），或者启动并清除窗口。一个窗口可以被求值多次，并且在被清除之前一直存在。注意，在清除窗口之前，窗口将一直消耗内存。</p>
<p>说了这么一大段，我们还是来看看 Trigger 的源码，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Trigger</span>&lt;<span class="title">T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当有数据进入到 Window 运算符就会触发该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title">onElement</span><span class="params">(T element, <span class="keyword">long</span> timestamp, W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">//当使用触发器上下文设置的处理时间计时器触发时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> time, W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">//当使用触发器上下文设置的事件时间计时器触发时调用该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title">onEventTime</span><span class="params">(<span class="keyword">long</span> time, W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有数据流入 Window 运算符时就会触发 onElement 方法、当处理时间和事件时间生效时会触发 onProcessingTime 和 onEventTime 方法。每个触发动作的返回结果用 TriggerResult 定义。继续来看下 TriggerResult 的源码定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TriggerResult &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不做任何操作</span></span><br><span class="line">    CONTINUE(<span class="keyword">false</span>, <span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理并移除窗口中的数据</span></span><br><span class="line">    FIRE_AND_PURGE(<span class="keyword">true</span>, <span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理窗口数据，窗口计算后不做清理</span></span><br><span class="line">    FIRE(<span class="keyword">true</span>, <span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除窗口中的所有元素，并且在不计算窗口函数或不发出任何元素的情况下丢弃窗口</span></span><br><span class="line">    PURGE(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看源码可以看见 Trigger 这个抽象类有如下实现类：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vqk5hxnj22ua0is3ys.jpg" alt="undefined"></p>
<p>这些 Trigger 实现类的作用介绍：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vqqwlzej227017sdnt.jpg" alt="undefined"></p>
<p>如果你细看了上面图中某个类的具体实现的话，你会发现一个规律，拿 CountTrigger 的源码来分析，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTrigger</span>&lt;<span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">extends</span> <span class="title">Trigger</span>&lt;<span class="title">Object</span>, <span class="title">W</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReducingStateDescriptor&lt;Long&gt; stateDesc = <span class="keyword">new</span> ReducingStateDescriptor&lt;&gt;(<span class="string">"count"</span>, <span class="keyword">new</span> Sum(), LongSerializer.INSTANCE);</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CountTrigger</span><span class="params">(<span class="keyword">long</span> maxCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxCount = maxCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写抽象类 Trigger 中的抽象方法 </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onElement</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//实现 CountTrigger 中的具体逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onEventTime</span><span class="params">(<span class="keyword">long</span> time, W window, TriggerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> time, W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>套路</strong>：</p>
<ol>
<li>定义好实现类的属性</li>
<li>根据定义的属性添加构造方法</li>
<li>重写 Trigger 中的 onElement、onEventTime、onProcessingTime 等方法</li>
<li>定义其他的方法供外部调用</li>
</ol>
<h3 id="Window-组件之-Evictor-使用及源码分析"><a href="#Window-组件之-Evictor-使用及源码分析" class="headerlink" title="Window 组件之 Evictor 使用及源码分析"></a>Window 组件之 Evictor 使用及源码分析</h3><p>Evictor 表示驱逐者，它可以遍历窗口元素列表，并可以决定从列表的开头删除首先进入窗口的一些元素，然后其余的元素被赋给一个计算函数，如果没有定义 Evictor，触发器直接将所有窗口元素交给计算函数。</p>
<p>我们来看看 Evictor 的源码定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Evictor</span>&lt;<span class="title">T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在窗口函数之前调用该方法选择性地清除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">evictBefore</span><span class="params">(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, <span class="keyword">int</span> size, W window, EvictorContext evictorContext)</span></span>;</span><br><span class="line">    <span class="comment">//在窗口函数之后调用该方法选择性地清除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">evictAfter</span><span class="params">(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, <span class="keyword">int</span> size, W window, EvictorContext evictorContext)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看源码可以看见 Evictor 这个接口有如下实现类：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vrfwkxpj215m0f8q30.jpg" alt="undefined"></p>
<p>这些 Evictor 实现类的作用介绍：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vro7oi3j225y0ts0vk.jpg" alt="undefined"></p>
<p>如果你细看了上面三种中某个类的实现的话，你会发现一个规律，比如我就拿 CountEvictor 的源码来分析，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountEvictor</span>&lt;<span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">implements</span> <span class="title">Evictor</span>&lt;<span class="title">Object</span>, <span class="title">W</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> doEvictAfter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CountEvictor</span><span class="params">(<span class="keyword">long</span> count, <span class="keyword">boolean</span> doEvictAfter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxCount = count;</span><br><span class="line">        <span class="keyword">this</span>.doEvictAfter = doEvictAfter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CountEvictor</span><span class="params">(<span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxCount = count;</span><br><span class="line">        <span class="keyword">this</span>.doEvictAfter = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写 Evictor 中的 evictBefore 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictBefore</span><span class="params">(Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, <span class="keyword">int</span> size, W window, EvictorContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!doEvictAfter) &#123;</span><br><span class="line">            <span class="comment">//调用内部的关键实现方法 evict</span></span><br><span class="line">            evict(elements, size, ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写 Evictor 中的 evictAfter 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictAfter</span><span class="params">(Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, <span class="keyword">int</span> size, W window, EvictorContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (doEvictAfter) &#123;</span><br><span class="line">            <span class="comment">//调用内部的关键实现方法 evict</span></span><br><span class="line">            evict(elements, size, ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, <span class="keyword">int</span> size, EvictorContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//内部的关键实现方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现<strong>套路</strong>：</p>
<ol>
<li>定义好实现类的属性</li>
<li>根据定义的属性添加构造方法</li>
<li>重写 Evictor 中的 evictBefore 和 evictAfter 方法</li>
<li>定义关键的内部实现方法 evict，处理具体的逻辑</li>
<li>定义其他的方法供外部调用</li>
</ol>
<p>上面我们详细讲解了 Window 中的组件 WindowAssigner、Trigger、Evictor，然后继续回到问题：如何自定义 Window？</p>
<p>上文讲解了 Flink 自带的 Window（Time Window、Count Window、Session Window），然后还分析了他们的源码实现，通过这几个源码，我们可以发现，它最后调用的都有一个方法，那就是 Window 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供自定义 Window</span></span><br><span class="line"><span class="keyword">public</span> &lt;W extends Window&gt; <span class="function">WindowedStream&lt;T, KEY, W&gt; <span class="title">window</span><span class="params">(WindowAssigner&lt;? <span class="keyword">super</span> T, W&gt; assigner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowedStream&lt;&gt;(<span class="keyword">this</span>, assigner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个 WindowedStream 实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WindowedStream</span><span class="params">(KeyedStream&lt;T, K&gt; input,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowAssigner&lt;? <span class="keyword">super</span> T, W&gt; windowAssigner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.input = input;</span><br><span class="line">    <span class="keyword">this</span>.windowAssigner = windowAssigner;</span><br><span class="line">    <span class="comment">//获取一个默认的 Trigger</span></span><br><span class="line">    <span class="keyword">this</span>.trigger = windowAssigner.getDefaultTrigger(input.getExecutionEnvironment());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个 Window 方法传入的参数是一个 WindowAssigner 对象（你可以利用 Flink 现有的 WindowAssigner，也可以根据上面的方法来自定义自己的 WindowAssigner），然后再通过构造一个 WindowedStream 实例（在构造实例的会传入 WindowAssigner 和获取默认的 Trigger）来创建一个 Window。</p>
<p>另外你可以看到滑动计数窗口，在调用 window 方法之后，还调用了 WindowedStream 的 evictor 和 trigger 方法，trigger 方法会覆盖掉你之前调用 Window 方法中默认的 trigger，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动计数窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title">countWindow</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">long</span> slide)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create()).evictor(CountEvictor.of(size)).trigger(CountTrigger.of(slide));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trigger 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, K, W&gt; <span class="title">trigger</span><span class="params">(Trigger&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> W&gt; trigger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (windowAssigner <span class="keyword">instanceof</span> MergingWindowAssigner &amp;&amp; !trigger.canMerge()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"A merging window assigner cannot be used with a trigger that does not support merging."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (windowAssigner <span class="keyword">instanceof</span> BaseAlignedWindowAssigner) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot use a "</span> + windowAssigner.getClass().getSimpleName() + <span class="string">" with a custom trigger."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//覆盖之前的 trigger</span></span><br><span class="line">    <span class="keyword">this</span>.trigger = trigger;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的各种窗口实现，你就会发现了：Evictor 是可选的，但是 WindowAssigner 和 Trigger 是必须会有的，这种创建 Window 的方法充分利用了 KeyedStream 和 WindowedStream 的 API，再加上现有的 WindowAssigner、Trigger、Evictor，你就可以创建 Window 了，另外你还可以自定义这三个窗口组件的实现类来满足你公司项目的需求。</p>
<h3 id="小结与反思-8"><a href="#小结与反思-8" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>本节从生活案例来分享关于 Window 方面的需求，进而开始介绍 Window 相关的知识，并把 Flink 中常使用的三种窗口都一一做了介绍，并告诉大家如何使用，还分析了其实现原理。最后还对 Window 的内部组件做了详细的分析，为自定义 Window 提供了方法。</p>
<p>不知道你看完本节后对 Window 还有什么疑问吗？你们是根据什么条件来选择使用哪种 Window 的？在使用的过程中有遇到什么问题吗？</p>
<h2 id="十、数据转换必须熟悉的算子（Operator）"><a href="#十、数据转换必须熟悉的算子（Operator）" class="headerlink" title="十、数据转换必须熟悉的算子（Operator）"></a>十、数据转换必须熟悉的算子（Operator）</h2><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0vsgous8j21ri0dcmxj.jpg" alt="undefined"></p>
<p>在 Flink 应用程序中，无论你的应用程序是批程序，还是流程序，都是上图这种模型，有数据源（source），有数据下游（sink），我们写的应用程序多是对数据源过来的数据做一系列操作，总结如下。</p>
<ol>
<li><strong>Source</strong>: 数据源，Flink 在流处理和批处理上的 source 大概有 4 类：基于本地集合的 source、基于文件的 source、基于网络套接字的 source、自定义的 source。自定义的 source 常见的有 Apache kafka、Amazon Kinesis Streams、RabbitMQ、Twitter Streaming API、Apache NiFi 等，当然你也可以定义自己的 source。</li>
<li><strong>Transformation</strong>: 数据转换的各种操作，有 Map / FlatMap / Filter / KeyBy / Reduce / Fold / Aggregations / Window / WindowAll / Union / Window join / Split / Select / Project 等，操作很多，可以将数据转换计算成你想要的数据。</li>
<li><strong>Sink</strong>: 接收器，Sink 是指 Flink 将转换计算后的数据发送的地点 ，你可能需要存储下来。Flink 常见的 Sink 大概有如下几类：写入文件、打印出来、写入 Socket 、自定义的 Sink 。自定义的 sink 常见的有 Apache kafka、RabbitMQ、MySQL、ElasticSearch、Apache Cassandra、Hadoop FileSystem 等，同理你也可以定义自己的 Sink。</li>
</ol>
<p>那么本文将给大家介绍的就是 Flink 中的批和流程序常用的算子（Operator）。</p>
<h3 id="DataStream-Operator"><a href="#DataStream-Operator" class="headerlink" title="DataStream Operator"></a>DataStream Operator</h3><p>我们先来看看流程序中常用的算子。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map 算子的输入流是 DataStream，经过 Map 算子后返回的数据格式是 SingleOutputStreamOperator 类型，获取一个元素并生成一个元素，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;Employee&gt; map = employeeStream.map(<span class="keyword">new</span> MapFunction&lt;Employee, Employee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">map</span><span class="params">(Employee employee)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        employee.salary = employee.salary + <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">return</span> employee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">map.print();</span><br></pre></td></tr></table></figure>
<p>新的一年给每个员工的工资加 5000。</p>
<h4 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h4><p>FlatMap 算子的输入流是 DataStream，经过 FlatMap 算子后返回的数据格式是 SingleOutputStreamOperator 类型，获取一个元素并生成零个、一个或多个元素，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;Employee&gt; flatMap = employeeStream.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;Employee, Employee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Employee employee, Collector&lt;Employee&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (employee.salary &gt;= <span class="number">40000</span>) &#123;</span><br><span class="line">            out.collect(employee);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">flatMap.print();</span><br></pre></td></tr></table></figure>
<p>将工资大于 40000 的找出来。</p>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0xjwko8fj21200aqaa3.jpg" alt="undefined"></p>
<p>对每个元素都进行判断，返回为 true 的元素，如果为 false 则丢弃数据，上面找出工资大于 40000 的员工其实也可以用 Filter 来做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;Employee&gt; filter = employeeStream.filter(<span class="keyword">new</span> FilterFunction&lt;Employee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Employee employee)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (employee.salary &gt;= <span class="number">40000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">filter.print();</span><br></pre></td></tr></table></figure>
<h4 id="KeyBy"><a href="#KeyBy" class="headerlink" title="KeyBy"></a>KeyBy</h4><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0xkegqp2j213s0ju3yu.jpg" alt="undefined"></p>
<p>KeyBy 在逻辑上是基于 key 对流进行分区，相同的 Key 会被分到一个分区（这里分区指的就是下游算子多个并行节点的其中一个）。在内部，它使用 hash 函数对流进行分区。它返回 KeyedDataStream 数据流。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KeyedStream&lt;ProductEvent, Integer&gt; keyBy = productStream.keyBy(<span class="keyword">new</span> KeySelector&lt;ProductEvent, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getKey</span><span class="params">(ProductEvent product)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product.shopId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">keyBy.print();</span><br></pre></td></tr></table></figure>
<p>根据商品的店铺 id 来进行分区。</p>
<h4 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h4><p>Reduce 返回单个的结果值，并且 reduce 操作每处理一个元素总是创建一个新值。常用的方法有 average、sum、min、max、count，使用 Reduce 方法都可实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;Employee&gt; reduce = employeeStream.keyBy(<span class="keyword">new</span> KeySelector&lt;Employee, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getKey</span><span class="params">(Employee employee)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employee.shopId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).reduce(<span class="keyword">new</span> ReduceFunction&lt;Employee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">reduce</span><span class="params">(Employee employee1, Employee employee2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        employee1.salary = (employee1.salary + employee2.salary) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> employee1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">reduce.print();</span><br></pre></td></tr></table></figure>
<p>上面先将数据流进行 keyby 操作，因为执行 Reduce 操作只能是 KeyedStream，然后将员工的工资做了一个求平均值的操作。</p>
<h4 id="Aggregations"><a href="#Aggregations" class="headerlink" title="Aggregations"></a>Aggregations</h4><p>DataStream API 支持各种聚合，例如 min、max、sum 等。 这些函数可以应用于 KeyedStream 以获得 Aggregations 聚合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">KeyedStream.sum(<span class="number">0</span>) </span><br><span class="line">KeyedStream.sum(<span class="string">"key"</span>) </span><br><span class="line">KeyedStream.min(<span class="number">0</span>) </span><br><span class="line">KeyedStream.min(<span class="string">"key"</span>) </span><br><span class="line">KeyedStream.max(<span class="number">0</span>) </span><br><span class="line">KeyedStream.max(<span class="string">"key"</span>) </span><br><span class="line">KeyedStream.minBy(<span class="number">0</span>) </span><br><span class="line">KeyedStream.minBy(<span class="string">"key"</span>) </span><br><span class="line">KeyedStream.maxBy(<span class="number">0</span>) </span><br><span class="line">KeyedStream.maxBy(<span class="string">"key"</span>)</span><br></pre></td></tr></table></figure>
<p>max 和 maxBy 之间的区别在于 max 返回流中的最大值，但 maxBy 返回具有最大值的键， min 和 minBy 同理。</p>
<h4 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h4><p>Window 函数允许按时间或其他条件对现有 KeyedStream 进行分组。 以下是以 10 秒的时间窗口聚合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputStream.keyBy(<span class="number">0</span>).window(Time.seconds(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p>有时候因为业务需求场景要求：聚合一分钟、一小时的数据做统计报表使用。</p>
<h4 id="WindowAll"><a href="#WindowAll" class="headerlink" title="WindowAll"></a>WindowAll</h4><p>WindowAll 将元素按照某种特性聚集在一起，该函数不支持并行操作，默认的并行度就是 1，所以如果使用这个算子的话需要注意一下性能问题，以下是使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputStream.keyBy(<span class="number">0</span>).windowAll(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>)));</span><br></pre></td></tr></table></figure>
<h4 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h4><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0y9pd8g3j210u0heq35.jpg" alt="undefined"></p>
<p>Union 函数将两个或多个数据流结合在一起。 这样后面在使用的时候就只需使用一个数据流就行了。 如果我们将一个流与自身组合，那么组合后的数据流会有两份同样的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputStream.union(inputStream1, inputStream2, ...);</span><br></pre></td></tr></table></figure>
<h4 id="Window-Join"><a href="#Window-Join" class="headerlink" title="Window Join"></a>Window Join</h4><p>我们可以通过一些 key 将同一个 window 的两个数据流 join 起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inputStream.join(inputStream1)</span><br><span class="line">           .where(<span class="number">0</span>).equalTo(<span class="number">1</span>)</span><br><span class="line">           .window(Time.seconds(<span class="number">5</span>))     </span><br><span class="line">           .apply (<span class="keyword">new</span> JoinFunction () &#123;...&#125;);</span><br></pre></td></tr></table></figure>
<p>以上示例是在 5 秒的窗口中连接两个流，其中第一个流的第一个属性的连接条件等于另一个流的第二个属性。</p>
<h4 id="Split"><a href="#Split" class="headerlink" title="Split"></a>Split</h4><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0ybr9m9lj212e0h4mxg.jpg" alt="undefined"></p>
<p>此功能根据条件将流拆分为两个或多个流。 当你获得混合流然后你可能希望单独处理每个数据流时，可以使用此方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SplitStream&lt;Integer&gt; split = inputStream.split(<span class="keyword">new</span> OutputSelector&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">select</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; output = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">        <span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            output.add(<span class="string">"even"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            output.add(<span class="string">"odd"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面就是将偶数数据流放在 even 中，将奇数数据流放在 odd 中。</p>
<h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0yg0tundj21gg0ggq3e.jpg" alt="undefined"></p>
<p>上面用 Split 算子将数据流拆分成两个数据流（奇数、偶数），接下来你可能想从拆分流中选择特定流，那么就得搭配使用 Select 算子（一般这两者都是搭配在一起使用的），</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SplitStream&lt;Integer&gt; split;</span><br><span class="line">DataStream&lt;Integer&gt; even = split.select(<span class="string">"even"</span>); </span><br><span class="line">DataStream&lt;Integer&gt; odd = split.select(<span class="string">"odd"</span>); </span><br><span class="line">DataStream&lt;Integer&gt; all = split.select(<span class="string">"even"</span>,<span class="string">"odd"</span>);</span><br></pre></td></tr></table></figure>
<p>我们就介绍这么些常用的算子了，当然肯定也会有遗漏，具体还得查看官网 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/operators/" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/operators/</a> 的介绍。</p>
<h3 id="DataSet-Operator"><a href="#DataSet-Operator" class="headerlink" title="DataSet Operator"></a>DataSet Operator</h3><p>上面介绍了 DataStream 的常用算子，其实上面也有一些算子也是同样适合于 DataSet 的，比如 Map、FlatMap、Filter 等（相同的我就不再重复了）；也有一些算子是 DataSet API 独有的，比如 DataStream 中分区使用的是 KeyBy，但是 DataSet 中使用的是 GroupBy。</p>
<h4 id="First-n"><a href="#First-n" class="headerlink" title="First-n"></a>First-n</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DataSet&lt;Tuple2&lt;String, Integer&gt;&gt; in = </span><br><span class="line"><span class="comment">// 返回 DataSet 中前 5 的元素</span></span><br><span class="line">DataSet&lt;Tuple2&lt;String, Integer&gt;&gt; out1 = in.first(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回分组后每个组的前 2 元素</span></span><br><span class="line">DataSet&lt;Tuple2&lt;String, Integer&gt;&gt; out2 = in.groupBy(<span class="number">0</span>)</span><br><span class="line">                                          .first(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回分组后每个组的前 3 元素（按照上升排序）</span></span><br><span class="line">DataSet&lt;Tuple2&lt;String, Integer&gt;&gt; out3 = in.groupBy(<span class="number">0</span>)</span><br><span class="line">                                          .sortGroup(<span class="number">1</span>, Order.ASCENDING)</span><br><span class="line">                                          .first(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>还有一些，感兴趣的可以查看官网 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/batch/dataset_transformations.html。" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/batch/dataset_transformations.html。</a></p>
<h3 id="流批统一的思路"><a href="#流批统一的思路" class="headerlink" title="流批统一的思路"></a>流批统一的思路</h3><p>一般公司里的业务场景需求肯定不止是只有批计算，也不只是有流计算的。一般这两种需求是都存在的。比如每天凌晨 00:00 去算昨天一天商品的售卖情况，然后出报表给运营或者老板去分析；另外的就是处理实时的数据。</p>
<p>但是这样就会有一个问题，需要让开发掌握两套 API。有些数据工程师的开发能力可能并不高，他们会更擅长写一些 SQL 去分析，所以要是掌握两套 API 的话，对他们来说成本可能会很大。要是 Flink 能够提供一种高级的 API，上层做好完全封装，让开发无感知底层到底运行的是 DataSet 还是 DataStream API，这样不管是开发还是数据工程师只需要学习一套高级的 API 就行。</p>
<p>Flink 社区包括阿里巴巴实时计算团队也在大力推广这块，那就是我们的 Flink Table API &amp; SQL，在 Flink 1.9 版本，开源版本的 Blink 大部分代码已经合进去了，期待阿里实时计算团队为社区带来更多的贡献。</p>
<p>对于开发人员来说，流批统一的引擎（Table API &amp; SQL）在执行之前会根据运行的环境翻译成 DataSet 或者 DataStream API。因为这两种 API 底层的实现有很大的区别，所以在统一流和批的过程中遇到了不少挑战。</p>
<ul>
<li>理论基础：动态表</li>
<li>架构改进（统一的 Operator 框架、统一的查询处理）</li>
<li>优化器的统一</li>
<li>基础数据结构的统一</li>
<li>物理实现的共享</li>
</ul>
<p>关于 Table API &amp; SQL，在进阶篇第五章中有讲解！</p>
<h3 id="小结与反思-9"><a href="#小结与反思-9" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>本节介绍了在开发 Flink 作业中数据转换常使用的算子（包含流作业和批作业），DataStream API 和 DataSet API 中部分算子名字是一致的，也有不同的地方，最后讲解了下 Flink 社区后面流批统一的思路。</p>
<p>你们公司使用 Flink 是流作业居多还是批作业居多？</p>
<h2 id="十一、如何使用-DataStream-API-来处理数据？"><a href="#十一、如何使用-DataStream-API-来处理数据？" class="headerlink" title="十一、如何使用 DataStream API 来处理数据？"></a>十一、如何使用 DataStream API 来处理数据？</h2><p>在 3.3 节中讲了数据转换常用的 Operators（算子），然后在 3.2 节中也讲了 Flink 中窗口的概念和原理，那么我们这篇文章再来细讲一下 Flink 中的各种 DataStream API。</p>
<p>我们先来看下源码里面的 DataStream 大概有哪些类呢？</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0yi4jstvj215m17ejss.jpg" alt="undefined"></p>
<p>可以发现其实还是有很多的类，只有熟练掌握了这些 API，我们才能在做数据转换和计算的时候足够灵活的运用开来（知道何时该选用哪种 DataStream？选用哪个 Function？）。那么我们先从 DataStream 开始吧！</p>
<h3 id="DataStream-如何使用及分析"><a href="#DataStream-如何使用及分析" class="headerlink" title="DataStream 如何使用及分析"></a>DataStream 如何使用及分析</h3><p>首先我们来看下 DataStream 这个类的定义吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A DataStream represents a stream of elements of the same type. A DataStreamcan be transformed into another DataStream by applying a transformation as</span><br><span class="line"> DataStream#map or DataStream#filter&#125;</span><br></pre></td></tr></table></figure>
<p>大概意思是：DataStream 表示相同类型的元素组成的数据流，一个数据流可以通过 map/filter 等算子转换成另一个数据流。</p>
<p>然后 DataStream 的类结构图如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0yppinynj21cy0fodfz.jpg" alt="undefined"></p>
<p>它的继承类有 KeyedStream、SingleOutputStreamOperator 和 SplitStream。这几个类本文后面都会一一给大家讲清楚。下面我们来看看 DataStream 这个类中的属性和方法吧。</p>
<p>它的属性就只有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> StreamExecutionEnvironment environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> StreamTransformation&lt;T&gt; transformation;</span><br></pre></td></tr></table></figure>
<p>但是它的方法却有很多，并且我们平时写的 Flink Job 几乎离不开这些方法，这也注定了这个类的重要性，所以得好好看下这些方法该如何使用，以及是如何实现的。</p>
<h4 id="union"><a href="#union" class="headerlink" title="union"></a>union</h4><p>通过合并相同数据类型的数据流，然后创建一个新的数据流，union 方法代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> DataStream&lt;T&gt; <span class="title">union</span><span class="params">(DataStream&lt;T&gt;... streams)</span> </span>&#123;</span><br><span class="line">    List&lt;StreamTransformation&lt;T&gt;&gt; unionedTransforms = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    unionedTransforms.add(<span class="keyword">this</span>.transformation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (DataStream&lt;T&gt; newStream : streams) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!getType().equals(newStream.getType())) &#123;   <span class="comment">//判断数据类型是否一致</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot union streams of different types: "</span> + getType() + <span class="string">" and "</span> + newStream.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        unionedTransforms.add(newStream.getTransformation());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建新的数据流</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataStream&lt;&gt;(<span class="keyword">this</span>.environment, <span class="keyword">new</span> UnionTransformation&lt;&gt;(unionedTransforms));<span class="comment">//通过使用 UnionTransformation 将多个 StreamTransformation 合并起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们该如何去使用 union 呢（不止连接一个数据流，也可以连接多个数据流）？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据流 1 和 2</span></span><br><span class="line"><span class="keyword">final</span> DataStream&lt;Integer&gt; stream1 = env.addSource(...);</span><br><span class="line"><span class="keyword">final</span> DataStream&lt;Integer&gt; stream2 = env.addSource(...);</span><br><span class="line"><span class="comment">//union</span></span><br><span class="line">stream1.union(stream2)</span><br></pre></td></tr></table></figure>
<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>该方法可以将两个数据流进行拆分，拆分后的数据流变成了 SplitStream（在下文会详细介绍这个类的内部实现），该 split 方法通过传入一个 OutputSelector 参数进行数据选择，方法内部实现就是构造一个 SplitStream 对象然后返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SplitStream&lt;T&gt; <span class="title">split</span><span class="params">(OutputSelector&lt;T&gt; outputSelector)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SplitStream&lt;&gt;(<span class="keyword">this</span>, clean(outputSelector));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们该如何使用这个方法呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dataStream.split(<span class="keyword">new</span> OutputSelector&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8354166915727490130L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">select</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; s = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">4</span>) &#123;    <span class="comment">//大于 4 的数据放到 &gt; 这个 tag 里面去</span></span><br><span class="line">            s.add(<span class="string">"&gt;"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//小于等于 4 的数据放到 &lt; 这个 tag 里面去</span></span><br><span class="line">            s.add(<span class="string">"&lt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意：该方法已经不推荐使用了！在 1.7 版本以后建议使用 Side Output 来实现分流操作。</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>通过连接不同或相同数据类型的数据流，然后创建一个新的连接数据流，如果连接的数据流也是一个 DataStream 的话，那么连接后的数据流为 ConnectedStreams（会在下文介绍这个类的具体实现），它的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">ConnectedStreams&lt;T, R&gt; <span class="title">connect</span><span class="params">(DataStream&lt;R&gt; dataStream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConnectedStreams&lt;&gt;(environment, <span class="keyword">this</span>, dataStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果连接的数据流是一个 BroadcastStream（广播数据流），那么连接后的数据流是一个 BroadcastConnectedStream（会在下文详细介绍该类的内部实现），它的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">BroadcastConnectedStream&lt;T, R&gt; <span class="title">connect</span><span class="params">(BroadcastStream&lt;R&gt; broadcastStream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BroadcastConnectedStream&lt;&gt;(</span><br><span class="line">            environment, <span class="keyword">this</span>, Preconditions.checkNotNull(broadcastStream), </span><br><span class="line">            broadcastStream.getBroadcastStateDescriptor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、连接 DataStream</span></span><br><span class="line">DataStream&lt;Tuple2&lt;Long, Long&gt;&gt; src1 = env.fromElements(<span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">0L</span>, <span class="number">0L</span>));</span><br><span class="line">DataStream&lt;Tuple2&lt;Long, Long&gt;&gt; src2 = env.fromElements(<span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">0L</span>, <span class="number">0L</span>));</span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt; connected = src1.connect(src2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、连接 BroadcastStream</span></span><br><span class="line">DataStream&lt;Tuple2&lt;Long, Long&gt;&gt; src1 = env.fromElements(<span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">0L</span>, <span class="number">0L</span>));</span><br><span class="line"><span class="keyword">final</span> BroadcastStream&lt;String&gt; broadcast = srcTwo.broadcast(utterDescriptor);</span><br><span class="line">BroadcastConnectedStream&lt;Tuple2&lt;Long, Long&gt;, String&gt; connect = src1.connect(broadcast);</span><br></pre></td></tr></table></figure>
<h4 id="keyBy"><a href="#keyBy" class="headerlink" title="keyBy"></a>keyBy</h4><p>keyBy 方法是用来将数据进行分组的，通过该方法可以将具有相同 key 的数据划分在一起组成新的数据流，该方法有四种（它们的参数各不一样）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、参数是 KeySelector 对象</span></span><br><span class="line"><span class="keyword">public</span> &lt;K&gt; <span class="function">KeyedStream&lt;T, K&gt; <span class="title">keyBy</span><span class="params">(KeySelector&lt;T, K&gt; key)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyedStream&lt;&gt;(<span class="keyword">this</span>, clean(key));<span class="comment">//构造 KeyedStream 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数是 KeySelector 对象和 TypeInformation 对象</span></span><br><span class="line"><span class="keyword">public</span> &lt;K&gt; <span class="function">KeyedStream&lt;T, K&gt; <span class="title">keyBy</span><span class="params">(KeySelector&lt;T, K&gt; key, TypeInformation&lt;K&gt; keyType)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyedStream&lt;&gt;(<span class="keyword">this</span>, clean(key), keyType);<span class="comment">//构造 KeyedStream 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、参数是 1 至多个字段（用 0、1、2... 表示）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> KeyedStream&lt;T, Tuple&gt; <span class="title">keyBy</span><span class="params">(<span class="keyword">int</span>... fields)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getType() <span class="keyword">instanceof</span> BasicArrayTypeInfo || getType() <span class="keyword">instanceof</span> PrimitiveArrayTypeInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span> keyBy(KeySelectorUtil.getSelectorForArray(fields, getType()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> keyBy(<span class="keyword">new</span> Keys.ExpressionKeys&lt;&gt;(fields, getType()));<span class="comment">//调用 private 的 keyBy 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、参数是 1 至多个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> KeyedStream&lt;T, Tuple&gt; <span class="title">keyBy</span><span class="params">(String... fields)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyBy(<span class="keyword">new</span> Keys.ExpressionKeys&lt;&gt;(fields, getType()));<span class="comment">//调用 private 的 keyBy 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正调用的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> KeyedStream&lt;T, Tuple&gt; <span class="title">keyBy</span><span class="params">(Keys&lt;T&gt; keys)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyedStream&lt;&gt;(<span class="keyword">this</span>, clean(KeySelectorUtil.getSelectorForKeys(keys,</span><br><span class="line">            getType(), getExecutionConfig())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何使用呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Event&gt; dataStream = env.fromElements(</span><br><span class="line">    <span class="keyword">new</span> Event(<span class="number">1</span>, <span class="string">"zhisheng01"</span>, <span class="number">1.0</span>),</span><br><span class="line">    <span class="keyword">new</span> Event(<span class="number">2</span>, <span class="string">"zhisheng02"</span>, <span class="number">2.0</span>),</span><br><span class="line">    <span class="keyword">new</span> Event(<span class="number">3</span>, <span class="string">"zhisheng03"</span>, <span class="number">2.1</span>),</span><br><span class="line">    <span class="keyword">new</span> Event(<span class="number">3</span>, <span class="string">"zhisheng04"</span>, <span class="number">3.0</span>),</span><br><span class="line">    <span class="keyword">new</span> SubEvent(<span class="number">4</span>, <span class="string">"zhisheng05"</span>, <span class="number">4.0</span>, <span class="number">1.0</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第1种</span></span><br><span class="line">dataStream.keyBy(<span class="keyword">new</span> KeySelector&lt;Event, Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getKey</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第2种</span></span><br><span class="line">dataStream.keyBy(<span class="keyword">new</span> KeySelector&lt;Event, Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getKey</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, Types.STRING);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第3种</span></span><br><span class="line">dataStream.keyBy(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第4种</span></span><br><span class="line">dataStream.keyBy(<span class="string">"zhisheng01"</span>, <span class="string">"zhisheng02"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="partitionCustom"><a href="#partitionCustom" class="headerlink" title="partitionCustom"></a>partitionCustom</h4><p>使用自定义分区器在指定的 key 字段上将 DataStream 分区，这个 partitionCustom 有 3 个不同参数的方法，分别要传入的参数有自定义分区 Partitioner 对象、位置、字符和 KeySelector。它们内部也都是调用了私有的 partitionCustom 方法。</p>
<h4 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h4><p>broadcast 是将数据流进行广播，然后让下游的每个并行 Task 中都可以获取到这份数据流，通常这些数据是一些配置，一般这些配置数据的数据量不能太大，否则资源消耗会比较大。这个 broadcast 方法也有两个，一个是无参数，它返回的数据是 DataStream；另一种的参数是 MapStateDescriptor，它返回的参数是 BroadcastStream（这个也会在下文详细介绍）。</p>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、第一种</span></span><br><span class="line">DataStream&lt;Tuple2&lt;Integer, String&gt;&gt; source = env.addSource(...).broadcast();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、第二种</span></span><br><span class="line"><span class="keyword">final</span> MapStateDescriptor&lt;Long, String&gt; utterDescriptor = <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(</span><br><span class="line">        <span class="string">"broadcast-state"</span>, BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO</span><br><span class="line">);</span><br><span class="line"><span class="keyword">final</span> DataStream&lt;String&gt; srcTwo = env.fromCollection(expected.values());</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> BroadcastStream&lt;String&gt; broadcast = srcTwo.broadcast(utterDescriptor);</span><br></pre></td></tr></table></figure>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map 方法需要传入的参数是一个 MapFunction，当然传入 RichMapFunction 也是可以的，它返回的是 SingleOutputStreamOperator（这个类在会在下文详细介绍），该 map 方法里面的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">map</span><span class="params">(MapFunction&lt;T, R&gt; mapper)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TypeInformation&lt;R&gt; outType = TypeExtractor.getMapReturnTypes(clean(mapper), getType(),</span><br><span class="line">            Utils.getCallLocationName(), <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//调用 transform 方法</span></span><br><span class="line">    <span class="keyword">return</span> transform(<span class="string">"Map"</span>, outType, <span class="keyword">new</span> StreamMap&lt;&gt;(clean(mapper)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法平时使用的非常频繁，然后我们该如何使用这个方法呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dataStream.map(<span class="keyword">new</span> MapFunction&lt;Integer, String&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(Integer value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p>flatMap 方法需要传入一个 FlatMapFunction 参数，当然传入 RichFlatMapFunction 也是可以的，如果你的 Flink Job 里面有连续的 filter 和 map 算子在一起，可以考虑使用 flatMap 一个算子来完成两个算子的工作，它返回的是 SingleOutputStreamOperator，该 flatMap 方法里面的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">flatMap</span><span class="params">(FlatMapFunction&lt;T, R&gt; flatMapper)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TypeInformation&lt;R&gt; outType = TypeExtractor.getFlatMapReturnTypes(clean(flatMapper),</span><br><span class="line">            getType(), Utils.getCallLocationName(), <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//调用 transform 方法</span></span><br><span class="line">    <span class="keyword">return</span> transform(<span class="string">"Flat Map"</span>, outType, <span class="keyword">new</span> StreamFlatMap&lt;&gt;(clean(flatMapper)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法平时使用的非常频繁，使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dataStream.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Integer value, Collector&lt;Integer&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.collect(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>在输入流上应用给定的 ProcessFunction，从而创建转换后的输出流，通过该方法返回的是 SingleOutputStreamOperator，具体代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">process</span><span class="params">(ProcessFunction&lt;T, R&gt; processFunction)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TypeInformation&lt;R&gt; outType = TypeExtractor.getUnaryOperatorReturnType(</span><br><span class="line">        processFunction, ProcessFunction.class, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        TypeExtractor.NO_INDEX, getType(), Utils.getCallLocationName(), <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//调用下面的 process 方法</span></span><br><span class="line">    <span class="keyword">return</span> process(processFunction, outType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessFunction&lt;T, R&gt; processFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">        TypeInformation&lt;R&gt; outputType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ProcessOperator&lt;T, R&gt; operator = <span class="keyword">new</span> ProcessOperator&lt;&gt;(clean(processFunction));</span><br><span class="line">    <span class="comment">//调用 transform 方法</span></span><br><span class="line">    <span class="keyword">return</span> transform(<span class="string">"Process"</span>, outputType, operator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DataStreamSource&lt;Long&gt; data = env.generateSequence(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的 ProcessFunction</span></span><br><span class="line">ProcessFunction&lt;Long, Integer&gt; processFunction = <span class="keyword">new</span> ProcessFunction&lt;Long, Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Long value, Context ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">            Collector&lt;Integer&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//具体逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">            Collector&lt;Integer&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//具体逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DataStream&lt;Integer&gt; processed = data.keyBy(<span class="keyword">new</span> IdentityKeySelector&lt;Long&gt;()).process(processFunction);</span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter 用来过滤数据的，它需要传入一个 FilterFunction，然后返回的数据也是 SingleOutputStreamOperator，该方法的实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SingleOutputStreamOperator&lt;T&gt; <span class="title">filter</span><span class="params">(FilterFunction&lt;T&gt; filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transform(<span class="string">"Filter"</span>, getType(), <span class="keyword">new</span> StreamFilter&lt;&gt;(clean(filter)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法平时使用非常多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; filter1 = src</span><br><span class="line">    .filter(<span class="keyword">new</span> FilterFunction&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"zhisheng"</span>.equals(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>上面这些方法是平时写代码时用的非常多的方法，我们这里讲解了它们的实现原理和使用方式，当然还有其他方法，比如 assignTimestampsAndWatermarks、join、shuffle、forward、addSink、rebalance、iterate、coGroup、project、timeWindowAll、countWindowAll、windowAll、print 等，这里由于篇幅的问题就不一一展开来讲了。</p>
<h3 id="SingleOutputStreamOperator-如何使用及分析"><a href="#SingleOutputStreamOperator-如何使用及分析" class="headerlink" title="SingleOutputStreamOperator 如何使用及分析"></a>SingleOutputStreamOperator 如何使用及分析</h3><p>SingleOutputStreamOperator 这个类继承自 DataStream，所以 DataStream 中有的方法在这里也都有，那么这里就讲解下额外的方法的作用，如下。</p>
<ul>
<li>name()：该方法可以设置当前数据流的名称，如果设置了该值，则可以在 Flink UI 上看到该值；uid() 方法可以为算子设置一个指定的 ID，该 ID 有个作用就是如果想从 savepoint 恢复 Job 时是可以根据这个算子的 ID 来恢复到它之前的运行状态；</li>
<li>setParallelism() ：该方法是为每个算子单独设置并行度的，这个设置优先于你通过 env 设置的全局并行度；</li>
<li>setMaxParallelism() ：该为算子设置最大的并行度；</li>
<li>setResources()：该方法有两个（参数不同），设置算子的资源，但是这两个方法对外还没开放（是私有的，暂时功能性还不全）；</li>
<li>forceNonParallel()：该方法强行将并行度和最大并行度都设置为 1；</li>
<li>setChainingStrategy()：该方法对给定的算子设置 ChainingStrategy；</li>
<li>disableChaining()：该这个方法设置后将禁止该算子与其他的算子 chain 在一起；</li>
<li>getSideOutput()：该方法通过给定的 OutputTag 参数从 side output 中来筛选出对应的数据流。</li>
</ul>
<h3 id="KeyedStream-如何使用及分析"><a href="#KeyedStream-如何使用及分析" class="headerlink" title="KeyedStream 如何使用及分析"></a>KeyedStream 如何使用及分析</h3><p>KeyedStream 是 DataStream 在根据 KeySelector 分区后的数据流，DataStream 中常用的方法在 KeyedStream 后也可以用（除了 shuffle、forward 和 keyBy 等分区方法），在该类中的属性分别是 KeySelector 和 TypeInformation。</p>
<p>DataStream 中的窗口方法只有 timeWindowAll、countWindowAll 和 windowAll 这三种全局窗口方法，但是在 KeyedStream 类中的种类就稍微多了些，新增了 timeWindow、countWindow 方法，并且是还支持滑动窗口。</p>
<p>除了窗口方法的新增外，还支持大量的聚合操作方法，比如 reduce、fold、sum、min、max、minBy、maxBy、aggregate 等方法（列举的这几个方法都支持多种参数的）。</p>
<p>最后就是它还有 asQueryableState() 方法，能够将 KeyedStream 发布为可查询的 ValueState 实例。</p>
<h3 id="SplitStream-如何使用及分析"><a href="#SplitStream-如何使用及分析" class="headerlink" title="SplitStream 如何使用及分析"></a>SplitStream 如何使用及分析</h3><p>SplitStream 这个类比较简单，它代表着数据分流后的数据流了，它有一个 select 方法可以选择分流后的哪种数据流了，通常它是结合 split 使用的，对于单次分流来说还挺方便的。但是它是一个被废弃的类（Flink 1.7 后被废弃的，可以看下笔者之前写的一篇文章 <a href="http://www.54tianzhisheng.cn/2019/06/12/flink-split/" target="_blank" rel="noopener">Flink 从0到1学习—— Flink 不可以连续 Split(分流)？</a> ），其实可以用 side output 来代替这种 split，后面文章中我们也会讲通过简单的案例来讲解一下该如何使用 side output 做数据分流操作。</p>
<p>因为这个类的源码比较少，我们可以看下这个类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitStream</span>&lt;<span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">DataStream</span>&lt;<span class="title">OUT</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SplitStream</span><span class="params">(DataStream&lt;OUT&gt; dataStream, OutputSelector&lt;OUT&gt; outputSelector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dataStream.getExecutionEnvironment(), <span class="keyword">new</span> SplitTransformation&lt;OUT&gt;(dataStream.getTransformation(), outputSelector));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择要输出哪种数据流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataStream&lt;OUT&gt; <span class="title">select</span><span class="params">(String... outputNames)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selectOutput(outputNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面那个 public 方法内部调用的就是这个方法，该方法是个 private 方法，对外隐藏了它是如何去找到特定的数据流。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DataStream&lt;OUT&gt; <span class="title">selectOutput</span><span class="params">(String[] outputNames)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String outName : outputNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (outName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Selected names must not be null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造了一个 SelectTransformation 对象</span></span><br><span class="line">        SelectTransformation&lt;OUT&gt; selectTransform = <span class="keyword">new</span> SelectTransformation&lt;OUT&gt;(<span class="keyword">this</span>.getTransformation(), Lists.newArrayList(outputNames));</span><br><span class="line">        <span class="comment">//构造了一个 DataStream 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataStream&lt;OUT&gt;(<span class="keyword">this</span>.getExecutionEnvironment(), selectTransform);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WindowedStream-如何使用及分析"><a href="#WindowedStream-如何使用及分析" class="headerlink" title="WindowedStream 如何使用及分析"></a>WindowedStream 如何使用及分析</h3><p>虽然 WindowedStream 不是继承自 DataStream，并且我们在 3.1 节中也做了一定的讲解，但是当时没讲里面的 Function，所以在这里刚好一起做一个补充。</p>
<p>在 WindowedStream 类中定义的属性有 KeyedStream、WindowAssigner、Trigger、Evictor、allowedLateness 和 lateDataOutputTag。</p>
<ul>
<li>KeyedStream：代表着数据流，数据分组后再开 Window</li>
<li>WindowAssigner：Window 的组件之一</li>
<li>Trigger：Window 的组件之一</li>
<li>Evictor：Window 的组件之一（可选）</li>
<li>allowedLateness：用户指定的允许迟到时间长</li>
<li>lateDataOutputTag：数据延迟到达的 Side output，如果延迟数据没有设置任何标记，则会被丢弃</li>
</ul>
<p>在 3.1 节中我们讲了上面的三个窗口组件 WindowAssigner、Trigger、Evictor，并教大家该如何使用，那么在这篇文章我就不再重复，那么接下来就来分析下其他几个的使用方式和其实现原理。</p>
<p>先来看下 allowedLateness 这个它可以在窗口后指定允许迟到的时间长，使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataStream.keyBy(<span class="number">0</span>)</span><br><span class="line">    .timeWindow(Time.milliseconds(<span class="number">20</span>))</span><br><span class="line">    .allowedLateness(Time.milliseconds(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>lateDataOutputTag 这个它将延迟到达的数据发送到由给定 OutputTag 标识的 side output（侧输出），当水印经过窗口末尾（并加上了允许的延迟后），数据就被认为是延迟了。</p>
<p>对于 keyed windows 有五个不同参数的 reduce 方法可以使用，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、参数为 ReduceFunction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SingleOutputStreamOperator&lt;T&gt; <span class="title">reduce</span><span class="params">(ReduceFunction&lt;T&gt; function)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> reduce(function, <span class="keyword">new</span> PassThroughWindowFunction&lt;K, W, T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数为 ReduceFunction 和 WindowFunction</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">reduce</span><span class="params">(ReduceFunction&lt;T&gt; reduceFunction, WindowFunction&lt;T, R, K, W&gt; function)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> reduce(reduceFunction, function, resultType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、参数为 ReduceFunction、WindowFunction 和 TypeInformation</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">reduce</span><span class="params">(ReduceFunction&lt;T&gt; reduceFunction, WindowFunction&lt;T, R, K, W&gt; function, TypeInformation&lt;R&gt; resultType)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> input.transform(opName, resultType, operator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、参数为 ReduceFunction 和 ProcessWindowFunction</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">reduce</span><span class="params">(ReduceFunction&lt;T&gt; reduceFunction, ProcessWindowFunction&lt;T, R, K, W&gt; function)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> reduce(reduceFunction, function, resultType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、参数为 ReduceFunction、ProcessWindowFunction 和 TypeInformation</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">reduce</span><span class="params">(ReduceFunction&lt;T&gt; reduceFunction, ProcessWindowFunction&lt;T, R, K, W&gt; function, TypeInformation&lt;R&gt; resultType)</span> </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">return</span> input.transform(opName, resultType, operator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 reduce 方法，还有六个不同参数的 fold 方法、aggregate 方法；两个不同参数的 apply 方法、process 方法（其中你会发现这两个 apply 方法和 process 方法内部其实都隐式的调用了一个私有的 apply 方法）；其实除了前面说的两个不同参数的 apply 方法外，还有四个其他的 apply 方法，这四个方法也是参数不同，但是其实最终的是利用了 transform 方法；还有的就是一些预定义的聚合方法比如 sum、min、minBy、max、maxBy，它们的方法参数的个数不一致，这些预聚合的方法内部调用的其实都是私有的 aggregate 方法，该方法允许你传入一个 AggregationFunction 参数。我们来看一个具体的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//max</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SingleOutputStreamOperator&lt;T&gt; <span class="title">max</span><span class="params">(String field)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//内部调用私有的的 aggregate 方法</span></span><br><span class="line">    <span class="keyword">return</span> aggregate(<span class="keyword">new</span> ComparableAggregator&lt;&gt;(field, input.getType(), AggregationFunction.AggregationType.MAX, <span class="keyword">false</span>, input.getExecutionConfig()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有的 aggregate 方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SingleOutputStreamOperator&lt;T&gt; <span class="title">aggregate</span><span class="params">(AggregationFunction&lt;T&gt; aggregator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续调用的是 reduce 方法</span></span><br><span class="line">    <span class="keyword">return</span> reduce(aggregator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该 reduce 方法内部其实又是调用了其他多个参数的 reduce 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SingleOutputStreamOperator&lt;T&gt; <span class="title">reduce</span><span class="params">(ReduceFunction&lt;T&gt; function)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    function = input.getExecutionEnvironment().clean(function);</span><br><span class="line">    <span class="keyword">return</span> reduce(function, <span class="keyword">new</span> PassThroughWindowFunction&lt;K, W, T&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的方法调用过程，你会发现代码封装的很深，得需要你自己好好跟一下源码才可以了解更深些。</p>
<p>上面讲了这么多方法，你会发现 reduce 方法其实是用的蛮多的之一，那么就来看看该如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dataStream.keyBy(<span class="number">0</span>)</span><br><span class="line">    .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">    .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Integer&gt; value1, Tuple2&lt;String, Integer&gt; value2)</span>  </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .print();</span><br></pre></td></tr></table></figure>
<h3 id="AllWindowedStream-如何使用及分析"><a href="#AllWindowedStream-如何使用及分析" class="headerlink" title="AllWindowedStream 如何使用及分析"></a>AllWindowedStream 如何使用及分析</h3><p>前面讲完了 WindowedStream，再来看看这个 AllWindowedStream 你会发现它的实现其实无太大区别，该类中的属性和方法都和前面 WindowedStream 是一样的，然后我们就不再做过多的介绍，直接来看看该如何使用呢？</p>
<p>AllWindowedStream 这种场景下是不需要让数据流做 keyBy 分组操作，直接就进行 windowAll 操作，然后在 windowAll 方法中传入 WindowAssigner 参数对象即可，然后返回的数据结果就是 AllWindowedStream 了，下面使用方式继续执行了 AllWindowedStream 中的 reduce 方法来返回数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dataStream.windowAll(SlidingEventTimeWindows.of(Time.of(<span class="number">1</span>, TimeUnit.SECONDS), Time.of(<span class="number">100</span>, TimeUnit.MILLISECONDS)))</span><br><span class="line">    .reduce(<span class="keyword">new</span> RichReduceFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6448847205314995812L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Integer&gt; value1,</span></span></span><br><span class="line"><span class="function"><span class="params">                Tuple2&lt;String, Integer&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="ConnectedStreams-如何使用及分析"><a href="#ConnectedStreams-如何使用及分析" class="headerlink" title="ConnectedStreams 如何使用及分析"></a>ConnectedStreams 如何使用及分析</h3><p>ConnectedStreams 这个类定义是表示（可能）两个不同数据类型的数据连接流，该场景如果对一个数据流进行操作会直接影响另一个数据流，因此可以通过流连接来共享状态。比较常见的一个例子就是一个数据流（随时间变化的规则数据流）通过连接其他的数据流，这样另一个数据流就可以利用这些连接的规则数据流。</p>
<p>ConnectedStreams 在概念上可以认为和 Union 数据流是一样的。</p>
<p>在 ConnectedStreams 类中有三个属性：environment、inputStream1 和 inputStream2，该类中的方法如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0yvb90dej21em0rygnv.jpg" alt="undefined"></p>
<p>在 ConnectedStreams 中可以通过 getFirstInput 获取连接的第一个流、通过 getSecondInput 获取连接的第二个流，同时它还含有六个 keyBy 方法来将连接后的数据流进行分组，这六个 keyBy 方法的参数各有不同。另外它还含有 map、flatMap、process 方法来处理数据（其中 map 和 flatMap 方法的参数分别使用的是 CoMapFunction 和 CoFlatMapFunction），其实如果你细看其方法里面的实现就会发现都是调用的 transform 方法。</p>
<p>上面讲完了 ConnectedStreams 类的基础定义，接下来我们来看下该类如何使用呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;Long, Long&gt;&gt; src1 = env.fromElements(<span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">0L</span>, <span class="number">0L</span>));    <span class="comment">//流 1</span></span><br><span class="line">DataStream&lt;Tuple2&lt;Long, Long&gt;&gt; src2 = env.fromElements(<span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">0L</span>, <span class="number">0L</span>));    <span class="comment">//流 2</span></span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt; connected = src1.connect(src2);    <span class="comment">//连接流 1 和流 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用连接流的六种 keyBy 方法</span></span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt; connectedGroup1 = connected.keyBy(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt; connectedGroup2 = connected.keyBy(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;);</span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt; connectedGroup3 = connected.keyBy(<span class="string">"f0"</span>, <span class="string">"f0"</span>);</span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt; connectedGroup4 = connected.keyBy(<span class="keyword">new</span> String[]&#123;<span class="string">"f0"</span>&#125;, <span class="keyword">new</span> String[]&#123;<span class="string">"f0"</span>&#125;);</span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt; connectedGroup5 = connected.keyBy(<span class="keyword">new</span> FirstSelector(), <span class="keyword">new</span> FirstSelector());</span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt; connectedGroup5 = connected.keyBy(<span class="keyword">new</span> FirstSelector(), <span class="keyword">new</span> FirstSelector(), Types.STRING);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用连接流的 map 方法</span></span><br><span class="line">connected.map(<span class="keyword">new</span> CoMapFunction&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;, Object&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">map1</span><span class="params">(Tuple2&lt;Long, Long&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">map2</span><span class="params">(Tuple2&lt;Long, Long&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用连接流的 flatMap 方法</span></span><br><span class="line">connected.flatMap(<span class="keyword">new</span> CoFlatMapFunction&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap1</span><span class="params">(Tuple2&lt;Long, Long&gt; value, Collector&lt;Tuple2&lt;Long, Long&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap2</span><span class="params">(Tuple2&lt;Long, Long&gt; value, Collector&lt;Tuple2&lt;Long, Long&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;).name(<span class="string">"testCoFlatMap"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用连接流的 process 方法</span></span><br><span class="line">connected.process(<span class="keyword">new</span> CoProcessFunction&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement1</span><span class="params">(Tuple2&lt;Long, Long&gt; value, Context ctx, Collector&lt;Tuple2&lt;Long, Long&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value.f0 &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            out.collect(value);</span><br><span class="line">            ctx.output(sideOutputTag, <span class="string">"sideout1-"</span> + String.valueOf(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement2</span><span class="params">(Tuple2&lt;Long, Long&gt; value, Context ctx, Collector&lt;Tuple2&lt;Long, Long&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value.f0 &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            out.collect(value);</span><br><span class="line">            ctx.output(sideOutputTag, <span class="string">"sideout2-"</span> + String.valueOf(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="BroadcastStream-如何使用及分析"><a href="#BroadcastStream-如何使用及分析" class="headerlink" title="BroadcastStream 如何使用及分析"></a>BroadcastStream 如何使用及分析</h3><p>BroadcastStream 这个类定义是表示 broadcast state（广播状态）组成的数据流。通常这个 BroadcastStream 数据流是通过调用 DataStream 中的 broadcast 方法才返回的，注意 BroadcastStream 后面不能使用算子去操作这些流，唯一可以做的就是使用 KeyedStream/DataStream 的 connect 方法去连接 BroadcastStream，连接之后的话就会返回一个 BroadcastConnectedStream 数据流。</p>
<p>在 BroadcastStream 中我们该如何使用呢？通常是在 DataStream 中使用 broadcast 方法，该方法需要传入一个 MapStateDescriptor 对象，可以看下该方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BroadcastStream&lt;T&gt; <span class="title">broadcast</span><span class="params">(<span class="keyword">final</span> MapStateDescriptor&lt;?, ?&gt;... broadcastStateDescriptors)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(broadcastStateDescriptors);  <span class="comment">//检查是否为空</span></span><br><span class="line">    <span class="keyword">final</span> DataStream&lt;T&gt; broadcastStream = setConnectionType(<span class="keyword">new</span> BroadcastPartitioner&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BroadcastStream&lt;&gt;(environment, broadcastStream, broadcastStateDescriptors);  <span class="comment">//构建 BroadcastStream 对象，传入 env 环境、broadcastStream 和 broadcastStateDescriptors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法传入的参数 broadcastStateDescriptors，我们可以像下面这样去定义一个 MapStateDescriptor 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> MapStateDescriptor&lt;Long, String&gt; utterDescriptor = <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(</span><br><span class="line">    <span class="string">"broadcast-state"</span>, BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="BroadcastConnectedStream-如何使用及分析"><a href="#BroadcastConnectedStream-如何使用及分析" class="headerlink" title="BroadcastConnectedStream 如何使用及分析"></a>BroadcastConnectedStream 如何使用及分析</h3><p>BroadcastConnectedStream 这个类定义是表示 keyed 或者 non-keyed 数据流和 BroadcastStream 数据流进行连接后组成的数据流。比如在 DataStream 中执行 connect 方法就可以连接两个数据流了，那么在 DataStream 中 connect 方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">BroadcastConnectedStream&lt;T, R&gt; <span class="title">connect</span><span class="params">(BroadcastStream&lt;R&gt; broadcastStream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BroadcastConnectedStream&lt;&gt;( <span class="comment">//构造 BroadcastConnectedStream 对象</span></span><br><span class="line">            environment,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            Preconditions.checkNotNull(broadcastStream),</span><br><span class="line">            broadcastStream.getBroadcastStateDescriptor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个 BroadcastConnectedStream 类中主要的方法有：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0yvm1xntj21hq0hujsj.jpg" alt="undefined"></p>
<p>从图中可以看到四个 process 方法和一个 transform 私有方法，其中四个 process 方法也是参数不同，最后实际调用的方法就是这个私有的 transform 方法。</p>
<h3 id="QueryableStateStream-如何使用及分析"><a href="#QueryableStateStream-如何使用及分析" class="headerlink" title="QueryableStateStream 如何使用及分析"></a>QueryableStateStream 如何使用及分析</h3><p>QueryableStateStream 该类代表着可查询的状态流。该类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryableStateStream</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要查询的状态名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String queryableStateName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态的 Key 序列化器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeSerializer&lt;K&gt; keySerializer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态的 descriptor </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StateDescriptor&lt;?, V&gt; stateDescriptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueryableStateStream</span><span class="params">(String queryableStateName, StateDescriptor&lt;?, V&gt; stateDescriptor, TypeSerializer&lt;K&gt; keySerializer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回可以查询状态的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getQueryableStateName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queryableStateName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回 key 序列化器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TypeSerializer&lt;K&gt; <span class="title">getKeySerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keySerializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回状态的 descriptor </span></span><br><span class="line">    <span class="keyword">public</span> StateDescriptor&lt;?, V&gt; getStateDescriptor() &#123;</span><br><span class="line">        <span class="keyword">return</span> stateDescriptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 KeyedStream 你可以通过 asQueryableState() 方法返回一个 QueryableStateStream 数据流，这个方法可以通过传入不同的参数来实现，主要的参数就是 queryableStateName 和 StateDescriptor（这个参数你可以传入 ValueStateDescriptor、FoldingStateDescriptor 和 ReducingStateDescriptor 三种）。</p>
<p>具体如何使用呢，我们来看个 demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ValueStateDescriptor&lt;Tuple2&lt;Integer, Long&gt;&gt; valueState = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(</span><br><span class="line">    <span class="string">"any"</span>, source.getType(),    <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">QueryableStateStream&lt;Integer, Tuple2&lt;Integer, Long&gt;&gt; queryableState =</span><br><span class="line">    source.keyBy(<span class="keyword">new</span> KeySelector&lt;Tuple2&lt;Integer, Long&gt;, Integer&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7480503339992214681L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getKey</span><span class="params">(Tuple2&lt;Integer, Long&gt; value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.f0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).asQueryableState(<span class="string">"zhisheng"</span>, valueState);</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本节算是对 Flink DataStream 包下的所有常用的 Stream 做了个讲解，不仅从使用方式来介绍这些 Stream API 该如何使用，而且还给出了部分 demo，此外还剖析了部分 Stream 的代码结构及其内部部分方法的源码实现，从而能够让大家不仅仅是从表面上去使用这些 DataStream API，还能够对它们的实现原理有了解，这样就可以做到活学活用，并且还可以自己去做扩展。</p>
<h2 id="十二、Flink-WaterMark-详解及结合-WaterMark-处理延迟数据"><a href="#十二、Flink-WaterMark-详解及结合-WaterMark-处理延迟数据" class="headerlink" title="十二、Flink WaterMark 详解及结合 WaterMark 处理延迟数据"></a>十二、Flink WaterMark 详解及结合 WaterMark 处理延迟数据</h2><p>在 3.1 节中讲解了 Flink 中的三种 Time 和其对应的使用场景，然后在 3.2 节中深入的讲解了 Flink 中窗口的机制以及 Flink 中自带的 Window 的实现原理和使用方法。如果在进行 Window 计算操作的时候，如果使用的时间是 Processing Time，那么在 Flink 消费数据的时候，它完全不需要关心的数据本身的时间，意思也就是说不需要关心数据到底是延迟数据还是乱序数据。因为 Processing Time 只是代表数据在 Flink 被处理时的时间，这个时间是顺序的。但是如果你使用的是 Event Time 的话，那么你就不得不面临着这么个问题：事件乱序 &amp; 事件延迟。</p>
<p>下图表示选择 Event Time 与 Process Time 的实际效果图：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zf4f9lvj217e0om74r.jpg" alt="undefined"></p>
<p>在理想的情况下，Event Time 和 Process Time 是相等的，数据发生的时间与数据处理的时间没有延迟，但是现实却仍然这么骨感，会因为各种各样的问题（网络的抖动、设备的故障、应用的异常等原因）从而导致如图中曲线一样，Process Time 总是会与 Event Time 有一些延迟。所谓乱序，其实是指 Flink 接收到的事件的先后顺序并不是严格的按照事件的 Event Time 顺序排列的。比如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zfc2xczj20s20hsaaj.jpg" alt="undefined"></p>
<p>然而在有些场景下，其实是特别依赖于事件时间而不是处理时间，比如：</p>
<ul>
<li>错误日志的时间戳，代表着发生的错误的具体时间，开发们只有知道了这个时间戳，才能去还原那个时间点系统到底发生了什么问题，或者根据那个时间戳去关联其他的事件，找出导致问题触发的罪魁祸首</li>
<li>设备传感器或者监控系统实时上传对应时间点的设备周围的监控情况，通过监控大屏可以实时查看，不错漏重要或者可疑的事件</li>
</ul>
<p>这种情况下，最有意义的事件发生的顺序，而不是事件到达 Flink 后被处理的顺序。庆幸的是 Flink 支持用户以事件时间来定义窗口（也支持以处理时间来定义窗口），那么这样就要去解决上面所说的两个问题。针对上面的问题（事件乱序 &amp; 事件延迟），Flink 引入了 Watermark 机制来解决。</p>
<h3 id="Watermark-是什么？"><a href="#Watermark-是什么？" class="headerlink" title="Watermark 是什么？"></a>Watermark 是什么？</h3><p>举个例子：</p>
<p>统计 8:00 ~ 9:00 这个时间段打开淘宝 App 的用户数量，Flink 这边可以开个窗口做聚合操作，但是由于网络的抖动或者应用采集数据发送延迟等问题，于是无法保证在窗口时间结束的那一刻窗口中是否已经收集好了在 8:00 ~ 9:00 中用户打开 App 的事件数据，但又不能无限期的等下去？当基于事件时间的数据流进行窗口计算时，最为困难的一点也就是如何确定对应当前窗口的事件已经全部到达。然而实际上并不能百分百的准确判断，因此业界常用的方法就是基于已经收集的消息来估算是否还有消息未到达，这就是 Watermark 的思想。</p>
<p>Watermark 是一种衡量 Event Time 进展的机制，它是数据本身的一个隐藏属性，数据本身携带着对应的 Watermark。Watermark 本质来说就是一个时间戳，代表着比这时间戳早的事件已经全部到达窗口，即假设不会再有比这时间戳还小的事件到达，这个假设是触发窗口计算的基础，只有 Watermark 大于窗口对应的结束时间，窗口才会关闭和进行计算。按照这个标准去处理数据，那么如果后面还有比这时间戳更小的数据，那么就视为迟到的数据，对于这部分迟到的数据，Flink 也有相应的机制（下文会讲）去处理。</p>
<p>下面通过几个图来了解一下 Watermark 是如何工作的！</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zfu71ysj21e20p0dgv.jpg" alt="undefined"></p>
<p>上图中的数据是 Flink 从消息队列中消费的，然后在 Flink 中有个 4s 的时间窗口（根据事件时间定义的窗口），消息队列中的数据是乱序过来的，数据上的数字代表着数据本身的 timestamp，<code>W(4)</code> 和 <code>W(9)</code> 是水印。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zqks7btj21ik0pqdgr.jpg" alt="undefined"></p>
<p>经过 Flink 的消费，数据 <code>1</code>、<code>3</code>、<code>2</code> 进入了第一个窗口，然后 <code>7</code> 会进入第二个窗口，接着 <code>3</code> 依旧会进入第一个窗口，然后就有水印了，此时水印过来了，就会发现水印的 timestamp 和第一个窗口结束时间是一致的，那么它就表示在后面不会有比 <code>4</code> 还小的数据过来了，接着就会触发第一个窗口的计算操作，如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zqrrk6kj21bi0nkgmc.jpg" alt="undefined"></p>
<p>那么接着后面的数据 <code>5</code> 和 <code>6</code> 会进入到第二个窗口里面，数据 <code>9</code> 会进入在第三个窗口里面。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zqyn66nj21cm0lsq46.jpg" alt="undefined"></p>
<p>那么当遇到水印 <code>9</code> 时，发现水印比第二个窗口的结束时间 <code>8</code> 还大，所以第二个窗口也会触发进行计算，然后以此继续类推下去。</p>
<p>相信看完上面几个图的讲解，你已经知道了 Watermark 的工作原理是啥了，那么在 Flink 中该如何去配置水印呢，下面一起来看看。</p>
<h3 id="Flink-中-Watermark-的设置"><a href="#Flink-中-Watermark-的设置" class="headerlink" title="Flink 中 Watermark 的设置"></a>Flink 中 Watermark 的设置</h3><p>在 Flink 中，数据处理中需要通过调用 DataStream 中的 assignTimestampsAndWatermarks 方法来分配时间和水印，该方法可以传入两种参数，一个是 AssignerWithPeriodicWatermarks，另一个是 AssignerWithPunctuatedWatermarks。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SingleOutputStreamOperator&lt;T&gt; <span class="title">assignTimestampsAndWatermarks</span><span class="params">(AssignerWithPeriodicWatermarks&lt;T&gt; timestampAndWatermarkAssigner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> inputParallelism = getTransformation().getParallelism();</span><br><span class="line">    <span class="keyword">final</span> AssignerWithPeriodicWatermarks&lt;T&gt; cleanedAssigner = clean(timestampAndWatermarkAssigner);</span><br><span class="line"></span><br><span class="line">    TimestampsAndPeriodicWatermarksOperator&lt;T&gt; operator = <span class="keyword">new</span> TimestampsAndPeriodicWatermarksOperator&lt;&gt;(cleanedAssigner);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transform(<span class="string">"Timestamps/Watermarks"</span>, getTransformation().getOutputType(), operator).setParallelism(inputParallelism);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SingleOutputStreamOperator&lt;T&gt; <span class="title">assignTimestampsAndWatermarks</span><span class="params">(AssignerWithPunctuatedWatermarks&lt;T&gt; timestampAndWatermarkAssigner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> inputParallelism = getTransformation().getParallelism();</span><br><span class="line">    <span class="keyword">final</span> AssignerWithPunctuatedWatermarks&lt;T&gt; cleanedAssigner = clean(timestampAndWatermarkAssigner);</span><br><span class="line"></span><br><span class="line">    TimestampsAndPunctuatedWatermarksOperator&lt;T&gt; operator = <span class="keyword">new</span> TimestampsAndPunctuatedWatermarksOperator&lt;&gt;(cleanedAssigner);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transform(<span class="string">"Timestamps/Watermarks"</span>, getTransformation().getOutputType(), operator).setParallelism(inputParallelism);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以设置 Watermark 是有如下两种方式：</p>
<ul>
<li>AssignerWithPunctuatedWatermarks：数据流中每一个递增的 EventTime 都会产生一个 Watermark。</li>
</ul>
<p>在实际的生产环境中，在 TPS 很高的情况下会产生大量的 Watermark，可能在一定程度上会对下游算子造成一定的压力，所以只有在实时性要求非常高的场景才会选择这种方式来进行水印的生成。</p>
<ul>
<li>AssignerWithPeriodicWatermarks：周期性的（一定时间间隔或者达到一定的记录条数）产生一个 Watermark。</li>
</ul>
<p>在实际的生产环境中，通常这种使用较多，它会周期性产生 Watermark 的方式，但是必须结合时间或者积累条数两个维度，否则在极端情况下会有很大的延时，所以 Watermark 的生成方式需要根据业务场景的不同进行不同的选择。</p>
<p>下面再分别详细讲下这两种的实现方式。</p>
<h3 id="Punctuated-Watermark"><a href="#Punctuated-Watermark" class="headerlink" title="Punctuated Watermark"></a>Punctuated Watermark</h3><p>AssignerWithPunctuatedWatermarks 接口中包含了 checkAndGetNextWatermark 方法，这个方法会在每次 extractTimestamp() 方法被调用后调用，它可以决定是否要生成一个新的水印，返回的水印只有在不为 null 并且时间戳要大于先前返回的水印时间戳的时候才会发送出去，如果返回的水印是 null 或者返回的水印时间戳比之前的小则不会生成新的水印。</p>
<p>那么该怎么利用这个来定义水印生成器呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordPunctuatedWatermark</span> <span class="keyword">implements</span> <span class="title">AssignerWithPunctuatedWatermarks</span>&lt;<span class="title">Word</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Watermark <span class="title">checkAndGetNextWatermark</span><span class="params">(Word lastElement, <span class="keyword">long</span> extractedTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> extractedTimestamp % <span class="number">3</span> == <span class="number">0</span> ? <span class="keyword">new</span> Watermark(extractedTimestamp) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Word element, <span class="keyword">long</span> previousElementTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element.getTimestamp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是这种情况下可以为每个事件都生成一个水印，但是因为水印是要在下游参与计算的，所以过多的话会导致整体计算性能下降。</p>
<h3 id="3-5-4-Periodic-Watermark"><a href="#3-5-4-Periodic-Watermark" class="headerlink" title="3.5.4 Periodic Watermark"></a>3.5.4 Periodic Watermark</h3><p>通常在生产环境中使用 AssignerWithPeriodicWatermarks 来定期分配时间戳并生成水印比较多，那么先来讲下这个该如何使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordWatermark</span> <span class="keyword">implements</span> <span class="title">AssignerWithPeriodicWatermarks</span>&lt;<span class="title">Word</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> currentTimestamp = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Word word, <span class="keyword">long</span> previousElementTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word.getTimestamp() &gt; currentTimestamp) &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentTimestamp = word.getTimestamp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Watermark <span class="title">getCurrentWatermark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> maxTimeLag = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Watermark(currentTimestamp == Long.MIN_VALUE ? Long.MIN_VALUE : currentTimestamp - maxTimeLag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的是我根据 Word 数据自定义的水印周期性生成器，在这个类中，有两个方法 extractTimestamp() 和 getCurrentWatermark()。extractTimestamp() 方法是从数据本身中提取 Event Time，该方法会返回当前时间戳与事件时间进行比较，如果事件的时间戳比 currentTimestamp 大的话，那么就将当前事件的时间戳赋值给 currentTimestamp。getCurrentWatermark() 方法是获取当前的水位线，这里有个 maxTimeLag 参数代表数据能够延迟的时间，上面代码中定义的 <code>long maxTimeLag = 5000;</code> 表示最大允许数据延迟时间为 5s，超过 5s 的话如果还来了之前早的数据，那么 Flink 就会丢弃了，因为 Flink 的窗口中的数据是要触发的，不可能一直在等着这些迟到的数据（由于网络的问题数据可能一直没发上来）而不让窗口触发结束进行计算操作。</p>
<p>通过定义这个时间，可以避免部分数据因为网络或者其他的问题导致不能够及时上传从而不把这些事件数据作为计算的，那么如果在这延迟之后还有更早的数据到来的话，那么 Flink 就会丢弃了，所以合理的设置这个允许延迟的时间也是一门细活，得观察生产环境数据的采集到消息队列再到 Flink 整个流程是否会出现延迟，统计平均延迟大概会在什么范围内波动。这也就是说明了一个事实那就是 Flink 中设计这个水印的根本目的是来解决部分数据乱序或者数据延迟的问题，而不能真正做到彻底解决这个问题，不过这一特性在相比于其他的流处理框架已经算是非常给力了。</p>
<p>AssignerWithPeriodicWatermarks 这个接口有四个实现类，分别如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zrpl1ivj21xk0i674j.jpg" alt="undefined"></p>
<p>BoundedOutOfOrdernessTimestampExtractor：该类用来发出滞后于数据时间的水印，它的目的其实就是和我们上面定义的那个类作用是类似的，你可以传入一个时间代表着可以允许数据延迟到来的时间是多长。该类内部实现如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zrx0blbj21hs1gsaci.jpg" alt="undefined"></p>
<p>你可以像下面一样使用该类来分配时间和生成水印：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time.seconds(10) 代表允许延迟的时间大小</span></span><br><span class="line">dataStream.assignTimestampsAndWatermarks(<span class="keyword">new</span> BoundedOutOfOrdernessTimestampExtractor&lt;Event&gt;(Time.seconds(<span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="comment">//重写 BoundedOutOfOrdernessTimestampExtractor 中的 extractTimestamp()抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event.getTimestamp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>CustomWatermarkExtractor：这是一个自定义的周期性生成水印的类，在这个类里面的数据是 KafkaEvent。</li>
<li>AscendingTimestampExtractor：时间戳分配器和水印生成器，用于时间戳单调递增的数据流，如果数据流的时间戳不是单调递增，那么会有专门的处理方法，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(T element, <span class="keyword">long</span> elementPrevTimestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> newTimestamp = extractAscendingTimestamp(element);</span><br><span class="line">    <span class="keyword">if</span> (newTimestamp &gt;= <span class="keyword">this</span>.currentTimestamp) &#123;</span><br><span class="line">        <span class="keyword">this</span>.currentTimestamp = ne∏wTimestamp;</span><br><span class="line">        <span class="keyword">return</span> newTimestamp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        violationHandler.handleViolation(newTimestamp, <span class="keyword">this</span>.currentTimestamp);</span><br><span class="line">        <span class="keyword">return</span> newTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>IngestionTimeExtractor：依赖于机器系统时间，它在 extractTimestamp 和 getCurrentWatermark 方法中是根据 <code>System.currentTimeMillis()</code> 来获取时间的，而不是根据事件的时间，如果这个时间分配器是在数据源进 Flink 后分配的，那么这个时间就和 Ingestion Time 一致了，所以命名也取的就是叫 IngestionTimeExtractor。</li>
</ul>
<p><strong>注意</strong>：</p>
<p>1、使用这种方式周期性生成水印的话，你可以通过 <code>env.getConfig().setAutoWatermarkInterval(...);</code> 来设置生成水印的间隔（每隔 n 毫秒）。</p>
<p>2、通常建议在数据源（source）之后就进行生成水印，或者做些简单操作比如 filter/map/flatMap 之后再生成水印，越早生成水印的效果会更好，也可以直接在数据源头就做生成水印。比如你可以在 source 源头类中的 run() 方法里面这样定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;MyType&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="comment">/* condition */</span>) &#123;</span><br><span class="line">        MyType next = getNext();</span><br><span class="line">        ctx.collectWithTimestamp(next, next.getEventTimestamp());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next.hasWatermarkTime()) &#123;</span><br><span class="line">            ctx.emitWatermark(<span class="keyword">new</span> Watermark(next.getWatermarkTime()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="每个-Kafka-分区的时间戳"><a href="#每个-Kafka-分区的时间戳" class="headerlink" title="每个 Kafka 分区的时间戳"></a>每个 Kafka 分区的时间戳</h3><p>当以 Kafka 来作为数据源的时候，通常每个 Kafka 分区的数据时间戳是递增的（事件是有序的），但是当你作业设置多个并行度的时候，Flink 去消费 Kafka 数据流是并行的，那么并行的去消费 Kafka 分区的数据就会导致打乱原每个分区的数据时间戳的顺序。在这种情况下，你可以使用 Flink 中的 <code>Kafka-partition-aware</code> 特性来生成水印，使用该特性后，水印会在 Kafka 消费端生成，然后每个 Kafka 分区和每个分区上的水印最后的合并方式和水印在数据流 shuffle 过程中的合并方式一致。</p>
<p>如果事件时间戳严格按照每个 Kafka 分区升序，则可以使用前面提到的 AscendingTimestampExtractor 水印生成器来为每个分区生成水印。下面代码教大家如何使用 <code>per-Kafka-partition</code> 来生成水印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FlinkKafkaConsumer011&lt;Event&gt; kafkaSource = <span class="keyword">new</span> FlinkKafkaConsumer011&lt;&gt;(<span class="string">"zhisheng"</span>, schema, props);</span><br><span class="line">kafkaSource.assignTimestampsAndWatermarks(<span class="keyword">new</span> AscendingTimestampExtractor&lt;Event&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractAscendingTimestamp</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event.eventTimestamp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">DataStream&lt;Event&gt; stream = env.addSource(kafkaSource);</span><br></pre></td></tr></table></figure>
<p>下图表示水印在 Kafka 分区后如何通过流数据流传播：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga0zs9dj5oj20r10a8t9f.jpg" alt="undefined"></p>
<p>其实在上文中已经提到的一点是在设置 Periodic Watermark 时，是允许提供一个参数，表示数据最大的延迟时间。其实这个值要结合自己的业务以及数据的情况来设置，如果该值设置的太小会导致数据因为网络或者其他的原因从而导致乱序或者延迟的数据太多，那么最后窗口触发的时候，可能窗口里面的数据量很少，那么这样计算的结果很可能误差会很大，对于有的场景（要求正确性比较高）是不太符合需求的。但是如果该值设置的太大，那么就会导致很多窗口一直在等待延迟的数据，从而一直不触发，这样首先就会导致数据的实时性降低，另外将这么多窗口的数据存在内存中，也会增加作业的内存消耗，从而可能会导致作业发生 OOM 的问题。</p>
<p>综上建议：</p>
<ul>
<li>合理设置允许数据最大延迟时间</li>
<li>不太依赖事件时间的场景就不要设置时间策略为 EventTime</li>
</ul>
<h3 id="延迟数据该如何处理-三种方法"><a href="#延迟数据该如何处理-三种方法" class="headerlink" title="延迟数据该如何处理(三种方法)"></a>延迟数据该如何处理(三种方法)</h3><h4 id="丢弃（默认）"><a href="#丢弃（默认）" class="headerlink" title="丢弃（默认）"></a>丢弃（默认）</h4><p>在 Flink 中，对这么延迟数据的默认处理方式是丢弃。</p>
<h4 id="allowedLateness-再次指定允许数据延迟的时间"><a href="#allowedLateness-再次指定允许数据延迟的时间" class="headerlink" title="allowedLateness 再次指定允许数据延迟的时间"></a>allowedLateness 再次指定允许数据延迟的时间</h4><p>allowedLateness 表示允许数据延迟的时间，这个方法是在 WindowedStream 中的，用来设置允许窗口数据延迟的时间，超过这个时间的元素就会被丢弃，这个的默认值是 0，该设置仅针对于以事件时间开的窗口，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, K, W&gt; <span class="title">allowedLateness</span><span class="params">(Time lateness)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> millis = lateness.toMilliseconds();</span><br><span class="line">    checkArgument(millis &gt;= <span class="number">0</span>, <span class="string">"The allowed lateness cannot be negative."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.allowedLateness = millis;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前有多个小伙伴问过我 Watermark 中允许的数据延迟和这个数据延迟的区别是啥？我的回复是该允许延迟的时间是在 Watermark 允许延迟的基础上增加的时间。那么具体该如何使用 allowedLateness 呢。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataStream.assignTimestampsAndWatermarks(<span class="keyword">new</span> TestWatermarkAssigner())</span><br><span class="line">    .keyBy(<span class="keyword">new</span> TestKeySelector())</span><br><span class="line">    .timeWindow(Time.milliseconds(<span class="number">1</span>), Time.milliseconds(<span class="number">1</span>))</span><br><span class="line">    .allowedLateness(Time.milliseconds(<span class="number">2</span>))  <span class="comment">//表示允许再次延迟 2 毫秒</span></span><br><span class="line">    .apply(<span class="keyword">new</span> WindowFunction&lt;Integer, String, Integer, TimeWindow&gt;() &#123;</span><br><span class="line">        <span class="comment">//计算逻辑</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="sideOutputLateData-收集迟到的数据"><a href="#sideOutputLateData-收集迟到的数据" class="headerlink" title="sideOutputLateData 收集迟到的数据"></a>sideOutputLateData 收集迟到的数据</h4><p>sideOutputLateData 这个方法同样是 WindowedStream 中的方法，该方法会将延迟的数据发送到给定 OutputTag 的 side output 中去，然后你可以通过 <code>SingleOutputStreamOperator.getSideOutput(OutputTag)</code> 来获取这些延迟的数据。具体的操作方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 OutputTag</span></span><br><span class="line">OutputTag&lt;Integer&gt; lateDataTag = <span class="keyword">new</span> OutputTag&lt;Integer&gt;(<span class="string">"late"</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;String&gt; windowOperator = dataStream</span><br><span class="line">        .assignTimestampsAndWatermarks(<span class="keyword">new</span> TestWatermarkAssigner())</span><br><span class="line">        .keyBy(<span class="keyword">new</span> TestKeySelector())</span><br><span class="line">        .timeWindow(Time.milliseconds(<span class="number">1</span>), Time.milliseconds(<span class="number">1</span>))</span><br><span class="line">        .allowedLateness(Time.milliseconds(<span class="number">2</span>))</span><br><span class="line">        .sideOutputLateData(lateDataTag)    <span class="comment">//指定 OutputTag</span></span><br><span class="line">        .apply(<span class="keyword">new</span> WindowFunction&lt;Integer, String, Integer, TimeWindow&gt;() &#123;</span><br><span class="line">            <span class="comment">//计算逻辑</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">windowOperator.addSink(resultSink);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过指定的 OutputTag 从 Side Output 中获取到延迟的数据之后，你可以通过 addSink() 方法存储下来，这样可以方便你后面去排查哪些数据是延迟的。</span></span><br><span class="line">windowOperator.getSideOutput(lateDataTag)</span><br><span class="line">        .addSink(lateResultSink);</span><br></pre></td></tr></table></figure>
<h3 id="小结与反思-10"><a href="#小结与反思-10" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>本节讲了 Watermark 的概念，并讲解了 Flink 中自带的 Watermark，然后还教大家如何设置 Watermark 以及如何自定义 Watermark，最后通过结合 Window 与 Watermark 去处理延迟数据，还讲解了三种常见的处理延迟数据的方法。</p>
<p>关于 Watermark 你有遇到什么问题吗？对于延迟数据你通常是怎么处理的？</p>
<p>本节相关的代码地址：<a href="https://github.com/zhisheng17/flink-learning/tree/master/flink-learning-examples/src/main/java/com/zhisheng/examples/streaming/watermark" target="_blank" rel="noopener">Watermark</a></p>
<h2 id="十三、Flink-常用的-Source-和-Sink-Connectors-介绍"><a href="#十三、Flink-常用的-Source-和-Sink-Connectors-介绍" class="headerlink" title="十三、Flink 常用的 Source 和 Sink Connectors 介绍"></a>十三、Flink 常用的 Source 和 Sink Connectors 介绍</h2><p>通过前面我们可以知道 Flink Job 的大致结构就是 <code>Source ——&gt; Transformation ——&gt; Sink</code>。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga1164fu1kj21ri0dcmxj.jpg" alt="undefined"></p>
<p>那么这个 Source 是什么意思呢？我们下面来看看。</p>
<h3 id="Data-Source-介绍"><a href="#Data-Source-介绍" class="headerlink" title="Data Source 介绍"></a>Data Source 介绍</h3><p>Data Source 是什么呢？就字面意思其实就可以知道：数据来源。</p>
<p>Flink 做为一款流式计算框架，它可用来做批处理，即处理静态的数据集、历史的数据集；也可以用来做流处理，即处理实时的数据流（做计算操作），然后将处理后的数据实时下发，只要数据源源不断过来，Flink 就能够一直计算下去。</p>
<p>Flink 中你可以使用 <code>StreamExecutionEnvironment.addSource(sourceFunction)</code> 来为你的程序添加数据来源。</p>
<p>Flink 已经提供了若干实现好了的 source function，当然你也可以通过实现 SourceFunction 来自定义非并行的 source 或者实现 ParallelSourceFunction 接口或者扩展 RichParallelSourceFunction 来自定义并行的 source。</p>
<p>那么常用的 Data Source 有哪些呢？</p>
<h3 id="常用的-Data-Source"><a href="#常用的-Data-Source" class="headerlink" title="常用的 Data Source"></a>常用的 Data Source</h3><p>StreamExecutionEnvironment 中可以使用以下这些已实现的 stream source。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga116diy51j21ji16aads.jpg" alt="undefined"></p>
<p>总的来说可以分为下面几大类：</p>
<h4 id="基于集合"><a href="#基于集合" class="headerlink" title="基于集合"></a>基于集合</h4><ol>
<li>fromCollection(Collection) - 从 Java 的 Java.util.Collection 创建数据流。集合中的所有元素类型必须相同。</li>
<li>fromCollection(Iterator, Class) - 从一个迭代器中创建数据流。Class 指定了该迭代器返回元素的类型。</li>
<li>fromElements(T …) - 从给定的对象序列中创建数据流。所有对象类型必须相同。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">DataStream&lt;Event&gt; input = env.fromElements(</span><br><span class="line">    <span class="keyword">new</span> Event(<span class="number">1</span>, <span class="string">"barfoo"</span>, <span class="number">1.0</span>),</span><br><span class="line">    <span class="keyword">new</span> Event(<span class="number">2</span>, <span class="string">"start"</span>, <span class="number">2.0</span>),</span><br><span class="line">    <span class="keyword">new</span> Event(<span class="number">3</span>, <span class="string">"foobar"</span>, <span class="number">3.0</span>),</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol>
<li>fromParallelCollection(SplittableIterator, Class) - 从一个迭代器中创建并行数据流。Class 指定了该迭代器返回元素的类型。</li>
<li>generateSequence(from, to) - 创建一个生成指定区间范围内的数字序列的并行数据流。</li>
</ol>
<h4 id="基于文件"><a href="#基于文件" class="headerlink" title="基于文件"></a>基于文件</h4><p>1、readTextFile(path) - 读取文本文件，即符合 TextInputFormat 规范的文件，并将其作为字符串返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">DataStream&lt;String&gt; text = env.readTextFile(<span class="string">"file:///path/to/file"</span>);</span><br></pre></td></tr></table></figure>
<p>2、readFile(fileInputFormat, path) - 根据指定的文件输入格式读取文件（一次）。</p>
<p>3、readFile(fileInputFormat, path, watchType, interval, pathFilter, typeInfo) - 这是上面两个方法内部调用的方法。它根据给定的 fileInputFormat 和读取路径读取文件。根据提供的 watchType，这个 source 可以定期（每隔 interval 毫秒）监测给定路径的新数据（FileProcessingMode.PROCESS<em>CONTINUOUSLY），或者处理一次路径对应文件的数据并退出（FileProcessingMode.PROCESS</em>ONCE）。你可以通过 pathFilter 进一步排除掉需要处理的文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">DataStream&lt;MyEvent&gt; stream = env.readFile(</span><br><span class="line">        myFormat, myFilePath, FileProcessingMode.PROCESS_CONTINUOUSLY, <span class="number">100</span>,</span><br><span class="line">        FilePathFilter.createDefaultFilter(), typeInfo);</span><br></pre></td></tr></table></figure>
<p><strong>实现:</strong></p>
<p>在具体实现上，Flink 把文件读取过程分为两个子任务，即目录监控和数据读取。每个子任务都由单独的实体实现。目录监控由单个非并行（并行度为1）的任务执行，而数据读取由并行运行的多个任务执行。后者的并行性等于作业的并行性。单个目录监控任务的作用是扫描目录（根据 watchType 定期扫描或仅扫描一次），查找要处理的文件并把文件分割成切分片（splits），然后将这些切分片分配给下游 reader。reader 负责读取数据。每个切分片只能由一个 reader 读取，但一个 reader 可以逐个读取多个切分片。</p>
<p><strong>重要注意：</strong></p>
<p>如果 watchType 设置为 FileProcessingMode.PROCESS_CONTINUOUSLY，则当文件被修改时，其内容将被重新处理。这会打破“exactly-once”语义，因为在文件末尾附加数据将导致其所有内容被重新处理。</p>
<p>如果 watchType 设置为 FileProcessingMode.PROCESS_ONCE，则 source 仅扫描路径一次然后退出，而不等待 reader 完成文件内容的读取。当然 reader 会继续阅读，直到读取所有的文件内容。关闭 source 后就不会再有检查点。这可能导致节点故障后的恢复速度较慢，因为该作业将从最后一个检查点恢复读取。</p>
<h4 id="基于-Socket"><a href="#基于-Socket" class="headerlink" title="基于 Socket"></a>基于 Socket</h4><p>socketTextStream(String hostname, int port) - 从 socket 读取。元素可以用分隔符切分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; dataStream = env</span><br><span class="line">        .socketTextStream(<span class="string">"localhost"</span>, <span class="number">9999</span>) <span class="comment">// 监听 localhost 的 9999 端口过来的数据</span></span><br><span class="line">        .flatMap(<span class="keyword">new</span> Splitter())</span><br><span class="line">        .keyBy(<span class="number">0</span>)</span><br><span class="line">        .timeWindow(Time.seconds(<span class="number">5</span>))</span><br><span class="line">        .sum(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>addSource - 添加一个新的 source function。例如，你可以用 addSource(new FlinkKafkaConsumer011&lt;&gt;(…)) 从 Apache Kafka 读取数据。</p>
<p><strong>说说上面几种的特点</strong></p>
<ol>
<li>基于集合：有界数据集，更偏向于本地测试用</li>
<li>基于文件：适合监听文件修改并读取其内容</li>
<li>基于 Socket：监听主机的 host port，从 Socket 中获取数据</li>
<li>自定义 addSource：大多数的场景数据都是无界的，会源源不断过来。比如去消费 Kafka 某个 topic 上的数据，这时候就需要用到这个 addSource，可能因为用的比较多的原因吧，Flink 直接提供了 FlinkKafkaConsumer011 等类可供你直接使用。你可以去看看 FlinkKafkaConsumerBase 这个基础类，它是 Flink Kafka 消费的最根本的类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">DataStream&lt;KafkaEvent&gt; input = env</span><br><span class="line">        .addSource(</span><br><span class="line">            <span class="keyword">new</span> FlinkKafkaConsumer011&lt;&gt;(</span><br><span class="line">                parameterTool.getRequired(<span class="string">"input-topic"</span>), <span class="comment">//从参数中获取传进来的 topic </span></span><br><span class="line">                <span class="keyword">new</span> KafkaEventSchema(),</span><br><span class="line">                parameterTool.getProperties())</span><br><span class="line">            .assignTimestampsAndWatermarks(<span class="keyword">new</span> CustomWatermarkExtractor()));</span><br></pre></td></tr></table></figure>
<p>Flink 目前支持如下面常见的 Source：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga117rgkt8j21kw0yeakr.jpg" alt="undefined"></p>
<p>如果你想自定义自己的 Source 呢？在后面 3.8 节会讲解。</p>
<h3 id="Data-Sink-介绍"><a href="#Data-Sink-介绍" class="headerlink" title="Data Sink 介绍"></a>Data Sink 介绍</h3><p>首先 Sink 的意思是：</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga1181fv12j20w20ri42r.jpg" alt="undefined"></p>
<p>大概可以猜到了吧！Data sink 有点把数据存储下来（落库）的意思。Flink 在拿到数据后做一系列的计算后，最后要将计算的结果往下游发送。比如将数据存储到 MySQL、ElasticSearch、Cassandra，或者继续发往 Kafka、 RabbitMQ 等消息队列，更或者直接调用其他的第三方应用服务（比如告警）。</p>
<h3 id="常用的-Data-Sink"><a href="#常用的-Data-Sink" class="headerlink" title="常用的 Data Sink"></a>常用的 Data Sink</h3><p>上面介绍了 Flink Data Source 有哪些，这里也看看 Flink Data Sink 支持的有哪些。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga118a05luj21kw0xgtk0.jpg" alt="undefined"></p>
<p>再看下源码有哪些呢？</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1ga118gxfh0j22tc0mijrw.jpg" alt="undefined"></p>
<p>可以看到有 Kafka、ElasticSearch、Socket、RabbitMQ、JDBC、Cassandra POJO、File、Print 等 Sink 的方式。</p>
<p>可能自带的这些 Sink 不支持你的业务场景，那么你也可以自定义符合自己公司业务需求的 Sink，同样在后面 3.8 节将教会大家。</p>
<h3 id="小结与反思-11"><a href="#小结与反思-11" class="headerlink" title="小结与反思"></a>小结与反思</h3><p>本节讲了 Flink 中常用的 Connector，包括 Source 和 Sink 的，其中每种都有很多 Connector，大家可以根据实际场景去使用合适的 Connector。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Flink/" rel="tag"># Flink</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/14/WaterMark原理以及验证/" rel="next" title="WaterMark原理以及验证">
                <i class="fa fa-chevron-left"></i> WaterMark原理以及验证
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/14/Pulsar与Kafka对比/" rel="prev" title="Pulsar与Kafka对比">
                Pulsar与Kafka对比 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80Mzk4NC8yMDUyMA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Fly Hugh">
            
              <p class="site-author-name" itemprop="name">Fly Hugh</p>
              <p class="site-description motion-element" itemprop="description">TRUST THE PROCESS</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/FlyMeToTheMars" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/3200892914" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/Fly__HoBo" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#大数据实时计算引擎-Flink-实战与性能优化"><span class="nav-number">1.</span> <span class="nav-text">大数据实时计算引擎 Flink 实战与性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、公司到底需不需要引入实时计算引擎？"><span class="nav-number">1.1.</span> <span class="nav-text">一、公司到底需不需要引入实时计算引擎？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实时计算需求"><span class="nav-number">1.1.1.</span> <span class="nav-text">实时计算需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据实时采集"><span class="nav-number">1.1.2.</span> <span class="nav-text">数据实时采集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据实时计算"><span class="nav-number">1.1.3.</span> <span class="nav-text">数据实时计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据实时下发"><span class="nav-number">1.1.4.</span> <span class="nav-text">数据实时下发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实时计算场景"><span class="nav-number">1.1.5.</span> <span class="nav-text">实时计算场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#离线计算-vs-实时计算"><span class="nav-number">1.1.6.</span> <span class="nav-text">离线计算 vs 实时计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#流处理与批处理"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">流处理与批处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#离线计算的特点"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">离线计算的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时计算的特点"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">实时计算的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流式数据的特点"><span class="nav-number">1.1.6.4.</span> <span class="nav-text">流式数据的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时计算的优势"><span class="nav-number">1.1.6.5.</span> <span class="nav-text">实时计算的优势</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实时计算面临的挑战"><span class="nav-number">1.1.7.</span> <span class="nav-text">实时计算面临的挑战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思"><span class="nav-number">1.1.8.</span> <span class="nav-text">小结与反思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、彻底了解大数据实时计算框架-Flink"><span class="nav-number">1.2.</span> <span class="nav-text">二、彻底了解大数据实时计算框架 Flink</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据集类型"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">数据集类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据运算模型"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">数据运算模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-是什么？"><span class="nav-number">1.2.1.</span> <span class="nav-text">Flink 是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-整体架构"><span class="nav-number">1.2.2.</span> <span class="nav-text">Flink 整体架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-支持多种方式部署"><span class="nav-number">1.2.3.</span> <span class="nav-text">Flink 支持多种方式部署</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-分布式运行"><span class="nav-number">1.2.4.</span> <span class="nav-text">Flink 分布式运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-程序与数据流结构"><span class="nav-number">1.2.5.</span> <span class="nav-text">Flink 程序与数据流结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-支持丰富的-Connector"><span class="nav-number">1.2.6.</span> <span class="nav-text">Flink 支持丰富的 Connector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-提供事件时间-amp-处理时间语义"><span class="nav-number">1.2.7.</span> <span class="nav-text">Flink 提供事件时间&amp;处理时间语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-提供灵活的窗口机制"><span class="nav-number">1.2.8.</span> <span class="nav-text">Flink 提供灵活的窗口机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-并行的执行任务"><span class="nav-number">1.2.9.</span> <span class="nav-text">Flink 并行的执行任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-支持状态存储和容错"><span class="nav-number">1.2.10.</span> <span class="nav-text">Flink 支持状态存储和容错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-实现了自己的内存管理机制"><span class="nav-number">1.2.11.</span> <span class="nav-text">Flink 实现了自己的内存管理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-支持多种扩展库"><span class="nav-number">1.2.12.</span> <span class="nav-text">Flink 支持多种扩展库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思-1"><span class="nav-number">1.2.13.</span> <span class="nav-text">小结与反思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、大数据框架-Flink、Blink、Spark-Streaming、Structured-Streaming和-Storm-的区别。"><span class="nav-number">1.3.</span> <span class="nav-text">三、大数据框架 Flink、Blink、Spark Streaming、Structured Streaming和 Storm 的区别。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink"><span class="nav-number">1.3.1.</span> <span class="nav-text">Flink</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Blink"><span class="nav-number">1.3.2.</span> <span class="nav-text">Blink</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-Spark"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3 Spark</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spark-Streaming"><span class="nav-number">1.3.4.</span> <span class="nav-text">Spark Streaming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Structured-Streaming"><span class="nav-number">1.3.5.</span> <span class="nav-text">Structured Streaming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-VS-Spark"><span class="nav-number">1.3.6.</span> <span class="nav-text">Flink VS Spark</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Storm"><span class="nav-number">1.3.7.</span> <span class="nav-text">Storm</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Storm-核心组件"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">Storm 核心组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Storm-核心概念"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">Storm 核心概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Storm-数据处理流程图"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">Storm 数据处理流程图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-VS-Storm"><span class="nav-number">1.3.8.</span> <span class="nav-text">Flink VS Storm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全部对比结果"><span class="nav-number">1.3.9.</span> <span class="nav-text">全部对比结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思-2"><span class="nav-number">1.3.10.</span> <span class="nav-text">小结与反思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、Flink-环境准备"><span class="nav-number">1.4.</span> <span class="nav-text">四、Flink 环境准备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-安装与配置"><span class="nav-number">1.4.1.</span> <span class="nav-text">JDK 安装与配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Maven-安装与配置"><span class="nav-number">1.4.2.</span> <span class="nav-text">Maven 安装与配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDE-安装与配置"><span class="nav-number">1.4.3.</span> <span class="nav-text">IDE 安装与配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-安装与配置"><span class="nav-number">1.4.4.</span> <span class="nav-text">MySQL 安装与配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-安装与配置"><span class="nav-number">1.4.5.</span> <span class="nav-text">Kafka 安装与配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ElasticSearch-安装与配置"><span class="nav-number">1.4.6.</span> <span class="nav-text">ElasticSearch 安装与配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思-3"><span class="nav-number">1.4.7.</span> <span class="nav-text">小结与反思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、Flink环境搭建"><span class="nav-number">1.5.</span> <span class="nav-text">五、Flink环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-下载与安装"><span class="nav-number">1.5.1.</span> <span class="nav-text">Flink 下载与安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Mac-amp-Linux-安装"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Mac &amp; Linux 安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows-安装"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">Windows 安装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-启动与运行"><span class="nav-number">1.5.2.</span> <span class="nav-text">Flink 启动与运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-目录配置文件解读"><span class="nav-number">1.5.3.</span> <span class="nav-text">Flink 目录配置文件解读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-源码下载"><span class="nav-number">1.5.4.</span> <span class="nav-text">Flink 源码下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-源码编译"><span class="nav-number">1.5.5.</span> <span class="nav-text">Flink 源码编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-源码导入到-IDE"><span class="nav-number">1.5.6.</span> <span class="nav-text">Flink 源码导入到 IDE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思-4"><span class="nav-number">1.5.7.</span> <span class="nav-text">小结与反思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、FlinkWordCount"><span class="nav-number">1.6.</span> <span class="nav-text">六、FlinkWordCount</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Maven-创建项目"><span class="nav-number">1.6.1.</span> <span class="nav-text">Maven 创建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDEA-创建项目"><span class="nav-number">1.6.2.</span> <span class="nav-text">IDEA 创建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流计算-WordCount-应用程序代码"><span class="nav-number">1.6.3.</span> <span class="nav-text">流计算 WordCount 应用程序代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WordCount-应用程序运行"><span class="nav-number">1.6.4.</span> <span class="nav-text">WordCount 应用程序运行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#本地-IDE-运行"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">本地 IDE 运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UI-运行-Job"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">UI 运行 Job</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WordCount-应用程序代码分析"><span class="nav-number">1.6.5.</span> <span class="nav-text">WordCount 应用程序代码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思-5"><span class="nav-number">1.6.6.</span> <span class="nav-text">小结与反思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、Flink-实时处理-Socket-数据"><span class="nav-number">1.7.</span> <span class="nav-text">七、Flink 实时处理 Socket 数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IDEA-创建项目-1"><span class="nav-number">1.7.1.</span> <span class="nav-text">IDEA 创建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-Socket-应用程序代码"><span class="nav-number">1.7.2.</span> <span class="nav-text">Flink Socket 应用程序代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-Socket-应用程序运行"><span class="nav-number">1.7.3.</span> <span class="nav-text">Flink Socket 应用程序运行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#本地-IDE-运行-1"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">本地 IDE 运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UI-运行-Job-1"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">UI 运行 Job</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-Socket-应用程序代码分析"><span class="nav-number">1.7.4.</span> <span class="nav-text">Flink Socket 应用程序代码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-中使用-Lambda-表达式"><span class="nav-number">1.7.5.</span> <span class="nav-text">Flink 中使用 Lambda 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思-6"><span class="nav-number">1.7.6.</span> <span class="nav-text">小结与反思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、Flink多种时间语义对比"><span class="nav-number">1.8.</span> <span class="nav-text">八、Flink多种时间语义对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Processing-Time"><span class="nav-number">1.8.1.</span> <span class="nav-text">Processing Time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-Time"><span class="nav-number">1.8.2.</span> <span class="nav-text">Event Time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ingestion-Time"><span class="nav-number">1.8.3.</span> <span class="nav-text">Ingestion Time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三种-Time-对比结果"><span class="nav-number">1.8.4.</span> <span class="nav-text">三种 Time 对比结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景分析"><span class="nav-number">1.8.5.</span> <span class="nav-text">使用场景分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何设置-Time-策略？"><span class="nav-number">1.8.6.</span> <span class="nav-text">如何设置 Time 策略？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思-7"><span class="nav-number">1.8.7.</span> <span class="nav-text">小结与反思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、Flink-Window-基础概念与实现原理"><span class="nav-number">1.9.</span> <span class="nav-text">九、Flink Window 基础概念与实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-Window？"><span class="nav-number">1.9.1.</span> <span class="nav-text">什么是 Window？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Window-有什么作用？"><span class="nav-number">1.9.2.</span> <span class="nav-text">Window 有什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-自带的-Window"><span class="nav-number">1.9.3.</span> <span class="nav-text">Flink 自带的 Window</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Time-Window-使用及源码分析"><span class="nav-number">1.9.4.</span> <span class="nav-text">Time Window 使用及源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Count-Window-使用及源码分析"><span class="nav-number">1.9.5.</span> <span class="nav-text">Count Window 使用及源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session-Window-使用及源码分析"><span class="nav-number">1.9.6.</span> <span class="nav-text">Session Window 使用及源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何自定义-Window？"><span class="nav-number">1.9.7.</span> <span class="nav-text">如何自定义 Window？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-8-Window-源码定义"><span class="nav-number">1.9.8.</span> <span class="nav-text">3.2.8 Window 源码定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Window-组件之-WindowAssigner-使用及源码分析"><span class="nav-number">1.9.9.</span> <span class="nav-text">Window 组件之 WindowAssigner 使用及源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Window-组件之-Trigger-使用及源码分析"><span class="nav-number">1.9.10.</span> <span class="nav-text">Window 组件之 Trigger 使用及源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Window-组件之-Evictor-使用及源码分析"><span class="nav-number">1.9.11.</span> <span class="nav-text">Window 组件之 Evictor 使用及源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思-8"><span class="nav-number">1.9.12.</span> <span class="nav-text">小结与反思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十、数据转换必须熟悉的算子（Operator）"><span class="nav-number">1.10.</span> <span class="nav-text">十、数据转换必须熟悉的算子（Operator）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DataStream-Operator"><span class="nav-number">1.10.1.</span> <span class="nav-text">DataStream Operator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Map"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FlatMap"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">FlatMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter"><span class="nav-number">1.10.1.3.</span> <span class="nav-text">Filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KeyBy"><span class="nav-number">1.10.1.4.</span> <span class="nav-text">KeyBy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reduce"><span class="nav-number">1.10.1.5.</span> <span class="nav-text">Reduce</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Aggregations"><span class="nav-number">1.10.1.6.</span> <span class="nav-text">Aggregations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Window"><span class="nav-number">1.10.1.7.</span> <span class="nav-text">Window</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WindowAll"><span class="nav-number">1.10.1.8.</span> <span class="nav-text">WindowAll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Union"><span class="nav-number">1.10.1.9.</span> <span class="nav-text">Union</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Window-Join"><span class="nav-number">1.10.1.10.</span> <span class="nav-text">Window Join</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Split"><span class="nav-number">1.10.1.11.</span> <span class="nav-text">Split</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Select"><span class="nav-number">1.10.1.12.</span> <span class="nav-text">Select</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DataSet-Operator"><span class="nav-number">1.10.2.</span> <span class="nav-text">DataSet Operator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#First-n"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">First-n</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流批统一的思路"><span class="nav-number">1.10.3.</span> <span class="nav-text">流批统一的思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思-9"><span class="nav-number">1.10.4.</span> <span class="nav-text">小结与反思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十一、如何使用-DataStream-API-来处理数据？"><span class="nav-number">1.11.</span> <span class="nav-text">十一、如何使用 DataStream API 来处理数据？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DataStream-如何使用及分析"><span class="nav-number">1.11.1.</span> <span class="nav-text">DataStream 如何使用及分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#union"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">union</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#split"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">split</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#connect"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">connect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#keyBy"><span class="nav-number">1.11.1.4.</span> <span class="nav-text">keyBy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#partitionCustom"><span class="nav-number">1.11.1.5.</span> <span class="nav-text">partitionCustom</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#broadcast"><span class="nav-number">1.11.1.6.</span> <span class="nav-text">broadcast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map"><span class="nav-number">1.11.1.7.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flatMap"><span class="nav-number">1.11.1.8.</span> <span class="nav-text">flatMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#process"><span class="nav-number">1.11.1.9.</span> <span class="nav-text">process</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filter"><span class="nav-number">1.11.1.10.</span> <span class="nav-text">filter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SingleOutputStreamOperator-如何使用及分析"><span class="nav-number">1.11.2.</span> <span class="nav-text">SingleOutputStreamOperator 如何使用及分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KeyedStream-如何使用及分析"><span class="nav-number">1.11.3.</span> <span class="nav-text">KeyedStream 如何使用及分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SplitStream-如何使用及分析"><span class="nav-number">1.11.4.</span> <span class="nav-text">SplitStream 如何使用及分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WindowedStream-如何使用及分析"><span class="nav-number">1.11.5.</span> <span class="nav-text">WindowedStream 如何使用及分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AllWindowedStream-如何使用及分析"><span class="nav-number">1.11.6.</span> <span class="nav-text">AllWindowedStream 如何使用及分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConnectedStreams-如何使用及分析"><span class="nav-number">1.11.7.</span> <span class="nav-text">ConnectedStreams 如何使用及分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BroadcastStream-如何使用及分析"><span class="nav-number">1.11.8.</span> <span class="nav-text">BroadcastStream 如何使用及分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BroadcastConnectedStream-如何使用及分析"><span class="nav-number">1.11.9.</span> <span class="nav-text">BroadcastConnectedStream 如何使用及分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QueryableStateStream-如何使用及分析"><span class="nav-number">1.11.10.</span> <span class="nav-text">QueryableStateStream 如何使用及分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">1.11.11.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十二、Flink-WaterMark-详解及结合-WaterMark-处理延迟数据"><span class="nav-number">1.12.</span> <span class="nav-text">十二、Flink WaterMark 详解及结合 WaterMark 处理延迟数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Watermark-是什么？"><span class="nav-number">1.12.1.</span> <span class="nav-text">Watermark 是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-中-Watermark-的设置"><span class="nav-number">1.12.2.</span> <span class="nav-text">Flink 中 Watermark 的设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Punctuated-Watermark"><span class="nav-number">1.12.3.</span> <span class="nav-text">Punctuated Watermark</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4-Periodic-Watermark"><span class="nav-number">1.12.4.</span> <span class="nav-text">3.5.4 Periodic Watermark</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#每个-Kafka-分区的时间戳"><span class="nav-number">1.12.5.</span> <span class="nav-text">每个 Kafka 分区的时间戳</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟数据该如何处理-三种方法"><span class="nav-number">1.12.6.</span> <span class="nav-text">延迟数据该如何处理(三种方法)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#丢弃（默认）"><span class="nav-number">1.12.6.1.</span> <span class="nav-text">丢弃（默认）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#allowedLateness-再次指定允许数据延迟的时间"><span class="nav-number">1.12.6.2.</span> <span class="nav-text">allowedLateness 再次指定允许数据延迟的时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sideOutputLateData-收集迟到的数据"><span class="nav-number">1.12.6.3.</span> <span class="nav-text">sideOutputLateData 收集迟到的数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思-10"><span class="nav-number">1.12.7.</span> <span class="nav-text">小结与反思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十三、Flink-常用的-Source-和-Sink-Connectors-介绍"><span class="nav-number">1.13.</span> <span class="nav-text">十三、Flink 常用的 Source 和 Sink Connectors 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Source-介绍"><span class="nav-number">1.13.1.</span> <span class="nav-text">Data Source 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的-Data-Source"><span class="nav-number">1.13.2.</span> <span class="nav-text">常用的 Data Source</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于集合"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">基于集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于文件"><span class="nav-number">1.13.2.2.</span> <span class="nav-text">基于文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于-Socket"><span class="nav-number">1.13.2.3.</span> <span class="nav-text">基于 Socket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义"><span class="nav-number">1.13.2.4.</span> <span class="nav-text">自定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Sink-介绍"><span class="nav-number">1.13.3.</span> <span class="nav-text">Data Sink 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的-Data-Sink"><span class="nav-number">1.13.4.</span> <span class="nav-text">常用的 Data Sink</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结与反思-11"><span class="nav-number">1.13.5.</span> <span class="nav-text">小结与反思</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fly Hugh</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">158.4k</span>
  
</div>


<!-- 
  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>

-->



        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

       <!-- 页面点击小红心 -->
    <script type="text/javascript" src="/js/src/src/clicklove.js"></script>

    
  </div>



  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("72l8G3xFxrAReJk0PBs8jCeC-gzGzoHsz", "r0TXzhifsg8y5LTKokFte6fz");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  





</body>


</html>

