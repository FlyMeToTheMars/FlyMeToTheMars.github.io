<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/xingqiushangcheng.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/xingqiushangcheng.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="之前Flink的Watermark原理老是不明白，并且在CSDN上找的一篇文章，似乎是因为版本的问题，两年前的博客，代码验证下来始终有问题，在网上和人谈论之后，重新用代码验证了，才有点清晰明了，在此记录一下。">
<meta name="keywords" content="Flink">
<meta property="og:type" content="article">
<meta property="og:title" content="WaterMark原理以及验证">
<meta property="og:url" content="http://yoursite.com/2019/11/06/WaterMark原理以及验证/index.html">
<meta property="og:site_name" content="Mars">
<meta property="og:description" content="之前Flink的Watermark原理老是不明白，并且在CSDN上找的一篇文章，似乎是因为版本的问题，两年前的博客，代码验证下来始终有问题，在网上和人谈论之后，重新用代码验证了，才有点清晰明了，在此记录一下。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8o1sw7244j20xd0g4q9s.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8o5410mbdj20xd0h3wlo.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8o549eyilj210b0i446b.jpg">
<meta property="og:updated_time" content="2020-04-10T17:12:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WaterMark原理以及验证">
<meta name="twitter:description" content="之前Flink的Watermark原理老是不明白，并且在CSDN上找的一篇文章，似乎是因为版本的问题，两年前的博客，代码验证下来始终有问题，在网上和人谈论之后，重新用代码验证了，才有点清晰明了，在此记录一下。">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/bec9bff2ly1g8o1sw7244j20xd0g4q9s.jpg">

<link rel="canonical" href="http://yoursite.com/2019/11/06/WaterMark原理以及验证/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>WaterMark原理以及验证 | Mars</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Mars" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mars</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/06/WaterMark原理以及验证/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fly Hugh">
      <meta itemprop="description" content="WE CHOOSE TO  GO TO THE MARS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          WaterMark原理以及验证
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-06 11:06:10" itemprop="dateCreated datePublished" datetime="2019-11-06T11:06:10+08:00">2019-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-11 01:12:41" itemprop="dateModified" datetime="2020-04-11T01:12:41+08:00">2020-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Apache/" itemprop="url" rel="index"><span itemprop="name">Apache</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Apache/Flink/" itemprop="url" rel="index"><span itemprop="name">Flink</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>之前Flink的Watermark原理老是不明白，并且在CSDN上找的一篇文章，似乎是因为版本的问题，两年前的博客，代码验证下来始终有问题，在网上和人谈论之后，重新用代码验证了，才有点清晰明了，在此记录一下。</p>
</blockquote>
<a id="more"></a> 

<h3 id="WaterMark"><a href="#WaterMark" class="headerlink" title="WaterMark"></a>WaterMark</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8o1sw7244j20xd0g4q9s.jpg" alt="1.png"></p>
<p>实时计算中，数据时间比较敏感。有<code>eventTime</code>和<code>processTime</code>区分，一般来说<code>eventTime</code>是从原始的消息中提取过来的，<code>processTime</code>是<code>Flink</code>自己提供的，<code>Flink</code>中一个亮点就是可以基于<code>eventTime</code>计算，这个功能很有用，因为实时数据可能会经过比较长的链路，多少会有延时，并且有很大的不确定性，对于一些需要精确体现事件变化趋势的场景中，单纯使用<code>processTime</code>显然是不合理的。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>watermark</code>是一种衡量<code>Event Time</code>进展的机制，它是数据本身的一个隐藏属性。通常基于Event Time的数据，自身都包含一个<code>timestamp.watermark</code>是用于处理乱序事件的，而正确的处理乱序事件，通常用<code>watermark</code>机制结合<code>window</code>来实现。</p>
<p>流处理从事件产生，到流经<code>source</code>，再到<code>operator</code>，中间是有一个过程和时间的。虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、背压等原因，导致乱序的产生（<code>out-of-order</code>或者说<code>late element</code>）。</p>
<p>但是对于<code>late element</code>，我们又不能无限期的等下去，必须要有个机制来保证一个特定的时间后，必须触发<code>window</code>去进行计算了。这个特别的机制，就是<code>watermark</code>。</p>
<h3 id="window划分"><a href="#window划分" class="headerlink" title="window划分"></a>window划分</h3><p><code>window</code>的设定无关数据本身，而是系统定义好了的。<br><code>window</code>是<code>flink</code>中划分数据一个基本单位，<code>window</code>的划分方式是固定的，默认会根据自然时间划分<code>window</code>，并且划分方式是前闭后开。</p>
<table>
<thead>
<tr>
<th>window划分</th>
<th>w1</th>
<th>w2</th>
<th>w3</th>
</tr>
</thead>
<tbody><tr>
<td>3s</td>
<td>[00:00:00~00:00:03)</td>
<td>[00:00:03~00:00:06)</td>
<td>[00:00:06~00:00:09)</td>
</tr>
<tr>
<td>5s</td>
<td>[00:00:00~00:00:05)</td>
<td>[00:00:05~00:00:10)</td>
<td>[00:00:10~00:00:15)</td>
</tr>
<tr>
<td>10s</td>
<td>[00:00:00~00:00:10)</td>
<td>[00:00:10~00:00:20)</td>
<td>[00:00:20~00:00:30)</td>
</tr>
<tr>
<td>1min</td>
<td>[00:00:00~00:01:00)</td>
<td>[00:01:00~00:02:00)</td>
<td>[00:02:00~00:03:00)</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>如果设置最大允许的乱序时间是10s，滚动时间窗口为5s</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"datetime"</span>:<span class="string">"2019-03-26 16:25:24"</span>,<span class="attr">"name"</span>:<span class="string">"zhangsan"</span>&#125;</span><br><span class="line">//currentThreadId:38,key:zhangsan,eventTime:[2019-03-26 16:25:24],currentMaxTimestamp:[2019-03-26 16:25:24],watermark:[2019-03-26 16:25:14]</span><br></pre></td></tr></table></figure>

<p>触达改记录的时间窗口应该为<code>2019-03-26 16:25:20~2019-03-26 16:25:25</code><br>即当有数据eventTime &gt;= 2019-03-26 16:25:35 时</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"datetime"</span>:<span class="string">"2019-03-26 16:25:35"</span>,<span class="attr">"name"</span>:<span class="string">"zhangsan"</span>&#125;</span><br><span class="line">//currentThreadId:38,key:zhangsan,eventTime:[2019-03-26 16:25:35],currentMaxTimestamp:[2019-03-26 16:25:35],watermark:[2019-03-26 16:25:25]</span><br><span class="line">//(zhangsan,1,2019-03-26 16:25:24,2019-03-26 16:25:24,2019-03-26 16:25:20,2019-03-26 16:25:25)</span><br></pre></td></tr></table></figure>

<h3 id="提取watermark"><a href="#提取watermark" class="headerlink" title="提取watermark"></a>提取watermark</h3><p>watermark的提取工作在taskManager中完成，意味着这项工作是并行进行的的，而watermark是一个全局的概念，就是一个整个Flink作业之后一个warkermark。</p>
<h3 id="AssignerWithPeriodicWatermarks"><a href="#AssignerWithPeriodicWatermarks" class="headerlink" title="AssignerWithPeriodicWatermarks"></a>AssignerWithPeriodicWatermarks</h3><p>定时提取watermark，这种方式会定时提取更新wartermark。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认200ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStreamTimeCharacteristic</span><span class="params">(TimeCharacteristic characteristic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.timeCharacteristic = Preconditions.checkNotNull(characteristic);</span><br><span class="line">    <span class="keyword">if</span> (characteristic == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">        getConfig().setAutoWatermarkInterval(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getConfig().setAutoWatermarkInterval(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AssignerWithPunctuatedWatermarks"><a href="#AssignerWithPunctuatedWatermarks" class="headerlink" title="AssignerWithPunctuatedWatermarks"></a>AssignerWithPunctuatedWatermarks</h3><p>伴随event的到来就提取watermark，就是每一个event到来的时候，就会提取一次Watermark。<br>这样的方式当然设置watermark更为精准，但是当数据量大的时候，频繁的更新wartermark会比较影响性能。<br>通常情况下采用定时提取就足够了。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h3 id="设置数据流时间特征"><a href="#设置数据流时间特征" class="headerlink" title="设置数据流时间特征"></a>设置数据流时间特征</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置为事件时间</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br></pre></td></tr></table></figure>

<p>默认为<code>TimeCharacteristic.ProcessingTime</code>,默认水位线更新每隔200ms</p>
<p>入口文件</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="comment">//便于测试，并行度设置为1</span></span><br><span class="line">env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//env.getConfig.setAutoWatermarkInterval(9000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置为事件时间</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置source 本地socket</span></span><br><span class="line"><span class="keyword">val</span> text: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">"localhost"</span>, <span class="number">9000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lateText = <span class="keyword">new</span> <span class="type">OutputTag</span>[(<span class="type">String</span>, <span class="type">String</span>, <span class="type">Long</span>, <span class="type">Long</span>)](<span class="string">"late_data"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> value = text.filter(<span class="keyword">new</span> <span class="type">MyFilterNullOrWhitespace</span>)</span><br><span class="line">.flatMap(<span class="keyword">new</span> <span class="type">MyFlatMap</span>)</span><br><span class="line">.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">MyWaterMark</span>)</span><br><span class="line">.map(x =&gt; (x.name, x.datetime, x.timestamp, <span class="number">1</span>L))</span><br><span class="line">.keyBy(_._1)</span><br><span class="line">.window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">5</span>)))</span><br><span class="line">.sideOutputLateData(lateText)</span><br><span class="line"><span class="comment">//.sum(2)</span></span><br><span class="line">.apply(<span class="keyword">new</span> <span class="type">MyWindow</span>)</span><br><span class="line"><span class="comment">//.window(TumblingEventTimeWindows.of(Time.seconds(3)))</span></span><br><span class="line"><span class="comment">//.apply(new MyWindow)</span></span><br><span class="line">value.getSideOutput(lateText).map(x =&gt; &#123;</span><br><span class="line"><span class="string">"延迟数据|name:"</span> + x._1 + <span class="string">"|datetime:"</span> + x._2</span><br><span class="line">&#125;).print()</span><br><span class="line"></span><br><span class="line">value.print()</span><br><span class="line"></span><br><span class="line">env.execute(<span class="string">"watermark test"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWaterMark</span> <span class="keyword">extends</span> <span class="title">AssignerWithPeriodicWatermarks</span>[<span class="type">EventObj</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> maxOutOfOrderness = <span class="number">10000</span>L <span class="comment">// 3.0 seconds</span></span><br><span class="line">  <span class="keyword">var</span> currentMaxTimestamp = <span class="number">0</span>L</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> sdf = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用于生成新的水位线，新的水位线只有大于当前水位线才是有效的</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 通过生成水印的间隔（每n毫秒）定义 ExecutionConfig.setAutoWatermarkInterval(...)。</span></span><br><span class="line"><span class="comment">    * getCurrentWatermark()每次调用分配器的方法，如果返回的水印非空并且大于先前的水印，则将发出新的水印。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Watermark</span>(<span class="keyword">this</span>.currentMaxTimestamp - <span class="keyword">this</span>.maxOutOfOrderness)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用于从消息中提取事件时间</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param element                  EventObj</span></span><br><span class="line"><span class="comment">    * @param previousElementTimestamp Long</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">EventObj</span>, previousElementTimestamp: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line"></span><br><span class="line">    currentMaxTimestamp = <span class="type">Math</span>.max(element.timestamp, currentMaxTimestamp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> id = <span class="type">Thread</span>.currentThread().getId</span><br><span class="line">    println(<span class="string">"currentThreadId:"</span> + id + <span class="string">",key:"</span> + element.name + <span class="string">",eventTime:["</span> + element.datetime + <span class="string">"],currentMaxTimestamp:["</span> + sdf.format(currentMaxTimestamp) + <span class="string">"],watermark:["</span> + sdf.format(getCurrentWatermark().getTimestamp) + <span class="string">"]"</span>)</span><br><span class="line"></span><br><span class="line">    element.timestamp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h3><ol>
<li>设置为事件时间</li>
<li>接受本地socket数据</li>
<li>抽取timestamp生成watermark，打印(线程id,key,eventTime,currentMaxTimestamp,watermark）</li>
<li>event time每隔3秒触发一次窗口，打印（key,窗口内元素个数，窗口内最早元素的时间，窗口内最晚元素的时间，窗口自身开始时间，窗口自身结束时间）</li>
</ol>
<h3 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h3><h4 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h4><p>数据</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"datetime"</span>:<span class="string">"2019-03-26 16:25:24"</span>,<span class="attr">"name"</span>:<span class="string">"zhangsan"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|currentThreadId:38,key:zhangsan,eventTime:[2019-03-26 16:25:24],currentMaxTimestamp:[2019-03-26 16:25:24],watermark:[2019-03-26 16:25:14]</span><br></pre></td></tr></table></figure>

<p>汇总</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>EventTime</th>
<th>currentMaxTimestamp</th>
<th>Watermark</th>
</tr>
</thead>
<tbody><tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:24</td>
<td>2019-03-26 16:25:24</td>
<td>2019-03-26 16:25:14</td>
</tr>
</tbody></table>
<h4 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h4><p>数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;datetime&quot;:&quot;2019-03-26 16:25:27&quot;,&quot;name&quot;:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentThreadId:38,key:zhangsan,eventTime:[2019-03-26 16:25:27],currentMaxTimestamp:[2019-03-26 16:25:27],watermark:[2019-03-26 16:25:17]</span><br></pre></td></tr></table></figure>

<p>随着EventTime的升高，Watermark升高。</p>
<p>汇总</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>EventTime</th>
<th>currentMaxTimestamp</th>
<th>Watermark</th>
</tr>
</thead>
<tbody><tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:24</td>
<td>2019-03-26 16:25:24</td>
<td>2019-03-26 16:25:14</td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:27</td>
<td>2019-03-26 16:25:27</td>
<td>2019-03-26 16:25:17</td>
</tr>
</tbody></table>
<h4 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h4><p>数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;datetime&quot;:&quot;2019-03-26 16:25:34&quot;,&quot;name&quot;:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentThreadId:38,key:zhangsan,eventTime:[2019-03-26 16:25:34],currentMaxTimestamp:[2019-03-26 16:25:34],watermark:[2019-03-26 16:25:24]</span><br></pre></td></tr></table></figure>

<p>到这里，window仍然没有被触发，此时watermark的时间已经等于了第一条数据的Event Time了。</p>
<p>汇总</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>EventTime</th>
<th>currentMaxTimestamp</th>
<th>Watermark</th>
</tr>
</thead>
<tbody><tr>
<td>zhangsan</td>
<td><strong>2019-03-26 16:25:24</strong></td>
<td>2019-03-26 16:25:24</td>
<td>2019-03-26 16:25:14</td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:27</td>
<td>2019-03-26 16:25:27</td>
<td>2019-03-26 16:25:17</td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:34</td>
<td>2019-03-26 16:25:34</td>
<td><strong>2019-03-26 16:25:24</strong></td>
</tr>
</tbody></table>
<h4 id="第四次"><a href="#第四次" class="headerlink" title="第四次"></a>第四次</h4><p>数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;datetime&quot;:&quot;2019-03-26 16:25:35&quot;,&quot;name&quot;:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentThreadId:38,key:zhangsan,eventTime:[2019-03-26 16:25:35],currentMaxTimestamp:[2019-03-26 16:25:35],watermark:[2019-03-26 16:25:25](zhangsan,1,2019-03-26 16:25:24,2019-03-26 16:25:24,2019-03-26 16:25:20,2019-03-26 16:25:25)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentThreadId:38,key:zhangsan,eventTime:[2019-03-26 16:25:35],currentMaxTimestamp:[2019-03-26 16:25:35],watermark:[2019-03-26 16:25:25](zhangsan,1,2019-03-26 16:25:24,2019-03-26 16:25:24,2019-03-26 16:25:20,2019-03-26 16:25:25)</span><br></pre></td></tr></table></figure>

<p>直接证明了window的设定无关数据本身，而是系统定义好了的。<br>输入的数据中，根据自身的Event Time，将数据划分到不同的window中，如果window中有数据，则当watermark时间&gt;=Event Time时，就符合了window触发的条件了，最终决定window触发，还是由数据本身的Event Time所属的window中的window_end_time决定。</p>
<p>当最后一条数据16:25:35到达是，Watermark提升到16:25:25，此时窗口16:25:20~16:25:25中有数据，Window被触发。</p>
<p>汇总</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>EventTime</th>
<th>currentMaxTimestamp</th>
<th>Watermark</th>
<th>WindowStartTime</th>
<th>WindowEndTime</th>
</tr>
</thead>
<tbody><tr>
<td>zhangsan</td>
<td><strong>2019-03-26 16:25:24</strong></td>
<td>2019-03-26 16:25:24</td>
<td>2019-03-26 16:25:14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:27</td>
<td>2019-03-26 16:25:27</td>
<td>2019-03-26 16:25:17</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:34</td>
<td>2019-03-26 16:25:34</td>
<td>2019-03-26 16:25:24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:35</td>
<td>2019-03-26 16:25:35</td>
<td><strong>2019-03-26 16:25:25</strong></td>
<td><strong>[2019-03-26 16:25:20</strong></td>
<td><strong>2019-03-26 16:25:25)</strong></td>
</tr>
</tbody></table>
<h4 id="第五次"><a href="#第五次" class="headerlink" title="第五次"></a>第五次</h4><p>数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;datetime&quot;:&quot;2019-03-26 16:25:37&quot;,&quot;name&quot;:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentThreadId:38,key:zhangsan,eventTime:[2019-03-26 16:25:37],currentMaxTimestamp:[2019-03-26 16:25:37],watermark:[2019-03-26 16:25:27]</span><br></pre></td></tr></table></figure>

<p>此时，watermark时间虽然已经达到了第二条数据的时间，但是由于其没有达到第二条数据所在window的结束时间，所以window并没有被触发。</p>
<p>第二条数据所在的window时间是：<code>[2019-03-26 16:25:25,2019-03-26 16:25:30)</code></p>
<p>汇总</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>EventTime</th>
<th>currentMaxTimestamp</th>
<th>Watermark</th>
<th>WindowStartTime</th>
<th>WindowEndTime</th>
</tr>
</thead>
<tbody><tr>
<td>zhangsan</td>
<td><strong>2019-03-26 16:25:24</strong></td>
<td>2019-03-26 16:25:24</td>
<td>2019-03-26 16:25:14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:27</td>
<td>2019-03-26 16:25:27</td>
<td>2019-03-26 16:25:17</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:34</td>
<td>2019-03-26 16:25:34</td>
<td>2019-03-26 16:25:24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:35</td>
<td>2019-03-26 16:25:35</td>
<td><strong>2019-03-26 16:25:25</strong></td>
<td><strong>[2019-03-26 16:25:20</strong></td>
<td><strong>2019-03-26 16:25:25)</strong></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:37</td>
<td>2019-03-26 16:25:37</td>
<td>2019-03-26 16:25:27</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="第六次"><a href="#第六次" class="headerlink" title="第六次"></a>第六次</h4><p>数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;datetime&quot;:&quot;2019-03-26 16:25:40&quot;,&quot;name&quot;:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentThreadId:38,key:zhangsan,eventTime:[2019-03-26 16:25:40],currentMaxTimestamp:[2019-03-26 16:25:40],watermark:[2019-03-26 16:25:30](zhangsan,1,2019-03-26 16:25:27,2019-03-26 16:25:27,2019-03-26 16:25:25,2019-03-26 16:25:30)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Key</th>
<th>EventTime</th>
<th>currentMaxTimestamp</th>
<th>Watermark</th>
<th>WindowStartTime</th>
<th>WindowEndTime</th>
</tr>
</thead>
<tbody><tr>
<td>zhangsan</td>
<td><strong>2019-03-26 16:25:24</strong></td>
<td>2019-03-26 16:25:24</td>
<td>2019-03-26 16:25:14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:27</td>
<td>2019-03-26 16:25:27</td>
<td>2019-03-26 16:25:17</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:34</td>
<td>2019-03-26 16:25:34</td>
<td>2019-03-26 16:25:24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:35</td>
<td>2019-03-26 16:25:35</td>
<td><strong>2019-03-26 16:25:25</strong></td>
<td><strong>[2019-03-26 16:25:20</strong></td>
<td><strong>2019-03-26 16:25:25)</strong></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:37</td>
<td>2019-03-26 16:25:37</td>
<td>2019-03-26 16:25:27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zhangsan</td>
<td>2019-03-26 16:25:40</td>
<td>2019-03-26 16:25:40</td>
<td><strong>2019-03-26 16:25:30</strong></td>
<td><strong>[2019-03-26 16:25:25</strong></td>
<td><strong>2019-03-26 16:25:30)</strong></td>
</tr>
</tbody></table>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>window的触发要符合以下几个条件：</p>
<ol>
<li>watermark时间 &gt;= window_end_time</li>
<li>在[window_start_time,window_end_time)中有数据存在</li>
</ol>
<p>同时满足了以上2个条件，window才会触发。<br>watermark是一个全局的值，不是某一个key下的值，所以即使不是同一个key的数据，其warmark也会增加.</p>
<h3 id="多并行度"><a href="#多并行度" class="headerlink" title="多并行度"></a>多并行度</h3><p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8o5410mbdj20xd0h3wlo.jpg" alt="2.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h3 id="Flink如何处理乱序？"><a href="#Flink如何处理乱序？" class="headerlink" title="Flink如何处理乱序？"></a>Flink如何处理乱序？</h3><p>watermark+window机制。window中可以对input进行按照Event Time排序，使得完全按照Event Time发生的顺序去处理数据，以达到处理乱序数据的目的。</p>
<h3 id="Flink何时触发window？"><a href="#Flink何时触发window？" class="headerlink" title="Flink何时触发window？"></a>Flink何时触发window？</h3><p>对于late element太多的数据而言</p>
<ol>
<li>Event Time &lt; watermark时间</li>
</ol>
<p>对于out-of-order以及正常的数据而言</p>
<ol>
<li>watermark时间 &gt;= window_end_time</li>
<li>在[window_start_time,window_end_time)中有数据存在</li>
</ol>
<h3 id="Flink应该如何设置最大乱序时间？"><a href="#Flink应该如何设置最大乱序时间？" class="headerlink" title="Flink应该如何设置最大乱序时间？"></a>Flink应该如何设置最大乱序时间？</h3><p>结合自己的业务以及数据情况去设置。</p>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2ly1g8o549eyilj210b0i446b.jpg" alt="3.png"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Flink/" rel="tag"># Flink</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/08/16/Scala Note/" rel="prev" title="Scala Note">
      <i class="fa fa-chevron-left"></i> Scala Note
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/11/06/Phoenix/" rel="next" title="Phoenix测试">
      Phoenix测试 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80Mzk4NC8yMDUyMA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#WaterMark"><span class="nav-number">1.</span> <span class="nav-text">WaterMark</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window划分"><span class="nav-number">3.</span> <span class="nav-text">window划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例"><span class="nav-number">4.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提取watermark"><span class="nav-number">5.</span> <span class="nav-text">提取watermark</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AssignerWithPeriodicWatermarks"><span class="nav-number">6.</span> <span class="nav-text">AssignerWithPeriodicWatermarks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AssignerWithPunctuatedWatermarks"><span class="nav-number">7.</span> <span class="nav-text">AssignerWithPunctuatedWatermarks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用"><span class="nav-number">8.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置数据流时间特征"><span class="nav-number">9.</span> <span class="nav-text">设置数据流时间特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码详解"><span class="nav-number">10.</span> <span class="nav-text">代码详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#试验"><span class="nav-number">11.</span> <span class="nav-text">试验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一次"><span class="nav-number">11.1.</span> <span class="nav-text">第一次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二次"><span class="nav-number">11.2.</span> <span class="nav-text">第二次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三次"><span class="nav-number">11.3.</span> <span class="nav-text">第三次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第四次"><span class="nav-number">11.4.</span> <span class="nav-text">第四次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第五次"><span class="nav-number">11.5.</span> <span class="nav-text">第五次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第六次"><span class="nav-number">11.6.</span> <span class="nav-text">第六次</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论"><span class="nav-number">12.</span> <span class="nav-text">结论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多并行度"><span class="nav-number">13.</span> <span class="nav-text">多并行度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">14.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink如何处理乱序？"><span class="nav-number">15.</span> <span class="nav-text">Flink如何处理乱序？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink何时触发window？"><span class="nav-number">16.</span> <span class="nav-text">Flink何时触发window？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink应该如何设置最大乱序时间？"><span class="nav-number">17.</span> <span class="nav-text">Flink应该如何设置最大乱序时间？</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fly Hugh"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Fly Hugh</p>
  <div class="site-description" itemprop="description">WE CHOOSE TO  GO TO THE MARS</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/FlyMeToTheMars" title="GitHub → https://github.com/FlyMeToTheMars" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/flyhobo@live.com" title="E-Mail → flyhobo@live.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3200892914" title="Weibo → https://weibo.com/u/3200892914" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Fly__HoBo" title="Twitter → https://twitter.com/Fly__HoBo" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fly Hugh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
