<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/xingqiushangcheng.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/xingqiushangcheng.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="正则表达式，学一次忘一次，记录之。">
<meta name="keywords" content="Regex">
<meta property="og:type" content="article">
<meta property="og:title" content="正则表达式">
<meta property="og:url" content="http://yoursite.com/2020/09/19/正则表达式/index.html">
<meta property="og:site_name" content="Mars">
<meta property="og:description" content="正则表达式，学一次忘一次，记录之。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1givri8wp12j20r802cmwx.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1givrsiqe4xj20hl0bsq37.jpg">
<meta property="og:updated_time" content="2020-09-19T08:38:23.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="正则表达式">
<meta name="twitter:description" content="正则表达式，学一次忘一次，记录之。">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/bec9bff2gy1givri8wp12j20r802cmwx.jpg">

<link rel="canonical" href="http://yoursite.com/2020/09/19/正则表达式/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>正则表达式 | Mars</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Mars" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mars</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/19/正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fly Hugh">
      <meta itemprop="description" content="WE CHOOSE TO  GO TO THE MARS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          正则表达式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-19 10:10:25 / 修改时间：16:38:23" itemprop="dateCreated datePublished" datetime="2020-09-19T10:10:25+08:00">2020-09-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1givri8wp12j20r802cmwx.jpg" alt="undefined"></p>
<blockquote>
<p> 正则表达式，学一次忘一次，记录之。</p>
</blockquote>
<a id="more"></a> 

<h1 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h1><blockquote>
<p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/bec9bff2gy1givrsiqe4xj20hl0bsq37.jpg" alt="undefined"></p>
<p>以上的正则表达式可以接受 <code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。 但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p>
<h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1.基本匹配"></a>1.基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。 例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;the&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2.元字符"></a>2.元字符</h2><p>元字符不代表他们本身的字面意思，他们都有特殊的含义。</p>
<p>一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>句号匹配任意单个字符除了换行符。</td>
</tr>
<tr>
<td>[ ]</td>
<td>字符种类。匹配方括号内的任意字符。</td>
</tr>
<tr>
<td>[^ ]</td>
<td>否定的字符种类。匹配除了方括号里的任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配&gt;=0个重复的在*号之前的字符。</td>
</tr>
<tr>
<td>+</td>
<td>匹配&gt;=1个重复的+号前的字符。</td>
</tr>
<tr>
<td>?</td>
<td>标记?之前的字符为可选.</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td>
</tr>
<tr>
<td>(xyz)</td>
<td>字符集，匹配与 xyz 完全相等的字符串.</td>
</tr>
<tr>
<td>|</td>
<td>或运算符，匹配符号前或后的字符.</td>
</tr>
<tr>
<td>\</td>
<td>转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td>
</tr>
<tr>
<td>^</td>
<td>从开始行开始匹配.</td>
</tr>
<tr>
<td>$</td>
<td>从末端开始匹配.</td>
</tr>
</tbody></table>
<h3 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a>2.1 点运算符 <code>.</code></h3><p><code>.</code>是元字符中最简单的例子。 <code>.</code>匹配任意单个字符，但不匹配换行符。 例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;.ar&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>

<h3 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h3><p>字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[Tt]he&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>

<p>方括号的句号就表示句号。 表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ar[.]&quot; =&gt; A garage is a good place to park a car.</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h4><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[^c]ar&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>

<h3 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a>2.3 重复次数</h3><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。</p>
<h4 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a>2.3.1 <code>*</code> 号</h4><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。 例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[a-z]*&quot; =&gt; The car parked in the garage #21.</span><br></pre></td></tr></table></figure>

<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。 <code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\s*cat\s*&quot; =&gt; The fat cat sat on the concatenation.</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a>2.3.2 <code>+</code> 号</h4><p><strong><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。</strong> 例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;c.+t&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a>2.3.3 <code>?</code> 号</h4><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[T]he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[T]?he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h3 id="2-4-号"><a href="#2-4-号" class="headerlink" title="2.4 {} 号"></a>2.4 <code>{}</code> 号</h3><p>在正则表达式中 <code>{}</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,3&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>

<p>我们可以省略第二个参数。 例如，<code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,&#125;&quot; =&gt; The number was 9.9997 but we rounded it of</span><br></pre></td></tr></table></figure>

<p>如果逗号也省略掉则表示重复固定的次数。 例如，<code>[0-9]{3}</code> 匹配3位数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;3&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>

<h3 id="2-5-特征标群"><a href="#2-5-特征标群" class="headerlink" title="2.5 (...) 特征标群"></a>2.5 <code>(...)</code> 特征标群</h3><p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, <strong>表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。</strong>再比如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>{}</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(c|g|p)ar&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h3 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a>2.6 <code>|</code> 或运算符</h3><p>或运算符就表示或，用作判断条件。</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he|car&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h3 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a>2.7 转码特殊字符</h3><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(f|c|m)at\.?&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a>2.8 锚点</h3><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p>
<h4 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a>2.8.1 <code>^</code> 号</h4><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p>
<p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p>
<p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;^(T|t)he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h4 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a>2.8.2 <code>$</code> 号</h4><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p>
<p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(at\.)&quot; =&gt; The fat cat. sat. on the mat.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(at\.)$&quot; =&gt; The fat cat. sat. on the mat.</span><br></pre></td></tr></table></figure>

<h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式提供一些常用的字符集简写。如下:</p>
<table>
<thead>
<tr>
<th>简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td>\W</td>
<td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字： <code>[0-9]</code></td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字： <code>[^\d]</code></td>
</tr>
<tr>
<td>\s</td>
<td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td>\S</td>
<td>匹配所有非空格字符： <code>[^\s]</code></td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符</td>
</tr>
<tr>
<td>\p</td>
<td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p>进阶内容：</p>
</blockquote>
<h2 id="4-零宽断言"><a href="#4-零宽断言" class="headerlink" title="4.零宽断言"></a>4.零宽断言</h2><blockquote>
<p>无论是零宽还是断言，听起来都古古怪怪的，<br>那先解释一下这两个词。</p>
</blockquote>
<ol>
<li><p>断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，<br>意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”,正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.</p>
</li>
<li><p>零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</p>
</li>
</ol>
<p>假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1   &quot;&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>其中也就‘641’这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果正则应该怎么匹配呢？</p>
<p>下面先来讲几种类型的断言：</p>
<ol>
<li>正向先行断言（正前瞻）：</li>
</ol>
<ul>
<li>语法：（?=pattern）<br>作用：匹配pattern表达式的前面内容，不返回本身。</li>
</ul>
<p>这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到<code>&lt;/span&gt;</code>前面的数字内容</p>
<p>按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=) 就可以匹配到前面的内容了。</p>
<p>匹配什么内容呢？如果要所有内容那就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">".+(?=&lt;/span&gt;)"</span>;</span><br><span class="line"></span><br><span class="line">String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=  pattern.matcher(test);</span><br><span class="line"><span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">	System.out.println(<span class="string">"匹配结果："</span>);</span><br><span class="line">	System.out.println(mc.group());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配结果：</span></span><br><span class="line"><span class="comment">//&lt;span class="read-count"&gt;阅读数：641</span></span><br></pre></td></tr></table></figure>

<p>可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"\\d+(?=&lt;/span&gt;)"</span>;</span><br><span class="line"></span><br><span class="line">String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=  pattern.matcher(test);</span><br><span class="line"><span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">  System.out.println(mc.group());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配结果：</span></span><br><span class="line"><span class="comment">//641</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>正向后行断言（正后顾）:</li>
</ol>
<ul>
<li><p>语法：（?&lt;=pattern）</p>
<p>作用：匹配pattern表达式的后面的内容，不返回本身。</p>
</li>
</ul>
<p>有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。<br>上面的栗子，我们也可以用后行断言来处理.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(?&lt;=&lt;span class="read-count"&gt;阅读数：)\d+</span></span><br><span class="line">String reg=<span class="string">"(?&lt;=&lt;span class=\"read-count\"&gt;阅读数：)\\d+"</span>;</span><br><span class="line"></span><br><span class="line">String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=    pattern.matcher(test);</span><br><span class="line">     <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">       System.out.println(mc.group());</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//匹配结果：</span></span><br><span class="line"><span class="comment">//641</span></span><br></pre></td></tr></table></figure>

<p>就这么简单。</p>
<ol start="3">
<li>负向先行断言（负前瞻）</li>
</ol>
<ul>
<li>语法：(?!pattern)</li>
<li>作用：匹配非pattern表达式的前面内容，不返回本身。</li>
</ul>
<p>有正向也有负向，负向在这里其实就是非的意思。<br>举个栗子：<strong>比如有一句 “我爱祖国，我是祖国的花朵”</strong><br><strong>现在要找到不是’的花朵’前面的祖国</strong><br>用正则就可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">祖国(?!的花朵)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>负向后行断言（负后顾）</li>
</ol>
<ul>
<li>语法：(?&lt;!pattern)</li>
<li>作用：匹配非pattern表达式的后面内容，不返回本身。</li>
</ul>
<h2 id="5-捕获和非捕获"><a href="#5-捕获和非捕获" class="headerlink" title="5. 捕获和非捕获"></a>5. 捕获和非捕获</h2><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”</p>
<blockquote>
<p>捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。</p>
</blockquote>
<p>而根据命名方式的不同，又可以分为两种组：</p>
<ol>
<li>数字编号捕获组：<br>语法：(exp)<br>解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。<br>比如固定电话的：020-85653333<br>他的正则表达式为：(0\d{2})-(\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</li>
</ol>
<table>
<thead>
<tr>
<th>序号</th>
<th>编号</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>(0\d{2})</td>
<td>020</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"020-85653333"</span>;</span><br><span class="line">     String reg=<span class="string">"(0\\d&#123;2&#125;)-(\\d&#123;8&#125;)"</span>;</span><br><span class="line">     Pattern pattern = Pattern.compile(reg);</span><br><span class="line">     Matcher mc= pattern.matcher(test);</span><br><span class="line">     <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line">       System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mc.groupCount();i++)&#123;</span><br><span class="line">             System.out.println(<span class="string">"第"</span>+i+<span class="string">"个分组为："</span>+mc.group(i));</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">第0个分组为：020-85653333</span><br><span class="line">第1个分组为：020</span><br><span class="line">第2个分组为：85653333</span><br></pre></td></tr></table></figure>

<p>可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。</p>
<ol start="2">
<li>命名编号捕获组：<br>语法：(?<name>exp)<br>解释：分组的命名由表达式中的name指定<br>比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</haoma></quhao></name></li>
</ol>
<table>
<thead>
<tr>
<th>序号</th>
<th>编号</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>quhao</td>
<td>(0\d{2})</td>
<td>020</td>
</tr>
<tr>
<td>2</td>
<td>haoma</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"020-85653333"</span>;</span><br><span class="line">     String reg=<span class="string">"(?&lt;quhao&gt;0\\d&#123;2&#125;)-(?&lt;haoma&gt;\\d&#123;8&#125;)"</span>;</span><br><span class="line">     Pattern pattern = Pattern.compile(reg);</span><br><span class="line">     Matcher mc= pattern.matcher(test);</span><br><span class="line">     <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line">         System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line">         System.out.println(mc.group(<span class="string">"quhao"</span>));</span><br><span class="line">         System.out.println(mc.group(<span class="string">"haoma"</span>));</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">分组名称为:quhao,匹配内容为：020</span><br><span class="line">分组名称为:haoma,匹配内容为：85653333</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>非捕获组：<br>语法：(?:exp)<br>解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。</li>
</ol>
<p>比如上面的正则表达式，程序<strong>不需要用到第一个分组</strong>，那就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?:\0\d&#123;2&#125;)-(\d&#123;8&#125;)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>序号</th>
<th>编号</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
</tbody></table>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：1</span><br><span class="line">第0个分组为：020-85653333</span><br><span class="line">第1个分组为：85653333</span><br></pre></td></tr></table></figure>

<h2 id="6-反向引用"><a href="#6-反向引用" class="headerlink" title="6.反向引用"></a>6.反向引用</h2><p>上面讲到捕获，我们知道：**<em>捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用**</em>。</p>
<p>根据捕获组的命名规则，反向引用可分为：</p>
<ol>
<li>数字编号组反向引用：\k<br>或\number</li>
<li>命名编号组反向引用：\k<br>或者&#39;name’</li>
</ol>
<p>上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用<br>注意两个字眼：“内容” 和 “使用”<br>这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住<br>那这里所说的“使用”是怎样使用呢？</p>
<ul>
<li>1）匹配到一个字母</li>
<li>2）匹配第下一个字母，检查是否和上一个字母是否一样</li>
<li>3）如果一样，则匹配成功，否则失败</li>
</ul>
<p>首先匹配一个字母：\w<br>我们需要做成分组才能捕获，因此写成这样：(\w)</p>
<p>那这个表达式就有一个捕获组：（\w）<br>然后我们要用这个捕获组作为条件，那就可以：(\w)\1<br>这样就大功告成了<br>可能有人不明白了，\1是什么意思呢？<br>还记得捕获组有两种命名方式吗，<strong>一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名</strong><br>在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的</p>
<p>因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k&lt;1&gt;或者\1<br>当然，通常都是是后者。<br>我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"aabbbbgbddesddfiid"</span>;</span><br><span class="line">     Pattern pattern = Pattern.compile(<span class="string">"(\\w)\\1"</span>);</span><br><span class="line">     Matcher mc= pattern.matcher(test);</span><br><span class="line">     <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">         System.out.println(mc.group());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">bb</span><br><span class="line">dd</span><br><span class="line">dd</span><br><span class="line">ii</span><br></pre></td></tr></table></figure>

<p>嗯，这就是我们想要的了。</p>
<p>在举个替换的例子，假如想要把字符串中abc换成a</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"abcbbabcbcgbddesddfiid"</span>;</span><br><span class="line">String reg=<span class="string">"(a)(b)c"</span>;</span><br><span class="line">System.out.println(test.replaceAll(reg, <span class="string">"$1"</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abbabcgbddesddfiid</span><br></pre></td></tr></table></figure>

<h2 id="7-贪婪和非贪婪"><a href="#7-贪婪和非贪婪" class="headerlink" title="7.贪婪和非贪婪"></a>7.贪婪和非贪婪</h2><p>我们都知道，贪婪就是不满足，尽可能多的要。<br>在正则中，贪婪也是差不多的意思:</p>
<blockquote>
<p>贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。<br>特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。</p>
</blockquote>
<p>前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;3,6&#125;</span><br></pre></td></tr></table></figure>

<p>用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"\\d&#123;3,6&#125;"</span>;        </span><br><span class="line">String test=<span class="string">"61762828 176 2991 871"</span>;</span><br><span class="line">System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line">System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line">Pattern p1 =Pattern.compile(reg);</span><br><span class="line">Matcher m1 = p1.matcher(test);</span><br><span class="line"> <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line">   System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文本：61762828 176 2991 44 871</span><br><span class="line">贪婪模式：\d&#123;3,6&#125;</span><br><span class="line">匹配结果：617628</span><br><span class="line">匹配结果：176</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：871</span><br></pre></td></tr></table></figure>

<p>由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。<br>一个量词就如此贪婪了，<br>那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？</p>
<blockquote>
<p>是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"(\\d&#123;1,2&#125;)(\\d&#123;3,4&#125;)"</span>;        </span><br><span class="line">String test=<span class="string">"61762828 176 2991 87321"</span>;</span><br><span class="line">System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line">System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line">Pattern p1 =Pattern.compile(reg);</span><br><span class="line">Matcher m1 = p1.matcher(test);</span><br><span class="line"> <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line">   System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>“617628” 是前面的\d{1,2}匹配出了61，后面的匹配出了7628</li>
<li>“2991” 是前面的\d{1,2}匹配出了29 ，后面的匹配出了91</li>
<li>“87321”是前面的\d{1,2}匹配出了87，后面的匹配出了321</li>
</ol>
<p><strong>2. 懒惰（非贪婪）</strong></p>
<blockquote>
<p>懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。<br>特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。</p>
</blockquote>
<p>懒惰量词是在贪婪量词后面加个“？”</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或者更多次，但尽可能减少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复0次或者1次，但尽可能减少重复</td>
</tr>
<tr>
<td>(n,m)?</td>
<td>重复n到m次，尽可能减少重复</td>
</tr>
<tr>
<td>(n,)?</td>
<td>重复n次以上，但尽可能减少重复</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg=<span class="string">"(\\d&#123;1,2&#125;?)(\\d&#123;3,4&#125;)"</span>;        </span><br><span class="line">     String test=<span class="string">"61762828 176 2991 87321"</span>;</span><br><span class="line">     System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line">     System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line">     Pattern p1 =Pattern.compile(reg);</span><br><span class="line">     Matcher m1 = p1.matcher(test);</span><br><span class="line">     <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line">         System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文本：61762828 176 2991 87321</span><br><span class="line">贪婪模式：(\d&#123;1,2&#125;?)(\d&#123;3,4&#125;)</span><br><span class="line">匹配结果：61762</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：87321</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762<br>“2991” 是左边的懒惰匹配出2，右边的贪婪匹配出991<br>“87321” 左边的懒惰匹配出8，右边的贪婪匹配出7321</p>
</blockquote>
<h2 id="8-反义"><a href="#8-反义" class="headerlink" title="8.反义"></a>8.反义</h2><p>前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody></table>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Regex/" rel="tag"># Regex</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/05/动态规划/" rel="prev" title="动态规划">
      <i class="fa fa-chevron-left"></i> 动态规划
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/21/设计模式/" rel="next" title="设计模式">
      设计模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80Mzk4NC8yMDUyMA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Regex"><span class="nav-number">1.</span> <span class="nav-text">Regex</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-基本匹配"><span class="nav-number">1.1.</span> <span class="nav-text">1.基本匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-元字符"><span class="nav-number">1.2.</span> <span class="nav-text">2.元字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-点运算符"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 点运算符 .</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-字符集"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 字符集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-否定字符集"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1 否定字符集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-重复次数"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 重复次数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-号"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">2.3.1 * 号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-号"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2.3.2 + 号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-号"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">2.3.3 ? 号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-号"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 {} 号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-特征标群"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 (...) 特征标群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-或运算符"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 | 或运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-转码特殊字符"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7 转码特殊字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-锚点"><span class="nav-number">1.2.8.</span> <span class="nav-text">2.8 锚点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-1-号"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">2.8.1 ^ 号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-2-号"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">2.8.2 $ 号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-简写字符集"><span class="nav-number">1.3.</span> <span class="nav-text">3. 简写字符集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-零宽断言"><span class="nav-number">1.4.</span> <span class="nav-text">4.零宽断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-捕获和非捕获"><span class="nav-number">1.5.</span> <span class="nav-text">5. 捕获和非捕获</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-反向引用"><span class="nav-number">1.6.</span> <span class="nav-text">6.反向引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-贪婪和非贪婪"><span class="nav-number">1.7.</span> <span class="nav-text">7.贪婪和非贪婪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-反义"><span class="nav-number">1.8.</span> <span class="nav-text">8.反义</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fly Hugh"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Fly Hugh</p>
  <div class="site-description" itemprop="description">WE CHOOSE TO  GO TO THE MARS</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/FlyMeToTheMars" title="GitHub → https://github.com/FlyMeToTheMars" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/flyhobo@live.com" title="E-Mail → flyhobo@live.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3200892914" title="Weibo → https://weibo.com/u/3200892914" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Fly__HoBo" title="Twitter → https://twitter.com/Fly__HoBo" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fly Hugh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
