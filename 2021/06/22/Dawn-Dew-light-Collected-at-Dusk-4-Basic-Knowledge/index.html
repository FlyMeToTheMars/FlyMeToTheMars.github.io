<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/xingqiushangcheng.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/xingqiushangcheng.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="硬件相关">
<meta name="keywords" content="Basic Knowledge">
<meta property="og:type" content="article">
<meta property="og:title" content="Dawn Dew-light Collected at Dusk 4 Basic Knowledge">
<meta property="og:url" content="http://yoursite.com/2021/06/22/Dawn-Dew-light-Collected-at-Dusk-4-Basic-Knowledge/index.html">
<meta property="og:site_name" content="Mars">
<meta property="og:description" content="硬件相关">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622170319.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181145.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181044.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181222.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181253.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181321.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082138.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082207.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082232.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082618.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082709.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082802.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623084951.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085008.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085105.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085438.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085453.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085618.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623092917.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623093020.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623094007.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623095415.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112258.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112408.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112429.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112440.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623113721.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623114108.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623114328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623163858.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623164748.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623164924.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623164950.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165424.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165523.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165554.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165746.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623181121.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623181158.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623184936.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185115.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185149.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185353.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185407.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192452.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192516.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192542.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192608.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192721.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192734.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192836.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192908.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192934.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623193000.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623193037.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163206.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163234.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163245.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163304.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163351.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163445.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163604.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164203.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164220.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164338.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164356.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164423.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164445.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164508.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164532.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164558.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164612.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175451.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175512.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175634.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175755.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175807.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175820.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175954.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625083225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625095958.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100100.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100117.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100241.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100254.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100315.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100334.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625112735.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625112814.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155406.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155440.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155533.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155618.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155651.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155721.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155915.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161610.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161838.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161919.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162004.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162028.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162217.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162350.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162413.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162620.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162748.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162857.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163156.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163419.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163747.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163858.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625164318.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625164501.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170256.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170318.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170357.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170428.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625171945.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625172114.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625172558.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625172807.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625184430.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231718.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231734.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231804.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231821.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231849.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625232027.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625232119.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234904.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234920.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234931.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234944.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234955.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625235008.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210627232933.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628093200.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628095938.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628100030.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628101849.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103020.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103053.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103553.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103822.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628162006.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628164745.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628170950.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628171637.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628171759.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628171907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628172018.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628174552.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628174702.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628174718.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628204545.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628204612.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628210820.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629101758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629102827.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103056.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103155.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103532.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103643.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103850.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103924.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629104016.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629142514.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629142927.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629142948.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629143035.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629144737.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629144754.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145239.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145400.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145457.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145715.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629153904.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629161923.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629163221.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629164711.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629164820.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629164948.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629165508.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629165525.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629165616.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170014.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170109.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170301.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170357.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170534.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170619.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172322.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172756.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172811.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172930.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172919.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629173135.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629174119.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630074809.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630074921.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630074952.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630075950.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080008.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080027.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080043.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080147.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080417.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080512.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080549.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080610.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080742.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080849.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082207.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082256.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082432.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082520.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082535.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082642.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082707.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630084651.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630084827.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630084959.png">
<meta property="og:image" content="c:/Users/flyho/AppData/Roaming/Typora/typora-user-images/image-20210630090802588.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630090928.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630091007.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630114725.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630114822.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115010.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115403.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115722.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115733.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115747.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115757.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115809.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115820.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115834.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115846.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115857.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630120634.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122049.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122159.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122235.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122411.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122600.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122821.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630123321.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630123348.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630123725.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630132054.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630132147.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630132331.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630133938.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630134225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630143310.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630143358.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630143425.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630151654.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630152655.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164233.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164829.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164854.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164918.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630170647.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630173215.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630173421.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630173726.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184343.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184512.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184649.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184722.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185319.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185409.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185657.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185709.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185721.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185800.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630191158.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702155902.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702160902.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702161329.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702162042.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702162145.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163612.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163639.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163658.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163712.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163732.png">
<meta property="og:image" content="https://s0.lgstatic.com/i/image6/M00/38/82/Cgp9HWB5WbqAVlGaAHeNbdcL7hg030.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703190417.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703190820.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703190919.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191322.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191719.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191730.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191833.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703192001.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703192457.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703211701.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210705220326.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210705220350.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104250.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104304.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104409.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104440.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104531.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104544.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104643.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104659.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802114305.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802115634.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802115717.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802121021.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802121620.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802121802.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802141337.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802141549.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802162709.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802162809.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802162837.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802171040.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174247.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174259.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174313.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174554.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174930.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183750.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183809.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183828.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183916.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183939.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802184039.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802200225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802200313.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803112824.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803112917.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113019.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113046.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113103.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113115.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803144303.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803145544.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803152908.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803153001.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803153240.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803153251.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805093142.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805093848.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805093929.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805112609.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805112645.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805112658.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808194717.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808195425.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808195528.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808195704.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808202324.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808205656.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808205853.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808205946.png">
<meta property="og:updated_time" content="2025-07-30T07:21:56.493Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dawn Dew-light Collected at Dusk 4 Basic Knowledge">
<meta name="twitter:description" content="硬件相关">
<meta name="twitter:image" content="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622170319.png">

<link rel="canonical" href="http://yoursite.com/2021/06/22/Dawn-Dew-light-Collected-at-Dusk-4-Basic-Knowledge/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Dawn Dew-light Collected at Dusk 4 Basic Knowledge | Mars</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Mars" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mars</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/22/Dawn-Dew-light-Collected-at-Dusk-4-Basic-Knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fly Hugh">
      <meta itemprop="description" content="WE CHOOSE TO  GO TO THE MARS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dawn Dew-light Collected at Dusk 4 Basic Knowledge
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-22 07:45:56" itemprop="dateCreated datePublished" datetime="2021-06-22T07:45:56+08:00">2021-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-30 15:21:56" itemprop="dateModified" datetime="2025-07-30T15:21:56+08:00">2025-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>硬件相关</p>
</blockquote>
<a id="more"></a> 

<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h2><h3 id="芯片工作的原理"><a href="#芯片工作的原理" class="headerlink" title="芯片工作的原理"></a>芯片工作的原理</h3><p>芯片工作的原理简单图示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622170319.png" alt="image-20210622170319444"></p>
<p>图灵机在计算科学有两个巨大的贡献：</p>
<p>1.清楚地定义了计算机能力的边界，也就是可计算理论。</p>
<p>2.定义了计算机由哪些部分组成，程序又是如何执行的。</p>
<h3 id="图灵机的构造"><a href="#图灵机的构造" class="headerlink" title="图灵机的构造"></a>图灵机的构造</h3><p>想要学懂程序执行的原理，就要从图灵机说起了。它在计算机科学方面有两个巨大的贡献：</p>
<p>第一，它清楚地定义了计算机能力的边界，也就是可计算理论；</p>
<p>第二，它定义了计算机由哪些部分组成，程序又是如何执行的。</p>
<p>我们先来看一看图灵机的内部构造：</p>
<p>图灵机拥有一条无限长的纸带，纸带上是一个格子挨着一个格子，格子中可以写字符，你可以把纸带看作内存，而这些字符可以看作是内存中的数据或者程序。</p>
<p>图灵机有一个读写头，读写头可以读取任意格子上的字符，也可以改写任意格子的字符。</p>
<p>读写头上面的盒子里是一些精密的零件，包括图灵机的存储、控制单元和运算单元。</p>
<h3 id="图灵机如何执行程序"><a href="#图灵机如何执行程序" class="headerlink" title="图灵机如何执行程序"></a>图灵机如何执行程序</h3><p>首先，我们将“11、15、+” 分别写入纸带上的 3 个格子（现在纸带上的字符串是11、15、 +)，然后将读写头先停在 11 对应的格子上。</p>
<p>接下来，图灵机通过读写头读入 11 到它的存储设备中（这个存储设备也叫作图灵机的状态）。图灵机没有说读写头为什么可以识别纸带上的字符，而是假定读写头可以做到这点。</p>
<p>然后读写头向右移动一个格，用同样的方法将 15 读入图灵机的状态中。现在图灵机的状态中有两个连续的数字，11 和 15。</p>
<p>接下来重复上面的过程，会读到一个+号。下面我详细说一下这个运算流程：</p>
<p>读写头读到一个 + 号 ；</p>
<p>然后将 + 号传输给控制单元 ；</p>
<p>控制单元发现是一个 + 号，所以没有存入状态中。因为 + 号是一个我们预设的控制符（指令），它的作用是加和目前状态。因此，控制单元识别出是控制符，并通知运算单元工作；</p>
<p>运算单元从状态中读入 11、15 并进行计算，将结果 26 存储到状态；</p>
<p>运算单元将结果回传给控制单元；</p>
<p>控制单元将结果传输给读写头。</p>
<p>读写头向右移动，将结果 26 写入纸带。</p>
<p>这样，我们就通过图灵机计算出了 11+15 的值。不知道你有没有发现，图灵机构造的这一台机器，主要功能就是读写纸带然后计算；纸带中有数据、也有控制字符（也就是指令），这个设计和我们今天的计算机是一样的。</p>
<p>图灵通过数学证明了，一个问题如果可以拆解成图灵机的可执行步骤，那问题就是可计算的。另一方面，图灵机定义了计算机的组成以及工作原理，但是没有给出具体的实现。</p>
<h3 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h3><p>具体的实现是 1945 年冯诺依曼和其他几位科学家在著名的 101 页报告中提出的。报告遵循了图灵机的设计，并提出用电子元件构造计算机，约定了用二进制进行计算和存储，并且将计算机结构分成以下 5 个部分：</p>
<p>​    输入设备；</p>
<p>​    输出设备；</p>
<p>​    内存；</p>
<p>​    中央处理器；</p>
<p>​    总线。</p>
<p>这个模型也被称为冯诺依曼模型，下面我们具体来看看这 5 部分的作用。</p>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。存储的数据单位是一个二进制位，英文是 bit。最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。</p>
<p>我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。</p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>冯诺依曼模型中 CPU 负责控制和计算。为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。</p>
<p>如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；</p>
<p>如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。</p>
<p>这里的 32 和 64，称作 CPU 的位宽。</p>
<p>为什么 CPU 要这样设计呢？ 因为一个 byte 最大的表示范围就是 0~255。比如要计算 20000*50，就超出了byte 最大的表示范围了。因此，CPU 需要支持多个 byte 一起计算。当然，CPU 位数越大，可以计算的数值就越大。但是在现实生活中不一定需要计算这么大的数值。比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。</p>
<h4 id="控制单元和逻辑运算单元"><a href="#控制单元和逻辑运算单元" class="headerlink" title="控制单元和逻辑运算单元"></a>控制单元和逻辑运算单元</h4><p>CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。具体的工作原理我们在指令部分给大家分析。</p>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>CPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。这种存储就是寄存器。寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。</p>
<p>寄存器中有一部分是可供用户编程用的，比如用来存加和指令的两个参数，是通用寄存器。</p>
<p>还有一部分寄存器有特殊的用途，叫作特殊寄存器。比如程序指针，就是一个特殊寄存器。它存储了 CPU 要执行的下一条指令所在的内存地址。注意，程序指针不是存储了下一条要执行的指令，此时指令还在内存中，程序指针只是存储了下一条指令的地址。</p>
<p>下一条要执行的指令，会从内存读入到另一个特殊的寄存器中，这个寄存器叫作指令寄存器。指令被执行完成之前，指令都存储在这里。</p>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。总线分成 3 种：</p>
<p>一种是地址总线，专门用来指定 CPU 将要操作的内存地址。</p>
<p>还有一种是数据总线，用来读写内存中的数据。</p>
<p>当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。</p>
<p>最后一种总线叫作控制总线，用来发送和接收关键信号，比如后面我们会学到的中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，这也需要控制总线。</p>
<h4 id="输入、输出设备"><a href="#输入、输出设备" class="headerlink" title="输入、输出设备"></a>输入、输出设备</h4><p>输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。</p>
<h3 id="冯诺依曼模型的几个问题："><a href="#冯诺依曼模型的几个问题：" class="headerlink" title="冯诺依曼模型的几个问题："></a>冯诺依曼模型的几个问题：</h3><h5 id="1-线路位宽问题"><a href="#1-线路位宽问题" class="headerlink" title="1.线路位宽问题"></a>1.线路位宽问题</h5><p>第一个问题是，你可能会好奇数据如何通过线路传递。其实是通过操作电压，低电压是 0，高电压是 1。</p>
<p>如果只有一条线路，每次只能传递 1 个信号，因为你必须在 0,1 中选一个。比如你构造高高低低这样的信号，其实就是 1100，相当于你传了一个数字 10 过去。大家注意，这种传递是相当慢的，因为你需要传递 4 次。</p>
<p>这种一个 bit 一个 bit 发送的方式，我们叫作串行。如果希望每次多传一些数据，就需要增加线路，也就是需要并行。</p>
<p>如果只有 1 条地址总线，那每次只能表示 0-1 两种情况，所以只能操作 2 个内存地址；如果有 10 条地址总线，一次就可以表示 210 种情况，也就是可以操作 1024 个内存地址；如果你希望操作 4G 的内存，那么就需要 32 条线，因为 232 是 4G。</p>
<p>到这里，你可能会问，那我串行发送行不行？当然也不是不行，只是速度会很慢，因为每多增加一条线路速度就会翻倍。</p>
<h5 id="2-64-位和-32-位的计算"><a href="#2-64-位和-32-位的计算" class="headerlink" title="2. 64 位和 32 位的计算"></a>2. 64 位和 32 位的计算</h5><p>第二个问题是，CPU 的位宽会对计算造成什么影响？</p>
<p>我们来看一个具体场景：要用 32 位宽的 CPU，加和两个 64 位的数字。</p>
<p>32 位宽的 CPU 控制 40 位宽的地址总线、数据总线工作会非常麻烦，需要双方制定协议。 因此通常 32 位宽 CPU 最多操作 32 位宽的地址总线和数据总线。</p>
<p>因此必须把两个 64 位数字拆成 2 个 32 位数字来计算，这样就需要一个算法，比如用像小时候做加法竖式一样，先加和两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位。</p>
<p>而 64 位的 CPU 就可以一次读入 64 位的数字，同时 64 位的 CPU 内部的逻辑计算单元，也支持 64 位的数字进行计算。但是你千万不要仅仅因为位宽的区别，就认为 64 位 CPU 性能比 32 位高很多。</p>
<p>要知道大部分应用不需要计算超过 32 位的数字，比如你做一个电商网站，用户的金额通常是 10 万以下的，而 32 位有符号整数，最大可以到 20 亿。所以这样的计算在 32 位还是 64 位中没有什么区别。</p>
<p>还有一点要注意，32 位宽的 CPU 没办法控制超过 32 位的地址总线、数据总线工作。比如说你有一条 40 位的地址总线（其实就是 40 条线），32 位的 CPU 没有办法一次给 40 个信号，因为它最多只有 32 位的寄存器。因此 32 位宽的 CPU 最多操作 232 个内存地址，也就是 4G 内存地址。</p>
<h3 id="程序的执行过程"><a href="#程序的执行过程" class="headerlink" title="程序的执行过程"></a>程序的执行过程</h3><p>当 CPU 执行程序的时候：</p>
<p>1.首先，CPU 读取 PC 指针指向的指令，将它导入指令寄存器。具体来说，完成读取指令这件事情有 3 个步骤：</p>
<p>步骤 1：CPU 的控制单元操作地址总线指定需要访问的内存地址（简单理解，就是把 PC 指针中的值拷贝到地址总线中）。</p>
<p>步骤 2：CPU 通知内存设备准备数据（内存设备准备好了，就通过数据总线将数据传送给 CPU）。</p>
<p>步骤 3：CPU 收到内存传来的数据后，将这个数据存入指令寄存器。</p>
<p>完成以上 3 步，CPU 成功读取了 PC 指针指向指令，存入了指令寄存器。</p>
<p>2.然后，CPU 分析指令寄存器中的指令，确定指令的类型和参数。<br>3.如果是计算类型的指令，那么就交给逻辑运算单元计算；如果是存储类型的指令，那么由控制单元执行。<br>4.PC 指针自增，并准备获取下一条指令。</p>
<blockquote>
<p>比如在 32 位的机器上，指令是 32 位 4 个字节，需要 4 个内存地址存储，因此 PC 指针会自增 4。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181145.png" alt="image-20210622181145576"></p>
</blockquote>
<p>了解了程序的执行过程后，我还有一些问题想和大家一起讨论：</p>
<p>内存虽然是一个随机存取器，但是我们通常不会把指令和数据存在一起，这是为了安全起见。具体的原因我会在模块四进程部分展开讲解，欢迎大家在本课时的留言区讨论起来，我会结合你们留言的内容做后续的课程设计。</p>
<p>程序指针也是一个寄存器，64 位的 CPU 会提供 64 位的寄存器，这样就可以使用更多内存地址。特别要说明的是，64 位的寄存器可以寻址的范围非常大，但是也会受到地址总线条数的限制。比如和 64 位 CPU 配套工作的地址总线只有 40 条，那么可以寻址的范围就只有 1T，也就是 240。</p>
<p>从 PC 指针读取指令、到执行、再到下一条指令，构成了一个循环，这个不断循环的过程叫作CPU 的指令周期，下面我们会详细讲解这个概念。</p>
<h3 id="详解-a-11-15-的执行过程"><a href="#详解-a-11-15-的执行过程" class="headerlink" title="详解 a = 11 + 15 的执行过程"></a>详解 a = 11 + 15 的执行过程</h3><p>上面我们了解了基本的程序执行过程，接下来我们来看看如果用冯诺依曼模型执行a=11+15是一个怎样的过程。</p>
<p>我们再 Review 下这个问题：程序员写的程序a=11+15是字符串，CPU 不能执行字符串，只能执行指令。所以这里需要用到一种特殊的程序——编译器。编译器的核心能力是翻译，它把一种程序翻译成另一种程序语言。</p>
<p>这里，我们需要编译器将程序员写的程序翻译成 CPU 认识的指令（指令我们认为是一种低级语言，我们平时书写的是高级语言）。你可以先跟我完整地学完操作系统，再去深入了解编译原理的内容。</p>
<p>下面我们来详细阐述 a=11+15 的执行过程：</p>
<p>1.编译器通过分析，发现 11 和 15 是数据，因此编译好的程序启动时，会在内存中开辟出一个专门的区域存这样的常数，这个专门用来存储常数的区域，就是数据段，如下图所示：</p>
<p>11 被存储到了地址 0x100；</p>
<p>15 被存储到了地址 0x104；</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181044.png" alt="image-20210622181044065"></p>
<p>2.编译器将a=11+15转换成了 4 条指令，程序启动后，这些指令被导入了一个专门用来存储指令的区域，也就是正文段。如上图所示，这 4 条指令被存储到了 0x200-0x20c 的区域中：</p>
<p>0x200 位置的 load 指令将地址 0x100 中的数据 11 导入寄存器 R0；</p>
<p>0x204 位置的 load 指令将地址 0x104 中的数据 15 导入寄存器 R1；</p>
<p>0x208 位置的 add 指令将寄存器 R0 和 R1 中的值相加，存入寄存器 R2；</p>
<p>0x20c 位置的 store 指令将寄存器 R2 中的值存回数据区域中的 0x1108 位置。</p>
<p>3.具体执行的时候，PC 指针先指向 0x200 位置，然后依次执行这 4 条指令。</p>
<p>这里还有几个问题要说明一下：</p>
<p>变量 a 实际上是内存中的一个地址，a 是给程序员的助记符。</p>
<p>为什么 0x200 中代表加载数据到寄存器的指令是 0x8c000100，我们会在下面详细讨论。</p>
<p>不知道细心的同学是否发现，在上面的例子中，我们每次操作 4 个地址，也就是 32 位，这是因为我们在用 32 位宽的 CPU 举例。在 32 位宽的 CPU 中，指令也是 32 位的。但是数据可以小于 32 位，比如可以加和两个 8 位的字节。</p>
<p>关于数据段和正文段的内容，会在模块四进程和线程部分继续讲解。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>接下来我会带你具体分析指令的执行过程。</p>
<p>在上面的例子中，load 指令将内存中的数据导入寄存器，我们写成了 16 进制：0x8c000100，拆分成二进制就是：</p>
<p>这里大家还是看下图，需要看一下才能明白。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181222.png" alt="image-20210622181222780"></p>
<p>最左边的 6 位，叫作操作码，英文是 OpCode，100011 代表 load 指令；</p>
<p>中间的 4 位 0000是寄存器的编号，这里代表寄存器 R0；</p>
<p>后面的 22 位代表要读取的地址，也就是 0x100。</p>
<p>所以我们是把操作码、寄存器的编号、要读取的地址合并到了一个 32 位的指令中。</p>
<p>我们再来看一条求加法运算的 add 指令，16 进制表示是 0x08048000，换算成二进制就是：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181253.png" alt="image-20210622181253269"></p>
<p>最左边的 6 位是指令编码，代表指令 add；</p>
<p>紧接着的 4 位 0000 代表寄存器 R0；</p>
<p>然后再接着的 4 位 0001 代表寄存器 R1；</p>
<p>再接着的 4 位 0010 代表寄存器 R2；</p>
<p>最后剩下的 14 位没有被使用。</p>
<p>构造指令的过程，叫作指令的编码，通常由编译器完成；解析指令的过程，叫作指令的解码，由 CPU 完成。由此可见 CPU 内部有一个循环：</p>
<p>首先 CPU 通过 PC 指针读取对应内存地址的指令，我们将这个步骤叫作 Fetch，就是获取的意思。</p>
<p>CPU 对指令进行解码，我们将这个部分叫作 Decode。</p>
<p>CPU 执行指令，我们将这个部分叫作 Execution。</p>
<p>CPU 将结果存回寄存器或者将寄存器存入内存，我们将这个步骤叫作 Store。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210622181321.png" alt="image-20210622181321836"></p>
<p>上面 4 个步骤，我们叫作 CPU 的指令周期。CPU 的工作就是一个周期接着一个周期，周而复始。</p>
<h3 id="指令的类型"><a href="#指令的类型" class="headerlink" title="指令的类型"></a>指令的类型</h3><p>通过上面的例子，你会发现不同类型（不同 OpCode）的指令、参数个数、每个参数的位宽，都不一样。而参数可以是以下这三种类型：</p>
<ol>
<li><p>寄存器；</p>
</li>
<li><p>内存地址；</p>
</li>
<li><p>数值（一般是整数和浮点）。</p>
</li>
</ol>
<p>当然，无论是寄存器、内存地址还是数值，它们都是数字。</p>
<p>指令从功能角度来划分，大概有以下 5 类：</p>
<ol>
<li><p>I/O 类型的指令，比如处理和内存间数据交换的指令 store/load 等；再比如将一个内存地址的数据转移到另一个内存地址的 mov 指令。</p>
</li>
<li><p>计算类型的指令，最多只能处理两个寄存器，比如加减乘除、位运算、比较大小等。</p>
</li>
<li><p>跳转类型的指令，用处就是修改 PC 指针。比如编程中大家经常会遇到需要条件判断+跳转的逻辑，比如 if-else，swtich-case、函数调用等。</p>
</li>
<li><p>信号类型的指令，比如发送中断的指令 trap。</p>
</li>
<li><p>闲置 CPU 的指令 nop，一般 CPU 都有这样一条指令，执行后 CPU 会空转一个周期。</p>
</li>
</ol>
<p>指令还有一个分法，就是寻址模式，比如同样是求和指令，可能会有 2 个版本：</p>
<ol>
<li><p>将两个寄存器的值相加的 add 指令。</p>
</li>
<li><p>将一个寄存器和一个整数相加的 addi 指令。</p>
</li>
</ol>
<p>另外，同样是加载内存中的数据到寄存器的 load 指令也有不同的寻址模式：</p>
<ol>
<li><p>比如直接加载一个内存地址中的数据到寄存器的指令la，叫作直接寻址。</p>
</li>
<li><p>直接将一个数值导入寄存器的指令li，叫作寄存器寻址。</p>
</li>
<li><p>将一个寄存器中的数值作为地址，然后再去加载这个地址中数据的指令lw，叫作间接寻址。</p>
</li>
</ol>
<p>因此寻址模式是从指令如何获取数据的角度，对指令的一种分类，目的是给编写指令的人更多选择。</p>
<p>了解了指令的类型后，我再强调几个细节问题：</p>
<ol>
<li><p>关于寻址模式和所有的指令，只要你不是嵌入式开发人员，就不需要记忆，理解即可。</p>
</li>
<li><p>不同 CPU 的指令和寄存器名称都不一样，因此这些名称也不需要你记忆。</p>
</li>
<li><p>有几个寄存器在所有 CPU 里名字都一样，比如 PC 指针、指令寄存器等。</p>
</li>
</ol>
<h3 id="指令的执行速度"><a href="#指令的执行速度" class="headerlink" title="指令的执行速度"></a>指令的执行速度</h3><p>之前我们提到过 CPU 是用石英晶体产生的脉冲转化为时钟信号驱动的，每一次时钟信号高低电平的转换就是一个周期，我们称为时钟周期。CPU 的主频，说的就是时钟信号的频率。比如一个 1GHz 的 CPU，说的是时钟信号的频率是 1G。</p>
<p>到这里你可能会有疑问：是不是每个时钟周期都可以执行一条指令？其实，不是的，多数指令不能在一个时钟周期完成，通常需要 2 个、4 个、6 个时钟周期。</p>
<h3 id="64-位和-32-位比较有哪些优势？"><a href="#64-位和-32-位比较有哪些优势？" class="headerlink" title="64 位和 32 位比较有哪些优势？"></a>64 位和 32 位比较有哪些优势？</h3><p>优势 1：64 位 CPU 可以执行更大数字的运算，这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显。</p>
<p>优势 2：64 位 CPU 可以寻址更大的内存空间</p>
<p>如果 32 位/64 位说的是程序，那么说的是指令是 64 位还是 32 位的。32 位指令在 64 位机器上执行，困难不大，可以兼容。 如果是 64 位指令，在 32 位机器上执行就困难了。因为 32 位指令在 64 位机器执行的时候，需要的是一套兼容机制；但是 64 位指令在 32 位机器上执行，32 位的寄存器都存不下指令的参数。</p>
<p>操作系统也是一种程序，如果是 64 位操作系统，也就是操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上。</p>
<h3 id="for-循环如何被执行"><a href="#for-循环如何被执行" class="headerlink" title="for 循环如何被执行"></a>for 循环如何被执行</h3><p>首先，我们来看 for 循环是如何实现的。</p>
<p>下面是一个求 1 加到 100 的 Java 程序，请你思考如何将它转换为指令：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">  s+=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过思考，如果按照顺序执行上面的程序，则需要很多指令，因为 for 循环可以执行 1 次，也可以执行 100W 次，还可以执行无数次。因此，指令的设计者提供了一种 <code>jump</code> 类型的指令，让你可以在程序间跳跃，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">  jump loop</span><br></pre></td></tr></table></figure>

<p>这就实现了一个无限循环，程序执行到 <code>jumploop</code> 的时候，就会跳回 <code>loop</code> 标签。</p>
<p>用这种方法，我们可以将 <code>for</code> 循环用底层的指令实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># var i = 1, s = 0</span><br><span class="line"></span><br><span class="line"># 对应 Java 代码，我们首先将 1 和 0 存储到两个地址</span><br><span class="line"># 这两个地址我们用 $i 和 $s 表示</span><br><span class="line">store #1 -&gt; $i // 将数字 1 存入i的地址</span><br><span class="line">store #0 -&gt; $s // 将数字 0 存入 s 的地址</span><br><span class="line"></span><br><span class="line"># 接下来循环要开始了，我们在这里预留一个 loop 标签</span><br><span class="line"># loop 是一个自定义标签，它代表指令的相对位置</span><br><span class="line"># 后续我们可以用 jump 指令跳转回这个位置实现循环</span><br><span class="line">loop: # 循环标签</span><br><span class="line"></span><br><span class="line"># for ... i &lt;= 100</span><br><span class="line"># 接下来我们开始实现循环控制</span><br><span class="line"># 我们先首先 i &lt;= 100的比较</span><br><span class="line"></span><br><span class="line"># 我们先将变量 i 的地址，也就是 $i 导入寄存器 R0</span><br><span class="line">load $i -&gt; R0</span><br><span class="line"></span><br><span class="line"># 然后我们用 cmp 比较指令 R0 和数字 100</span><br><span class="line">cmp R0 #100 // 比较 R0 和数字 100</span><br><span class="line"></span><br><span class="line"># 注意指令不会有返回值，它会进行计算，然后改变机器的状态（也就是寄存器）</span><br><span class="line"># 比较后，有几个特殊的寄存器会保存比较结果</span><br><span class="line"># 然后我们用 ja（jump above）, 如果比较结果 R0 比 100 大</span><br><span class="line"># 那么我们就跳转到 end 标签，实现循环的跳出</span><br><span class="line">ja end </span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"># 如果 R0&lt;=100，那么ja end 没有生效，这时我们处理 s+=i</span><br><span class="line"># 首先我们把变量 s 所在地址的数据导入寄存器 R1</span><br><span class="line">load $s -&gt; R1</span><br><span class="line"></span><br><span class="line"># 然后我们把寄存器R0和R1加和，把结果存储寄存器 R2</span><br><span class="line">add R0 R1 R2 </span><br><span class="line"></span><br><span class="line"># 这时，我们把寄存器 R2 的值存入变量 s 所在的地址</span><br><span class="line">store R2 -&gt; $s</span><br><span class="line"></span><br><span class="line"># 刚才我们完成了一次循环</span><br><span class="line"># 我们还需要维护变量 i 的自增</span><br><span class="line"># 现在 i 的值在 R0 中，我们首先将整数 1 叠加到 R0 上</span><br><span class="line">add R0 #1 R0</span><br><span class="line"></span><br><span class="line"># 再把 R0 的值存入i所在的内存地址</span><br><span class="line">store R0 -&gt; $i</span><br><span class="line"></span><br><span class="line"># 这时我们的循环体已经全部执行完成，我们需要调转回上面 loop 标签所在的位置</span><br><span class="line"># 继续循环</span><br><span class="line">jump loop</span><br><span class="line">nop</span><br><span class="line">end:</span><br></pre></td></tr></table></figure>

<p>Tips:</p>
<ol>
<li>jump 指令直接操作 PC 指针，但是很多 CPU 会抢先执行下一条指令，因此通常我们在 jump 后面要跟随一条 nop 指令，让 CPU 空转一个周期，避免 jump 下面的指令被执行。<strong>是不是到了微观世界，和你所认识的程序还不太一样</strong>？</li>
<li>上面我写指令的时候用到了 add/store 这些指令，它们叫作助记符，是帮助你记忆的。整体这段程序，我们就称作汇编程序。</li>
<li>因为不同的机器助记符也不一样，所以你不用太关注我用的是什么汇编语言，也不用去记忆这些指令。当你拿到指定芯片的时候，直接去查阅芯片的说明书就可以了。</li>
<li>虽然不同 CPU 的指令不一样，但也是有行业标准的。现在使用比较多的是 RISC（精简指令集）和 CISC（复杂指令集）。比如目前Inte 和 AMD 家族主要使用 CISC 指令集，ARM 和 MIPS 等主要使用RISC 指令集。</li>
</ol>
<h3 id="条件控制程序"><a href="#条件控制程序" class="headerlink" title="条件控制程序"></a>条件控制程序</h3><p>条件控制程序有两种典型代表，一种是 <code>if-else</code> ，另一种是 <code>switch-case</code> 。 总体来说， <code>if-else</code> 翻译成指令，是比较简单的，你需要用跳转指令和比较指令处理它的跳转逻辑。</p>
<p>当然，它们的使用场景不同，这块我不展开了。在这里我主要想跟你说说，它们的内部实现是不一样的。<code>if-else</code> 是一个自上向下的执行逻辑， <code>switch-case</code>是一种精确匹配算法。比如你有 1000 个 case，如果用 <code>if-else</code> 你需要一个个比较，最坏情况下需要比较 <code>999</code> 次；而如果用 <code>switch-case</code> ，就不需要一个个比较，通过算法就可以直接定位到对应的<code>case</code> 。</p>
<p>举个具体的例子，比如一个根据数字返回星期的程序。如果用<code>if-else</code>，那么你需要这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(week == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"周一"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"周二"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用 <code>switch-case</code> 的逻辑，你可能会这样计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跳转位置=当前PC + 4*(week * 2 - 1)</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>了解了循环和条件判断，我们再来看看函数是如何被执行的。函数的执行过程必须深入到底层，也会涉及一种叫作栈的数据结构。</p>
<p>下面是一段 C 程序，传入两个参数，然后返回两个参数的和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我先不说具体的解决方案，希望你可以先自己思考。其实到这里，你已经学了不少知识了。下面我们一起分析一下，一种思考的方向是：</p>
<ol>
<li>通过观察，我们发现函数的参数 a,b 本质是内存中的数据，因此需要给它们分配内存地址。</li>
<li>函数返回值也是内存中的数据，也就是返回值也需要分配内存地址。</li>
<li>调用函数其实就是跳转到函数体对应的指令所在的位置，因此函数名可以用一个标签，调用时，就用 <code>jump</code> 指令跟这个标签。</li>
</ol>
<p>比如上面函数进行了<code>a+b</code>的运算，我们可以这样构造指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 首先我们定义一个叫作add的标签</span><br><span class="line">add:</span><br><span class="line"></span><br><span class="line"># 然后我们将a和b所在地址中的数据都导入寄存器</span><br><span class="line">load $a -&gt; R0</span><br><span class="line">load $b -&gt; R1</span><br><span class="line"></span><br><span class="line"># 然后我们将寄存器求和，并将结果回写到返回地址</span><br><span class="line">add R0 R1 R2</span><br><span class="line">store R2 -&gt; $r</span><br></pre></td></tr></table></figure>

<p>当我们需要调用这个函数的时候，我们就构造下面这样的指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump add</span><br></pre></td></tr></table></figure>

<p>细心的同学可能已经发现，这里有 2 个问题还没有解决：</p>
<ol>
<li>参数如何传递给函数？</li>
<li>返回值如何传递给调用者？</li>
</ol>
<p>为了解决这 2 个问题，我们就需要用到前面提到的一个叫作栈的数据结构。栈的英文是 Stack，意思是码放整齐的一堆东西。首先在调用方，我们将参数传递给栈；然后在函数执行过程中，我们从栈中取出参数。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082138.png" alt="image-20210623082138584"></p>
<p>函数执行过程中，先将执行结果写入栈中，然后在返回前把之前压入的参数出栈，调用方再从栈中取出执行结果。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082207.png" alt="image-20210623082207315"></p>
<p>将参数传递给 Stack 的过程，叫作压栈。取出结果的过程，叫作出栈。栈就好像你书桌上的一摞书，压栈就是把参数放到书上面，出栈就是把顶部的书拿下来。</p>
<p>因为栈中的每个数据大小都一样，所以在函数执行的过程中，我们可以通过参数的个数和参数的序号去计算参数在栈中的位置。</p>
<p>接下来我们来看看函数执行的整体过程：假设要计算 11 和 15 的和，我们首先在内存中开辟一块单独的空间，也就是栈。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082232.png" alt="image-20210623082232407"></p>
<p>就如前面所讲，栈的使用方法是不断往上堆数据，所以需要一个栈指针（Stack Pointer， SP）指向栈顶（也就是下一个可以写入的位置）。每次将数据写入栈时，就把数据写到栈指针指向的位置，然后将 SP 的值增加。</p>
<p>为了提高效率，我们通常会用一个特殊的寄存器来存储栈指针，这个寄存器就叫作 Stack Pointer，在大多数芯片中都有这个特殊的寄存器。一开始，SP 指向 0x100 位置，而 0x100 位置还没有数据。</p>
<ul>
<li><strong>压栈参数11</strong></li>
</ul>
<p>接下来我们开始传参，我们先将 11 压栈，之所以称作压栈（ Push)，就好像我们把数据 11 堆在内存中一样。模拟压栈的过程是下面两条指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store #11 -&gt; $SP // 将11存入SP指向的地址0x100</span><br><span class="line"></span><br><span class="line">add SP, 4, SP  // 栈指针增加4（32位机器）</span><br></pre></td></tr></table></figure>

<p>第一条 store 指令将 SP 寄存器指向的内存地址设置为常数 11。</p>
<p>第二条指令将栈指针自增 4。</p>
<p>这里用美元符号代表将 11 存入的是 SP 寄存器指向的内存地址，这是一次间接寻址。存入后，栈指针不是自增 1 而是自增了 4，因为我在这里给你讲解时，用的是一个 32 位宽的 CPU 。如果是 64 位宽的 CPU，那么栈指针就需要自增 8。</p>
<p>压栈完成后，内存变成下图中所示的样子。11 被写入内存，并且栈指针指向了 0x104 位置。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082618.png" alt="image-20210623082618231"></p>
<ul>
<li><strong>压栈参数15</strong></li>
</ul>
<p>然后我们用同样的方法将参数 15 压栈。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082709.png" alt="image-20210623082709576"></p>
<p>压栈后，11 和 15 都被放入了对应的内存位置，并且栈指针指向了 0x108。</p>
<ul>
<li><strong>将返回值压栈</strong></li>
</ul>
<p>接下来，我们将返回值压栈。到这里你可能会问，返回值还没有计算呢，怎么就压栈了？其实这相当于一个占位，后面我们会改写这个地址。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623082802.png" alt="image-20210623082802255"></p>
<ul>
<li><strong>调用函数</strong></li>
</ul>
<p>当我们完成了上面的压栈后，就开始调用函数，一种简单的做法是用 jump 指令直接跳转到函数的标签，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump add</span><br></pre></td></tr></table></figure>

<p>这个时候，要加和在栈中的数据 11 和 15，我们可以利用 SP 指针寻找数据。11 距离当前 SP 指针差 3 个位置，15 距离 SP 指针差 2 个位置。这种寻址方式是一种复合的寻址方式，是间接 + 偏移量寻址。</p>
<p>我们可以用下面的代码完成将 11 和 15 导入寄存器的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load $(SP - 12) -&gt; R0</span><br><span class="line">load $(SP - 8) -&gt; R1</span><br></pre></td></tr></table></figure>

<p>然后进行加和，将结果存入 R2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load R0 R1 R2</span><br></pre></td></tr></table></figure>

<p>最后我们可以再次利用数学关系将结果写入返回值所在的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store R2 -&gt; $(SP-4)</span><br></pre></td></tr></table></figure>

<p>上面我们用到了一种间接寻址的方式来进行加和运算，也就是利用 SP 中的地址做加减法操作内存。</p>
<p>经过函数调用的结果如下图所示，运算结果 26 已经被写入了返回值的位置：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623084951.png" alt="image-20210623084951620"></p>
<ul>
<li><strong>发现-解决问题</strong></li>
</ul>
<p>一个好的解决方案，也会面临问题。现在我们就遇到了麻烦：</p>
<ol>
<li>函数计算完成，这时应该跳转回去。可是我们没有记录函数调用前 PC 指针的位置，因此这里需要改进，我们需要存储函数调用前的 PC 指针方便调用后恢复。</li>
<li>栈不可以被无限使用，11和 15 作为参数，计算出了结果 26，那么它们就可以清空了。如果用调整栈指针的方式去清空，我们就会先清空 26。此时就会出现顺序问题，因此我们需要调整压栈的顺序。</li>
</ol>
<p>具体顺序你可以看下图。首先，我们将函数参数和返回值换位，这样在清空数据的时候，就会先清空参数，再清空返回值。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085008.png" alt="image-20210623085008446"></p>
<p>然后我们在调用函数前，还需要将返回地址压栈。这样在函数计算完成前，就能跳转回对应的返回地址。翻译成指令，就是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 压栈返回值</span><br><span class="line">add SP, 4  -&gt; SP </span><br><span class="line"></span><br><span class="line"># 计算返回地址</span><br><span class="line"># 我们需要跳转到清理堆栈那行，也就是16行</span><br><span class="line">MOV PC+4*(参数个数*2+1) -&gt; SP</span><br><span class="line"></span><br><span class="line"># 压栈参数的程序</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"># 执行函数，计算返回值</span><br><span class="line">call function</span><br><span class="line"></span><br><span class="line"># 清理堆栈</span><br><span class="line">add SP, -(参数个数+1)*4， SP</span><br></pre></td></tr></table></figure>

<h3 id="递归函数如何被执行"><a href="#递归函数如何被执行" class="headerlink" title="递归函数如何被执行"></a>递归函数如何被执行</h3><p>我们刚刚使用了栈解决了函数的调用问题。但是这个方案究竟合不合理，还需要用更复杂的情况来验证。</p>
<p>如下所示，我们给出一个递归函数，请你判断是否可以用上面的方法执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum(int n)&#123;</span><br><span class="line">  if(n == 1) &#123;return 1;&#125;</span><br><span class="line">  return n + sum(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归的时候，我们每次执行函数都形成一个如下所示的栈结构：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085105.png" alt="image-20210623085105798"></p>
<p>比如执行 sum(100)，我们就会形成一个复杂的栈，第一次调用 n = 100，第二次递归调用 n = 99：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085438.png" alt="image-20210623085438298"></p>
<p>它们堆在了一起，就形成了一个很大的栈，简化一下就是这样的一个模型，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085453.png" alt="image-20210623085453807"></p>
<p>到这里，递归消耗了更多空间，但是也保证了中间计算的独立性。当递归执行到 100 次的时候，就会执行下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(n == 1) &#123;return 1;&#125;</span><br></pre></td></tr></table></figure>

<p>于是触发第 99 次递归执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return 2 + sum(1) // sum(1) = 1</span><br></pre></td></tr></table></figure>

<p>上面程序等价于<code>return 3</code>，接着再触发第 98 次递归的执行，然后是第 97 次，最终触发到第一次函数调用返回结果。</p>
<p>由此可见，栈这种结构同样适合递归的计算。事实上，计算机编程语言就是用这种结构来实现递归函数。</p>
<h3 id="类型（class）如何实现"><a href="#类型（class）如何实现" class="headerlink" title="类型（class）如何实现"></a>类型（class）如何实现</h3><p>按照我们之前已经学习到的知识：</p>
<ul>
<li>变量是一个内存地址，所以只需要分配内存就好了；</li>
<li>循环控制可以用跳转加判断实现；</li>
<li>条件控制也可以用跳转加判断实现，只不过如果是 <code>switch-case</code> 还需要一定的数学计算；</li>
<li>函数调用需要压栈参数、返回值和返回地址。</li>
</ul>
<p>最后，我们来说说类型是如何实现的，也就是很多语言都支持的 class 如何被翻译成指令。其实 class 实现非常简单，首先一个 class 会分成两个部分，一部分是数据（也称作属性），另一部分是函数（也称作方法）。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623085618.png" alt="image-20210623085618557"></p>
<p>class 有一个特殊的方法叫作构造函数，它会为 class 分配内存。构造函数执行的时候，开始扫描类型定义中所有的属性和方法。</p>
<ul>
<li>如果遇到属性，就为属性分配内存地址；</li>
<li>如果遇到方法，方法本身需要存到正文段（也就是程序所在的内存区域），再将方法的值设置为方法指令所在的内存地址。</li>
</ul>
<p>当我们调用一个 class 方法的时候，本质上是执行了一个函数，因此和函数调用是一致的：</p>
<ol>
<li>首先把返回值和返回地址压栈；</li>
<li>然后压栈参数；</li>
<li>最后执行跳转。</li>
</ol>
<p>这里有一个小问题，有时候 class 的方法会用到<code>this</code> ，这其实并不复杂，你仔细想想， <code>this</code>指针不就是构造函数创建的一个指向 class 实例的地址吗？那么，有一种简单的实现，就是我们可以把 <code>this</code> 作为函数的第一个参数压栈。这样，类型的函数就可以访问类型的成员了，而类型也就可以翻译成指令了。</p>
<p>下面我们做一个简单的总结：</p>
<ol>
<li>我们写的程序需要翻译成指令才能被执行，在前面中我们提到过，这个翻译工具叫作编译器。</li>
<li>平时你编程做的事情，用机器指令也能做，所以从计算能力上来说它们是等价的，最终这种计算能力又和图灵机是等价的。如果一个语言的能力和图灵机等价，我们就说这个语言是图灵完备的语言。现在市面上的绝大多数语言都是图灵完备的语言，但也有一些不是，比如 HTML、正则表达式和 SQL 等。</li>
<li>我们通过汇编语言构造高级程序；通过高级程序构造自己的业务逻辑，这些都是工程能力的一种体现。</li>
</ol>
<p><strong>一个程序语言如果不支持递归函数的话，该如何实现递归算法？</strong></p>
<ul>
<li>我们需要用到一个栈（其实用数组就可以）；</li>
<li>我们还需要一个栈指针，支持寄存器的编程语言能够直接用寄存器，而不支持直接用寄存器的编程语言，比如 Java，我们可以用一个变量；</li>
<li>然后我们可以实现压栈、出栈的操作，并按照上面学习的函数调用方法操作我们的栈。</li>
</ul>
<h3 id="为什么会有存储器分级策略？"><a href="#为什么会有存储器分级策略？" class="headerlink" title="为什么会有存储器分级策略？"></a>为什么会有存储器分级策略？</h3><p>要想弄清楚存储器分级策略。</p>
<p>首先，你要弄清楚，“我们希望存储器是什么样子的”，也就是“我们的需求是什么”？</p>
<p>然后，你要弄清楚，我们的需求有哪些“实现约束”。</p>
<p>从需求上讲，我们希望存储器速度快、体积小、空间大、能耗低、散热好、断电数据不丢失。但在现实中，我们往往无法把所有需求都实现。</p>
<p>下面我们举几个例子，带你深入体会一下，比如：</p>
<ul>
<li>如果一个存储器的体积小，那它存储空间就会受到制约。</li>
<li>如果一个存储器电子元件密度很大，那散热就会有问题。因为电子元件都会产生热能，所以电子元件非常集中的 CPU，就需要单独的风扇或者水冷帮助电子元件降温。</li>
<li>如果一个存储器离 CPU 较远，那么在传输过程中必然会有延迟，因此传输速度也会下降。</li>
</ul>
<p>这里你可能会有疑问，因为在大多数人的认知里，光速是很快的，而信号又是以光速传输的。既然光速这么快，那信号的延迟应该很小才对。但事实并不是这样，比如时钟信号是 1GHz 的 CPU，1G 代表 10 个亿，因此时钟信号的一个周期是 1/10 亿秒。而光的速度是 3×10 的 8 次方米每秒，就是 3 亿米每秒。所以在一个周期内，光只能前进 30 厘米。</p>
<p>你看！虽然在宏观世界里光速非常快，但是到计算机世界里，光速并没有像我们认知中的那么快。所以即使元件离 CPU 的距离稍微远了一点，运行速度也会下降得非常明显。</p>
<p>你可能还会问，那干吗不把内存放到 CPU 里？</p>
<p>如果你这么做的话，除了整个电路散热和体积会出现问题，服务器也没有办法做定制内存了。也就是说 CPU 在出厂时就决定了它的内存大小，如果你想换更大的内存，就要换 CPU，而组装定制化是你非常重要的诉求，这肯定是不能接受的。</p>
<p>此外，在相同价格下，一个存储器的速度越快，那么它的能耗通常越高。能耗越高，发热量越大。</p>
<p>因此，我们上面提到的需求是不可能被全部满足的，除非将来哪天存储技术有颠覆性的突破。</p>
<h3 id="存储器分级策略"><a href="#存储器分级策略" class="headerlink" title="存储器分级策略"></a>存储器分级策略</h3><p>既然我们不能用一块存储器来解决所有的需求，那就必须把需求分级。</p>
<p>一种可行的方案，就是根据数据的使用频率使用不同的存储器：高频使用的数据，读写越快越好，因此用最贵的材料，放到离 CPU 最近的位置；使用频率越低的数据，我们放到离 CPU 越远的位置，用越便宜的材料。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623092917.png" alt="image-20210623092917007"></p>
<p>具体来说，通常我们把存储器分成这么几个级别：</p>
<ol>
<li>寄存器；</li>
<li>L1-Cache；</li>
<li>L2-Cache；</li>
<li>L3-Cahce；</li>
<li>内存；</li>
<li>硬盘/SSD。</li>
</ol>
<h4 id="寄存器（Register）"><a href="#寄存器（Register）" class="headerlink" title="寄存器（Register）"></a>寄存器（Register）</h4><p>寄存器紧挨着 CPU 的控制单元和逻辑计算单元，它所使用的材料速度也是最快的。就像我们前面讲到的，存储器的速度越快、能耗越高、产热越大，而且花费也是最贵的，因此数量不能很多。</p>
<p>寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定字节（byte）的数据。比如：</p>
<ul>
<li>32 位 CPU 中大多数寄存器可以存储 4 个字节；</li>
<li>64 位 CPU 中大多数寄存器可以存储 8 个字节。</li>
</ul>
<p>寄存机的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写。比如一条要在 4 个周期内完成的指令，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，那 4 个周期就可能无法完成这条指令了。</p>
<h4 id="L1-Cache"><a href="#L1-Cache" class="headerlink" title="L1-Cache"></a>L1-Cache</h4><p>L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低。通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2~4 个 CPU 时钟周期。</p>
<h4 id="L2-Cache"><a href="#L2-Cache" class="headerlink" title="L2-Cache"></a>L2-Cache</h4><p>L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远。它的大小比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10~20 个 CPU 周期。</p>
<h4 id="L3-Cache"><a href="#L3-Cache" class="headerlink" title="L3-Cache"></a>L3-Cache</h4><p>L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远。大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。L3 缓存大小也是看型号的，比如 i9 CPU 有 512KB L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。</p>
<h4 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h4><p>内存的主要材料是半导体硅，是插在主板上工作的。因为它的位置距离 CPU 有一段距离，所以需要用总线和 CPU 连接。因为内存有了独立的空间，所以体积更大，造价也比上面提到的存储器低得多。现在有的个人电脑上的内存是 16G，但有些服务器的内存可以到几个 T。内存速度大概在 200~300 个 CPU 周期之间。</p>
<h4 id="SSD-和硬盘"><a href="#SSD-和硬盘" class="headerlink" title="SSD 和硬盘"></a>SSD 和硬盘</h4><p>SSD 也叫固态硬盘，结构和内存类似，但是它的优点在于断电后数据还在。内存、寄存器、缓存断电后数据就消失了。内存的读写速度比 SSD 大概快 10~1000 倍。以前还有一种物理读写的磁盘，我们也叫作硬盘，它的速度比内存慢 100W 倍左右。因为它的速度太慢，现在已经逐渐被 SSD 替代。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623093020.png" alt="image-20210623093020389"></p>
<p>当 CPU 需要内存中某个数据的时候，如果寄存器中有这个数据，我们可以直接使用；如果寄存器中没有这个数据，我们就要先查询 L1 缓存；L1 中没有，再查询 L2 缓存；L2 中没有再查询 L3 缓存；L3 中没有，再去内存中拿。</p>
<h3 id="缓存条目结构"><a href="#缓存条目结构" class="headerlink" title="缓存条目结构"></a>缓存条目结构</h3><p>上面我们介绍了存储器分级结构大概有哪些存储以及它们的特点，接下来还有一些缓存算法和数据结构的设计困难要和你讨论。比如 CPU 想访问一个内存地址，那么如何检查这个数据是否在 L1- 缓存中？换句话说，缓存中的数据结构和算法是怎样的？</p>
<p>无论是缓存，还是内存，它们都是一个线性存储器，也就是数据一个挨着一个的存储。如果我们把内存想象成一个只有 1 列的表格，那么缓存就是一个多列的表格，这个表格中的每一行叫作一个缓存条目。</p>
<h4 id="方案-1"><a href="#方案-1" class="headerlink" title="方案 1"></a>方案 1</h4><p>缓存本质上是一个 Key-Value 的存储，它的 Key 是内存地址，值是缓存时刻内存地址中的值。我们先思考一种简单的方案，一个缓存条目设计 2 列：</p>
<ol>
<li>内存的地址；</li>
<li>缓存的值。</li>
</ol>
<p>CPU 读取到一个内存地址，我们就增加一个条目。当我们要查询一个内存地址的数据在不在 L1- 缓存中的时候，可以遍历每个条目，看条目中的内存地址是否和查询的内存地址相同。如果相同，我们就取出条目中缓存的值。</p>
<p>这个方法需要遍历缓存中的每个条目，因此计算速度会非常慢，在最坏情况下，算法需要检查所有的条目，所以这不是一个可行的方案。</p>
<h4 id="方案-2"><a href="#方案-2" class="headerlink" title="方案 2"></a>方案 2</h4><p>其实很多优秀的方案，往往是从最笨的方案改造而来的。现在我们已经拥有了一个方案，但是这个方案无法快速确定一个内存地址缓存在哪一行。因此我们想要找到一个更好的方法，让我们看到一个内存地址，就能够快速知道它在哪一行。</p>
<p>这里，我们可以用一个数学的方法。比如有 1000 个内存地址，但只有 10 个缓存条目。内存地址的编号是 0、1、2、3，…，999，缓存条目的编号是 0~9。我们思考一个内存编号，比如 701，然后用数学方法把它映射到一个缓存条目，比如 701 整除 10，得到缓存条目 1。</p>
<p>用这种方法，我们每次拿到一个内存地址，都可以快速确定它的缓存条目；然后再比较缓存条目中的第一列内存地址和查询的内存地址是否相同，就可以确定内存地址有没有被缓存。</p>
<p>延伸一下，这里用到了一种类似哈希表的方法：<code>地址 % 10</code>，其实就构成了一个简单的哈希函数。</p>
<h3 id="指令的预读"><a href="#指令的预读" class="headerlink" title="指令的预读"></a>指令的预读</h3><p>接下来我们讨论下指令预读的问题。</p>
<p>之前我们学过，CPU 顺序执行内存中的指令，CPU 执行指令的速度是非常快的，一般是 2<del>6 个 CPU 时钟周期；这节课，我们学习了存储器分级策略，发现内存的读写速度其实是非常慢的，大概有 200</del>300 个时钟周期。</p>
<p>不知道你发现没有？这也产生了一个非常麻烦的问题：CPU 其实是不能从内存中一条条读取指令再执行的，如果是这样做，那每执行一条指令就需要 200~300 个时钟周期了。</p>
<p>那么，这个问题如何处理呢？</p>
<p>这里我再多说一句，你在做业务开发 RPC 调用的时候，其实也会经常碰到这种情况，远程调用拖慢了整体执行效率，下面我们一起讨论这类问题的解决方案。</p>
<p>一个解决办法就是 CPU 把内存中的指令预读几十条或者上百条到读写速度较快的 L1- 缓存中，因为 L1- 缓存的读写速度只有 2~4 个时钟周期，是可以跟上 CPU 的执行速度的。</p>
<p>这里又产生了另一个问题：如果数据和指令都存储在 L1- 缓存中，如果数据缓存覆盖了指令缓存，就会产生非常严重的后果。因此，L1- 缓存通常会分成两个区域，一个是指令区，一个是数据区。</p>
<p>与此同时，又出现了一个问题，L1- 缓存分成了指令区和数据区，那么 L2/L3 需不需要这样分呢？其实，是不需要的。因为 L2 和 L3，不需要协助处理指令预读的问题。</p>
<h3 id="缓存的命中率"><a href="#缓存的命中率" class="headerlink" title="缓存的命中率"></a>缓存的命中率</h3><p>接下来，还有一个重要的问题需要解决。就是 L1/L2/L3 加起来，缓存的命中率有多少？</p>
<p>所谓命中就是指在缓存中找到需要的数据。和命中相反的是穿透，也叫 miss，就是一次读取操作没有从缓存中找到对应的数据。</p>
<p>据统计，L1 缓存的命中率在 80% 左右，L1/L2/L3 加起来的命中率在 95% 左右。因此，CPU 缓存的设计还是相当合理的。只有 5% 的内存读取会穿透到内存，95% 都能读取到缓存。 这也是为什么程序语言逐渐取消了让程序员操作寄存器的语法，因为缓存保证了很高的命中率，多余的优化意义不大，而且很容易出错。</p>
<h3 id="缓存置换问题"><a href="#缓存置换问题" class="headerlink" title="缓存置换问题"></a>缓存置换问题</h3><p>最后的一个问题，比如现在 L1- 缓存条目已经存满了，接下来 CPU 又读了内存，需要把一个新的条目存到 L1- 缓存中，既然有一个新的条目要进来，那就有一个旧的条目要出去。所以，这个时候我们就需要用一个算法去计算哪个条目应该被置换出去。这个问题叫作缓存置换问题。有关缓存置换问题，我会在 “21 | 进程的调度：进程调度都有哪些方法？”中和你讨论。</p>
<p><strong>SSD、内存和 L1 Cache 相比速度差多少倍</strong>？</p>
<p><strong>【解析】</strong> 因为内存比 SSD 快 10<del>1000 倍，L1 Cache 比内存快 100 倍左右。因此 L1 Cache 比 SSD 快了 1000</del>100000 倍。所以你有没有发现 SSD 的潜力很大，好的 SSD 已经接近内存了，只不过造价还略高。</p>
<p>这个问题告诉我们，不同的存储器之间性能差距很大，构造存储器分级很有意义，分级的目的是要构造缓存体系。</p>
<p><strong>存不存在一个通用函数判断另一个函数是否会停止？</strong></p>
<p>假设存在一个函数willStop, 它只有一个参数func，willStop可以判断任意函数func是否会停止。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623094007.png" alt="image-20210623094007708"></p>
<p>存在这么一个悖论，所以这个问题是不可计算问题。</p>
<p><strong>假设一个维维数组，总共有1M个条目，如果我们要遍历这个二维数组，应该逐行遍历还是逐列遍历？</strong><br>首先要知道，二维数组在内存中的排列情况，</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623095415.png" alt="image-20210623095414990"></p>
<p>本质上还是一位数组的一个状态，只不过每行是连续的，由多个连续内存拼接在一起。</p>
<p>当CPU遍历二维数组的时候，存在一个预读取的操作，我们按行读取的话，会利用这个机制，并且，当我们在读取内存地址比较跳跃的数据的时候，会触发CPU的一个分页操作，更加增加了开销，降低了效率。</p>
<p>这里我比较好奇，就用Java实现了一个两种不同的遍历方式，逻辑比较简陋，属于是够用就好，结果一起附上。</p>
<script src="https://gist.github.com/FlyMeToTheMars/6a3559806787435bfe6ae64a73a2aeb1.js"></script>

<h3 id="什么是-Shell-和-Bash"><a href="#什么是-Shell-和-Bash" class="headerlink" title="什么是 Shell 和 Bash"></a>什么是 Shell 和 Bash</h3><p>在我们学习 Linux 指令之前，先来说一下什么是 Shell？Shell 把我们输入的指令，传递给操作系统去执行，所以 Shell 是一个命令行的用户界面。</p>
<p>早期程序员没有图形界面用，就用 Shell。而且图形界面制作成本较高，不能实现所有功能，因此今天的程序员依然在用 Shell。</p>
<p>你平时还经常会看到一个词叫作bash（Bourne Again Shell），它是用 Shell 组成的程序。这里的 Bourne 是一个人名，Steve Bourne 是 bash 的发明者。</p>
<h3 id="几种常见的文件类型"><a href="#几种常见的文件类型" class="headerlink" title="几种常见的文件类型"></a>几种常见的文件类型</h3><p>另一方面，Linux 下的目录也是一种文件；但是文件也不只有目录和可执行文件两种。常见的文件类型有以下 7 种:</p>
<ol>
<li>普通文件（比如一个文本文件）；</li>
<li>目录文件（目录也是一个特殊的文件，它用来存储文件清单，比如<code>/</code>也是一个文件）；</li>
<li>可执行文件（上面的<code>rm</code>就是一个可执行文件）；</li>
<li>管道文件（我们会在 07 课时讨论管道文件）；</li>
<li>Socket 文件（我们会在模块七网络部分讨论 Socket 文件）；</li>
<li>软链接文件（相当于指向另一个文件所在路径的符号）；</li>
<li>硬链接文件（相当于指向另一个文件的指针，关于软硬链接我们将在模块六文件系统部分讨论）。</li>
</ol>
<p>你如果使用<code>ls -F</code>就可以看到当前目录下的文件和它的类型。比如下面这种图：</p>
<ol>
<li>* 结尾的是可执行文件；</li>
<li>= 结尾的是 Socket 文件；</li>
<li>@ 结尾的是软链接；</li>
<li>| 结尾的管道文件；</li>
<li>没有符号结尾的是普通文件；</li>
<li>/ 结尾的是目录。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112258.png" alt="image-20210623112257938"></p>
<p><strong>more</strong></p>
<p><code>more</code>可以帮助我们读取文件，但不需要读取整个文件到内存中。本身<code>more</code>的定位是一个阅读过滤器，比如你在<code>more</code>里除了可以向下翻页，还可以输入一段文本进行搜索。</p>
<p><strong>less</strong></p>
<p><code>less</code>是一个和<code>more</code>功能差不多的工具，打开<code>man</code>能够看到<code>less</code>的介绍上写着自己是<code>more</code>的反义词（opposite of more）。这样你可以看出<code>linux</code>生态其实也是很自由的一个生态，在这里创造工具也可以按照自己的喜好写文档。<code>less</code>支持向上翻页，这个功能<code>more</code>是做不到的。所以现在<code>less</code>用得更多一些。</p>
<p><strong>head/tail</strong></p>
<p><code>head</code>和<code>tail</code>是一组，它们用来读取一个文件的头部 N 行或者尾部 N 行。比如一个线上的大日志文件，当线上出了 bug，服务暂停的时候，我们就可以用<code>tail -n 1000</code>去查看最后的 1000 行日志文件，寻找导致服务异常的原因。</p>
<p>另一个比较重要的用法是，如果你想看一个实时的<code>nginx</code>日志，可以使用<code>tail -f 文件名</code>，这样你会看到用户的请求不断进来。查一下<code>man</code>，你会发现<code>-f</code>是 follow 的意思，就是文件追加的内容会跟随输出到标准输出流。</p>
<p><strong>grep</strong></p>
<p>有时候你需要查看一个指定<code>ip</code>的nginx日志，或者查看一段时间内的<code>nginx</code>日志。如果不想用<code>less</code>和<code>more</code>进入文件中去查看，就可以用<code>grep</code>命令。Linux 的文件命名风格都很短，所以也影响了很多人，比如之前我看到过一个大牛的程序，变量名从来不超过 5 个字母，而且都有意义。</p>
<p>grep 这个词，我们分成三段来看，是 g|re|p。</p>
<ul>
<li>g 就是 global，全局；</li>
<li>re 就是 regular expression，正则表达式；</li>
<li>p 就是 pattern，模式。</li>
</ul>
<p>所以这个指令的作用是通过正则表达式全局搜索一个文件找到匹配的模式。我觉得这种命名真的很牛，软件命名也是一个世纪难题，grep这个名字不但发音不错，而且很有含义，又避免了名字过长，方便记忆。</p>
<p>下面我们举两个例子看看 grep 的用法：</p>
<ul>
<li>例 1：查找 ip 地址</li>
</ul>
<p>我们可以通过<code>grep</code>命令定位某个<code>ip</code>地址的用户都做了什么事情，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112408.png" alt="image-20210623112408158"></p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112429.png" alt="image-20210623112429600"></p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623112440.png" alt="image-20210623112440021"></p>
<p><strong>man 指令</strong>：相当于指令手册</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong><em>什么是进程？</em></strong></p>
<p>*<strong>可以回答：进程是应用的执行副本；而不要回答进程是操作系统分配资源的最小单位。前者是定义，后者是作用**</strong>。*</p>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a><strong>ps</strong></h4><p>如果你要看当前的进程，可以用<code>ps</code>指令。p 代表 processes，也就是进程；s 代表 snapshot，也就是快照。所谓快照，就是像拍照一样。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623113721.png" alt="image-20210623113721850"></p>
<p><strong>TTY</strong>：TTY 这个概念是一个历史的概念，过去用来传递信息，现在已经被传真、邮件、微信等取代。</p>
<p>操作系统上的 TTY 是一个输入输出终端的概念，比如用户打开 bash，操作系统就为用户分配了一个输入输出终端。没有加任何参数的<code>ps</code>只显示在同一个 TTY 的进程。</p>
<p>如果想看到所有的进程，可以用<code>ps -e</code>，<code>-e</code>没有特殊含义，只是为了和<code>-A</code>区分开。我们通常不直接用<code>ps -e</code>而是用<code>ps -ef</code>，这是因为<code>-f</code>可以带上更多的描述字段，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623114108.png" alt="image-20210623114107889"></p>
<ul>
<li>UID 指进程的所有者；</li>
<li>PID 是进程的唯一标识；</li>
<li>PPID 是进程的父进程 ID；</li>
<li>C 是 CPU 的利用率（就是 CPU 占用）；</li>
<li>STIME 是开始时间；</li>
<li>TTY 是进程所在的 TTY，如果没有 TTY 就是 ？号；</li>
<li>TIME；</li>
<li>CMD 是进程启动时的命令，如果不是一个 Shell 命令，而是用方括号括起来，那就是系统进程或者内核过程。</li>
</ul>
<p>另外一个用得比较多的是<code>ps aux</code>，它和<code>ps -ef</code>能力差不多，但是是 BSD 风格的。就是加州伯克利分校研发的 Unix 分支版本的衍生风格，这种风格其实不太好描述，我截了一张图，你可以体会一下：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623114328.png" alt="image-20210623114328257"></p>
<p>在 BSD 风格中有些字段的叫法和含义变了。</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>另外还有一个和<code>ps</code>能力差不多，但是显示的不是快照而是实时更新数据的<code>top</code>指令。因为自带的<code>top</code>显示的内容有点少， 所以我喜欢用一个叫作<code>htop</code>的指令，是需要额外安装的。</p>
<h3 id="管道（Pipeline）"><a href="#管道（Pipeline）" class="headerlink" title="管道（Pipeline）"></a>管道（Pipeline）</h3><p>现管道（Pipeline）的作用是在命令和命令之间，传递数据。比如说一个命令的结果，就可以作为另一个命令的输入。我们了解了进程，所以这里说的命令就是进程。更准确地说，管道在进程间传递数据。</p>
<h4 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><p>每个进程拥有自己的标准输入流、标准输出流、标准错误流。</p>
<p>这几个标准流说起来很复杂，但其实都是文件。</p>
<ul>
<li>标准输入流（用 0 表示）可以作为进程执行的上下文（进程执行可以从输入流中获取数据）。</li>
<li>标准输出流（用 1 表示）中写入的结果会被打印到屏幕上。</li>
<li>如果进程在执行过程中发生异常，那么异常信息会被记录到标准错误流（用 2 表示）中。</li>
</ul>
<p><strong>重定向</strong></p>
<p>我们执行一个指令，比如<code>ls -l</code>，结果会写入标准输出流，进而被打印。这时可以用重定向符将结果重定向到一个文件，比如说<code>ls -l &gt; out</code>，这样<code>out</code>文件就会有<code>ls -l</code>的结果；而屏幕上也不会再打印<code>ls -l</code>的结果。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623163858.png" alt="image-20210623163857940"></p>
<p>具体来说<code>&gt;</code>符号叫作覆盖重定向；<code>&gt;&gt;</code>叫作追加重定向。<code>&gt;</code>每次都会把目标文件覆盖，<code>&gt;&gt;</code>会在目标文件中追加。经过这样的操作后，每次执行程序日志就不会被覆盖了。</p>
<p>另外还有一种情况，比如我们输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls1 &gt; out</span><br></pre></td></tr></table></figure>

<p>结果并不会存入<code>out</code>文件，因为<code>ls1</code>指令是不存在的。结果会输出到标准错误流中，仍然在屏幕上。这里我们可以把标准错误流也重定向到标准输出流，然后再重定向到文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls1 &amp;&gt; out</span><br></pre></td></tr></table></figure>

<p>这个写法等价于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls1 &gt; out 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h4 id="管道的作用和分类"><a href="#管道的作用和分类" class="headerlink" title="管道的作用和分类"></a>管道的作用和分类</h4><p>有了进程和重定向的知识，接下来我们梳理下管道的作用。管道（Pipeline）将一个进程的输出流定向到另一个进程的输入流，就像水管一样，作用就是把这两个文件接起来。如果一个进程输出了一个字符 X，那么另一个进程就会获得 X 这个输入。</p>
<p><strong>管道和重定向很像，但是管道是一个连接一个进行计算，重定向是将一个文件的内容定向到另一个文件，这二者经常会结合使用</strong>。</p>
<p>Linux 中的管道也是文件，有两种类型的管道：</p>
<ol>
<li>匿名管道（Unnamed Pipeline），这种管道也在文件系统中，但是它只是一个存储节点，不属于任何一个目录。说白了，就是没有路径。</li>
<li>命名管道（Named Pipeline），这种管道就是一个文件，有自己的路径。</li>
</ol>
<h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>管道具有 FIFO（<strong>First In First Out</strong>），FIFO 和排队场景一样，先排到的先获得。所以先流入管道文件的数据，也会先流出去传递给管道下游的进程。</p>
<h3 id="使用场景分析"><a href="#使用场景分析" class="headerlink" title="使用场景分析"></a>使用场景分析</h3><p>接下来我们以多个场景举例帮助你深入学习管道。</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>比如我们用<code>ls</code>，希望按照文件名排序倒序，可以使用匿名管道，将<code>ls</code>的结果传递给<code>sort</code>指令去排序。你看，这样<code>ls</code>的开发者就不用关心排序问题了。</p>
<h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>另一个比较常见的场景是去重，比如有一个字典文件，里面都是词语。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>如果我们想要去重可以使用<code>uniq</code>指令，<code>uniq</code>指令能够找到文件中相邻的重复行，然后去重。但是我们上面的文件重复行是交替的，所以不可以直接用<code>uniq</code>，因此可以先<code>sort</code>这个文件，然后利用管道将<code>sort</code>的结果重定向到<code>uniq</code>指令。指令如下：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623164748.png" alt="image-20210623164748417"></p>
<h4 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h4><p>有时候我们想根据正则模式筛选对应的内容。比如说我们想找到项目文件下所有文件名中含有<code>Spring</code>的文件。就可以利用<code>grep</code>指令，操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ | grep Spring</span><br></pre></td></tr></table></figure>

<p><code>find ./</code>递归列出当前目录下所有目录中的文件。<code>grep</code>从<code>find</code>的输出流中找出含有<code>Spring</code>关键字的行。</p>
<p>如果我们希望包含<code>Spring</code>但不包含<code>MyBatis</code>就可以这样操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ | grep Spring | grep -v MyBatis</span><br></pre></td></tr></table></figure>

<p><code>grep -v</code>是匹配不包含 MyBatis 的结果。</p>
<h4 id="数行数"><a href="#数行数" class="headerlink" title="数行数"></a>数行数</h4><p>还有一个比较常见的场景是数行数。比如你写了一个 Java 文件想知道里面有多少行，就可以使用<code>wc -l</code>指令，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623164924.png" alt="image-20210623164923942"></p>
<p>但是如果你想知道当前目录下有多少个文件，可以用<code>ls | wc -l</code>，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623164950.png" alt="image-20210623164950862"></p>
<p><strong>接下来请你思考一个问题：我们如何知道当前</strong><code>java</code><strong>的项目目录下有多少行代码</strong>？</p>
<p>提示一下。你可以使用下面这个指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -i <span class="string">".java"</span> ./ | wc -l</span><br></pre></td></tr></table></figure>

<h4 id="中间结果"><a href="#中间结果" class="headerlink" title="中间结果"></a>中间结果</h4><p>管道一个接着一个，是一个计算逻辑。有时候我们想要把中间的结果保存下来，这就需要用到<code>tee</code>指令。<code>tee</code>指令从标准输入流中读取数据到标准输出流。</p>
<p><code>tee</code>还有一个能力，就是自己利用这个过程把输入流中读取到的数据存到文件中。比如下面这条指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -i <span class="string">"*.java"</span> | tee JavaList | grep Spring</span><br></pre></td></tr></table></figure>

<p>这句指令的意思是从当前目录中找到所有含有 Spring 关键字的 Java 文件。tee 本身不影响指令的执行，但是 tee 会把 find 指令的结果保存到 JavaList 文件中。</p>
<p><code>tee</code>这个执行就像英文字母中的 T 一样，连通管道两端，下面又开了口。这个开口，在函数式编程里面叫作副作用。</p>
<h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p><code>xargs</code>指令从标准数据流中构造并执行一行行的指令。<code>xargs</code>从输入流获取字符串，然后利用空白、换行符等切割字符串，在这些字符串的基础上构造指令，最后一行行执行这些指令。</p>
<p>举个例子，如果我们重命名当前目录下的所有 .a 的文件，想在这些文件前面加一个前缀<code>prefix_</code>。比如说<code>x.a</code>文件需要重命名成<code>prefix_x.a</code>，我们就可以用<code>xargs</code>指令构造模块化的指令。</p>
<p>现在我们有<code>x.a``y.a``z.a</code>三个文件，然后使用下图中的指令构造我们需要的指令：：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165424.png" alt="image-20210623165424707"></p>
<ul>
<li>我们用<code>ls</code>找到所有的文件；</li>
<li><code>-I</code>参数是查找替换符，这里我们用<code>GG</code>替代<code>ls</code>找到的结果；<code>-I GG</code>后面的字符串 GG 会被替换为<code>x.a``x.b</code>或<code>x.z</code>；</li>
<li><code>echo</code>是一个在命令行打印字符串的指令。使用<code>echo</code>主要是为了安全，帮助我们检查指令是否有错误。</li>
</ul>
<p>我们用<code>xargs</code>构造了 3 条指令。这里我再多讲一个词，叫作样板代码。如果你没有用<code>xargs</code>指令，而是用一条条<code>mv</code>指令去敲，这样就构成了样板代码。</p>
<p>最后去掉 echo，就是我们想要的结果，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165523.png" alt="image-20210623165523353"></p>
<h3 id="管道文件"><a href="#管道文件" class="headerlink" title="管道文件"></a>管道文件</h3><p>上面我们花了较长的一段时间讨论匿名管道，用<code>|</code>就可以创造和使用。匿名管道也是利用了文件系统的能力，是一种文件结构。当你学到模块六文件系统的内容，会知道匿名管道拥有一个自己的<code>inode</code>，但不属于任何一个文件夹。</p>
<p>还有一种管道叫作命名管道（Named Pipeline）。命名管道是要挂到文件夹中的，因此需要创建。用<code>mkfifo</code>指令可以创建一个命名管道，下面我们来创建一个叫作<code>pipe1</code>的命名管道，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165554.png" alt="image-20210623165554555"></p>
<p>命名管道和匿名管道能力类似，可以连接一个输出流到另一个输入流，也是 First In First Out。</p>
<p>当执行<code>cat pipe1</code>的时候，你可以观察到，当前的终端处于等待状态。因为我们<code>cat pipe1</code>的时候<code>pipe1</code>中没有内容。</p>
<p>如果这个时候我们再找一个终端去写一点东西到<code>pipe</code>中，比如说:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"XXX"</span> &gt; pipe1</span><br></pre></td></tr></table></figure>

<p>这个时候，<code>cat pipe1</code>就会返回，并打印出<code>xxx</code>，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623165746.png" alt="image-20210623165745970"></p>
<p>我们可以像上图那样演示这段程序，在<code>cat pipe1</code>后面增加了一个<code>&amp;</code>符号。这个<code>&amp;</code>符号代表指令在后台执行，不会阻塞用户继续输入。然后我们通过<code>echo</code>指令往<code>pipe1</code>中写入东西，接着就会看到<code>xxx</code>被打印出来。</p>
<p><strong>xargs 的作用</strong></p>
<p>xargs 将标准输入流中的字符串分割成一条条子字符串，然后再按照我们自己想要的方式构建成一条条指令，大大拓展了 Linux 指令的能力。</p>
<h3 id="权限抽象"><a href="#权限抽象" class="headerlink" title="权限抽象"></a>权限抽象</h3><p><strong>首先，我们先来说说用户和组</strong>。Linux 是一个多用户平台，允许多个用户同时登录系统工作。Linux 将用户抽象成了账户，账户可以登录系统，比如通过输入登录名 + 密码的方式登录；也可以通过证书的方式登录。</p>
<p>但为了方便分配每个用户的权限，Linux 还支持组 <strong>（Group）账户</strong>。组账户是多个账户的集合，组可以为成员们分配某一类权限。每个用户可以在多个组，这样就可以利用组给用户快速分配权限。</p>
<p>组的概念有点像微信群。一个用户可以在多个群中。比如某个组中分配了 10 个目录的权限，那么新建用户的时候可以将这个用户增加到这个组中，这样新增的用户就不必再去一个个目录分配权限。</p>
<p>而每一个微信群都有一个群主，<strong>Root 账户也叫作超级管理员</strong>，就相当于微信群主，它对系统有着完全的掌控。一个超级管理员可以使用系统提供的全部能力。</p>
<p>此外，Linux 还对<strong>文件</strong>进行了权限抽象（<strong>注意目录也是一种文件</strong>）。Linux 中一个文件可以设置下面 3 种权限：</p>
<ol>
<li>读权限（r）：控制读取文件。</li>
<li>写权限（w）：控制写入文件。</li>
<li>执行权限（x）：控制将文件执行，比如脚本、应用程序等。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623181121.png" alt="image-20210623181121589"></p>
<p>然后每个文件又可以从 3 个维度去配置上述的 3 种权限：</p>
<ol>
<li>用户维度。每个文件可以所属 1 个用户，用户维度配置的 rwx 在用户维度生效；</li>
<li>组维度。每个文件可以所属 1 个分组，组维度配置的 rwx 在组维度生效；</li>
<li>全部用户维度。设置对所有用户的权限。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623181158.png" alt="image-20210623181158847"></p>
<p>因此 Linux 中文件的权限可以用 9 个字符，3 组<code>rwx</code>描述：第一组是用户权限，第二组是组权限，第三组是所有用户的权限。然后用<code>-</code>代表没有权限。比如<code>rwxrwxrwx</code>代表所有维度可以读写执行。<code>rw--wxr-x</code>代表用户维度不可以执行，组维度不可以读取，所有用户维度不可以写入。</p>
<p>通常情况下，如果用<code>ls -l</code>查看一个文件的权限，会有 10 个字符，这是因为第一个字符代表的是文件类型。我们在 06 课时讲解“几种常见的文件类型”时提到过，有管道文件、目录文件、链接文件等等。<code>-</code>代表普通文件、<code>d</code>代表目录、<code>p</code>代表管道。</p>
<h4 id="问题一：初始权限问题"><a href="#问题一：初始权限问题" class="headerlink" title="问题一：初始权限问题"></a><strong>问题一：初始权限问题</strong></h4><p>一个文件创建后，文件的所属用户会被设置成创建文件的用户。谁创建谁拥有，这个逻辑很顺理成章。但是文件的组又是如何分配的呢？</p>
<p>这里 Linux 想到了一个很好的办法，就是为每个用户创建一个同名分组。</p>
<p>比如说<code>zhang</code>这个账户创建时，会创建一个叫作<code>zhang</code>的分组。<code>zhang</code>登录之后，工作分组就会默认使用它的同名分组<code>zhang</code>。如果<code>zhang</code>想要切换工作分组，可以使用<code>newgrp</code>指令切换到另一个工作分组。因此，被创建文件所属的分组是当时用户所在的工作分组，如果没有特别设置，那么就属于用户所在的同名分组。</p>
<p>再说下文件的权限如何？文件被创建后的权限通常是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rw-rw-r--</span><br></pre></td></tr></table></figure>

<p>也就是用户、组维度不可以执行，所有用户可读。</p>
<h4 id="问题二：公共执行文件的权限"><a href="#问题二：公共执行文件的权限" class="headerlink" title="问题二：公共执行文件的权限"></a><strong>问题二：公共执行文件的权限</strong></h4><p>前面提到过可以用<code>which</code>指令查看<code>ls</code>指令所在的目录，我们发现在<code>/usr/bin</code>中。然后用<code>ls -l</code>查看<code>ls</code>的权限，可以看到下图所示：</p>
<ul>
<li>第一个<code>-</code>代表这是一个普通文件，后面的 rwx 代表用户维度可读写和执行；</li>
<li>第二个<code>r-x</code>代表组维度不可读写；</li>
<li>第三个<code>r-x</code>代表所有用户可以读和执行；</li>
<li>后两个<code>root</code>，第一个代表所属用户，第二个代表所属分组。</li>
</ul>
<p><strong>如果一个文件设置为不可读，但是可以执行，那么结果会怎样？</strong></p>
<p>答案当然是不可以执行，无法读取文件内容自然不可以执行。</p>
<h4 id="问题三：执行文件"><a href="#问题三：执行文件" class="headerlink" title="问题三：执行文件"></a><strong>问题三：执行文件</strong></h4><p>在 Linux 中，如果一个文件可以被执行，则可以直接通过输入文件路径（相对路径或绝对路径）的方式执行。如果想执行一个不可以执行的文件，Linux 则会报错。</p>
<p>当用户输入一个文件名，如果没有指定完整路径，Linux 就会在一部分目录中查找这个文件。你可以通过<code>echo $PATH</code>看到 Linux 会在哪些目录中查找可执行文件，<code>PATH</code>是 Linux 的环境变量。</p>
<h4 id="问题四：可不可以都-root"><a href="#问题四：可不可以都-root" class="headerlink" title="问题四：可不可以都 root"></a><strong>问题四：可不可以都 root</strong></h4><p>不可以</p>
<p>下面我们就来说说 root 的危害。</p>
<p>举个例子，你有一个 MySQL 进程执行在 root（最大权限）账户上，如果有黑客攻破了你的 MySQL 服务，获得了在 MySQL 上执行 SQL 的权限，那么，你的整个系统就都暴露在黑客眼前了。这会导致非常严重的后果。</p>
<p>黑客可以利用 MySQL 的 Copy From Prgram 指令为所欲为，比如先备份你的关键文件，然后再删除他们，并要挟你通过指定账户打款。如果执行最小权限原则，那么黑客即便攻破我们的 MySQL 服务，他也只能获得最小的权限。当然，黑客拿到 MySQL 权限也是非常可怕的，但是相比拿到所有权限，这个损失就小多了。</p>
<hr>
<p><strong>内核</strong>是操作系统连接硬件、提供最核心能力的程序。</p>
<p>内核提供操作硬件、磁盘、内存分页、进程等最核心的能力，并拥有直接操作全部内存的权限，因此内核不能把自己的全部能力都提供给用户，而且也不能允许用户通过<code>shell</code>指令进行系统调用。Linux 下内核把部分进程需要的系统调用以 C 语言 API 的形式提供出来。部分系统调用会有权限检查，比如说设置系统时间的系统调用。</p>
<h3 id="权限架构思想"><a href="#权限架构思想" class="headerlink" title="权限架构思想"></a>权限架构思想</h3><p>优秀的权限架构主要目标是让系统安全、稳定且用户、程序之间相互制约、相互隔离。这要求权限系统中的权限划分足够清晰，分配权限的成本足够低。</p>
<p>因此，优秀的架构，应该遵循最小权限原则（Least Privilege）。权限设计需要保证系统的安全和稳定。比如：每一个成员拥有的权限应该足够的小，每一段特权程序执行的过程应该足够的短。对于安全级别较高的时候，还需要成员权限互相牵制。比如金融领域通常登录线上数据库需要两次登录，也就是需要两个密码，分别掌握在两个角色手中。这样即便一个成员出了问题，也可以保证整个系统安全。</p>
<p>同样的，每个程序也应该减少权限，比如说只拥有少量的目录读写权限，只可以进行少量的系统调用。</p>
<h3 id="权限划分"><a href="#权限划分" class="headerlink" title="权限划分"></a>权限划分</h3><p>此外，权限架构思想还应遵循一个原则，权限划分边界应该足够清晰，尽量做到相互隔离。Linux 提供了用户和分组。当然 Linux 没有强迫你如何划分权限，这是为了应对更多的场景。通常我们服务器上重要的应用，会由不同的账户执行。比如说 Nginx、Web 服务器、数据库不会执行在一个账户下。现在随着容器化技术的发展，我们甚至希望每个应用独享一个虚拟的空间，就好像运行在一个单独的操作系统中一样，让它们互相不用干扰。</p>
<h4 id="分级保护"><a href="#分级保护" class="headerlink" title="分级保护"></a>分级保护</h4><p>因为内核可以直接操作内存和 CPU，因此非常危险。驱动程序可以直接控制摄像头、显示屏等核心设备，也需要采取安全措施，比如防止恶意应用开启摄像头盗用隐私。通常操作系统都采取一种环状的保护模式。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623184936.png" alt="image-20210623184936622"></p>
<p>如上图所示，内核在最里面，也就是 Ring 0。 应用在最外面也就是 Ring 3。驱动在中间，也就是 Ring 1 和 Ring 2。对于相邻的两个 Ring，内层 Ring 会拥有较高的权限，可以改变外层的 Ring；而外层的 Ring 想要使用内层 Ring 的资源时，会有专门的程序（或者硬件）进行保护。</p>
<p>比如说一个 Ring3 的应用需要使用内核，就需要发送一个系统调用给内核。这个系统调用会由内核进行验证，比如验证用户有没有足够的权限，以及这个行为是否安全等等。</p>
<p><strong>权限包围（Privilege Bracking）</strong></p>
<p>之前我们讨论过，当 MySQL 跑在 root 权限时，如果 MySQLl 被攻破，整个机器就被攻破了。因此我们所有应用都不要跑在 root 上。如果所有应用都跑在普通账户下，那么就会有临时提升权限的场景。比如说安装程序可能需要临时拥有管理员权限，将应用装到<code>/usr/bin</code>目录下。</p>
<p>Linux 提供了权限包围的能力。比如一个应用，临时需要高级权限，可以利用交互界面（比如让用户输入 root 账户密码）验证身份，然后执行需要高级权限的操作，然后马上恢复到普通权限工作。这样做可以减少应用在高级权限的时间，并做到专权专用，防止被恶意程序利用。</p>
<h3 id="用户分组指令"><a href="#用户分组指令" class="headerlink" title="用户分组指令"></a>用户分组指令</h3><p>上面我们讨论了 Linux 权限的架构，接下来我们学习一些具体的指令。</p>
<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>如果想查看当前用户的分组可以使用<code>groups</code>指令。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185115.png" alt="image-20210623185115808"></p>
<p>上面指令列出当前用户的所有分组。第一个是同名的主要分组，后面从<code>adm</code>开始是次级分组。</p>
<p>我先给你介绍两个分组，其他分组你可以去查资料：</p>
<ul>
<li>adm 分组用于系统监控，比如<code>/var/log</code>中的部分日志就是 adm 分组。</li>
<li>sudo 分组用户可以通过 sudo 指令提升权限。</li>
</ul>
<p>如果想查看当前用户，可以使用<code>id</code>指令，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185149.png" alt="image-20210623185149343"></p>
<ul>
<li>uid 是用户 id；</li>
<li>gid 是组 id；</li>
<li>groups 后面是每个分组和分组的 id。</li>
</ul>
<p>如果想查看所有的用户，可以直接看<code>/etc/passwd</code>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185353.png" alt="image-20210623185352703"></p>
<p><code>/etc/passwd</code>这个文件存储了所有的用户信息，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623185407.png" alt="image-20210623185407518"></p>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>创建用户用<code>useradd</code>指令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd foo</span><br></pre></td></tr></table></figure>

<p>sudo 原意是 superuser do，后来演变成用另一个用户的身份去执行某个指令。如果没有指定需要 sudo 的用户，就可以像上面那样，以超级管理员的身份。因为 useradd 需要管理员身份。这句话执行后，会进行权限提升，并弹出输入管理员密码的输入界面。</p>
<h4 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a><strong>创建分组</strong></h4><p>创建分组用<code>groupadd</code>指令。下面指令创建一个叫作<code>hello</code>的分组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd hello</span><br></pre></td></tr></table></figure>

<h4 id="为用户增加次级分组"><a href="#为用户增加次级分组" class="headerlink" title="为用户增加次级分组"></a>为用户增加次级分组</h4><p>组分成主要分组（Primary Group）和次级分组（Secondary Group）。主要分组只有 1 个，次级分组可以有多个。如果想为用户添加一个次级分组，可以用<code>usermod</code>指令。下面指令将用户<code>foo</code>添加到<code>sudo</code>分组，从而<code>foo</code>拥有了<code>sudo</code>的权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G sudo foo</span><br></pre></td></tr></table></figure>

<p><code>-a</code>代表append，<code>-G</code>代表一个次级分组的清单， 最后一个<code>foo</code>是账户名。</p>
<h4 id="修改用户主要分组"><a href="#修改用户主要分组" class="headerlink" title="修改用户主要分组"></a>修改用户主要分组</h4><p>修改主要分组还是使用<code>usermod</code>指令。只不过参数是小写的<code>-g</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -g somegroup foo</span><br></pre></td></tr></table></figure>

<h3 id="文件权限管理指令"><a href="#文件权限管理指令" class="headerlink" title="文件权限管理指令"></a>文件权限管理指令</h3><p>接下来我们学习文件管理相关的指令。</p>
<h4 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h4><p>我们可以用<code>ls -l</code>查看文件的权限，相关内容在本课时前面已经介绍过了。</p>
<h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p>可以用<code>chmod</code>修改文件权限，<code>chmod</code>（ change file mode bits），也就是我们之前学习的 rwx，只不过 rwx 在 Linux 中是用三个连在一起的二进制位来表示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置foo可以执行</span></span><br><span class="line">chmod +x ./foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不允许foo执行</span></span><br><span class="line">chmod -x ./foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以同时设置多个权限</span></span><br><span class="line">chmod +rwx ./foo</span><br></pre></td></tr></table></figure>

<p>因为<code>rwx</code>在 Linux 中用相邻的 3 个位来表示。比如说<code>111</code>代表<code>rwx</code>，<code>101</code>代表<code>r-x</code>。而<code>rwx</code>总共有三组，分别是用户权限、组权限和全部用户权限。也就是可以用<code>111111111</code> 9 个 1 代表<code>rwxrwxrwx</code>。又因为<code>111</code>10 进制是 7，因此当需要一次性设置用户权限、组权限和所有用户权限的时候，我们经常用数字表示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置rwxrwxrwx (111111111 -&gt; 777)</span></span><br><span class="line">chmod 777 ./foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置rw-rw-rw-(110110110 -&gt; 666)</span></span><br><span class="line">chmod 666 ./foo</span><br></pre></td></tr></table></figure>

<h4 id="修改文件所属用户"><a href="#修改文件所属用户" class="headerlink" title="修改文件所属用户"></a>修改文件所属用户</h4><p>有时候我们需要修改文件所属用户，这个时候会使用<code>chown</code>指令。 下面指令修改<code>foo</code>文件所属的用户为<code>bar</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown bar ./foo</span><br></pre></td></tr></table></figure>

<p>还有一些情况下，我们需要同时修改文件所属的用户和分组，比如我们想修改<code>foo</code>的分组位<code>g</code>，用户为<code>u</code>，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown g.u ./foo</span><br></pre></td></tr></table></figure>

<p><strong>简述 Linux 权限划分的原则？</strong></p>
<p>老规矩，请你先在脑海里构思下给面试官的表述，并把你的思考写在留言区，然后再来看我接下来的分析。</p>
<p><strong>【解析】</strong> Linux 遵循最小权限原则。</p>
<ol>
<li>每个用户掌握的权限应该足够小，每个组掌握的权限也足够小。实际生产过程中，最好管理员权限可以拆分，互相牵制防止问题。</li>
<li>每个应用应当尽可能小的使用权限。最理想的是每个应用单独占用一个容器（比如 Docker），这样就不存在互相影响的问题。即便应用被攻破，也无法攻破 Docker 的保护层。</li>
<li>尽可能少的<code>root</code>。如果一个用户需要<code>root</code>能力，那么应当进行权限包围——马上提升权限（比如 sudo），处理后马上释放权限。</li>
<li>系统层面实现权限分级保护，将系统的权限分成一个个 Ring，外层 Ring 调用内层 Ring 时需要内层 Ring 进行权限校验。</li>
</ol>
<h3 id="远程操作指令"><a href="#远程操作指令" class="headerlink" title="远程操作指令"></a>远程操作指令</h3><p>远程操作指令用得最多的是<code>ssh</code>，<code>ssh</code>指令允许远程登录到目标计算机并进行远程操作和管理。还有一个比较常用的远程指令是<code>scp</code>，<code>scp</code>帮助我们远程传送文件。</p>
<h4 id="ssh（Secure-Shell）"><a href="#ssh（Secure-Shell）" class="headerlink" title="ssh（Secure Shell）"></a>ssh（Secure Shell）</h4><p>有一种场景需要远程登录一个 Linux 系统，这时我们会用到<code>ssh</code>指令。比如你想远程登录一台机器，可以使用<code>ssh user@ip</code>的方式。</p>
<h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><p>另一种场景是我需要拷贝一个文件到远程，这时可以使用<code>scp</code>指令，如下图，我使用<code>scp</code>指令将本地计算机的一个文件拷贝到了 ubuntu 虚拟机用户的家目录中。</p>
<p>比如从<code>u1</code>拷贝家目录下的文件<code>a.txt</code>到<code>u2</code>。家目录有一个简写，就是用<code>~</code>。</p>
<p>输入 scp 指令之后会弹出一个提示，要求输入密码，系统验证通过后文件会被成功拷贝。</p>
<h3 id="查看本地网络状态"><a href="#查看本地网络状态" class="headerlink" title="查看本地网络状态"></a>查看本地网络状态</h3><p>如果你想要了解本地的网络状态，比较常用的网络指令是<code>ifconfig</code>和<code>netstat</code>。</p>
<h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>当你想知道本地<code>ip</code>以及本地有哪些网络接口时，就可以使用<code>ifconfig</code>指令。你可以把一个网络接口理解成一个网卡，有时候虚拟机会装虚拟网卡，虚拟网卡是用软件模拟的网卡。</p>
<p>比如：VMware 为每个虚拟机创造一个虚拟网卡，通过虚拟网卡接入虚拟网络。当然物理机也可以接入虚拟网络，它可以通过虚拟网络向虚拟机的虚拟网卡上发送信息。</p>
<p>下图是我的 ubuntu 虚拟机用 ifconfig 查看网络接口信息。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192452.png" alt="image-20210623192452089"></p>
<p>可以看到我的这台 ubuntu 虚拟机一共有 2 个网卡，ens33 和 lo。<code>lo</code>是本地回路（local lookback），发送给<code>lo</code>就相当于发送给本机。<code>ens33</code>是一块连接着真实网络的虚拟网卡。</p>
<h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>另一个查看网络状态的场景是想看目前本机的网络使用情况，这个时候可以用<code>netstat</code>。</p>
<p><strong>默认行为</strong></p>
<p>不传任何参数的<code>netstat</code>帮助查询所有的本地 socket，下图是<code>netstat | less</code>的结果。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192516.png" alt="image-20210623192516557"></p>
<p>如上图，我们看到的是 socket 文件。socket 是网络插槽被抽象成了文件，负责在客户端、服务器之间收发数据。当客户端和服务端发生连接时，客户端和服务端会同时各自生成一个 socket 文件，用于管理这个连接。这里，可以用<code>wc -l</code>数一下有多少个<code>socket</code>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192542.png" alt="image-20210623192541989"></p>
<p>这里没有找到连接中的<code>tcp</code>，因为我们这台虚拟机当时没有发生任何的网络连接。因此我们尝试从机器<code>u2</code>（另一台机器）ssh 登录进<code>u1</code>，再看一次：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192608.png" alt="image-20210623192608861"></p>
<p>如上图所示，可以看到有一个 TCP 连接了。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192721.png" alt="image-20210623192721531"></p>
<p><strong>查看端口占用</strong></p>
<p>还有一种非常常见的情形，我们想知道某个端口是哪个应用在占用。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192734.png" alt="image-20210623192734416"></p>
<p>这里我们看到 22 端口被 sshd，也就是远程登录模块被占用了。<code>-n</code>是将一些特殊的端口号用数字显示，<code>-t</code>是指看 TCP 协议，<code>-l</code>是只显示连接中的连接，<code>-p</code>是显示程序名称。</p>
<h3 id="网络测试"><a href="#网络测试" class="headerlink" title="网络测试"></a>网络测试</h3><p>当我们需要测试网络延迟、测试服务是否可用时，可能会用到<code>ping</code>和<code>telnet</code>指令。</p>
<h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>想知道本机到某个网站的网络延迟，就可以使用<code>ping</code>指令。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192758.png" alt="image-20210623192757989"></p>
<p><code>ping</code>一个网站需要使用 ICMP 协议。因此你可以在上图中看到 icmp 序号。 这里的时间<code>time</code>是往返一次的时间。<code>ttl</code>叫作 time to live，是封包的生存时间。就是说，一个封包从发出就开始倒计时，如果途中超过 128ms，这个包就会被丢弃。如果包被丢弃，就会被算进丢包率。</p>
<p>另外<code>ping</code>还可以帮助我们看到一个网址的 IP 地址。 通过网址获得 IP 地址的过程叫作 DNS Lookup（DNS 查询）。<code>ping</code>利用了 DNS 查询，但是没有显示全部的 DNS 查询结果。</p>
<h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><p>有时候我们想知道本机到某个 IP + 端口的网络是否通畅，也就是想知道对方服务器是否在这个端口上提供了服务。这个时候可以用<code>telnet</code>指令。 如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192836.png" alt="image-20210623192836203"></p>
<p>如上图所示，第 5 行的<code>GET</code> 和第 6 行的<code>HOST</code>是我输入的。 拉勾网返回了一个 301 永久跳转。这是因为拉勾网尝试把<code>http</code>协议链接重定向到<code>https</code>。</p>
<h3 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h3><p>我们排查网络故障时想要进行一次 DNS Lookup，想知道一个网址 DNS 的解析过程。这个时候有多个指令可以用。</p>
<h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><p>host 就是一个 DNS 查询工具。比如我们查询拉勾网的 DNS，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192908.png" alt="image-20210623192908805"></p>
<p>我们看到拉勾网 <a href="http://www.lagou.comw/" target="_blank" rel="noopener">www.lagou.com</a> 是一个别名，它的原名是 lgmain 开头的一个域名，这说明拉勾网有可能在用 CDN 分发主页（关于 CDN，我们《计算机网络》专栏见）。</p>
<p>上图中，可以找到 3 个域名对应的 IP 地址。</p>
<p>如果想追查某种类型的记录，可以使用<code>host -t</code>。比如下图我们追查拉勾的 AAAA 记录，因为拉勾网还没有部署 IPv6，所以没有找到。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623192934.png" alt="image-20210623192934697"></p>
<h4 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h4><p><code>dig</code>指令也是一个做 DNS 查询的。不过<code>dig</code>指令显示的内容更详细。下图是<code>dig</code>拉勾网的结果。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623193000.png" alt="image-20210623193000544"></p>
<p>从结果可以看到<a href="http://www.lagou.c/" target="_blank" rel="noopener">www.lagou.com</a> 有一个别名，用 CNAME 记录定义 lgmain 开头的一个域名，然后有 3 条 A 记录，通常这种情况是为了均衡负载或者分发内容。</p>
<h3 id="HTTP-相关"><a href="#HTTP-相关" class="headerlink" title="HTTP 相关"></a>HTTP 相关</h3><p>最后我们来说说<code>http</code>协议相关的指令。</p>
<h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>如果要在命令行请求一个网页，或者请求一个接口，可以用<code>curl</code>指令。<code>curl</code>支持很多种协议，比如 LDAP、SMTP、FTP、HTTP 等。</p>
<p>我们可以直接使用 curl 请求一个网址，获取资源，比如我用 curl 直接获取了拉勾网的主页，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210623193037.png" alt="image-20210623193037525"></p>
<p>如果只想看 HTTP 返回头，可以使用<code>curl -I</code>。</p>
<p>另外<code>curl</code>还可以执行 POST 请求，比如下面这个语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">'&#123;"x" : 1&#125;'</span> -H <span class="string">"Content-Type: application/json"</span> -X POST http://localhost:3000/api</span><br></pre></td></tr></table></figure>

<p>curl在向<code>localhost:3000</code>发送 POST 请求。<code>-d</code>后面跟着要发送的数据， -<code>X</code>后面是用到的 HTTP 方法，<code>-H</code>是指定自定义的请求头。</p>
<h3 id="如何查看一个域名有哪些-NS-记录？"><a href="#如何查看一个域名有哪些-NS-记录？" class="headerlink" title="如何查看一个域名有哪些 NS 记录？"></a><strong>如何查看一个域名有哪些 NS 记录？</strong></h3><p><strong>【解析】</strong> host 指令提供了一个<code>-t</code>参数指定需要查找的记录类型。我们可以使用<code>host -t ns {网址}</code>。另外 dig 也提供了同样的能力。如果你感兴趣，还可以使用<code>man</code>对系统进行操作。</p>
<h3 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h3><p>在 Linux 上安装程序大概有 2 种思路：</p>
<ol>
<li>直接编译源代码；</li>
<li>使用包管理器。</li>
</ol>
<p>受开源运动影响，Linux 上很多软件都可以拿到源代码，这也是 Linux 能取得成功的一个重要原因。接下来我们先尝试用包管理器安装应用，然后再用一个实战的例子，教你如何编译安装<code>nginx</code>。</p>
<h3 id="包管理器使用"><a href="#包管理器使用" class="headerlink" title="包管理器使用"></a>包管理器使用</h3><p>Linux 下的应用程序多数以软件包的形式发布，用户拿到对应的包之后，使用包管理器进行安装。说到包管理器，就要提到<code>dpkg</code>和<code>rpm</code>。</p>
<p>我们先说说包。 Linux 下两大主流的包就是<code>rpm</code>和<code>dpkg</code>。</p>
<p><code>dpkg</code>（debian package），是<code>linux</code>一个主流的社区分支开发出来的。社区就是开源社区，有很多世界顶级的程序员会在社区贡献代码，比如 github。一般衍生于<code>debian</code>的 Linux 版本都支持<code>dpkg</code>，比如<code>ubuntu</code>。</p>
<p><code>rpm</code>（redhatpackage manager）。在正式讲解之前，我们先来聊聊 RedHat 这家公司。</p>
<p>RedHat 是一个做 Linux 的公司，你可以把它理解成一家“保险公司”。 很多公司购买红帽的服务，是为了给自己的业务上一个保险。以防万一哪天公司内部搞不定 Linux 底层，或者底层有 Bug，再或者底层不适合当下的业务发展，需要修改等问题，红帽的工程师都可以帮企业解决。</p>
<p>再比如，RedHat 收购了JBoss，把 JBoss 改名为 WildFly。 像 WildFly 这种工具更多是面向企业级，比如没有大量研发团队的企业会更倾向使用成熟的技术。RedHat 公司也有自己的 Linux，就叫作 RedHat。RedHat 系比较重要的 Linux 有 RedHat/Fedora 等。</p>
<p>无论是<code>dpkg</code>还是<code>rpm</code>都抽象了自己的包格式，就是以<code>.dpkg</code>或者<code>.rpm</code>结尾的文件。</p>
<p><code>dpkg</code>和<code>rpm</code>也都提供了类似的能力：</p>
<ul>
<li>查询是否已经安装了某个软件包；</li>
<li>查询目前安装了什么软件包；</li>
<li>给定一个软件包，进行安装；</li>
<li>删除一个安装好的软件包。</li>
</ul>
<p>关于<code>dpkg</code>和<code>rpm</code>的具体用法，你可以用<code>man</code>进行学习。接下来我们聊聊<code>yum</code>和<code>apt</code>。</p>
<h4 id="自动依赖管理"><a href="#自动依赖管理" class="headerlink" title="自动依赖管理"></a>自动依赖管理</h4><p>Linux 是一个开源生态，因此工具非常多。工具在给用户使用之前，需要先打成<code>dpkg</code>或者<code>rpm</code>包。 有的时候一个包会依赖很多其他的包，而<code>dpkg</code>和<code>rpm</code>不会对这种情况进行管理，有时候为了装一个包需要先装十几个依赖的包，过程非常艰辛！因此现在多数情况都在用<code>yum</code>和<code>apt</code>。</p>
<p><strong>yum</strong></p>
<p>你可能会说，我不用<code>yum</code>也不用<code>apt</code>，我只用<code>docker</code>。首先给你一个连击 666，然后我还是要告诉你，如果你做<code>docker</code>镜像，那么还是要用到<code>yum</code>和<code>apt</code>，因此还是有必要学一下。</p>
<p><code>yum</code>的全名是 Yellodog Updator，Modified。 看名字就知道它是基于<code>Yellodog Updator</code>这款软件修改而来的一个工具。<code>yum</code>是 Python 开发的，提供的是<code>rpm</code>包，因此只有<code>redhat</code>系的 Linux，比如 Fedora，Centos 支持<code>yum</code>。<code>yum</code>的主要能力就是帮你解决下载和依赖两个问题。</p>
<p>下载之所以是问题，是因为 Linux 生态非常庞大，有时候用户不知道该去哪里下载一款工具。比如用户想安装<code>vim</code>，只需要输入<code>sudo yum install vim</code>就可以安装了。<code>yum</code>的服务器收集了很多<code>linux</code>软件，因此<code>yum</code>会帮助用户找到<code>vim</code>的包。</p>
<p>另一方面，<code>yum</code>帮助用户解决了很多依赖，比如用户安装一个软件依赖了 10 个其他的软件，<code>yum</code>会把这 11 个软件一次性的装好。</p>
<p>关于<code>yum</code>的具体用法，你可以使用man工具进行学习。</p>
<p><strong>apt</strong></p>
<p>接下来我们来重点说说<code>apt</code>，然后再一起尝试使用。因为我这次是用<code>ubuntu</code>Linux 给你教学，所以我以 apt 为例子，yum 的用法是差不多的，你可以自己 man 一下。</p>
<p><code>apt</code>全名是 Advanced Packaging Tools，是一个<code>debian</code>及其衍生 Linux 系统下的包管理器。由于<code>advanced</code>（先进）是相对于<code>dpkg</code>而言的，因此它也能够提供和<code>yum</code>类似的下载和依赖管理能力。比如在没有<code>vim</code>的机器上，我们可以用下面的指令安装<code>vim</code>。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163206.png" alt="image-20210624163206691"></p>
<p>然后用<code>dpkg</code>指令查看 vim 的状态是<code>ii</code>。第一个<code>i</code>代表期望状态是已安装，第二个<code>i</code>代表实际状态是已安装。</p>
<p>下面我们卸载<code>vim</code>，再通过<code>dpkg</code>查看，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163234.png" alt="image-20210624163234275"></p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163245.png" alt="image-20210624163245181"></p>
<p>我们看到 vim 的状态从<code>ii</code>变成了<code>rc</code>，<code>r</code>是期望删除，<code>c</code>是实际上还有配置文件遗留。 如果我们想彻底删除配置文件，可以使用<code>apt purge</code>，就是彻底清除的意思，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163304.png" alt="image-20210624163304544"></p>
<p>再使用<code>dpkg -l</code>时，<code>vim</code>已经清除了。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163328.png" alt="image-20210624163328213"></p>
<p>期待结果是<code>u</code>就是 unkonw（未知）说明已经没有了。实际结果是<code>n</code>，就是 not-installed（未安装）。</p>
<p>如果想查询<code>mysql</code>相关的包，可以使用<code>apt serach mysql</code>，这样会看到很多和<code>mysql</code>相关的包，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163351.png" alt="image-20210624163351037"></p>
<p>如果我们想精确查找一个叫作<code>mysql-server</code>的包，可以用<code>apt list</code>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163445.png" alt="image-20210624163445128"></p>
<p>这里我们找到了<code>mysql-server</code>包。</p>
<p>另外有时候国内的<code>apt</code>服务器速度比较慢，你可以尝试使用阿里云的镜像服务器。具体可参考我下面的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">--以下是文件内容--</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>镜像地址可以通过<code>/etc/apt/sources.list</code>配置，注意<code>focal</code>是我用的<code>ubuntu</code>版本，你可以使用<code>sudo lsb_release</code>查看自己的 Ubuntu 版本。如果你想用我上面给出的内容覆盖你的<code>sources.list</code>，只需把版本号改成你自己的。注意，每个<code>ubuntu</code>版本都有自己的代号。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624163604.png" alt="image-20210624163604579"></p>
<p>通过上面的学习，相信你已经逐渐了解了包管理器的基本概念和使用。如果你是<code>centos</code>或者<code>fedora</code>，需要自己<code>man</code>一下<code>yum</code>。</p>
<h3 id="编译安装-Nginx"><a href="#编译安装-Nginx" class="headerlink" title="编译安装 Nginx"></a>编译安装 Nginx</h3><p>接下来我们说说编译安装 Nginx（发音是 engine X），是一个家喻户晓的 Web 服务器。 它的发明者是俄国的伊戈尔·赛索耶夫。赛索耶夫 2002 年开始写 Nginx，主要目的是解决同一个互联网节点同时进入大量并发请求的问题。注意，大量并发请求不是大量 QPS 的意思，QPS 是吞吐量大，需要快速响应，而高并发时则需要合理安排任务调度。</p>
<p>后来塞索耶夫成立了 Nginx 公司， 2018 年估值到达到 4.3 亿美金。现在基本上国内大厂的 Web 服务器都是基于 Nginx，只不过进行了特殊的修改，比如淘宝用 Tengine。</p>
<p>下面我们再来看看源码安装，在 Linux 上获取<code>nginx</code>源码，可以去搜索 <a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx 官方网站</a>，一般都会提供源码包。</p>
<p>如上图所示，可以看到 nginx-1.18.0 的网址是：<a href="http://nginx.org/download/nginx-1.19.2.tar.gz%E3%80%82%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E7%94%A8" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.19.2.tar.gz。然后我们用</a> wget 去下载这个包。 wget 是 GNU 项目下的下载工具，GNU 是早期<code>unix</code>项目的一个变种。<code>linux</code>下很多工具都是从<code>unix</code>继承来的，这就是开源的好处，很多工具不用再次开发了。你可能很难想象<code>windows</code>下的命令工具可以在<code>linux</code>下用，但是<code>linux</code>下的工具却可以在任何系统中用。 因此，<code>linux</code>下面的工具发展速度很快，如今已成为最受欢迎的服务器操作系统。</p>
<p>当然也有同学的机器上没有<code>wget</code>，那么你可以用<code>apt</code>安装一下。</p>
<ul>
<li>第一步：下载源码。我们使用<code>wget</code>下载<code>nginx</code>源码包：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164203.png" alt="image-20210624164203352"></p>
<p>可以像我这样使用<code>cd</code>先切换到家目录。</p>
<ul>
<li>第二步：解压。我们解压下载好的<code>nginx</code>源码包。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164220.png" alt="image-20210624164219798"></p>
<p>用<code>ls</code>发现包已经存在了，然后使用<code>tar</code>命令解压。</p>
<p><code>tar</code>是用来打包和解压用的。之所以叫作<code>tar</code>是有一些历史原因：<code>t</code>代表<code>tape</code>（磁带）；<code>ar</code>是 archive（档案）。因为早期的存储介质很小，人们习惯把文件打包然后存储到磁带上，那时候<code>unix</code>用的命令就是<code>tar</code>。因为<code>linux</code>是个开源生态，所以就沿袭下来继续使用<code>tar</code>。</p>
<p><code>-x</code>代表 extract（提取）。-z代表<code>gzip</code>，也就是解压<code>gz</code>类型的文件。<code>-v</code>代表 verbose（显示细节），如果你不输入<code>-v</code>，就不会打印解压过程了。<code>-f</code>代表 file，这里指的是要操作文件，而不是磁带。 所以<code>tar</code>解压通常带有<code>x</code>和<code>f</code>，打包通常是<code>c</code>就是 create 的意思。</p>
<ul>
<li>第三步：配置和解决依赖。解压完，我们进入<code>nginx</code>的目录看一看。 如下图所示：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164338.png" alt="image-20210624164338269"></p>
<p>可以看到一个叫作<code>configure</code>的文件是绿色的，也就是可执行文件。然后我们执行 configure 文件进行配置，这个配置文件来自一款叫作<code>autoconf</code>的工具，也是 GNU 项目下的，说白了就是<code>bash</code>（Bourne Shell）下的安装打包工具（就是个安装程序）。这个安装程序支持很多配置，你可以用<code>./configure --help</code>看到所有的配置项，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164356.png" alt="image-20210624164356170"></p>
<p>这里有几个非常重要的配置项，叫作<code>prefix</code>。<code>prefix</code>配置项决定了软件的安装目录。如果不配置这个配置项，就会使用默认的安装目录。<code>sbin-path</code>决定了<code>nginx</code>的可执行文件的位置。<code>conf-path</code>决定了<code>nginx</code>配置文件的位置。我们都使用默认，然后执行<code>./configure</code>，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164423.png" alt="image-20210624164423509"></p>
<p><code>autoconf</code>进行依赖检查的时候，报了一个错误，cc 没有找到。这是因为机器上没有安装<code>gcc</code>工具，gcc 是家喻户晓的工具套件，全名是 GNU Compiler Collection——里面涵盖了包括 c/c++ 在内的多门语言的编译器。</p>
<p>我们用包管理器，安装<code>gcc</code>，如下图所示。安装<code>gcc</code>通常是安装<code>build-essential</code>这个包。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164445.png" alt="image-20210624164445155"></p>
<p>安装完成之后，再执行<code>./configure</code>，如下图所示：</p>
<p>我们看到配置程序开始执行。但是最终报了一个错误，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164508.png" alt="image-20210624164508442"></p>
<p>报错的内容是，<code>nginx</code>的<code>HTTP rewrite</code>模块，需要<code>PCRE</code>库。 PCRE 是<code>perl</code>语言的兼容正则表达式库。<code>perl</code>语言一直以支持原生正则表达式，而受到广大编程爱好者的喜爱。我曾经看到过一个 IBM 的朋友用<code>perl</code>加上<code>wget</code>就实现了一个简单的爬虫。接下来，我们开始安装<code>PCRE</code>。</p>
<p>一般这种依赖库，会叫<code>pcre-dev</code>或者<code>libpcre</code>。用<code>apt</code>查询了一下，然后<code>grep</code>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164532.png" alt="image-20210624164532229"></p>
<p>我们看到有<code>pcre2</code>也有<code>pcre3</code>。这个时候可以考虑试试<code>pcre3</code>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164558.png" alt="image-20210624164557771"></p>
<p>安装完成之后再试试<code>./configure</code>，提示还需要<code>zlib</code>。然后我们用类似的方法解决<code>zlib</code>依赖。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624164612.png" alt="image-20210624164611872"></p>
<p><code>zlib</code>包的名字叫<code>zlib1g</code>不太好找，需要查资料才能确定是这个名字。</p>
<p>我们再尝试配置，终于配置成功了。</p>
<ul>
<li>第四步：编译和安装。</li>
</ul>
<p>通常配置完之后，我们输入<code>make &amp;&amp; sudo make install</code>进行编译和安装。<code>make</code>是<code>linux</code>下面一个强大的构建工具。<code>autoconf</code>也就是<code>./configure</code>会在当前目录下生成一个 MakeFile 文件。<code>make</code>会根据<code>MakeFile</code>文件编译整个项目。编译完成后，能够形成和当前操作系统以及 CPU 指令集兼容的二进制可执行文件。然后再用<code>make install</code>安装。<code>&amp;&amp;</code>符号代表执行完<code>make</code>再去执行<code>make installl</code>。</p>
<p>你可以看到编译是个非常慢的活。等待了差不多 1 分钟，终于结束了。<code>nginx</code>被安装到了<code>/usr/local/nginx</code>中，如果需要让<code>nginx</code>全局执行，可以设置一个软连接到<code>/usr/local/bin</code>，具体如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/<span class="built_in">local</span>/nginx/sbin/nginx /usr/<span class="built_in">local</span>/sbin/nginx</span><br></pre></td></tr></table></figure>

<h4 id="为什么会有编译安装？"><a href="#为什么会有编译安装？" class="headerlink" title="为什么会有编译安装？"></a>为什么会有编译安装？</h4><p>学完整个编译安装 Ngnix 过程后，你可能会问，为什么会有编译安装这么复杂的事情。</p>
<p>原来使用 C/C++ 写的程序存在一个交叉编译的问题。就是写一次程序，在很多个平台执行。而不同指令集的 CPU 指令，还有操作系统的可执行文件格式是不同的。因此，这里有非常多的现实问题需要解决。一般是由操作系统的提供方，比如 RedHat 来牵头解决这些问题。你可以用<code>apt</code>等工具提供给用户已经编译好的包。<code>apt</code>会自动根据用户的平台类型选择不同的包。</p>
<p>但如果某个包没有在平台侧注册，也没有提供某个 Linux 平台的软件包，我们就需要回退到编译安装，通过源代码直接在某个平台安装。</p>
<p><strong>编译安装和包管理安装有什么优势和劣势？</strong></p>
<p>老规矩，请你先在脑海里构思下给面试官的表述，并把你的思考写在留言区，然后再来看我接下来的分析。</p>
<p><strong>【解析】</strong> 包管理安装很方便，但是有两点劣势。</p>
<p>第一点是需要提前将包编译好，因此有一个发布的过程，如果某个包没有发布版本，或者在某个平台上找不到对应的发布版本，就需要编译安装。</p>
<p>第二点就是如果一个软件的定制程度很高，可能会在编译阶段传入参数，比如利用<code>configure</code>传入配置参数，这种时候就需要编译安装。</p>
<h3 id="利用-Linux-指令分析-Web-日志"><a href="#利用-Linux-指令分析-Web-日志" class="headerlink" title="利用 Linux 指令分析 Web 日志"></a><strong>利用 Linux 指令分析 Web 日志</strong></h3><h4 id="第一步：能不能这样做？"><a href="#第一步：能不能这样做？" class="headerlink" title="第一步：能不能这样做？"></a>第一步：能不能这样做？</h4><p>当我们想要分析一个线上文件的时候，首先要思考，能不能这样做？ 这里你可以先用<code>htop</code>指令看一下当前的负载。如果你的机器上没有<code>htop</code>，可以考虑用<code>yum</code>或者<code>apt</code>去安装。</p>
<p>然后我们用<code>ls</code>查看文件大小。发现这只是一个 7M 的文件，因此对线上的影响可以忽略不计。如果文件太大，建议你用<code>scp</code>指令将文件拷贝到闲置服务器再分析。下图中我使用了<code>--block-size</code>让<code>ls</code>以<code>M</code>为单位显示文件大小。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175451.png" alt="image-20210624175451215"></p>
<h4 id="第二步：LESS-日志文件"><a href="#第二步：LESS-日志文件" class="headerlink" title="第二步：LESS 日志文件"></a>第二步：LESS 日志文件</h4><p>在分析日志前，给你提个醒，记得要<code>less</code>一下，看看日志里面的内容。之前我们说过，尽量使用<code>less</code>这种不需要读取全部文件的指令，因为在线上执行<code>cat</code>是一件非常危险的事情，这可能导致线上服务器资源不足。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175512.png" alt="image-20210624175512545"></p>
<p>如上图所示，我们看到<code>nginx</code>的<code>access_log</code>每一行都是一次用户的访问，从左到右依次是：</p>
<ul>
<li>IP 地址；</li>
<li>时间；</li>
<li>HTTP 请求的方法、路径和协议版本、返回的状态码；</li>
<li>User Agent。</li>
</ul>
<h4 id="第三步：PV-分析"><a href="#第三步：PV-分析" class="headerlink" title="第三步：PV 分析"></a>第三步：PV 分析</h4><p>PV（Page View），用户每访问一个页面就是一次<code>Page View</code>。对于<code>nginx</code>的<code>acess_log</code>来说，分析 PV 非常简单，我们直接使用<code>wc -l</code>就可以看到整体的<code>PV</code>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175634.png" alt="image-20210624175634864"></p>
<p>如上图所示：我们看到了一共有 51462 条 PV。</p>
<h4 id="第四步：PV-分组"><a href="#第四步：PV-分组" class="headerlink" title="第四步：PV 分组"></a>第四步：PV 分组</h4><p>通常一个日志中可能有几天的 PV，为了得到更加直观的数据，有时候需要按天进行分组。为了简化这个问题，我们先来看看日志中都有哪些天的日志。</p>
<p>使用<code>awk &#39;{print $4}&#39; access.log | less</code>可以看到如下结果。<code>awk</code>是一个处理文本的领域专有语言。这里就牵扯到领域专有语言这个概念，英文是Domain Specific Language。领域专有语言，就是为了处理某个领域专门设计的语言。比如awk是用来分析处理文本的DSL，html是专门用来描述网页的DSL，SQL是专门用来查询数据的DSL……大家还可以根据自己的业务设计某种针对业务的DSL。</p>
<p>你可以看到我们用<code>$4</code>代表文本的第 4 列，也就是时间所在的这一列，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175755.png" alt="image-20210624175754952"></p>
<p>我们想要按天统计，可以利用 <code>awk</code>提供的字符串截取的能力。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175807.png" alt="image-20210624175807734"></p>
<p>上图中，我们使用<code>awk</code>的<code>substr</code>函数，数字<code>2</code>代表从第 2 个字符开始，数字<code>11</code>代表截取 11 个字符。</p>
<p>接下来我们就可以分组统计每天的日志条数了。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175820.png" alt="image-20210624175820453"></p>
<p>上图中，使用<code>sort</code>进行排序，然后使用<code>uniq -c</code>进行统计。你可以看到从 2015 年 5 月 17 号一直到 6 月 4 号的日志，还可以看到每天的 PV 量大概是在 2000~3000 之间。</p>
<h4 id="第五步：分析-UV"><a href="#第五步：分析-UV" class="headerlink" title="第五步：分析 UV"></a>第五步：分析 UV</h4><p>接下来我们分析 UV。UV（Uniq Visitor），也就是统计访问人数。通常确定用户的身份是一个复杂的事情，但是我们可以用 IP 访问来近似统计 UV。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210624175954.png" alt="image-20210624175954237"></p>
<p>上图中，我们使用 awk 去打印<code>$1</code>也就是第一列，接着<code>sort</code>排序，然后用<code>uniq</code>去重，最后用<code>wc -l</code>查看条数。 这样我们就知道日志文件中一共有<code>2660</code>个 IP，也就是<code>2660</code>个 UV。</p>
<h4 id="第六步：分组分析-UV"><a href="#第六步：分组分析-UV" class="headerlink" title="第六步：分组分析 UV"></a>第六步：分组分析 UV</h4><p>接下来我们尝试按天分组分析每天的 UV 情况。这个情况比较复杂，需要较多的指令，我们先创建一个叫作<code>sum.sh</code>的<code>bash</code>脚本文件，写入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line">awk <span class="string">'&#123;print substr($4, 2, 11) " " $1&#125;'</span> access.log |\</span><br><span class="line">	sort | uniq |\</span><br><span class="line">	awk <span class="string">'&#123;uv[$1]++;next&#125;END&#123;for (ip in uv) print ip, uv[ip]&#125;'</span></span><br></pre></td></tr></table></figure>

<p>具体分析如下。</p>
<ul>
<li>文件首部我们使用<code>#!</code>，表示我们将使用后面的<code>/usr/bin/bash</code>执行这个文件。</li>
<li>第一次<code>awk</code>我们将第 4 列的日期和第 1 列的<code>ip</code>地址拼接在一起。</li>
<li>下面的<code>sort</code>是把整个文件进行一次字典序排序，相当于先根据日期排序，再根据 IP 排序。</li>
<li>接下来我们用<code>uniq</code>去重，日期 +IP 相同的行就只保留一个。</li>
<li>最后的<code>awk</code>我们再根据第 1 列的时间和第 2 列的 IP 进行统计。</li>
</ul>
<p>为了理解最后这一行描述，我们先来简单了解下<code>awk</code>的原理。</p>
<p><code>awk</code>本身是逐行进行处理的。因此我们的<code>next</code>关键字是提醒<code>awk</code>跳转到下一行输入。 对每一行输入，<code>awk</code>会根据第 1 列的字符串（也就是日期）进行累加。之后的<code>END</code>关键字代表一个触发器，就是 END 后面用 {} 括起来的语句会在所有输入都处理完之后执行——当所有输入都执行完，结果被累加到<code>uv</code>中后，通过<code>foreach</code>遍历<code>uv</code>中所有的<code>key</code>，去打印<code>ip</code>和<code>ip</code>对应的数量。</p>
<p>编写完上面的脚本之后，我们保存退出编辑器。接着执行<code>chmod +x ./sum.sh</code>，给<code>sum.sh</code>增加执行权限。然后我们可以像下图这样执行，获得结果：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625083225.png" alt="image-20210625083225035"></p>
<h3 id="在成百上千的集群中安装一个-Java-环境"><a href="#在成百上千的集群中安装一个-Java-环境" class="headerlink" title="在成百上千的集群中安装一个 Java 环境"></a>在成百上千的集群中安装一个 Java 环境</h3><h4 id="第一步：搭建学习用的集群"><a href="#第一步：搭建学习用的集群" class="headerlink" title="第一步：搭建学习用的集群"></a>第一步：搭建学习用的集群</h4><p>第一步我们先搭建一个学习用的集群。这里简化一下模型。我在自己的电脑上装一个<code>ubuntu</code>桌面版的虚拟机，然后再装两个<code>ubuntu</code>服务器版的虚拟机。</p>
<p>相对于桌面版，服务器版对资源的消耗会少很多。我将教学材料中桌面版的<code>ubuntu</code>命名为<code>u1</code>，两个用来被管理的服务器版<code>ubuntu</code>叫作<code>v1</code>和<code>v2</code>。</p>
<p>用桌面版的原因是：我喜欢<code>ubuntu</code>漂亮的开源字体，这样会让我在给你准备素材的时候拥有一个好心情。如果你对此感兴趣，可以搜索<code>ubuntu mono</code>，尝试把这个字体安装到自己的文本编辑器中。不过我还是觉得在<code>ubuntu</code>中敲代码更有感觉。</p>
<p>注意，我在这里只用了 3 台服务器，但是接下来我们要写的脚本是可以在很多台服务器之间复用的。</p>
<h4 id="第二步：循环遍历-IP-列表"><a href="#第二步：循环遍历-IP-列表" class="headerlink" title="第二步：循环遍历 IP 列表"></a>第二步：循环遍历 IP 列表</h4><p>你可以想象一个局域网中有很多服务器需要管理，它们彼此之间网络互通，我们通过一台主服务器对它们进行操作，即通过<code>u1</code>操作<code>v1</code>和<code>v2</code>。</p>
<p>在主服务器上我们维护一个<code>ip</code>地址的列表，保存成一个文件，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625095958.png" alt="image-20210625095958770"></p>
<p>目前<code>iplist</code>中只有两项，但是如果我们有足够的机器，可以在里面放成百上千项。接下来，请你思考<code>shell</code>如何遍历这些<code>ip</code>？</p>
<p>你可以先尝试实现一个最简单的程序，从文件<code>iplist</code>中读出这些<code>ip</code>并尝试用<code>for</code>循环遍历这些<code>ip</code>，具体程序如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">readarray</span> -t ips &lt; iplist</span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="variable">$&#123;ips[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$ip</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>首行的<code>#!</code>叫作 Shebang。Linux 的程序加载器会分析 Shebang 的内容，决定执行脚本的程序。这里我们希望用<code>bash</code>来执行这段程序，因为我们用到的 readarray 指令是<code>bash 4.0</code>后才增加的能力。</p>
<p><code>readarray</code>指令将 iplist 文件中的每一行读取到变量<code>ips</code>中。<code>ips</code>是一个数组，可以用<code>echo ${ips[@]}</code>打印其中全部的内容：<code>@</code>代表取数组中的全部内容；<code>$</code>符号是一个求值符号。不带<code>$</code>的话，<code>ips[@]</code>会被认为是一个字符串，而不是表达式。</p>
<p><code>for</code>循环遍历数组中的每个<code>ip</code>地址，<code>echo</code>把地址打印到屏幕上。</p>
<p>如果用<code>shell</code>执行上面的程序会报错，因为<code>readarray</code>是<code>bash 4.0</code>后支持的能力，因此我们用<code>chomd</code>为<code>foreach.sh</code>增加执行权限，然后直接利用<code>shebang</code>的能力用<code>bash</code>执行，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100100.png" alt="image-20210625100100006"></p>
<h4 id="第三步：创建集群管理账户"><a href="#第三步：创建集群管理账户" class="headerlink" title="第三步：创建集群管理账户"></a>第三步：创建集群管理账户</h4><p>为了方便集群管理，通常使用统一的用户名管理集群。这个账号在所有的集群中都需要保持命名一致。比如这个集群账号的名字就叫作<code>lagou</code>。</p>
<p>接下来我们探索一下如何创建这个账户<code>lagou</code>，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100117.png" alt="image-20210625100117108"></p>
<p>上面我们创建了<code>lagou</code>账号，然后把<code>lagou</code>加入<code>sudo</code>分组。这样<code>lagou</code>就有了<code>sudo</code>成为<code>root</code>的能力，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100241.png" alt="image-20210625100241632"></p>
<p>接下来，我们设置<code>lagou</code>用户的初始化<code>shell</code>是<code>bash</code>，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100254.png" alt="image-20210625100254044"></p>
<p>这个时候如果使用命令<code>su lagou</code>，可以切换到<code>lagou</code>账号，但是你会发现命令行没有了颜色。因此我们可以将原来用户下面的<code>.bashrc</code>文件拷贝到<code>/home/lagou</code>目录下，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100315.png" alt="image-20210625100315812"></p>
<p>这样，我们就把一些自己平时用的设置拷贝了过去，包括终端颜色的设置。<code>.bashrc</code>是启动<code>bash</code>的时候会默认执行的一个脚本文件。</p>
<p>接下来，我们编辑一下<code>/etc/sudoers</code>文件，增加一行<code>lagou ALL=(ALL) NOPASSWD:ALL</code>表示<code>lagou</code>账号 sudo 时可以免去密码输入环节，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625100334.png" alt="image-20210625100333873"></p>
<p>我们可以把上面的完整过程整理成指令文件，<code>create_lagou.sh</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m -d /home/lagou lagou</span><br><span class="line">sudo passwd lagou</span><br><span class="line">sudo usermod -G sudo lagou</span><br><span class="line">sudo usermod --shell /bin/bash lagou</span><br><span class="line">sudo cp ~/.bashrc /home/lagou/</span><br><span class="line">sudo chown lagou.lagou /home/lagou/.bashrc</span><br><span class="line">sduo sh -c <span class="string">'echo "lagou ALL=(ALL)  NOPASSWD:ALL"&gt;&gt;/etc/sudoers'</span></span><br></pre></td></tr></table></figure>

<p>你可以删除用户<code>lagou</code>，并清理<code>/etc/sudoers</code>文件最后一行。用指令<code>userdel lagou</code>删除账户，然后执行<code>create_lagou.sh</code>重新创建回<code>lagou</code>账户。如果发现结果一致，就代表<code>create_lagou.sh</code>功能没有问题。</p>
<p>最后我们想在<code>v1``v2</code>上都执行<code>create_logou.sh</code>这个脚本。但是你不要忘记，我们的目标是让程序在成百上千台机器上传播，因此还需要一个脚本将<code>create_lagou.sh</code>拷贝到需要执行的机器上去。</p>
<p>这里，可以对<code>foreach.sh</code>稍做修改，然后分发<code>create_lagou.sh</code>文件。</p>
<p>如果你的机器非常多，上述过程会变得非常烦琐。你可以先带着这个问题学习下面的<code>Step 4</code>，然后再返回来重新思考这个问题，当然你也可以远程执行脚本。另外，还有一个叫作<code>sshpass</code>的工具，可以帮你把密码传递给要远程执行的指令，如果你对这块内容感兴趣，可以自己研究下这个工具。</p>
<h4 id="第四步：-打通集群权限"><a href="#第四步：-打通集群权限" class="headerlink" title="第四步： 打通集群权限"></a>第四步： 打通集群权限</h4><p>接下来我们需要打通从主服务器到<code>v1</code>和<code>v2</code>的权限。当然也可以每次都用<code>ssh</code>输入用户名密码的方式登录，但这并不是长久之计。 如果我们有成百上千台服务器，输入用户名密码就成为一件繁重的工作。</p>
<p>这时候，你可以考虑利用主服务器的公钥在各个服务器间登录，避免输入密码。接下来我们聊聊具体的操作步骤：</p>
<p>首先，需要在<code>u1</code>上用<code>ssh-keygen</code>生成一个公私钥对，然后把公钥写入需要管理的每一台机器的<code>authorized_keys</code>文件中。如下图所示：我们使用<code>ssh-keygen</code>在主服务器<code>u1</code>中生成公私钥对。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625112735.png" alt="image-20210625112735298"></p>
<p>然后使用<code>mkdir -p</code>创建<code>~/.ssh</code>目录，<code>-p</code>的优势是当目录不存在时，才需要创建，且不会报错。<code>~</code>代表当前家目录。 如果文件和目录名前面带有一个<code>.</code>，就代表该文件或目录是一个需要隐藏的文件。平时用<code>ls</code>的时候，并不会查看到该文件，通常这种文件拥有特别的含义，比如<code>~/.ssh</code>目录下是对<code>ssh</code>的配置。</p>
<p>我们用<code>cd</code>切换到<code>.ssh</code>目录，然后执行<code>ssh-keygen</code>。这样会在<code>~/.ssh</code>目录中生成两个文件，<code>id_rsa.pub</code>公钥文件和<code>is_rsa</code>私钥文件。 如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625112814.png" alt="image-20210625112814620"></p>
<p>可以看到id_rsa.pub文件中是加密的字符串，我们可以把这些字符串拷贝到其他机器对应用户的~/.ssh/authorized_keys文件中，当ssh登录其他机器的时候，就不用重新输入密码了。 这个传播公钥的能力，可以用一个shell脚本执行，这里我用transfer_key.sh实现。</p>
<p>我们修改一下foreach.sh，并写一个transfer_key.sh配合foreach.sh的工作。transfer_key.sh内容如下：</p>
<p><em>foreach.sh</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">readarray</span> -t ips &lt; iplist</span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="variable">$&#123;ips[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sh ./transfer_key.sh <span class="variable">$ip</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><em>tranfer_key.sh</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ip=<span class="variable">$1</span></span><br><span class="line">pubkey=$(cat ~/.ssh/id_rsa.pub)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"execute on .. <span class="variable">$ip</span>"</span></span><br><span class="line">ssh lagou@<span class="variable">$ip</span> <span class="string">" </span></span><br><span class="line"><span class="string">mkdir -p ~/.ssh</span></span><br><span class="line"><span class="string">echo <span class="variable">$pubkey</span>  &gt;&gt; ~/.ssh/authorized_keys</span></span><br><span class="line"><span class="string">chmod 700 ~/ssh</span></span><br><span class="line"><span class="string">chmod 600 ~/.ssh/authorized_keys</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure>

<p>在<code>foreach.sh</code>中我们执行 transfer_key.sh，并且将 IP 地址通过参数传递过去。在 transfer_key.sh 中，用<code>$1</code>读出 IP 地址参数， 再将公钥写入变量<code>pubkey</code>，然后登录到对应的服务器，执行多行指令。用<code>mkdir</code>指令检查<code>.ssh</code>目录，如不存在就创建这个目录。最后我们将公钥追加写入目标机器的<code>~/.ssh/authorized_keys</code>中。</p>
<p><code>chmod 700</code>和<code>chmod 600</code>是因为某些特定的<code>linux</code>版本需要<code>.ssh</code>的目录为可读写执行，<code>authorized_keys</code>文件的权限为只可读写。而为了保证安全性，组用户、所有用户都不可以访问这个文件。</p>
<p>此前，我们执行<code>foreach.sh</code>需要输入两次密码。完成上述操作后，我们再登录这两台服务器就不需要输入密码了。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155406.png" alt="image-20210625155359241"></p>
<p>接下来，我们尝试一下免密登录，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155440.png" alt="image-20210625155440560"></p>
<h4 id="第五步：单机安装-Java-环境"><a href="#第五步：单机安装-Java-环境" class="headerlink" title="第五步：单机安装 Java 环境"></a>第五步：单机安装 Java 环境</h4><p>在远程部署 Java 环境之前，我们先单机完成以下 Java 环境的安装，用来收集需要执行的脚本。</p>
<p>在<code>ubuntu</code>上安装<code>java</code>环境可以直接用<code>apt</code>。</p>
<p>我们通过下面几个步骤脚本配置 Java 环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk</span><br></pre></td></tr></table></figure>

<p>经过一番等待我们已经安装好了<code>java</code>，然后执行下面的脚本确认<code>java</code>安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> java</span><br><span class="line">java --version</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155533.png" alt="image-20210625155533445"></p>
<p>根据最小权限原则，执行 Java 程序我们考虑再创建一个用户<code>ujava</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m -d /opt/ujava ujava</span><br><span class="line">sudo usermod --shell /bin/bash lagou</span><br></pre></td></tr></table></figure>

<p>这个用户可以不设置密码，因为我们不会真的登录到这个用户下去做任何事情。接下来我们为用户配置 Java 环境变量，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155618.png" alt="image-20210625155618741"></p>
<p>通过两次 ls 追查，可以发现<code>java</code>可执行文件软连接到<code>/etc/alternatives/java</code>然后再次软连接到<code>/usr/lib/jvm/java-11-openjdk-amd64</code>下。</p>
<p>这样我们就可以通过下面的语句设置 JAVA_HOME 环境变量了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/</span><br></pre></td></tr></table></figure>

<p>Linux 的环境变量就好比全局可见的数据，这里我们使用 export 设置<code>JAVA_HOME</code>环境变量的指向。如果你想看所有的环境变量的指向，可以使用<code>env</code>指令。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155651.png" alt="image-20210625155651643"></p>
<p>其中有一个环境变量比较重要，就是<code>PATH</code>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155721.png" alt="image-20210625155721103"></p>
<p>如上图，我们可以使用<code>shell</code>查看<code>PATH</code>的值，<code>PATH</code>中用<code>:</code>分割，每一个目录都是<code>linux</code>查找执行文件的目录。当用户在命令行输入一个命令，Linux 就会在<code>PATH</code>中寻找对应的执行文件。</p>
<p>当然我们不希望<code>JAVA_HOME</code>配置后重启一次电脑就消失，因此可以把这个环境变量加入<code>ujava</code>用户的<code>profile</code>中。这样只要发生用户登录，就有这个环境变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">'echo "export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/" &gt;&gt; /opt/ujava/.bash_profile'</span></span><br></pre></td></tr></table></figure>

<p>将<code>JAVA_HOME</code>加入<code>bash_profile</code>，这样后续远程执行<code>java</code>指令时就可以使用<code>JAVA_HOME</code>环境变量了。</p>
<p>最后，我们将上面所有的指令整理起来，形成一个<code>install_java.sh</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install openjdk-11-jdk</span><br><span class="line"></span><br><span class="line">sudo useradd -m -d /opt/ujava ujava</span><br><span class="line"></span><br><span class="line">sudo usermod --shell /bin/bash ujava</span><br><span class="line"></span><br><span class="line">sudo sh -c <span class="string">'echo "export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/" &gt;&gt; /opt/ujava/.bash_profile'</span></span><br></pre></td></tr></table></figure>

<p><code>apt</code>后面增了一个<code>-y</code>是为了让执行过程不弹出确认提示。</p>
<h4 id="第六步：远程安装-Java-环境"><a href="#第六步：远程安装-Java-环境" class="headerlink" title="第六步：远程安装 Java 环境"></a>第六步：远程安装 Java 环境</h4><p>终于到了远程安装 Java 环境这一步，我们又需要用到<code>foreach.sh</code>。为了避免每次修改，你可以考虑允许<code>foreach.sh</code>带一个文件参数，指定需要远程执行的脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">readarray</span> -t ips &lt; iplist</span><br><span class="line"></span><br><span class="line">script=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="variable">$&#123;ips[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ssh <span class="variable">$ip</span> <span class="string">'bash -s'</span> &lt; <span class="variable">$script</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>改写后的<code>foreach</code>会读取第一个执行参数作为远程执行的脚本文件。 而<code>bash -s</code>会提示使用标准输入流作为命令的输入；<code>&lt; $script</code>负责将脚本文件内容重定向到远程<code>bash</code>的标准输入流。</p>
<p>然后我们执行<code>foreach.sh install_java.sh</code>，机器等待 1 分钟左右，在执行结束后，可以用下面这个脚本检测两个机器中的安装情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -u ujava -i /bin/bash -c <span class="string">'echo $JAVA_HOME'</span></span><br><span class="line"></span><br><span class="line">sudo -u ujava -i java --version</span><br></pre></td></tr></table></figure>

<p><code>check.sh</code>中我们切换到<code>ujava</code>用户去检查<code>JAVA_HOME</code>环境变量和 Java 版本。执行的结果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625155915.png" alt="image-20210625155915600"></p>
<h3 id="linux命令的一些题目"><a href="#linux命令的一些题目" class="headerlink" title="linux命令的一些题目"></a>linux命令的一些题目</h3><h4 id="搜索文件系统中所有以包含-std字符串且以-h扩展名结尾的文件。"><a href="#搜索文件系统中所有以包含-std字符串且以-h扩展名结尾的文件。" class="headerlink" title="搜索文件系统中所有以包含 std字符串且以.h扩展名结尾的文件。"></a>搜索文件系统中所有以包含 <code>std</code>字符串且以<code>.h</code>扩展名结尾的文件。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -name &quot;*std*.h&quot;</span><br></pre></td></tr></table></figure>

<h4 id="请问下面这段-Shell-程序的作用是什么？"><a href="#请问下面这段-Shell-程序的作用是什么？" class="headerlink" title="请问下面这段 Shell 程序的作用是什么？"></a>请问下面这段 Shell 程序的作用是什么？</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkfifo pipe1</span><br><span class="line">mkfifo pipe2</span><br><span class="line">echo -n run | cat - pipe1 &gt; pipe2 &amp;</span><br><span class="line">cat &lt; pipe2 &gt; pipe1</span><br></pre></td></tr></table></figure>

<p>前 2 行代码创建了两个管道文件。</p>
<p>从第 3 行开始，代码变得复杂。<code>echo -n run</code>就是向输出流中写入一个<code>run</code>字符串（不带回车，所以用<code>-n</code>）。通过管道，将这个结果传递给了<code>cat</code>。<code>cat</code>是 concatenate 的缩写，意思是把文件粘在一起。</p>
<ul>
<li>当<code>cat</code>用<code>&gt;</code>重定向输出到一个管道文件时，如果没有其他进程从管道文件中读取内容，<code>cat</code>会阻塞。</li>
<li>当<code>cat</code>用<code>&lt;</code>读取一个管道内容时，如果管道中没有输入，也会阻塞。</li>
</ul>
<p>从这个角度来看，总共有 3 次重定向：</p>
<ul>
<li>将<code>-</code>也就是输入流的内容和<code>pipe1</code>内容合并重定向到<code>pipe2</code>；</li>
<li>将<code>pipe2</code>内容重定向到<code>cat</code>；</li>
<li>将<code>cat</code>的内容重定向到<code>pipe1</code>。</li>
</ul>
<p>仔细观察下路径：<code>pipe1</code>-&gt;<code>pipe2</code>-&gt;<code>pipe1</code>，构成了一个循环。 这样导致管道<code>pipe1</code>管道<code>pipe2</code>中总是有数据（没有数据的时间太短）。于是，就构成了一个无限循环。我们打开执行这个程序后，可以用<code>htop</code>查看当前的 CPU 使用情况，会发现 CPU 占用率很高。</p>
<h4 id="如果一个目录是只读权限，那么这个目录下面的文件还可写吗？"><a href="#如果一个目录是只读权限，那么这个目录下面的文件还可写吗？" class="headerlink" title="如果一个目录是只读权限，那么这个目录下面的文件还可写吗？"></a>如果一个目录是只读权限，那么这个目录下面的文件还可写吗？</h4><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161610.png" alt="image-20210625161610424"></p>
<p>你可以看到上图中，foo 目录不可读了，下面的<code>foo/bar</code>文件还可以写。 即便它不可写了，下面的<code>foo/bar</code>文件还是可以写。</p>
<p>但是想要创建新文件就会出现报错，因为创建新文件也需要改目录文件。这个例子说明 Linux 中的文件内容并没有存在目录中，目录中却有文件清单。</p>
<h4 id="如何查看正在-TIME-WAIT-状态的连接数量？"><a href="#如何查看正在-TIME-WAIT-状态的连接数量？" class="headerlink" title="如何查看正在 TIME_WAIT 状态的连接数量？"></a>如何查看正在 TIME_WAIT 状态的连接数量？</h4><p>注意，这里有个小坑，就是 netstat 会有两行表头，这两行可以用 tail 过滤掉，下面<code>tail -n +3</code>就是告诉你 tail 从第 3 行开始显示。<code>-a</code>代表显示所有的 socket。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | tail -n +3  | wc -l</span><br></pre></td></tr></table></figure>

<h4 id="如果你在编译安装-MySQL-时，发现找不到libcrypt-so-，应该如何处理？"><a href="#如果你在编译安装-MySQL-时，发现找不到libcrypt-so-，应该如何处理？" class="headerlink" title="如果你在编译安装 MySQL 时，发现找不到libcrypt.so ，应该如何处理？"></a>如果你在编译安装 MySQL 时，发现找不到libcrypt.so ，应该如何处理？</h4><p>遇到这类问题，首先应该去查资料。 比如查 StackOverflow，搜索关键词：libcrypt.so not found，或者带上自己的操作系统<code>ubuntu</code>。下图是关于 Stackoverflow 的一个解答：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161838.png" alt="image-20210625161837849"></p>
<h4 id="根据今天的-access-log-分析出有哪些终端访问了这个网站，并给出分组统计结果。"><a href="#根据今天的-access-log-分析出有哪些终端访问了这个网站，并给出分组统计结果。" class="headerlink" title="根据今天的 access_log 分析出有哪些终端访问了这个网站，并给出分组统计结果。"></a>根据今天的 access_log 分析出有哪些终端访问了这个网站，并给出分组统计结果。</h4><p><code>access_log</code>中有<code>Debian</code>和<code>Ubuntu</code>等等。我们可以利用下面的指令看到，第 12 列是终端，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161919.png" alt="image-20210625161919389"></p>
<p>我们还可以使用<code>sort</code>和<code>uniq</code>查看有哪些终端，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625161932.png" alt="image-20210625161932754"></p>
<p>最后需要写一个脚本，进行统计：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat nginx_logs.txt |\</span><br><span class="line">awk &apos;&#123;tms[$12]++;next&#125;END&#123;for (t in tms) print t, tms[t]&#125;&apos;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162004.png" alt="image-20210625162004295"></p>
<h4 id="根据-access-log-分析出访问量-Top-前三的网页。"><a href="#根据-access-log-分析出访问量-Top-前三的网页。" class="headerlink" title="根据 access_log 分析出访问量 Top 前三的网页。"></a>根据 access_log 分析出访问量 Top 前三的网页。</h4><p>如果不需要 Substring 等复杂的处理，也可以使用<code>sort</code>和<code>uniq</code>的组合。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162028.png" alt="image-20210625162027902"></p>
<h4 id="bashrc-bash-profile-profile-和-etc-profile-的区别是什么？"><a href="#bashrc-bash-profile-profile-和-etc-profile-的区别是什么？" class="headerlink" title="~/.bashrc ~/.bash_profile, ~/.profile 和 /etc/profile 的区别是什么？"></a>~/.bashrc ~/.bash_profile, ~/.profile 和 /etc/profile 的区别是什么？</h4><p>执行一个 shell 的时候分成<strong>login shell</strong>和<strong>non-login shell</strong>。顾名思义我们使用了<code>sudo``su</code>切换到某个用户身份执行 shell，也就是<code>login shell</code>。还有 ssh 远程执行指令也是 login shell，也就是伴随登录的意思——<code>login shell</code> 会触发很多文件执行，路径如下：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162217.png" alt="image-20210625162217545"></p>
<p>如果以当前用户身份正常执行一个 shell，比如说<code>./a.sh</code>，就是一个<code>non-login</code>的模式。 这时候不会触发上述的完整逻辑。</p>
<p>另外shell还有另一种分法，就是<code>interactive</code>和<code>non-interactive</code>。interactive 是交互式的意思，当用户打开一个终端命令行工具后，会进入一个输入命令得到结果的交互界面，这个时候，就是<code>interactive shell</code>。</p>
<p><code>baserc</code>文件通常只在<code>interactive</code>模式下才会执行，这是因为<code>~/.bashrc</code>文件中通常有这样的语句，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162350.png" alt="image-20210625162349945"></p>
<p>这个语句通过<code>$-</code>看到当前<code>shell</code>的执行环境，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162413.png" alt="image-20210625162413103"></p>
<p>带 i 字符的就是<code>interactive</code>，没有带i字符就不是。</p>
<p>因此， 如果你需要通过 ssh 远程 shell 执行一个文件，你就不是在 interactive 模式下，bashrc 不会触发。但是因为登录的原因，login shell 都会触发，也就是说 profile 文件依然会执行。</p>
<h3 id="Linux-内核和-Windows-内核有什么区别？"><a href="#Linux-内核和-Windows-内核有什么区别？" class="headerlink" title="Linux 内核和 Windows 内核有什么区别？"></a><strong>Linux 内核和 Windows 内核有什么区别？</strong></h3><p>Windows 和 Linux 是当今两款最主流的服务器操作系统产品，都拥有广泛的用户和信徒。Windows 通过强大的商业运作，驱动了大量优秀人才加盟到它的开发团队中；Linux 通过社区产品的魅力吸引着世界上大量的顶级程序员为它贡献源代码、解答问题。两者在服务器市场上竞争激烈，不分伯仲，但也存在互相扶持的关系。</p>
<p><strong>今天从一道面试题目“ Linux 内核和 Windows 内核有什么区别</strong>？”入手，去了解这两个操作系统内核的设计，帮助你学习操作系统中最核心的一个概念——内核，并希望这些知识可以伴随你日后的每个系统设计。</p>
<h4 id="什么是内核？"><a href="#什么是内核？" class="headerlink" title="什么是内核？"></a>什么是内核？</h4><p>说到操作系统，就必须说内核。内核是操作系统中应用连接硬件设备的桥梁。</p>
<h4 id="内核的能力"><a href="#内核的能力" class="headerlink" title="内核的能力"></a>内核的能力</h4><p>对于一个现代的操作系统来说，它的内核至少应该提供以下 4 种基本能力：</p>
<ul>
<li>管理进程、线程（决定哪个进程、线程使用 CPU）；</li>
<li>管理内存（决定内存用来做什么）；</li>
<li>连接硬件设备（为进程、和设备间提供通信能力）；</li>
<li>提供系统调用（接收进程发送来的系统调用）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162620.png" alt="image-20210625162620146"></p>
<h4 id="操作系统分层"><a href="#操作系统分层" class="headerlink" title="操作系统分层"></a>操作系统分层</h4><p>从上面 4 种能力来看操作系统和内核之间的关系，通常可以把操作系统分成 3 层，最底层的硬件设备抽象、中间的内核和最上层的应用。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162748.png" alt="image-20210625162748240"></p>
<h4 id="内核是如何工作的？"><a href="#内核是如何工作的？" class="headerlink" title="内核是如何工作的？"></a>内核是如何工作的？</h4><p><strong>为了帮助你理解什么是内核，请你先思考一个问题：进程和内核的关系，是不是像浏览器请求服务端服务</strong>？你可以先自己思考，然后在留言区写下你此时此刻对这个问题的认知，等学完“模块三”再反过头来回顾这个知识，相信你定会产生新的理解。</p>
<p>接下来，我们先一起分析一下这个问题。</p>
<p>内核权限非常高，它可以管理进程、可以直接访问所有的内存，因此确实需要和进程之间有一定的隔离。这个隔离用类似请求/响应的模型，非常符合常理。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625162857.png" alt="image-20210625162857681"></p>
<p>但不同的是在浏览器、服务端模型中，浏览器和服务端是用不同的机器在执行，因此不需要共享一个 CPU。但是在进程调用内核的过程中，这里是存在资源共享的。</p>
<ul>
<li>比如，一个机器有 4 个 CPU，不可能让内核用一个 CPU，其他进程用剩下的 CPU。这样太浪费资源了。</li>
<li>再比如，进程向内核请求 100M 的内存，内核把 100M 的数据传回去。 这个模型不可行，因为传输太慢了。</li>
</ul>
<p>所以，这里多数操作系统的设计都遵循一个原则：进程向内核发起一个请求，然后将 CPU 执行权限让出给内核。内核接手 CPU 执行权限，然后完成请求，再转让出 CPU 执行权限给调用进程。</p>
<h4 id="Linux-的设计"><a href="#Linux-的设计" class="headerlink" title="Linux 的设计"></a>Linux 的设计</h4><p>Linux 操作系统第一版是1991 年林纳斯托·瓦兹（一个芬兰的小伙子，当时 22 岁）用 C 语音写的。 写完之后他在网络上发布了 Linux 内核的源代码。又经过了 3 年的努力，在 1994 年发布了完整的核心 Version 1.0。</p>
<p>说到 Linux 内核设计，这里有很多有意思的名词。大多数听起来复杂、专业，但是理解起来其实很简单。接下来我们一一讨论。</p>
<ul>
<li><strong>Multitask and SMP（Symmetric multiprocessing）</strong></li>
</ul>
<p><strong>MultiTask 指多任务</strong>，Linux 是一个多任务的操作系统。多任务就是多个任务可以同时执行，这里的“同时”并不是要求并发，而是在一段时间内可以执行多个任务。当然 Linux 支持并发。</p>
<p><strong>SMP 指对称多处理</strong>。其实是说 Linux 下每个处理器的地位是相等的，内存对多个处理器来说是共享的，每个处理器都可以访问完整的内存和硬件资源。 这个特点决定了在 Linux 上不会存在一个特定的处理器处理用户程序或者内核程序，它们可以被分配到任何一个处理器上执行。</p>
<ul>
<li><strong>ELF（Executable and Linkable Format）</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163156.png" alt="image-20210625163156664"></p>
<p>这个名词翻译过来叫作可执行文件链接格式。这是一种从 Unix 继承而来的可执行文件的存储格式。我们可以看到 ELF 中把文件分成了一个个分段（Segment），每个段都有自己的作用。如果想要深入了解这块知识，会涉及部分编译原理的知识，如果你感兴趣可以去网上多查些资料或者去留言区我们一起讨论。</p>
<ul>
<li><strong>Monolithic Kernel</strong></li>
</ul>
<p>这个名词翻译过来就是宏内核，宏内核反义词就是 Microkernel ，微内核的意思。Linux 是宏内核架构，这说明 Linux 的内核是一个完整的可执行程序，且内核用最高权限来运行。宏内核的特点就是有很多程序会打包在内核中，比如，文件系统、驱动、内存管理等。当然这并不是说，每次安装驱动都需要重新编译内核，现在 Linux 也可以动态加载内核模块。所以哪些模块在内核层，哪些模块在用户层，这是一种系统层的拆分，并不是很强的物理隔离。</p>
<p>与宏内核对应，接下来说说<strong>微内核，内核只保留最基本的能力。比如进程调度、虚拟内存、中断。多数应用，甚至包括驱动程序、文件系统，是在用户空间管理的</strong>。</p>
<p>与宏内核对应，接下来说说<strong>微内核，内核只保留最基本的能力。比如进程调度、虚拟内存、中断。多数应用，甚至包括驱动程序、文件系统，是在用户空间管理的</strong>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163419.png" alt="image-20210625163418940"></p>
<p>学到这里，你可能会问：在内核层和在用户层有什么区别吗？</p>
<p>感觉分层其实差不多。 我这里说一个很大的区别，比如说驱动程序是需要频繁调用底层能力的，如果在内核中，性能肯定会好很多。对于微内核设计，驱动在内核外，驱动和硬件设备交互就需要频繁做内核态的切换。</p>
<p>当然微内核也有它的好处，比如说微内核体积更小、可移植性更强。不过我认为，随着计算能力、存储技术越来越发达，体积小、安装快已经不能算是一个很大的优势了。现在更重要的是如何有效利用硬件设备的性能。</p>
<p>之所以这么思考，也可能因为我是带着现代的目光回望当时人们对内核的评判，事实上，当时 Linux 团队也因此争论过很长一段时间。 但是我觉得历史往往是螺旋上升的，说不定将来性能发展到了一个新的阶段，像微内核的灵活性、可以提供强大的抽象能力这样的特点，又重新受到人们的重视。</p>
<p>还有一种就是混合类型内核。 混合类型的特点就是架构像微内核，内核中会有一个最小版本的内核，其他功能会在这个能力上搭建。但是实现的时候，是用宏内核的方式实现的，就是内核被做成了一个完整的程序，大部分功能都包含在内核中。就是在宏内核之内有抽象出了一个微内核。</p>
<p>上面我们大体介绍了内核几个重要的特性，有关进程、内存、虚拟化等特性，我们会在后面几个模块中逐步讨论。</p>
<h4 id="Window-设计"><a href="#Window-设计" class="headerlink" title="Window 设计"></a>Window 设计</h4><p>接下来我们说说 Windows 的设计，Windows 和 Linux 的设计有很大程度的相似性。Windows也有内核，它的内核是 C/C++ 写的。准确地说，Windows 有两个内核版本。一个是早期的Windows 9x 内核，早期的 Win95, Win98 都是这个内核。我们今天用的 Windows 7, Windows 10 是另一个内核，叫作 Windows NT。NT 指的是 New Technology。接下来我们讨论的都是 NT 版本的内核。</p>
<p>下面我找到一张 Windows 内核架构的图片给你一个直观感受。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163747.png" alt="image-20210625163747124"></p>
<p>Windows 同样支持 Multitask 和 SMP（对称多处理）。Windows 的内核设计属于混合类型。你可以看到内核中有一个 Microkernel 模块。而整个内核实现又像宏内核一样，含有的能力非常多，是一个完整的整体。</p>
<p>Windows 下也有自己的可执行文件格式，这个格式叫作 Portable Executable（PE），也就是可移植执行文件，扩展名通常是<code>.exe</code>、<code>.dll</code>、<code>.sys</code>等。</p>
<p>PE 文件的结构和 ELF 结构有很多相通的地方，我找到了一张图片帮助你更直观地理解。 因为这部分知识涉及编译原理，我这里就不详细介绍了</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625163858.png" alt="image-20210625163858613"></p>
<p>Windows 还有很多独特的能力，比如 Hyper-V 虚拟化技术，有关虚拟化技术我们将在“模块八：虚拟化和其他”中详细讲解。</p>
<h4 id="Linux-内核和-Windows-内核有什么区别？-1"><a href="#Linux-内核和-Windows-内核有什么区别？-1" class="headerlink" title="Linux 内核和 Windows 内核有什么区别？"></a><strong>Linux 内核和 Windows 内核有什么区别？</strong></h4><p>Windows 有两个内核，最新的是 NT 内核，目前主流的 Windows 产品都是 NT 内核。NT 内核和 Linux 内核非常相似，没有太大的结构化差异。</p>
<p>从整体设计上来看，Linux 是宏内核，NT 内核属于混合型内核。和微内核不同，宏内核和混合类型内核从实现上来看是一个完整的程序。只不过混合类型内核内部也抽象出了微内核的概念，从内核内部看混合型内核的架构更像微内核。</p>
<p>另外 NT 内核和 Linux 内核还存在着许多其他的差异，比如：</p>
<ul>
<li>Linux 内核是一个开源的内核；</li>
<li>它们支持的可执行文件格式不同；</li>
<li>它们用到的虚拟化技术不同。</li>
</ul>
<h3 id="用户态线程和内核态线程"><a href="#用户态线程和内核态线程" class="headerlink" title="用户态线程和内核态线程"></a><strong>用户态线程和内核态线程</strong></h3><h4 id="什么是用户态和内核态"><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h4><p>Kernel 运行在超级权限模式（Supervisor Mode）下，所以拥有很高的权限。按照权限管理的原则，多数应用程序应该运行在最小权限下。因此，很多操作系统，将内存分成了两个区域：</p>
<ul>
<li>内核空间（Kernal Space），这个空间只有内核程序可以访问；</li>
<li>用户空间（User Space），这部分内存专门给应用程序使用。</li>
</ul>
<h4 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h4><p>用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在<strong>用户态（User Mode）</strong> 执行。内核空间中的代码可以访问所有内存，我们称这些程序在<strong>内核态（Kernal Mode）</strong> 执行。</p>
<h4 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h4><p>如果用户态程序需要执行系统调用，就需要切换到内核态执行。下面我们来讲讲这个过程的原理。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625164318.png" alt="image-20210625164318025"></p>
<p>如上图所示：内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。当发生系统调用时，用户态的程序发起系统调用。因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。</p>
<p>发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。关于中断，后续会补充。</p>
<p>上面我们学习了用户态和内核态，接下来我们从进程和线程的角度进一步思考本课时开头抛出的问题。</p>
<h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>一个应用程序启动后会在内存中创建一个执行副本，这就是<strong>进程</strong>。Linux 的内核是一个 Monolithic Kernel（宏内核），因此可以看作一个进程。也就是开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625164501.png" alt="image-20210625164501467"></p>
<p>进程可以分成用户态进程和内核态进程两类。用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。</p>
<p><strong>那么用户态进程如果要执行程序，是否也要向内核申请呢</strong>？</p>
<p>程序在现代操作系统中并不是以进程为单位在执行，而是以一种轻量级进程（Light Weighted Process），也称作线程（Thread）的形式执行。</p>
<p>如果进程想要创造更多的线程，就需要思考一件事情，这个线程创建在用户态还是内核态。</p>
<p>你可能会问，难道不是用户态的进程创建用户态的线程，内核态的进程创建内核态的线程吗？</p>
<p>其实不是，进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程，接下来我们说说用户态的线程和内核态的线程。</p>
<h4 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h4><p>用户态线程也称作用户级线程（User Level Thread）。操作系统内核并不知道它的存在，它完全是在用户空间中创建。</p>
<p>用户级线程有很多优势，比如。</p>
<ul>
<li><strong>管理开销小</strong>：创建、销毁不需要系统调用。</li>
<li><strong>切换成本低</strong>：用户空间程序可以自己维护，不需要走操作系统调度。</li>
</ul>
<p>但是这种线程也有很多的缺点。</p>
<ul>
<li><strong>与内核协作成本高</strong>：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。</li>
<li><strong>线程间协作成本高</strong>：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要支付额外的系统调用成本。</li>
<li><strong>无法利用多核优势</strong>：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。</li>
<li><strong>操作系统无法针对线程调度进行优化</strong>：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。</li>
</ul>
<h4 id="内核态线程"><a href="#内核态线程" class="headerlink" title="内核态线程"></a>内核态线程</h4><p>内核态线程也称作内核级线程（Kernel Level Thread）。这种线程执行在内核态，可以通过系统调用创造一个内核级线程。</p>
<p>内核级线程有很多优势。</p>
<ul>
<li><strong>可以利用多核 CPU 优势</strong>：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。</li>
<li><strong>操作系统级优化</strong>：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。</li>
</ul>
<p>当然内核线程也有一些缺点。</p>
<ul>
<li><strong>创建成本高</strong>：创建的时候需要系统调用，也就是切换到内核态。</li>
<li><strong>扩展性差</strong>：由一个内核程序管理，不可能数量太多。</li>
<li><strong>切换成本较高</strong>：切换的时候，也同样存在需要内核操作，需要切换内核态。</li>
</ul>
<h4 id="用户态线程和内核态线程之间的映射关系"><a href="#用户态线程和内核态线程之间的映射关系" class="headerlink" title="用户态线程和内核态线程之间的映射关系"></a>用户态线程和内核态线程之间的映射关系</h4><p>线程简单理解，就是要执行一段程序。程序不会自发的执行，需要操作系统进行调度。<strong>我们思考这样一个问题，如果有一个用户态的进程，它下面有多个线程。如果这个进程想要执行下面的某一个线程，应该如何做呢</strong>？</p>
<p>这时，比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。毕竟，内核线程是真正的线程。因为它会分配到 CPU 的执行资源。</p>
<p>如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。</p>
<p>这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。</p>
<p>由此可见，<strong>用户态线程创建成本低，问题明显，不可以利用多核。内核态线程，创建成本高，可以利用多核，切换速度慢</strong>。因此通常我们会在内核中预先创建一些线程，并反复利用这些线程。这样，用户态线程和内核态线程之间就构成了下面 4 种可能的关系：</p>
<h4 id="多对一（Many-to-One）"><a href="#多对一（Many-to-One）" class="headerlink" title="多对一（Many to One）"></a>多对一（Many to One）</h4><p>用户态进程中的多线程复用一个内核态线程。这样，极大地减少了创建内核态线程的成本，但是线程不可以并发。因此，这种模型现在基本上用的很少。我再多说一句，这里你可能会有疑问，比如：用户态线程怎么用内核态线程执行程序？</p>
<p>程序是存储在内存中的指令，用户态线程是可以准备好程序让内核态线程执行的。后面的几种方式也是利用这样的方法。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170256.png" alt="image-20210625170256011"></p>
<h4 id="一对一（One-to-One）"><a href="#一对一（One-to-One）" class="headerlink" title="一对一（One to One）"></a>一对一（One to One）</h4><p>该模型为每个用户态的线程分配一个单独的内核态线程，在这种情况下，每个用户态都需要通过系统调用创建一个绑定的内核线程，并附加在上面执行。 这种模型允许所有线程并发执行，能够充分利用多核优势，Windows NT 内核采取的就是这种模型。但是因为线程较多，对内核调度的压力会明显增加。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170318.png" alt="image-20210625170318451"></p>
<h4 id="多对多（Many-To-Many）"><a href="#多对多（Many-To-Many）" class="headerlink" title="多对多（Many To Many）"></a>多对多（Many To Many）</h4><p>这种模式下会为 n 个用户态线程分配 m 个内核态线程。m 通常可以小于 n。一种可行的策略是将 m 设置为核数。这种多对多的关系，减少了内核线程，同时也保证了多核心并发。Linux 目前采用的就是该模型。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170357.png" alt="image-20210625170357628"></p>
<h4 id="两层设计（Two-Level）"><a href="#两层设计（Two-Level）" class="headerlink" title="两层设计（Two Level）"></a>两层设计（Two Level）</h4><p>这种模型混合了多对多和一对一的特点。多数用户态线程和内核线程是 n 对 m 的关系，少量用户线程可以指定成 1 对 1 的关系。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625170428.png" alt="image-20210625170428222"></p>
<p>上图所展现的是一个非常经典的设计。</p>
<p>我们这节课讲解的问题、考虑到的情况以及解决方法，将为你今后解决实际工作场景中的问题打下坚实的基础。比如处理并发问题、I/O 性能瓶颈、思考数据库连接池的配置等，要想完美地解决问题，就必须掌握这些模型，了解问题的本质上才能更好地思考问题衍生出来的问题。</p>
<h4 id="用户态线程和内核态线程的区别？"><a href="#用户态线程和内核态线程的区别？" class="headerlink" title="用户态线程和内核态线程的区别？"></a><strong>用户态线程和内核态线程的区别？</strong></h4><p>用户态线程工作在用户空间，内核态线程工作在内核空间。用户态线程调度完全由进程负责，通常就是由进程的主线程负责。相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。内核线程由内核维护，由操作系统调度。</p>
<p>用户态线程无法跨核心，一个进程的多个用户态线程不能并发，阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限。这些都是用户态线程的劣势。内核线程可以独立执行，操作系统会分配时间片段。因此内核态线程更完整，也称作轻量级进程。内核态线程创建成本高，切换成本高，创建太多还会给调度算法增加压力，因此不会太多。</p>
<p>实际操作中，往往结合两者优势，将用户态线程附着在内核态线程中执行。</p>
<h3 id="中断和中断向量"><a href="#中断和中断向量" class="headerlink" title="中断和中断向量"></a><strong>中断和中断向量</strong></h3><h4 id="如何设计响应键盘的整个链路？"><a href="#如何设计响应键盘的整个链路？" class="headerlink" title="如何设计响应键盘的整个链路？"></a>如何设计响应键盘的整个链路？</h4><p>当你拿到一个问题时，需要冷静下来思考和探索解决方案。你可以查资料、看视频或者咨询专家，但是在这之前，你先要进行一定的思考和梳理，有的问题可以直接找到答案，有的问题却需要继续深挖寻找其背后的理论支撑。</p>
<p><strong>问题 1：我们的目标是什么?</strong></p>
<p>我们的目标是在 Java/JS 中实现按键响应程序。这种实现有点像 Switch-Case 语句——根据不同的按键执行不同的程序，比如按下回车键可以换行，按下左右键可以移动光标。</p>
<p><strong>问题 2：按键怎么抽象？</strong></p>
<p>键盘上一般不超过 100 个键。因此我们可以考虑用一个 Byte 的数据来描述用户按下了什么键。按键有两个操作，一个是按下、一个是释放，这是两个不同的操作。对于一个 8 位的字节，可以考虑用最高位的 1 来描述按下还是释放的状态，然后后面的 7 位（0~127）描述具体按了哪个键。这样我们只要确定了用户按键/释放的顺序，对我们的系统来说，就不会有歧义。</p>
<p><strong>问题 3：如何处理按键？使用操作系统处理还是让每个程序自己实现？</strong></p>
<p>处理按键是一个通用程序，可以考虑由操作系统先进行一部分处理，比如：</p>
<ul>
<li>用户按下了回车键，先由操作系统进行统一的封装，再把按键的编码转换为字符串<code>Enter</code>方便各种程序使用。</li>
<li>处理组合键这种操作，由操作系统先一步进行计算比较好。因为底层只知道按键、释放，组合键必须结合时间因素判断。</li>
</ul>
<p>你可以把下面这种情况看作是一个<code>Ctrl + C</code>组合键，这种行为可以由操作系统进行统一处理，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">按下 Ctrl</span><br><span class="line">按下 C</span><br><span class="line">释放 Ctrl</span><br><span class="line">释放 C</span><br></pre></td></tr></table></figure>

<p><strong>问题 4：程序用什么模型响应按键？</strong></p>
<p>当一个 Java 或者 JS 写的应用程序想要响应按键时，应该考虑消息模型。因为如果程序不停地扫描按键，会给整个系统带来很大的负担。比如程序写一个<code>while</code>循环去扫描有没有按键，开销会很大。 如果程序在操作系统端注册一个响应按键的函数，每次只有真的触发按键时才执行这个函数，这样就能减少开销了。</p>
<p><strong>问题 5：处理用户按键，需不需要打断正在执行的程序？</strong></p>
<p>从用户体验上讲，按键应该是一个高优先级的操作，比如用户按 Ctrl+C 或者 Esc 的时候，可能是因为用户想要打断当前执行的程序。即便是用户只想要输入，也应该尽可能地集中资源给到用户，因为我们不希望用户感觉到延迟。</p>
<p>如果需要考虑到程序随时会被中断，去响应其他更高优先级的情况，那么从程序执行的底层就应该支持这个行为，而且最好从硬件层面去支持，这样速度最快。 这就引出了本课时的主角——中断。具体如何处理，见下面我们关于中断部分的分析。</p>
<p><strong>问题 6：操作系统如何知道用户按了哪个键？</strong></p>
<p>这里有一个和问题 5 类似的问题。操作系统是不断主动触发读取键盘按键，还是每次键盘按键到来的时候都触发一段属于操作系统的程序呢？</p>
<p>显然，后者更节省效率。</p>
<p>那么谁能随时随地中断操作系统的程序？ 谁有这个权限？是管理员账号吗？ 当然不是，拥有这么高权限的应该是机器本身。</p>
<p>我们思考下这个模型，用户每次按键，触发一个 CPU 的能力，这个能力会中断正在执行的程序，去处理按键。那 CPU 内部是不是应该有处理按键的程序呢？这肯定不行，因为我们希望 CPU 就是用来做计算的，如果 CPU 内部有自带的程序，会把问题复杂化。这在软件设计中，叫作耦合。CPU 的工作就是专注高效的执行指令。</p>
<p>因此，每次按键，必须有一个机制通知 CPU。我们可以考虑用总线去通知 CPU，也就是主板在通知 CPU。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625171945.png" alt="image-20210625171945006"></p>
<p>那么 CPU 接收到通知后，如何通知操作系统呢？CPU 只能中断正在执行的程序，然后切换到另一个需要执行的程序。说白了就是改变 PC 指针，CPU 只有这一种办法切换执行的程序。这里请你思考，是不是只有这一种方法：CPU 中断当前执行的程序，然后去执行另一个程序，才能改变 PC 指针？</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625172114.png" alt="image-20210625172114377"></p>
<p>接下来我们进一步思考，CPU 怎么知道 PC 指针应该设置为多少呢？是不是 CPU 知道操作系统响应按键的程序位置呢？</p>
<p>答案当然是不知道。</p>
<p>因此，我们只能控制 CPU 跳转到一个固定的位置。比如说 CPU 一收到主板的信息（某个按键被触发），CPU 就马上中断当前执行的程序，将 PC 指针设置为 0。也就是 PC 指针下一步会从内存地址 0 中读取下一条指令。当然这只是我们的一个思路，具体还需要进一步考虑。而操作系统要做的就是在这之前往内存地址 0 中写一条指令，比如说让 PC 指针跳转到自己处理按键程序的位置。</p>
<p>讲到这里，我们总结一下，CPU 要做的就是一看到中断，就改变 PC 指针（相当于中断正在执行的程序），而 PC 改变成多少，可以根据不同的类型来判断，比如按键就到 0。操作系统就要向这些具体的位置写入指令，当中断发生时，接管程序的控制权，也就是让 PC 指针指向操作系统处理按键的程序。</p>
<p>上面这个模型和实际情况还有出入，但是我们已经开始逐渐完善了。</p>
<p><strong>问题 7：主板如何知道键盘被按下?</strong></p>
<p>经过一层一层地深挖“如何设计响应键盘的整个链路？”这个问题，目前操作系统已经能接管按键，接下来，我们还需要思考主板如何知道有按键，并且通知 CPU。</p>
<p>你可以把键盘按键看作按下了某个开关，我们需要一个芯片将按键信息转换成具体按键的值。比如用户按下 A 键，A 键在第几行、第几列，可以看作一个电学信号。接着我们需要芯片把这个电学信号转化为具体的一个数字（一个 Byte）。转化完成后，主板就可以接收到这个数字（按键码），然后将数字写入自己的一个寄存器中，并通知 CPU。</p>
<p>为了方便 CPU 计算，CPU 接收到主板通知后，按键码会被存到一个寄存器里，这样方便处理按键的程序执行。</p>
<p>通过对以上 7 个问题的思考和分析，我们已经有了一个粗浅的设计，接下来就要开始整理思路了。</p>
<h4 id="思路的整理：中断的设计"><a href="#思路的整理：中断的设计" class="headerlink" title="思路的整理：中断的设计"></a>思路的整理：中断的设计</h4><p>整体设计分成了 3 层，第一层是硬件设计、第二层是操作系统设计、第三层是程序语言的设计。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625172558.png" alt="image-20210625172558167"></p>
<p>按键码的收集，是键盘芯片和主板的能力。主板知道有新的按键后，通知 CPU，CPU 要中断当前执行的程序，将 PC 指针跳转到一个固定的位置，我们称为一次<strong>中断</strong>（<strong>interrupt</strong>）。</p>
<p>考虑到系统中会出现各种各样的事件，我们需要根据中断类型来判断PC 指针跳转的位置，中断类型不同，PC 指针跳转的位置也可能会不同。比如按键程序、打印机就绪程序、系统异常等都需要中断，包括在“<strong>14 课时</strong>”我们学习的系统调用，也需要中断正在执行的程序，切换到内核态执行内核程序。</p>
<p>考虑到系统中会出现各种各样的事件，我们需要根据中断类型来判断PC 指针跳转的位置，中断类型不同，PC 指针跳转的位置也可能会不同。比如按键程序、打印机就绪程序、系统异常等都需要中断.</p>
<p>因此我们需要把不同的中断类型进行分类，这个类型叫作<strong>中断识别码</strong>。比如按键，我们可以考虑用编号 16，数字 16 就是按键中断类型的识别码。不同类型的中断发生时，CPU 需要知道 PC 指针该跳转到哪个地址，这个地址，称为<strong>中断向量（Interupt Vector）。</strong></p>
<p>你可以考虑这样的实现：当编号 16 的中断发生时，32 位机器的 PC 指针直接跳转到内存地址 16*4 的内存位置。如果设计最多有 255 个中断，编号就是从 0~255，刚好需要 1K 的内存地址存储中断向量——这个 1K 的空间，称为<strong>中断向量表</strong>。</p>
<p>因此 CPU 接收到中断后，CPU 根据中断类型操作 PC 指针，找到中断向量。操作系统必须在这之前，修改中断向量，插入一条指令。比如操作系统在这里写一条<code>Jump</code>指令，将 PC 指针再次跳转到自己处理对应中断类型的程序。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625172807.png" alt="image-20210625172807759"></p>
<p>操作系统接管之后，以按键程序为例，操作系统会进行一些处理，包括下面的几件事情：</p>
<ol>
<li>将按键放入一个队列，保存下来。这是因为，操作系统不能保证及时处理所有的按键，比如当按键过快时，需要先存储下来，再分时慢慢处理。</li>
<li>计算组合键。可以利用按下、释放之间的时间关系。</li>
<li>经过一定计算将按键抽象成消息（事件结构或对象）。</li>
<li>提供 API 给应用程序，让应用程序可以监听操作系统处理后的消息。</li>
<li>分发按键消息给监听按键的程序。</li>
</ol>
<p>所以程序在语言层面，比如像 Java/Node.js 这种拥有虚拟机的语言，只需要对接操作系统 API 就可以了。</p>
<h4 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h4><p>接下来我们一起讨论下中断的分类方法：</p>
<ul>
<li>按照中断的触发方分成<strong>同步中断和异步中断</strong>；</li>
<li>根据中断是否强制触发分成<strong>可屏蔽中断和不可屏蔽中断</strong>。</li>
</ul>
<p>中断可以由 CPU 指令直接触发，这种主动触发的中断，叫作<strong>同步中断</strong>。同步中断有几种情况。</p>
<ul>
<li>之前我们学习的系统调用，需要从用户态切换内核态，这种情况需要程序触发一个中断，叫作<strong>陷阱</strong>（Trap），中断触发后需要继续执行系统调用。</li>
<li>还有一种同步中断情况是错误（Fault），通常是因为检测到某种错误，需要触发一个中断，中断响应结束后，会重新执行触发错误的地方，比如后面我们要学习的缺页中断。</li>
<li>最后还有一种情况是程序的异常，这种情况和 Trap 类似，用于实现程序抛出的异常。</li>
</ul>
<p>另一部分中断不是由 CPU 直接触发，是因为需要响应外部的通知，比如响应键盘、鼠标等设备而触发的中断。这种中断我们称为<strong>异步中断</strong>。</p>
<p>CPU 通常都支持设置一个中断屏蔽位（一个寄存器），设置为 1 之后 CPU 暂时就不再响应中断。对于键盘鼠标输入，比如陷阱、错误、异常等情况，会被临时屏蔽。但是对于一些特别重要的中断，比如 CPU 故障导致的掉电中断，还是会正常触发。可以被屏蔽的中断我们称为<strong>可屏蔽中断，多数中断都是可屏蔽中断</strong>。</p>
<p>所以这里我们讲了两种分类方法，一种是同步中断和异步中断。另一种是可屏蔽中断和不可屏蔽中断。</p>
<h4 id="Java-Js-等语言为什么可以捕获到键盘输入？"><a href="#Java-Js-等语言为什么可以捕获到键盘输入？" class="headerlink" title="Java/Js 等语言为什么可以捕获到键盘输入？"></a><strong>Java/Js 等语言为什么可以捕获到键盘输入？</strong></h4><p>为了捕获到键盘输入，硬件层面需要把按键抽象成中断，中断 CPU 执行。CPU 根据中断类型找到对应的中断向量。操作系统预置了中断向量，因此发生中断后操作系统接管了程序。操作系统实现了基本解析按键的算法，将按键抽象成键盘事件，并且提供了队列存储多个按键，还提供了监听按键的 API。因此应用程序，比如 Java/Node.js 虚拟机，就可以通过调用操作系统的 API 使用键盘事件。</p>
<p><strong>Unix 和 Mac OS 内核属于哪种类型？</strong></p>
<p>Unix 和 Linux 非常类似，也是宏内核。Mac OS 用的是 XNU 内核， XNU 是一种混合型内核。为了帮助你理解，我找了一张 Mac OS 的内核架构图。 如下图所示，可以看到内部是一个叫作 XNU 的宏内核。XNU 是 X is not Unix 的意思， 是一个受 Unix 影响很大的内核。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625184430.png" alt="image-20210625184430161"></p>
<p><strong>JVM 的线程是用户态线程还是内核态线程？</strong></p>
<p>JVM 自己本身有一个线程模型。在 JDK 1.1 的时候，JVM 自己管理用户级线程。这样做缺点非常明显，操作系统只调度内核级线程，用户级线程相当于基于操作系统分配到进程主线程的时间片，再次拆分，因此无法利用多核特性。</p>
<p>为了解决这个问题，后来 Java 改用线程映射模型，因此，需要操作系统支持。在 Windows 上是 1 对 1 的模型，在 Linux 上是 n 对 m 的模型。顺便说一句，Linux 的PThreadAPI 创建的是用户级线程，如果 Linux 要创建内核级线程有KThreadAPI。映射关系是操作系统自动完成的，用户不需要管。</p>
<p><strong>操作系统可以处理键盘按键，这很好理解，但是在开机的时候系统还没有载入内存，为什么可以使用键盘呢？这个怎么解释？</strong></p>
<p>主板的一块 ROM 上往往还有一个简化版的操作系统，叫 BIOS（Basic Input/Ouput System）。在 OS 还没有接管计算机前，先由 BIOS 管理机器，并协助加载 OS 到内存。早期的 OS 还会利用 BIOS 的能力，现代的 OS 接管后，就会替换掉 BIOS 的中断向量。</p>
<p><strong>林纳斯 21 岁写出 Linux，那么开发一个操作系统的难度到底大不大？</strong></p>
<p>毫无疑问能在 21 岁就写出 Linux 的人定是天赋异禀，林纳斯是参照一个 Minix 系统写的 Linux 内核。如果你对此感兴趣，可以参考这个 1991 年的源代码。</p>
<p>写一个操作系统本身并不是非常困难。需要了解一些基础的数据结构与算法，硬件设备工作原理。关键是要有参照，比如核心部分可以参考前人的内核。</p>
<p>但是随着硬件、软件技术发展了这么多年，如果想再写一个大家能够接受的内核，是一件非常困难的事情。内核的能力在上升，硬件的种类在上升，所以 Android 和很多后来的操作系统都是拿 Linux 改装。</p>
<h3 id="进程和线程-1"><a href="#进程和线程-1" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程（Process），顾名思义就是正在执行的应用程序，是软件的执行副本。而线程是轻量级的进程。</p>
<p>进程是分配资源的基础单位。而线程很长一段时间被称作轻量级进程（Light Weighted Process），是程序执行的基本单位。</p>
<p>在计算机刚刚诞生的年代，程序员拿着一个写好程序的闪存卡，插到机器里，然后电能推动芯片计算，芯片每次从闪存卡中读出一条指令，执行后接着读取下一条指令。闪存中的所有指令执行结束后，计算机就关机。</p>
<p>一开始，这种单任务的模型，在那个时代叫作作业（Job），当时计算机的设计就是希望可以多处理作业。图形界面出现后，人们开始利用计算机进行办公、购物、聊天、打游戏等，因此一台机器正在执行的程序会被随时切来切去。于是人们想到，设计进程和线程来解决这个问题。</p>
<p>每一种应用，比如游戏，执行后是一个进程。但是游戏内部需要图形渲染、需要网络、需要响应用户操作，这些行为不可以互相阻塞，必须同时进行，这样就设计成线程。</p>
<h4 id="资源分配问题"><a href="#资源分配问题" class="headerlink" title="资源分配问题"></a>资源分配问题</h4><p>设计进程和线程，操作系统需要思考分配资源。最重要的 3 种资源是：计算资源（CPU）、内存资源和文件资源。早期的 OS 设计中没有线程，3 种资源都分配给进程，多个进程通过分时技术交替执行，进程之间通过管道技术等进行通信。</p>
<p>但是这样做的话，设计者们发现用户（程序员），一个应用往往需要开多个进程，因为应用总是有很多必须要并行做的事情。并行并不是说绝对的同时，而是说需要让这些事情看上去是同时进行的——比如图形渲染和响应用户输入。于是设计者们想到了，进程下面，需要一种程序的执行单位，仅仅被分配 CPU 资源，这就是线程。</p>
<h4 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h4><p>线程设计出来后，因为只被分配了计算资源（CPU），因此被称为轻量级进程。被分配的方式，就是由操作系统调度线程。操作系统创建一个进程后，进程的入口程序被分配到了一个主线程执行，这样看上去操作系统是在调度进程，其实是调度进程中的线程。</p>
<p>这种被操作系统直接调度的线程，我们也成为内核级线程。另外，有的程序语言或者应用，用户（程序员）自己还实现了线程。相当于操作系统调度主线程，主线程的程序用算法实现子线程，这种情况我们称为用户级线程。Linux 的 PThread API 就是用户级线程，KThread API 则是内核级线程。</p>
<h4 id="分时和调度"><a href="#分时和调度" class="headerlink" title="分时和调度"></a>分时和调度</h4><p>因为通常机器中 CPU 核心数量少（从几个到几十个）、进程&amp;线程数量很多（从几十到几百甚至更多），你可以类比为发动机少，而机器多，因此进程们在操作系统中只能排着队一个个执行。每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。再强调一下，现代操作系统都是直接调度线程，不会调度进程。</p>
<h4 id="分配时间片段"><a href="#分配时间片段" class="headerlink" title="分配时间片段"></a>分配时间片段</h4><p>如下图所示，进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始。这个就是分时技术。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231718.png" alt="image-20210625231711276"></p>
<p>下面这张图更加直观一些，进程 P1 先执行一个时间片段，然后进程 P2 开始执行一个时间片段， 然后进程 P3，然后进程 P4……</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231734.png" alt="image-20210625231734470"></p>
<p>注意，上面的两张图是以进程为单位演示，如果换成线程，操作系统依旧是这么处理。</p>
<h4 id="进程和线程的状态"><a href="#进程和线程的状态" class="headerlink" title="进程和线程的状态"></a>进程和线程的状态</h4><p>一个进程（线程）运行的过程，会经历以下 3 个状态：</p>
<p>进程（线程）创建后，就开始排队，此时它会处在“就绪”（Ready）状态；</p>
<p>当轮到该进程（线程）执行时，会变成“运行”（Running）状态；</p>
<p>当一个进程（线程）将操作系统分配的时间片段用完后，会回到“就绪”（Ready）状态。</p>
<p>我这里一直用进程(线程）是因为旧的操作系统调度进程，没有线程；现代操作系统调度线程。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231804.png" alt="image-20210625231804573"></p>
<p>有时候一个进程（线程）会等待磁盘读取数据，或者等待打印机响应，此时进程自己会进入“阻塞”（Block）状态。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231821.png" alt="image-20210625231821657"></p>
<p>因为这时计算机的响应不能马上给出来，而是需要等待磁盘、打印机处理完成后，通过中断通知 CPU，然后 CPU 再执行一小段中断控制程序，将控制权转给操作系统，操作系统再将原来阻塞的进程（线程）置为“就绪”（Ready）状态重新排队。</p>
<p>而且，一旦一个进程（线程）进入阻塞状态，这个进程（线程）此时就没有事情做了，但又不能让它重新排队（因为需要等待中断），所以进程（线程）中需要增加一个“阻塞”（Block）状态。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231849.png" alt="image-20210625231849282"></p>
<p>注意，因为一个处于“就绪”（Ready）的进程（线程）还在排队，所以进程（线程）内的程序无法执行，也就是不会触发读取磁盘数据的操作，这时，“就绪”（Ready）状态无法变成阻塞的状态，因此下图中没有从就绪到阻塞的箭头。</p>
<p>而处于“阻塞”（Block）状态的进程（线程）如果收到磁盘读取完的数据，它又需要重新排队，所以它也不能直接回到“运行”（Running）状态，因此下图中没有从阻塞态到运行态的箭头。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625231932.png" alt="image-20210625231932849"></p>
<h4 id="进程和线程的设计"><a href="#进程和线程的设计" class="headerlink" title="进程和线程的设计"></a>进程和线程的设计</h4><p>接下来我们思考几个核心的设计约束：</p>
<p>进程和线程在内存中如何表示？需要哪些字段？</p>
<p>进程代表的是一个个应用，需要彼此隔离，这个隔离方案如何设计？</p>
<p>操作系统调度线程，线程间不断切换，这种情况如何实现？</p>
<p>需要支持多 CPU 核心的环境，针对这种情况如何设计？</p>
<p>接下来我们来讨论下这4个问题。</p>
<h4 id="进程和线程的表示"><a href="#进程和线程的表示" class="headerlink" title="进程和线程的表示"></a>进程和线程的表示</h4><p>可以这样设计，在内存中设计两张表，一张是进程表、一张是线程表。</p>
<p>进程表记录进程在内存中的存放位置、PID 是多少、当前是什么状态、内存分配了多大、属于哪个用户等，这就有了进程表。如果没有这张表，进程就会丢失，操作系统不知道自己有哪些进程。这张表可以考虑直接放到内核中。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625232027.png" alt="image-20210625232027197"></p>
<p>细分的话，进程表需要这几类信息。</p>
<p>描述信息：这部分是描述进程的唯一识别号，也就是 PID，包括进程的名称、所属的用户等。</p>
<p>资源信息：这部分用于记录进程拥有的资源，比如进程和虚拟内存如何映射、拥有哪些文件、在使用哪些 I/O 设备等，当然 I/O 设备也是文件。</p>
<p>内存布局：操作系统也约定了进程如何使用内存。如下图所示，描述了一个进程大致内存分成几个区域，以及每个区域用来做什么。 每个区域我们叫作一个段。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625232119.png" alt="image-20210625232118993"></p>
<p>操作系统还需要一张表来管理线程，这就是线程表。线程也需要 ID， 可以叫作 ThreadID。然后线程需要记录自己的执行状态（阻塞、运行、就绪）、优先级、程序计数器以及所有寄存器的值等等。线程需要记录程序计数器和寄存器的值，是因为多个线程需要共用一个 CPU，线程经常会来回切换，因此需要在内存中保存寄存器和 PC 指针的值。</p>
<p>用户级线程和内核级线程存在映射关系，因此可以考虑在内核中维护一张内核级线程的表，包括上面说的字段。</p>
<p>如果考虑到这种映射关系，比如 n-m 的多对多映射，可以将线程信息还是存在进程中，每次执行的时候才使用内核级线程。相当于内核中有个线程池，等待用户空间去使用。每次用户级线程把程序计数器等传递过去，执行结束后，内核线程不销毁，等待下一个任务。这里其实有很多灵活的实现，总体来说，创建进程开销大、成本高；创建线程开销小，成本低。</p>
<h4 id="隔离方案"><a href="#隔离方案" class="headerlink" title="隔离方案"></a>隔离方案</h4><p>操作系统中运行了大量进程，为了不让它们互相干扰，可以考虑为它们分配彼此完全隔离的内存区域，即便进程内部程序读取了相同地址，而实际的物理地址也不会相同。这就好比 A 小区的 10 号楼 808 和 B 小区的 10 号楼 808 不是一套房子，这种方法叫作地址空间，我们将在“21 讲”的页表部分讨论“地址空间”的详细内容。</p>
<p>所以在正常情况下进程 A 无法访问进程 B 的内存，除非进程 A 找到了某个操作系统的漏洞，恶意操作了进程 B 的内存，或者利用我们在“21 讲”讲到的“进程间通信”的手段。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234904.png" alt="image-20210625234904626"></p>
<p>对于一个进程的多个线程来说，可以考虑共享进程分配到的内存资源，这样线程就只需要被分配执行资源。</p>
<h4 id="进程（线程）切换"><a href="#进程（线程）切换" class="headerlink" title="进程（线程）切换"></a>进程（线程）切换</h4><p>进程（线程）在操作系统中是不断切换的，现代操作系统中只有线程的切换。 每次切换需要先保存当前寄存器的值的内存，注意 PC 指针也是一种寄存器。当恢复执行的时候，就需要从内存中读出所有的寄存器，恢复之前的状态，然后执行。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234920.png" alt="image-20210625234920411"></p>
<p>上面讲到的内容，我们可以概括为以下 5 个步骤：</p>
<p>当操作系统发现一个进程（线程）需要被切换的时候，直接控制 PC 指针跳转是非常危险的事情，所以操作系统需要发送一个“中断”信号给 CPU，停下正在执行的进程（线程）。</p>
<p>当 CPU 收到中断信号后，正在执行的进程（线程）会立即停止。注意，因为进程（线程）马上被停止，它还来不及保存自己的状态，所以后续操作系统必须完成这件事情。</p>
<p>操作系统接管中断后，趁寄存器数据还没有被破坏，必须马上执行一小段非常底层的程序（通常是汇编编写），帮助寄存器保存之前进程（线程）的状态。</p>
<p>操作系统保存好进程状态后，执行调度程序，决定下一个要被执行的进程（线程）。</p>
<p>最后，操作系统执行下一个进程（线程）。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234931.png" alt="image-20210625234931667"></p>
<p>当然，一个进程（线程）被选择执行后，它会继续完成之前被中断时的任务，这需要操作系统来执行一小段底层的程序帮助进程（线程）恢复状态。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234944.png" alt="image-20210625234944395"></p>
<p>一种可能的算法就是通过栈这种数据结构。进程（线程）中断后，操作系统负责压栈关键数据（比如寄存器）。恢复执行时，操作系统负责出栈和恢复寄存器的值。</p>
<h4 id="多核处理"><a href="#多核处理" class="headerlink" title="多核处理"></a>多核处理</h4><p>在多核系统中我们上面所讲的设计原则依然成立，只不过动力变多了，可以并行执行的进程（线程）。通常情况下，CPU 有几个核，就可以并行执行几个进程（线程）。这里强调一个概念，我们通常说的并发，英文是 concurrent，指的在一段时间内几个任务看上去在同时执行（不要求多核）；而并行，英文是 parallel，任务必须绝对的同时执行（要求多核）。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625234955.png" alt="image-20210625234955314"></p>
<p>比如一个 4 核的 CPU 就好像拥有 4 条流水线，可以并行执行 4 个任务。一个进程的多个线程执行过程则会产生竞争条件，这块我们会在“19 讲”锁和信号量部分给你介绍。因为操作系统提供了保存、恢复进程状态的能力，使得进程（线程）也可以在多个核心之间切换。</p>
<h4 id="创建进程（线程）的-API"><a href="#创建进程（线程）的-API" class="headerlink" title="创建进程（线程）的 API"></a>创建进程（线程）的 API</h4><p>用户想要创建一个进程，最直接的方法就是从命令行执行一个程序，或者双击打开一个应用。但对于程序员而言，显然需要更好的设计。</p>
<p>站在设计者的角度，你可以这样思考：首先，应该有 API 打开应用，比如可以通过函数打开某个应用；另一方面，如果程序员希望执行完一段代价昂贵的初始化过程后，将当前程序的状态复制好几份，变成一个个单独执行的进程，那么操作系统提供了 fork 指令。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210625235008.png" alt="image-20210625235008770"></p>
<p>也就是说，每次 fork 会多创造一个克隆的进程，这个克隆的进程，所有状态都和原来的进程一样，但是会有自己的地址空间。如果要创造 2 个克隆进程，就要 fork 两次。</p>
<p>你可能会问：那如果我就是想启动一个新的程序呢？</p>
<p>我在上文说过：操作系统提供了启动新程序的 API。</p>
<p>你可能还会问：如果我就是想用一个新进程执行一小段程序，比如说每次服务端收到客户端的请求时，我都想用一个进程去处理这个请求。</p>
<p>如果是这种情况，我建议你不要单独启动进程，而是使用线程。因为进程的创建成本实在太高了，因此不建议用来做这样的事情：要创建条目、要分配内存，特别是还要在内存中形成一个个段，分成不同的区域。所以通常，我们更倾向于多创建线程。</p>
<p>不同程序语言会自己提供创建线程的 API，比如 Java 有 Thread 类；go 有 go-routine（注意不是协程，是线程）。</p>
<h4 id="进程的开销比线程大在了哪里？"><a href="#进程的开销比线程大在了哪里？" class="headerlink" title="进程的开销比线程大在了哪里？"></a>进程的开销比线程大在了哪里？</h4><p>Linux 中创建一个进程自然会创建一个线程，也就是主线程。创建进程需要为进程划分出一块完整的内存空间，有大量的初始化操作，比如要把内存分段（堆栈、正文区等）。创建线程则简单得多，只需要确定 PC 指针和寄存器的值，并且给线程分配一个栈用于执行程序，同一个进程的多个线程间可以复用堆栈。因此，创建进程比创建线程慢，而且进程的内存开销更大。</p>
<h3 id="如何控制同一时间只有-2-个线程运行？"><a href="#如何控制同一时间只有-2-个线程运行？" class="headerlink" title="如何控制同一时间只有 2 个线程运行？"></a>如何控制同一时间只有 2 个线程运行？</h3><p>锁是一个面试的热门话题，有乐观锁、悲观锁、重入锁、公平锁、分布式锁。有很多和锁相关的数据结构，比如说阻塞队列。还有一些关联的一些工具，比如说 Semaphore、Monitor 等。这些知识点可以关联很多的面试题目，比如：</p>
<p>锁是如何实现的？</p>
<p>如何控制同一时间只有 2 个线程运行？</p>
<p>如何实现分布式锁？</p>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>要想弄清楚锁，就要弄清楚锁的实现，实现锁需要底层提供的原子操作，因此我们先来学习下原子操作。</p>
<p>原子操作就是操作不可分。在多线程环境，一个原子操作的执行过程无法被中断。那么你可以思考下，具体原子操作的一个示例。</p>
<p>比如<code>i++</code>就不是一个原子操作，因为它是 3 个原子操作组合而成的：</p>
<p>读取 <code>i</code> 的值；</p>
<p>计算 <code>i+1</code>；</p>
<p>写入新的值。</p>
<p>像这样的操作，在多线程 + 多核环境会造成竞争条件。</p>
<h4 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h4><p>竞争条件就是说多个线程对一个资源（内存地址）的读写存在竞争，在这种条件下，最后这个资源的值不可预测，而是取决于竞争时具体的执行顺序。</p>
<p>举个例子，比如两个线程并发执行<code>i++</code>。那么可以有下面这个操作顺序，假设执行前<code>i=0</code>：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210627232933.png" alt="image-20210627232933788"></p>
<p>虽然上面的程序执行了两次<code>i++</code>，但最终<code>i</code>的值为 1。</p>
<p><code>i++</code>这段程序访问了共享资源，也就是变量<code>i</code>，这种访问共享资源的程序片段我们称为<em>临界区</em>。在临界区，程序片段会访问共享资源，造成竞争条件，也就是共享资源的值最终取决于程序执行的时序，因此这个值不是确定的。</p>
<p>竞争条件是一件非常糟糕的事情，你可以把上面的程序想象成两个自动提款机。如果用户同时操作两个自动提款机，用户的余额就可能会被算错。</p>
<h4 id="解决竞争条件"><a href="#解决竞争条件" class="headerlink" title="解决竞争条件"></a>解决竞争条件</h4><p>解决竞争条件有很多方案，一种方案就是不要让程序同时进入临界区，这个方案叫作互斥。还有一些方案旨在避免竞争条件，比如 ThreadLocal、 cas 指令以及 “19 讲”中我们要学习的乐观锁。</p>
<h4 id="避免临界区"><a href="#避免临界区" class="headerlink" title="避免临界区"></a>避免临界区</h4><p>不让程序同时进入临界区这个方案比较简单，核心就是我们给每个线程一个变量i，比如利用 ThreadLocal，这样线程之间就不存在竞争关系了。这样做优点很明显，缺点就是并不是所有的情况都允许你这样做。有一些资源是需要共享的，比如一个聊天室，如果每次用户请求都有一个单独的线程在处理，不可能为每个请求（线程）都维护一份聊天记录。</p>
<h4 id="cas-指令"><a href="#cas-指令" class="headerlink" title="cas 指令"></a>cas 指令</h4><p>另一个方案是利用 CPU 的指令，让<code>i++</code>成为一个原子操作。 很多 CPU 都提供 Compare And Swap 指令。这个指令的作用是更新一个内存地址的值，比如把<code>i</code>更新为<code>i+1</code>，但是这个指令明确要求使用者必须确定知道内存地址中的值是多少。比如一个线程想把<code>i</code>从100更新到101，线程必须明确地知道现在<code>i</code>是 100，否则就会更新失败。</p>
<p>cas 可以用下面这个函数表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas(&amp;oldValue, expectedValue, targetValue)</span><br></pre></td></tr></table></figure>

<p>这里我用的是伪代码，用&amp;符号代表这里取内存地址。注意 cas 是 CPU 提供的原子操作。因此上面的比较和设置值的过程，是原子的，也就是不可分。</p>
<p>比如想用 cas 更新i的值，而且知道i是 100，想更新成101。那么就可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas(&amp;i, 100, 101)</span><br></pre></td></tr></table></figure>

<p>如果在这个过程中，有其他线程把i更新为101，这次调用会返回 false，否则返回 true。</p>
<p>所以i++程序可以等价的修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas(&amp;i, i, i+1)</span><br></pre></td></tr></table></figure>

<p>上面的程序执行时，其实是 3 条指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读取i </span><br><span class="line">计算i+1</span><br><span class="line">cas操作：比较期望值i和i的真实值的值是否相等，如果是，更新目标值</span><br></pre></td></tr></table></figure>

<p>假设i=0，考虑两个线程分别执行一次这个程序，尝试构造竞争条件：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628093200.png" alt="image-20210628093200450"></p>
<p>你可以看到通过这种方式，cas 解决了一部分问题，找到了竞争条件，并返回了 false。但是还是无法计算出正确的结果。因为最后一次 cas 失败了。</p>
<p>如果要完全解决可以考虑这样去实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(!cas(&amp;i, i, i+1))&#123;</span><br><span class="line">  // 什么都不做</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 cas 返回 false，那么会尝试再读一次 i 的值，直到 cas 成功。</p>
<h4 id="tas-指令"><a href="#tas-指令" class="headerlink" title="tas 指令"></a>tas 指令</h4><p>还有一个方案是 tas 指令，有的 CPU 没有提供 cas（大部分服务器是提供的），提供一种 Test-And-Set 指令（tas）。tas 指令的目标是设置一个内存地址的值为 1，它的工作原理和 cas 相似。首先比较内存地址的数据和 1 的值，如果内存地址是 0，那么把这个地址置 1。如果是 1，那么失败。</p>
<p>所以你可以把 tas 看作一个特殊版的cas，可以这样来理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tas(&amp;lock) &#123;</span><br><span class="line">  return cas(&amp;lock, 0, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁（lock），目标是实现抢占（preempt）。就是只让给定数量的线程进入临界区。锁可以用tas或者cas来实现。</p>
<p>举个例子：如果希望同时只能有一个线程执行i++，伪代码可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enter();</span><br><span class="line">i++;</span><br><span class="line">leave();</span><br></pre></td></tr></table></figure>

<p>可以考虑用cas实现enter和leave函数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int lock = 0;</span><br><span class="line">enter()&#123;</span><br><span class="line">  while( !cas(&amp;lock, 0, 1) ) &#123;</span><br><span class="line">    // 什么也不做</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">leave()&#123;</span><br><span class="line">  lock = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个线程竞争一个整数的 lock 变量，0 代表目前没有线程进入临界区，1 代表目前有线程进入临界区。利用cas原子指令我们可以对临界区进行管理。如果一个线程利用 cas 将 lock 设置为 1，那么另一个线程就会一直执行cas操作，直到锁被释放。</p>
<h4 id="语言级锁的实现"><a href="#语言级锁的实现" class="headerlink" title="语言级锁的实现"></a>语言级锁的实现</h4><p>上面解决竞争条件的时候，我们用到了锁。 相比 cas，锁是一种简单直观的模型。总体来说，cas 更底层，用 cas 解决问题优化空间更大。但是用锁解决问题，代码更容易写——进入临界区之前 lock，出去就 unlock。 从上面这段代码可以看出，为了定义锁，我们需要用到一个整型。如果实现得好，可以考虑这个整数由语言级定义。</p>
<p>比如考虑让用户传递一个变量过去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int lock = 0;</span><br><span class="line">enter(&amp;lock);</span><br><span class="line">//临界区代码</span><br><span class="line">leave(&amp;lock);</span><br></pre></td></tr></table></figure>

<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>上面我们已经用过自旋锁了，这是之前的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enter()&#123;</span><br><span class="line">  while( !cas(&amp;lock, 0, 1) ) &#123;</span><br><span class="line">    // 什么也不做</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码不断在 CPU 中执行指令，直到锁被其他线程释放。这种情况线程不会主动释放资源，我们称为自旋锁。自旋锁的优点就是不会主动发生 Context Switch，也就是线程切换，因为线程切换比较消耗时间。自旋锁缺点也非常明显，比较消耗 CPU 资源。如果自旋锁一直拿不到锁，会一直执行。</p>
<h4 id="wait-操作"><a href="#wait-操作" class="headerlink" title="wait 操作"></a>wait 操作</h4><p>你可以考虑实现一个 wait 操作，主动触发 Context Switch。这样就解决了 CPU 消耗的问题。但是触发 Context Switch 也是比较消耗成本的事情，那么有没有更好的方法呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enter()&#123;</span><br><span class="line">  while( !cas(&amp;lock, 0, 1) ) &#123;</span><br><span class="line">    // sleep(1000ms);</span><br><span class="line">    wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以看下上面的代码，这里有一个更好的方法：就是 cas 失败后，马上调用sleep方法让线程休眠一段时间。但是这样，可能会出现锁已经好了，但是还需要多休眠一小段时间的情况，影响计算效率。</p>
<p>另一个方案，就是用wait方法，等待一个信号——直到另一个线程调用notify方法，通知这个线程结束休眠。但是这种情况——wait 和 notify 的模型要如何实现呢？</p>
<h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><p>一个合理的实现就是生产者消费者模型。 wait 是一个生产者，将当前线程挂到一个等待队列上，并休眠。notify 是一个消费者，从等待队列中取出一个线程，并重新排队。</p>
<p>如果使用这个模型，那么我们之前简单用<code>enter</code>和<code>leave</code>来封装加锁和解锁的模式，就需要变化。我们需要把<code>enter</code> <code>leave</code> <code>wait</code> <code>notify</code>的逻辑都封装起来，不让用户感知到它们的存在。</p>
<p>比如 Java 语言，Java 为每个对象增加了一个 Object Header 区域，里面一个锁的位（bit），锁并不需要一个 32 位整数，一个 bit 足够。下面的代码用户使用 synchronized 关键字让临界区访问互斥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj)&#123;// enter</span><br><span class="line">  // 临界区代码</span><br><span class="line">&#125; // leave</span><br></pre></td></tr></table></figure>

<p>synchronized 关键字的内部实现，用到了封装好的底层代码——Monitor 对象。每个 Java 对象都关联了一个 Monitor 对象。Monitor 封装了对锁的操作，比如 enter、leave 的调用，这样简化了 Java 程序员的心智负担，你只需要调用 synchronized 关键字。</p>
<p>另外，Monitor 实现了生产者、消费者模型。</p>
<ul>
<li>如果一个线程拿到锁，那么这个线程继续执行；</li>
<li>如果一个线程竞争锁失败，Montior 就调用 wait 方法触发生产者的逻辑，把线程加入等待集合；</li>
<li>如果一个线程执行完成，Monitor 就调用一次 notify 方法恢复一个等待的线程。</li>
</ul>
<p>这样，Monitor 除了提供了互斥，还提供了线程间的通信，避免了使用自旋锁，还简化了程序设计。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>接下来介绍一个叫作信号量的方法，你可以把它看作是互斥的一个广义版。我们考虑一种更加广义的锁，这里请你思考如何同时允许 N 个线程进入临界区呢？</p>
<p>我们先考虑实现一个基础的版本，用一个整数变量<code>lock</code>来记录进入临界区线程的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int lock = 0;</span><br><span class="line">enter()&#123;</span><br><span class="line">  while(lock++ &gt; 2) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">leave()&#123;</span><br><span class="line">  lock--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码具有一定的欺骗性，没有考虑到<strong>竞争条件</strong>，执行的时候会出问题，可能会有超过2个线程同时进入临界区。</p>
<p>下面优化一下，作为一个考虑了竞争条件的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">up(&amp;lock)&#123;</span><br><span class="line">  while(!cas(&amp;lock, lock, lock+1)) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">down(&amp;lock)&#123;</span><br><span class="line">  while(!cas(&amp;lock, lock, lock - 1) || lock == 0)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了简化模型，我们重新设计了两个原子操作<code>up</code>和<code>down</code>。<code>up</code>将<code>lock</code>增 1，<code>down</code>将<code>lock</code>减 1。当 lock 为 0 时，如果还在<code>down</code>那么会自旋。考虑用多个线程同时执行下面这段程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int lock = 2;</span><br><span class="line">down(&amp;lock);</span><br><span class="line">// 临界区</span><br><span class="line">up(&amp;lock);</span><br></pre></td></tr></table></figure>

<p>如果只有一个线程在临界区，那么<code>lock</code>等于 1，第 2 个线程还可以进入。 如果两个线程在临界区，第 3 个线程尝试<code>down</code>的时候，会陷入自旋锁。当然我们也可以用其他方式来替代自旋锁，比如让线程休眠。</p>
<p>当<code>lock</code>初始值为 1 的时候，这个模型就是实现<strong>互斥（mutex）</strong>。如果 lock 大于 1，那么就是同时允许多个线程进入临界区。这种方法，我们称为<strong>信号量（semaphore）</strong>。</p>
<h4 id="信号量实现生产者消费者模型"><a href="#信号量实现生产者消费者模型" class="headerlink" title="信号量实现生产者消费者模型"></a>信号量实现生产者消费者模型</h4><p>信号量可以用来实现生产者消费者模型。下面我们通过一段代码实现生产者消费者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">int empty = N; // 当前空位置数量</span><br><span class="line"></span><br><span class="line">int mutex = 1; // 锁</span><br><span class="line"></span><br><span class="line">int full = 0; // 当前的等待的线程数</span><br><span class="line"></span><br><span class="line">wait()&#123;</span><br><span class="line"></span><br><span class="line">  down(&amp;empty);</span><br><span class="line"></span><br><span class="line">  down(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  insert(); </span><br><span class="line"></span><br><span class="line">  up(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  up(&amp;full);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notify()&#123;</span><br><span class="line"></span><br><span class="line">  down(&amp;full);</span><br><span class="line"></span><br><span class="line">  down(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  remove(); </span><br><span class="line"></span><br><span class="line">  up(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  up(&amp;empty)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert()&#123;</span><br><span class="line"></span><br><span class="line">  wait_queue.add(currentThread);</span><br><span class="line"></span><br><span class="line">  yield();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove()&#123;</span><br><span class="line"></span><br><span class="line">  thread = wait_queue.dequeue();</span><br><span class="line"></span><br><span class="line">  thread.resume();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中 wait 是生产者，notify 是消费者。 每次<code>wait</code>操作减少一个空位置数量，empty-1；增加一个等待的线程，full+1。每次<code>notify</code>操作增加一个空位置，empty+1，减少一个等待线程，full-1。</p>
<p><code>insert</code>和<code>remove</code>方法是互斥的操作，需要用另一个 mutex 锁来保证。<code>insert</code>方法将当前线程加入等待队列，并且调用 yield 方法，交出当前线程的控制权，当前线程休眠。<code>remove</code>方法从等待队列中取出一个线程，并且调用<code>resume</code>进行恢复。以上， 就构成了一个简单的生产者消费者模型。</p>
<h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><p>另外就是在并行的时候，如果两个线程互相等待对方获得的锁，就会发生死锁。你可以把死锁理解成一个环状的依赖关系。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int lock1 = 0;</span><br><span class="line"></span><br><span class="line">int lock2 = 0;</span><br><span class="line"></span><br><span class="line">// 线程1</span><br><span class="line"></span><br><span class="line">enter(&amp;lock1);</span><br><span class="line"></span><br><span class="line">enter(&amp;lock2);</span><br><span class="line"></span><br><span class="line">leave(&amp;lock1);</span><br><span class="line"></span><br><span class="line">leave(&amp;lock2);</span><br><span class="line"></span><br><span class="line">// 线程2</span><br><span class="line"></span><br><span class="line">enter(&amp;lock2);</span><br><span class="line"></span><br><span class="line">enter(&amp;lock1);</span><br><span class="line"></span><br><span class="line">leave(&amp;lock1);</span><br><span class="line"></span><br><span class="line">leave(&amp;lock2)</span><br></pre></td></tr></table></figure>

<p>上面的程序，如果是按照下面这个顺序执行，就会死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程1： enter(&amp;lock1);</span><br><span class="line"></span><br><span class="line">线程2： enter(&amp;lock2);</span><br><span class="line"></span><br><span class="line">线程1： enter(&amp;lock2)</span><br><span class="line"></span><br><span class="line">线程2:  enter(&amp;lock1)</span><br><span class="line"></span><br><span class="line">// 死锁发生，线程1、2陷入等待</span><br></pre></td></tr></table></figure>

<p>上面程序线程 1 获得了<code>lock1</code>，线程 2 获得了<code>lock2</code>。接下来线程 1 尝试获得<code>lock2</code>，线程 2 尝试获得<code>lock1</code>，于是两个线程都陷入了等待。这个等待永远都不会结束，我们称之为<strong>死锁</strong>。</p>
<p>关于死锁如何解决，我们会在“<strong>21 | 哲学家就餐问题：什么情况下会触发饥饿和死锁</strong>？”讨论。这里我先讲一种最简单的解决方案，你可以尝试让两个线程对锁的操作顺序相同，这样就可以避免死锁问题。</p>
<h4 id="分布式环境的锁"><a href="#分布式环境的锁" class="headerlink" title="分布式环境的锁"></a>分布式环境的锁</h4><p>最后，我们留一点时间给分布式锁。我们之前讨论了非常多的实现，是基于多个线程访问临界区。现在要考虑一个更庞大的模型，我们有 100 个容器，每一个里面有一个为用户<strong>减少积分</strong>的服务。</p>
<p>简化下模型，假设积分存在 Redis 中。当然数据库中也有，但是我们只考虑 Redis。使用 Redis，我们目标是给数据库减负。</p>
<p>假设这个接口可以看作 3 个原子操作：</p>
<ol>
<li>从 Redis 读出当前库存；</li>
<li>计算库存 -1；</li>
<li>更新 Redis 库存。</li>
</ol>
<p>和<code>i++</code>类似，很明显，当用户并发的访问这个接口，是会发生竞争条件的。 因为程序已经不是在同一台机器上执行了，解决方案就是<strong>分布式锁</strong>。实现锁，我们需要原子操作。</p>
<p>在单机多线程并发的场景下，原子操作由 CPU 指令提供，比如 <code>cas</code> 和 <code>tas</code> 指令。那么在分布式环境下，原子操作由谁提供呢？``</p>
<p>有很多工具都可以提供分布式的原子操作，比如 <code>Redis</code> 的 <code>setnx</code> 指令，Zookeeper 的节点操作等等。作为操作系统课程，这部分我不再做进一步的讲解。这里是从多线程的处理方式，引出分布式的处理方式，通过两个类比，帮助你提高。如果你感兴趣，可以自己查阅更多的分布式锁的资料。</p>
<h4 id="如何控制同一时间只有-2-个线程运行？-1"><a href="#如何控制同一时间只有-2-个线程运行？-1" class="headerlink" title="如何控制同一时间只有 2 个线程运行？"></a>如何控制同一时间只有 2 个线程运行？</h4><p>同时控制两个线程进入临界区，一种方式可以考虑用信号量（semaphore）。</p>
<p>另一种方式是考虑生产者、消费者模型。想要进入临界区的线程先在一个等待队列中等待，然后由消费者每次消费两个。这种实现方式，类似于实现一个线程池，所以也可以考虑实现一个 <code>ThreadPool</code> 类，然后再实现一个调度器类，最后实现一个每次选择两个线程执行的调度算法。</p>
<h3 id="除了上锁还有哪些并发控制方法？"><a href="#除了上锁还有哪些并发控制方法？" class="headerlink" title="除了上锁还有哪些并发控制方法？"></a><strong>除了上锁还有哪些并发控制方法？</strong></h3><p>上面这道面试题是在“有哪些并发控制方法？”这个问题的基础上加了一个限制条件。</p>
<p>在我面试候选人的过程中，“上锁”是我听到过回答频次最多的答案，也就是说大多数程序员都可以想到这个并发控制方法。因此，是否能回答出上锁以外的方法，是检验程序员能力的一个分水岭，其实锁以外还有大量优秀的方法。</p>
<p>你掌握的方法越多，那么在解决实际问题的时候，思路就越多。即使你没有做过高并发场景的设计，但是如果脑海中有大量优秀的方法可以使用，那么公司也会考虑培养你，将高并发场景交给你去解决。今天我们就以这道面试题为引，一起探讨下“锁以外的并发控制方法”。</p>
<h4 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁/乐观锁"></a>悲观锁/乐观锁</h4><p>说到并发场景，设计系统的目的往往是达到同步（Synchronized）的状态，同步就是大家最终对数据的理解达成了一致。</p>
<p>同步的一种方式，就是让<strong>临界区</strong>互斥。 这种方式，每次只有一个线程可以进入临界区。比如多个人修改一篇文章，这意味着必须等一个人编辑完，另一个人才能编辑。但是从实际问题出发，如果多个人编辑的不是文章的同一部分，是可以同时编辑的。因此，让临界区互斥的方法（对临界区上锁），具有强烈的排他性，对修改持保守态度，我们称为<strong>悲观锁（Pressimistic Lock）</strong>。</p>
<p>通常意义上，我们说上锁，就是悲观锁，比如说 MySQL 的表锁、行锁、Java 的锁，本质是互斥（mutex）。</p>
<p>和<strong>悲观锁（PressimisticLock）</strong>持相反意见的，是<strong>乐观锁（Optimistic Lock）</strong>。你每天都用的，基于乐观锁的应用就是版本控制工具 Git。Git 允许大家一起编辑，将结果先存在本地，然后都可以向远程仓库提交，如果没有版本冲突，就可以提交上去。这就是一种典型的乐观锁的场景，或者称为基于版本控制的场景。</p>
<h4 id="Git-的类比"><a href="#Git-的类比" class="headerlink" title="Git 的类比"></a>Git 的类比</h4><p>比如现在代码仓库的版本是 100。Bob 和 Alice 把版本 100 拷贝到本地，Bob 在本地写到了 106 版本，Alice 在本地写到 108 版本。那么如果 Alice 先提交，代码仓库的版本就到了 108。 Bob 再提交的时候，发现版本已经不是 100 了，就需要把最新的代码 fetch 到本地，然后合并冲突，再尝试提交一个更新的版本，比如 110。</p>
<p>这种方式非常类似<code>cas</code>指令的形式，就是每次更新的发起方，需要明确地知道想从多少版本更新到多少版本。以 Git 为例，可以写出<code>cas</code>的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cas(&amp;version, 100, 108); // 成功</span><br><span class="line"></span><br><span class="line">cas(&amp;version, 100, 106); // 失败，因为version是108</span><br></pre></td></tr></table></figure>

<h4 id="购物车的类比"><a href="#购物车的类比" class="headerlink" title="购物车的类比"></a>购物车的类比</h4><p>再举个例子，比如说要实现一个购物车。用户可能在移动端、PC 端之间切换，比如他用一会手机累了，然后换成用电脑，当他用电脑累了，再换回手机。</p>
<p>在移动端和 PC 端，用户都在操作购物车。 比如在移动端上，用户增加了商品 A；然后用户打开 PC 端，增加了商品 B；然后用户又换回了移动端，想增加商品 C。</p>
<p>这种时候，如果用悲观锁，用户登录移动端后，一种方案就是把 PC 端下线——当然这个方案显然不合理。 合理的方案是给购物车一个版本号，假设是 MySQL 表，那么购物车表中就会多一个版本字段。这样当用户操作购物车的时候，检查一下当前购物车的版本号是不是最新的，如果是最新的，那么就正常操作。如果不是最新的，就提示用户购物车在其他地方已被更新，需要刷新。</p>
<h4 id="去中心化方案：区块链的类比"><a href="#去中心化方案：区块链的类比" class="headerlink" title="去中心化方案：区块链的类比"></a>去中心化方案：区块链的类比</h4><p>继续类比，我们可以思考一个更加有趣的方案。在传统的架构中，我们之所以害怕并发，是因为中心化。比如说 DNS 系统，如果全球所有的 DNS 查询都执行一个集群，这个吞吐量是非常恐怖的，因此 DNS 系统用了一个分级缓存的策略。</p>
<p>但是交易数据分布的时候，比如下单、支付、修改库存，如果用分布式处理，就牵扯到分布式锁（分布式事务）。那么，有没有一个去中心化的方案，让业务不需要集中处理呢？比如说双 11 期间你在淘宝上买东西，可不可以直接和商家下单，而不用通过淘宝的中心系统呢？——如果可以，这也就相当于实现了同步，或者说去掉了高并发的同步。</p>
<h4 id="解决最基本的信用问题"><a href="#解决最基本的信用问题" class="headerlink" title="解决最基本的信用问题"></a>解决最基本的信用问题</h4><p>考虑购买所有的网购产品，下单不再走中心化的平台。比如阿里、拼多多、 京东、抖音……这些平台用户都不走平台的中心系统下单，而是用户直接和商家签订合同。这个技术现在已经实现了，叫作电子合同。</p>
<p>举例：Alice（A）向苹果店 B 购买了一个 iPhone。那么双方签订电子合同，合同内容 C 是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from=A, to=B, price=10000, signature=alice的签名</span><br><span class="line">from=B, to=A, object=iphone, signature=苹果店的签名</span><br></pre></td></tr></table></figure>

<p>上面两条记录，第 1 条是说 A 同意给 B 转 10000 块钱；第 2 条记录说，B 同意给 A 一个 iPhone。如果 A 收了 iPhone 不给 B 打款，B 可以拿着这个电子合同去法院告 A。因为用 A 的签名，可以确定是 Alice 签署了这份协议。同理，如果苹果店不给 Alice iPhone，Alice 可以去法院告苹果店，因为 Alice 可以用苹果店的签名证明合同是真的。</p>
<h4 id="解决货币和库存的问题"><a href="#解决货币和库存的问题" class="headerlink" title="解决货币和库存的问题"></a>解决货币和库存的问题</h4><p>有了上面的例子，最基本的信用问题解决了。接下来，你可能会问，Alice 怎么证明自己有足够的钱买 iPhone？苹果店怎么证明有足够的 iPhone？</p>
<p>比如在某个对公开放的节点中，记录了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">account=alice, money=10000</span><br><span class="line"></span><br><span class="line">account=bob, iphone=100</span><br><span class="line"></span><br><span class="line">…… 以及很多其他的数据</span><br></pre></td></tr></table></figure>

<p>我们假设这里的钱可能是 Alice 用某种手段放进来的。或者我们再简化这个模型，比如全世界所有人的钱，都在这个系统里，这样我们就不用关心钱从哪里来这个问题了。如果是比特币，钱是需要挖矿的。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628095938.png" alt="image-20210628095938526"></p>
<p>如图，这个结构也叫作区块链。每个 Block 下面可以存一些数据，每个 Block 知道上一个节点是谁。每个 Block 有上一个节点的摘要签名。也就是说，如果 Block 10 是 Block 11 的上一个节点，那么 Block 11 会知道 Block 10 的存在，且用 Block 11 中 Block 10 的摘要签名，可以证明 Block 10 的数据没有被篡改过。</p>
<p>区块链构成了一个基于历史版本的事实链，前一个版本是后一个版本的历史。Alice 的钱和苹果店的 iPhone 数量，包括全世界所有人的钱，都在这些 Block 里。</p>
<h4 id="购买转账的过程"><a href="#购买转账的过程" class="headerlink" title="购买转账的过程"></a><strong>购买转账的过程</strong></h4><p>下面请你思考，Alice 购买了 iPhone，需要提交两条新数据到上面的区块链。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628100030.png" alt="image-20210628100030658"></p>
<p>比如，Alice 先在本地完成这件事情，本地的区块链就会像上图那样。 假设有一个中心化的服务器，专门接收这些区块数据，Alice 接下来就可以把数据提交到中心化的服务器，苹果店从中心化服务器上看到这条信息，认为交易被 Alice 执行了，就准备发货。</p>
<p>如果世界上有很多人同时在这个末端节点上写新的 Block。那么可以考虑由一个可信任的中心服务帮助合并新增的区块数据。就好像多个人同时编辑了一篇文章，发生了冲突，那就可以考虑由一个人整合大家需要修改和新增的内容，避免同时操作产生混乱。</p>
<h4 id="解决欺诈问题"><a href="#解决欺诈问题" class="headerlink" title="解决欺诈问题"></a>解决欺诈问题</h4><p>正常情况下，所有记录都可以直接合并。但是比如Alice在一家店购买了 1 个 iPhone，在另外一家店购买了 2 个 iPhone，这个时候 Alice 的钱就不够付款了。 或者说 Alice 想用 20000 块买 3 个 iPhone，她还想骗一个。</p>
<p>那么 Alice 最终就需要写这样的记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from=A, to=B, price=10000, signature=alice的签名</span><br><span class="line"></span><br><span class="line">from=B, to=A, object=iphone, signature=一个苹果店的签名</span><br><span class="line"></span><br><span class="line">from=A, to=B1, price=20000, signature=alice的签名</span><br><span class="line"></span><br><span class="line">from=B1, to=A, object=iphonex2, signature=另一个苹果店的签名</span><br></pre></td></tr></table></figure>

<p>无论 Alice 以什么顺序写入这些记录，她的钱都是不够的，因为她只有 20000 的余额。 这样简单地就解决了欺诈问题。</p>
<p>如果 Alice 想要修改自己的余额，那么 Alice 怎么做呢？</p>
<p>Alice 需要新增一个末端的节点，比如她在末端节点上将自己的余额修改为 999999。那么 Alice 的余额，就和之前 Block 中记录的冲突了。简单一查，就知道 Alice 在欺诈。如果 Alice 想要修改之前的某个节点的数据，这个节点的摘要签名就会发生变化了， 那么后面所有的节点就失效了。</p>
<p>比如 Alice 修改了 Block 9 的数据，并把整个区块链拷贝给 Bob。Bob 通过验证签名，就知道 Alice 在骗人。如果 Alice 修改了所有 Block 9 以后的 Block，相当于修改了完整的一个链条，且修改了所有的签名。Bob 只需要核对其中几个版本和其他人，或者和中心服务的签名的区别就知道 Alice 在欺诈。</p>
<p>刚才有一个设计，就是有一个中心平台供 Bob 下载。如果中心平台修改了数据。那么 Bob 会马上发现存在本地的和自己相关的数据与中心平台不一致。这样 Bob 就会联合其他用户一起抵制中心平台。</p>
<p>所以结论是，区块链一旦写入就不能修改，这样可以防止很多欺诈行为。</p>
<h4 id="解决并发问题"><a href="#解决并发问题" class="headerlink" title="解决并发问题"></a>解决并发问题</h4><p>假设全球有几十亿人都在下单。那么每次下单，需要创建新的一个 Block。这种情况，会导致最后面的 Block，开很多分支。</p>
<p>这个时候你会发现，这里有同步问题对不对？ 最傻的方案就是用锁解决，比如用一个集中式的办法，去接收所有的请求，这样就又回到中心化的设计。</p>
<p>还有一个高明的办法，就是允许商家开分支。 用户和苹果店订合同，苹果店独立做一个分支，把用户的合同连起来。</p>
<p>这样苹果店自己先维护自己的 Block-Chain，等待合适的时机，再去合并到主分支上。 如果有合同合并不进去，比如余额不足，那再作废这个合同（不发货了）。</p>
<p>这里请你思考这样一种处理方式：如果全世界每天有 1000 亿笔订单要处理，那么可以先拆分成 100 个区域，每个区域是 10W 家店。这样最终每家店的平均并发量在 10000 单。 然后可以考虑每过多长时间，比如 10s，进行一次逐级合并。</p>
<p>这样，整体每个节点的压力就不是很大了。</p>
<p>并发问题也不仅仅是要解决并发问题，并发还伴随着一致性、可用性、欺诈及吞吐量等。一名优秀的架构师是需要储备多个维度的知识，所以还是我常常跟你强调的，知识在于积累，绝非朝夕之功。</p>
<h4 id="除了上锁还有哪些并发控制方法？-1"><a href="#除了上锁还有哪些并发控制方法？-1" class="headerlink" title="除了上锁还有哪些并发控制方法？"></a><strong>除了上锁还有哪些并发控制方法？</strong></h4><p>这一讲我们介绍了基于乐观锁的版本控制，还介绍了区块链技术。另外还有一个名词，并不属于操作系统课程范畴，我也简单给你介绍下。处理并发还可以考虑 Lock-Free 数据结构。比如 Lock-Free 队列，是基于 cas 指令实现的，允许多个线程使用这个队列。再比如 ThreadLocal，让每个线程访问不同的资源，旨在用空间换时间，也是避免锁的一种方案。</p>
<h3 id="线程调度都有哪些方法？"><a href="#线程调度都有哪些方法？" class="headerlink" title="线程调度都有哪些方法？"></a><strong>线程调度都有哪些方法？</strong></h3><p>所谓<strong>调度</strong>，是一个制定计划的过程，放在线程调度背景下，就是操作系统如何决定未来执行哪些线程？</p>
<p>第一条是形形色色调度场景怎么来的？第二条是每个调度算法是如何工作的？</p>
<h4 id="先到先服务"><a href="#先到先服务" class="headerlink" title="先到先服务"></a>先到先服务</h4><p>早期的操作系统是一个个处理作业（Job），比如很多保险业务，每处理一个称为一个作业（Job）。处理作业最容易想到的就是<strong>先到先服务（First Come First Service，FCFS）</strong>，也就是先到的作业先被计算，后到的作业，排队进行。</p>
<p>这里需要用到一个叫作队列的数据结构，具有<strong>先入先出（First In First Out，FIFO）性质</strong>。先进入队列的作业，先处理，因此从<strong>公平性</strong>来说，这个算法非常朴素。另外，一个作业完全完成才会进入下一个作业，作业之间不会发生切换，从<strong>吞吐量</strong>上说，是最优的——因为没有额外开销。</p>
<p>但是这样对于等待作业的用户来说，是有问题的。比如一笔需要用时 1 天的作业 ，如果等待了 10 分钟，用户是可以接受的；一个用时 10 分钟的作业，用户等待一天就要投诉了。 因此如果用时 1 天的作业先到，用时 10 分钟的任务后到，应该优先处理用时少的，也就是<strong>短作业优先（Shortest Job First，SJF）</strong>。</p>
<h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><p>通常会同时考虑到来顺序和作业预估时间的长短，比如下面的到来顺序和预估时间：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628101849.png" alt="image-20210628101849835"></p>
<p>这样就会优先考虑第一个到来预估时间为 3 分钟的任务。 我们还可以从另外一个角度来审视短作业优先的优势，就是平均等待时间。</p>
<h4 id="平均等待时间-总等待时间-任务数"><a href="#平均等待时间-总等待时间-任务数" class="headerlink" title="平均等待时间 = 总等待时间/任务数"></a><strong>平均等待时间 = 总等待时间/任务数</strong></h4><p>上面例子中，如果按照 3,3,10 的顺序处理，平均等待时间是：(0 + 3 + 6) / 3 = 3 分钟。 如果按照 10,3,3 的顺序来处理，就是( 0+10+13 )/ 3 = 7.66 分钟。</p>
<p>平均等待时间和用户满意度是成反比的，等待时间越长，用户越不满意，因此<strong>在大多数情况下，应该优先处理用时少的，从而降低平均等待时长</strong>。</p>
<p>采用 FCFS 和 SJF 后，还有一些问题没有解决。</p>
<ol>
<li>紧急任务如何插队？比如老板安排的任务。</li>
<li>等待太久的任务如何插队？比如用户等太久可能会投诉。</li>
<li>先执行的大任务导致后面来的小任务没有执行如何处理？比如先处理了一个 1 天才能完成的任务，工作半天后才发现预估时间 1 分钟的任务也到来了。</li>
</ol>
<p>为了解决上面的问题，我们设计了两种方案， <strong>一种是优先级队列（PriorityQueue）</strong>，<strong>另一种是抢占（Preemption）。</strong></p>
<h4 id="优先级队列（PriorityQueue）"><a href="#优先级队列（PriorityQueue）" class="headerlink" title="优先级队列（PriorityQueue）"></a>优先级队列（PriorityQueue）</h4><p>刚才提到老板安排的任务需要紧急插队，那么下一个作业是不是应该安排给老板？毫无疑问肯定是这样！那么如何控制这种优先级顺序呢？一种方法是用优先级队列。优先级队列可以给队列中每个元素一个优先级，优先级越高的任务就会被先执行。</p>
<p>优先级队列的一种实现方法就是用到了堆（Heap）这种数据结构，更最简单的实现方法，就是每次扫描一遍整个队列找到优先级最高的任务。也就是说，堆（Heap）可以帮助你在 O(1) 的时间复杂度内查找到最大优先级的元素。<br>比如老板的任务，就给一个更高的优先级。 而对于普通任务，可以在<strong>等待时间（W）</strong> 和<strong>预估执行时间（P）</strong> 中，找一个数学关系来描述。比如：优先级 = W/P。W 越大，或者 P 越小，就越排在前面。 当然还可以有很多其他的数学方法，利用对数计算，或者某种特别的分段函数。</p>
<p>这样，关于紧急任务如何插队？等待太久的任务如何插队？这两个问题我们都解决了，接下来我们来看先执行的大任务导致后面来的小任务没有执行的情况如何处理？</p>
<h4 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h4><p>为了解决这个问题，我们需要用到<strong>抢占（Preemption）</strong>。</p>
<p>抢占就是把执行能力分时，分成时间片段。 让每个任务都执行一个时间片段。如果在时间片段内，任务完成，那么就调度下一个任务。如果任务没有执行完成，则中断任务，让任务重新排队，调度下一个任务。</p>
<p>拥有了抢占的能力，再结合之前我们提到的优先级队列能力，这就构成了一个基本的线程调度模型。线程相对于操作系统是排队到来的，操作系统为每个到来的线程分配一个优先级，然后把它们放入一个优先级队列中，优先级最高的线程下一个执行。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103020.png" alt="image-20210628103020152"></p>
<p>每个线程执行一个时间片段，然后每次执行完一个线程就执行一段调度程序。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103053.png" alt="image-20210628103053438"></p>
<p>图中用红色代表调度程序，其他颜色代表被调度线程的时间片段。调度程序可以考虑实现为一个单线程模型，这样不需要考虑竞争条件。</p>
<p>上面这个模型已经是一个非常优秀的方案了，但是还有一些问题可以进一步处理得更好。</p>
<ol>
<li>如果一个线程优先级非常高，其实没必要再抢占，因为无论如何调度，下一个时间片段还是给它。那么这种情况如何实现？</li>
<li>如果希望实现最短作业优先的抢占，就必须知道每个线程的执行时间，而这个时间是不可预估的，那么这种情况又应该如何处理？</li>
</ol>
<p>为了解决上面两个问题，我们可以考虑引入多级队列模型。</p>
<h4 id="多级队列模型"><a href="#多级队列模型" class="headerlink" title="多级队列模型"></a>多级队列模型</h4><p>多级队列，就是多个队列执行调度。 我们先考虑最简单的两级模型，如图：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103553.png" alt="image-20210628103552965"></p>
<p>上图中设计了两个优先级不同的队列，从下到上优先级上升，上层队列调度紧急任务，下层队列调度普通任务。只要上层队列有任务，下层队列就会让出执行权限。</p>
<ul>
<li>低优先级队列可以考虑抢占 + 优先级队列的方式实现，这样每次执行一个时间片段就可以判断一下高优先级的队列中是否有任务。</li>
<li>高优先级队列可以考虑用非抢占（每个任务执行完才执行下一个）+ 优先级队列实现，这样紧急任务优先级有个区分。如果遇到十万火急的情况，就可以优先处理这个任务。</li>
</ul>
<p>上面这个模型虽然解决了任务间的优先级问题，但是还是没有解决短任务先行的问题。可以考虑再增加一些队列，让级别更多。比如下图这个模型：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628103822.png" alt="image-20210628103822066"></p>
<p>紧急任务仍然走高优队列，非抢占执行。普通任务先放到优先级仅次于高优任务的队列中，并且只分配很小的时间片；如果没有执行完成，说明任务不是很短，就将任务下调一层。下面一层，最低优先级的队列中时间片很大，长任务就有更大的时间片可以用。通过这种方式，短任务会在更高优先级的队列中执行完成，长任务优先级会下调，也就类似实现了最短作业优先的问题。</p>
<p>实际操作中，可以有 n 层，一层层把大任务筛选出来。 最长的任务，放到最闲的时间去执行。要知道，大部分时间 CPU 不是满负荷的。</p>
<p><strong>线程调度都有哪些方法</strong>？</p>
<p>回答这个问题你要把握主线，千万不要教科书般的回答：任务调度分成抢占和非抢占的，抢占的可以轮流执行，也可以用优先级队列执行；非抢占可以先到先服务，也可以最短任务优先。</p>
<p>上面这种回答可以用来过普通的程序员岗位，但是面试官其实更希望听到你的见解，这是初中级开发人员与高级开发人员之间的差异。</p>
<p>比如你告诉面试官：非抢占的先到先服务的模型是最朴素的，公平性和吞吐量可以保证。但是因为希望减少用户的平均等待时间，操作系统往往需要实现抢占。操作系统实现抢占，仍然希望有优先级，希望有最短任务优先。</p>
<p>但是这里有个困难，操作系统无法预判每个任务的预估执行时间，就需要使用分级队列。最高优先级的任务可以考虑非抢占的优先级队列。 其他任务放到分级队列模型中执行，从最高优先级时间片段最小向最低优先级时间片段最大逐渐沉淀。这样就同时保证了小任务先行和高优任务最先执行。</p>
<h3 id="什么情况下会触发饥饿和死锁？"><a href="#什么情况下会触发饥饿和死锁？" class="headerlink" title="什么情况下会触发饥饿和死锁？"></a><strong>什么情况下会触发饥饿和死锁</strong>？</h3><p>读题可知，这道题目在提问“场景”，从表面来看，解题思路是列举几个例子。但是在回答这类面试题前你一定要想一想面试官在考察什么，往往在题目中看到“<strong>什么情况下</strong>”时，其实考察的是你总结和概括信息的能力。</p>
<p>关于上面这道题目，如果你只回答一个场景，而没有输出概括性的总结内容，就很容易被面试官认为对知识理解不到位，因而挂掉面试。另外，<strong>提问死锁和饥饿还有一个更深层的意思，就是考察你在实战中对并发控制算法的理解，是否具备设计并发算法来解决死锁问题并且兼顾性能（并发量）的思维和能力</strong>。</p>
<p>要学习这部分知识有一个非常不错的模型，就是哲学家就餐问题。1965 年，计算机科学家 Dijkstra 为了帮助学生更好地学习并发编程设计的一道练习题，后来逐渐成为大家广泛讨论的问题。</p>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>问题描述如下：有 5 个哲学家，围着一个圆桌就餐。圆桌上有 5 份意大利面和 5 份叉子。哲学家比较笨，他们必须拿到左手和右手的 2 个叉子才能吃面。哲学不饿的时候就在思考，饿了就去吃面，吃面的必须前提是拿到 2 个叉子，吃完面哲学家就去思考。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628162006.png" alt="image-20210628162006422"></p>
<h4 id="问题的抽象"><a href="#问题的抽象" class="headerlink" title="问题的抽象"></a>问题的抽象</h4><p>接下来请你继续思考，我们对问题进行一些抽象，比如哲学是一个数组，编号 0~4。我这里用 Java 语言给你演示，哲学家是一个类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Philosopher[] philosophers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">       philosophers = <span class="keyword">new</span> Philosopher[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里考虑叉子也使用编号 0~4，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer[] forks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Philosopher[] philosophers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        philosophers[i] = <span class="keyword">new</span> Philosopher(i);</span><br><span class="line">        forks[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>forks[i]</code>的值等于 x，相当于编号为<code>i</code>的叉子被编号为 x 的哲学家拿起；如果等于<code>-1</code>，那么叉子目前放在桌子上。</p>
<p>我们经常需要描述左、右的关系，为了方便计算，可以设计 1 个帮助函数（helper functions），帮助我们根据一个编号，计算它左边的编号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LEFT</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">4</span> : i-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设和哲学家编号一致的叉子在右边，这样如果要判断编号为<code>id</code>哲学家是否可以吃面，需要这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(forks[LEFT(id)] == id &amp;&amp; forks[id] == id) &#123;</span><br><span class="line">  <span class="comment">// 可以吃面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个<code>_take</code>函数拿起编号为<code>i</code>叉子; 再设计一个<code>_put</code>方法放下叉子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_take</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    forks[i] = id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_put</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(forks[i] == id)</span><br><span class="line"></span><br><span class="line">    forks[i] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>forks[i]</code>的值等于 x，相当于编号为<code>i</code>的叉子被编号为 x 的哲学家拿起；如果等于<code>-1</code>，那么叉子目前放在桌子上。</p>
<p>我们经常需要描述左、右的关系，为了方便计算，可以设计 1 个帮助函数（helper functions），帮助我们根据一个编号，计算它左边的编号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> private static int LEFT(int i) &#123;</span><br><span class="line">      return i == 0 ? 4 : i-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设和哲学家编号一致的叉子在右边，这样如果要判断编号为<code>id</code>哲学家是否可以吃面，需要这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(forks[LEFT(id)] == id &amp;&amp; forks[id] == id) &#123;</span><br><span class="line">  <span class="comment">// 可以吃面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个<code>_take</code>函数拿起编号为<code>i</code>叉子; 再设计一个<code>_put</code>方法放下叉子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_take</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    forks[i] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_put</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(forks[i] == id)</span><br><span class="line">    forks[i] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_take</code>函数之所以会等待 10ms，是因为<strong>哲学家就餐问题的实际意义，是 I/O 处理的场景，拿起叉子好比读取磁盘，需要有一等的时间开销，这样思考才有意义</strong>。</p>
<p>然后是对<code>think</code>和<code>eat</code>两个方法的抽象。首先我封装了一个枚举类型，描述哲学家的状态，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> PHIS &#123;</span><br><span class="line"></span><br><span class="line">    THINKING,</span><br><span class="line"></span><br><span class="line">    HUNGRY,</span><br><span class="line"></span><br><span class="line">    EATING</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现<code>think</code>方法，<code>think</code>方法不需要并发控制，但是这里用<code>Thread.sleep</code>模拟实际思考需要的开销，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">think</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(String.format(<span class="string">"Philosopher %d thinking..."</span>, id));</span><br><span class="line"></span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) Math.floor(Math.random()*<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.state = PHIS.HUNGRY;</span><br></pre></td></tr></table></figure>

<p>最后是<code>eat</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (forks) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(forks[LEFT(id)] == id &amp;&amp; forks[id] == id) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">this</span>.state = PHIS.EATING;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread.sleep((<span class="keyword">long</span>) Math.floor(Math.random()*<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>eat</code>方法依赖于<code>forks</code>对象的锁，相当于<code>eat</code>方法这里会同步——因为这里有读取临界区操作做。<code>Thread.sleep</code>依然用于描述<code>eat</code>方法的时间开销。<code>sleep</code>方法没有放到<code>synchronized</code>内是因为<strong>在并发控制时，应该尽量较少锁的范围，这样可以增加更大的并发量</strong>。</p>
<p>以上，我们对问题进行了一个基本的抽象。接下来请你思考在什么情况会发生死锁？</p>
<h4 id="死锁（DeadLock）和活锁（LiveLock）"><a href="#死锁（DeadLock）和活锁（LiveLock）" class="headerlink" title="死锁（DeadLock）和活锁（LiveLock）"></a>死锁（DeadLock）和活锁（LiveLock）</h4><p>首先，可以思考一种最简单的解法，每个哲学家用一个<code>while</code>循环表示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">  think();</span><br><span class="line"></span><br><span class="line">  _take(LEFT(id)); </span><br><span class="line"></span><br><span class="line">  _take(id);</span><br><span class="line"></span><br><span class="line">  eat();</span><br><span class="line"></span><br><span class="line">  _put(LEFT(id));</span><br><span class="line"></span><br><span class="line">  _put(id); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_take</span><span class="params">(id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(forks[id] != -<span class="number">1</span>) &#123;  Thread.yield();  &#125;</span><br><span class="line">  Thread.sleep(<span class="number">10</span>); <span class="comment">// 模拟I/O用时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_take</code>可以考虑阻塞，直到哲学家得到叉子。上面程序我们还没有进行并发控制，会发生竞争条件。 顺着这个思路，就可以想到加入并发控制，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">  think();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span>(fork[LEFT(id)]) &#123;</span><br><span class="line">    _take(LEFT(id)); </span><br><span class="line">    <span class="keyword">synchronized</span>(fork[id]) &#123;</span><br><span class="line">      _take(id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  eat();</span><br><span class="line">  <span class="keyword">synchronized</span>(fork[LEFT(id)]) &#123;</span><br><span class="line">    _put(LEFT(id));</span><br><span class="line">    <span class="keyword">synchronized</span>(fork[id]) &#123;</span><br><span class="line">      _put(id); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的并发控制，会发生死锁问题，大家可以思考这样一个时序，如果 5 个哲学家都同时通过<code>synchronized(fork[LEFT(id)])</code>，有可能会出现下面的情况：</p>
<ul>
<li>第 0 个哲学家获得叉子 4，接下来请求叉子 0；</li>
<li>第 1 个哲学家获得叉子 0，接下来请求叉子 1；</li>
<li>第 2 个哲学家获得叉子 1，接下来请求叉子 2；</li>
<li>第 3 个哲学家获得叉子 2，接下来请求叉子 3；</li>
<li>第 4 个哲学家获得叉子 3，接下来请求叉子 4。</li>
</ul>
<p>为了帮助你理解，这里我画了一幅图。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628164745.png" alt="image-20210628164745775"></p>
<p>如上图所示，可以看到这是一种循环依赖的关系，在这种情况下所有哲学家都获得了一个叉子，并且在等待下一个叉子。这种等待永远不会结束，因为没有哲学家愿意放弃自己拿起的叉子。</p>
<p>以上这种情况称为<strong>死锁（Deadlock），</strong>这是一种<strong>饥饿（Starvation）</strong>的形式。从概念上说，死锁是线程间互相等待资源，但是没有一个线程可以进行下一步操作。饥饿就是因为某种原因导致线程得不到需要的资源，无法继续工作。死锁是饥饿的一种形式，因为循环等待无法得到资源。哲学家就餐问题，会形成一种环状的死锁（循环依赖）， 因此非常具有代表性。</p>
<p>死锁有 4 个基本条件。</p>
<ol>
<li><strong>资源存在互斥逻辑：每次只有一个线程可以抢占到资源</strong>。这里是哲学家抢占叉子。</li>
<li><strong>持有等待</strong>：这里哲学家会一直等待拿到叉子。</li>
<li><strong>禁止抢占：如果拿不到资源一直会处于等待状态，而不会释放已经拥有的资源</strong>。</li>
<li><strong>循环等待</strong>：这里哲学家们会循环等待彼此的叉子。</li>
</ol>
<p>刚才提到死锁也是一种饥饿（Starvation）的形式，饥饿比较简单，就是线程长期拿不到需要的资源，无法进行下一步操作。</p>
<p>要解决死锁的问题，可以考虑哲学家拿起 1 个叉子后，如果迟迟没有等到下一个叉子，就放弃这次操作。比如 Java 的 Lock Interface 中，提供的<code>tryLock</code>方法，就可以实现定时获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>Java 提供的这个能力是拿不到锁，就报异常，并可以依据这个能力开发释放已获得资源的能力。</p>
<p>但是这样，我们会碰到一个叫作活锁（LiveLock）的问题。LiveLock 也是一种饥饿。可能在某个时刻，所有哲学及都拿起了左手的叉子，然后发现右手的叉子拿不到，就放下了左手的叉子——如此周而复始，这就是一种活锁。所有线程都在工作，但是没有线程能够进一步——解决问题。</p>
<p>在实际工作场景下，LiveLock 可以靠概率解决，因为同时拿起，又同时放下这种情况不会很多。实际工作场景很多系统，确实依赖于这个问题不频发。但是，优秀的设计者不能把系统设计依托在一个有概率风险的操作上，因此我们需要继续往深一层思考。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>其实解决上述问题有很多的方案，最简单、最直观的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(someLock) &#123;</span><br><span class="line"></span><br><span class="line">      think();</span><br><span class="line"></span><br><span class="line">      _take(LEFT(id)); </span><br><span class="line"></span><br><span class="line">      _take(id);</span><br><span class="line"></span><br><span class="line">      eat();</span><br><span class="line"></span><br><span class="line">      _put(LEFT(id));</span><br><span class="line"></span><br><span class="line">      _put(id); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段程序同时只允许一个哲学家使用所有资源，我们用<code>synchronized</code>构造了一种排队的逻辑。而哲学家，每次必须拿起所有的叉子，吃完，再到下一哲学家。 这样并发度是 1，同时最多有一个线程在执行。 这样的方式可以完成任务，但是性能太差。</p>
<p>另一种方法是规定拿起过程必须同时拿起，放下过程也同时放下，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    think();</span><br><span class="line">    <span class="keyword">synchronized</span>(someLock) &#123;</span><br><span class="line">      _takeForks(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(someLock) &#123;</span><br><span class="line"></span><br><span class="line">      _puts();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_takeForks</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( forks[LEFT(id)] == -<span class="number">1</span> &amp;&amp; forks[id] == -<span class="number">1</span> ) &#123;</span><br><span class="line"></span><br><span class="line">    forks[LEFT(id)] = id;</span><br><span class="line"></span><br><span class="line">    forks[id] = id;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_puts</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(forks[LEFT(id)] == id)</span><br><span class="line"></span><br><span class="line">      forks[LEFT(id)] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(forks[id] == id)</span><br><span class="line"></span><br><span class="line">      forks[id] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段程序，<code>think</code>函数没有并发控制，一个哲学家要么拿起两个叉子，要么不拿起，这样并发度最高为 2（最多有两个线程同时执行）。而且，这个算法中只有一个锁，因此不存在死锁和饥饿问题。</p>
<p>到这里，我们已经对这个问题有了一个初步的方案，那么如何进一步优化呢？</p>
<h4 id="思考和最终方案"><a href="#思考和最终方案" class="headerlink" title="思考和最终方案"></a>思考和最终方案</h4><p>整个问题复杂度的核心在于哲学家拿起叉子是有成本的。好比线程读取磁盘，需要消耗时间。哲学家的思考，是独立的。好比读取了磁盘数据，进行计算。那么有没有办法允许 5 个哲学家都同时去拿叉子呢？这样并发度是最高的。</p>
<p>经过初步思考，马上会发现这里有环状依赖， 会出现<strong>死锁</strong>。 原因就是如果 5 个哲学家同时拿叉子，那就意味着有的哲学家必须要放弃叉子。但是如果不放下会出现什么情况呢？</p>
<p>假设当一个哲学家发现自己拿不到两个叉子的时候，他去和另一个哲学家沟通把自己的叉子给对方。这样就相当于，有一个转让方法。相比于磁盘 I/O，转让内存中的数据成本就低的多了。 我们假设有这样一个转让的方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">_transfer</span><span class="params">(<span class="keyword">int</span> fork, <span class="keyword">int</span> philosopher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      forks[fork] = philosopher;</span><br><span class="line"></span><br><span class="line">dirty[fork] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法相当于把叉子转让给另一个哲学家，这里你先不用管上面代码中的 dirty，后文中会讲到。而获取叉子的过程，我们可以进行调整，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (forks[i]) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(forks[i] == -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">              _take(id); </span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              Philosopher other = philosophers[forks[i]];</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(other.state != PHIS.EATING &amp;&amp; dirty[i]) &#123;</span><br><span class="line"></span><br><span class="line">                  other._transfer(i, forks[i]);</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_take</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    forks[i] = id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们把每个叉子看作一个锁，有多少个叉子，就有多少个锁，相当于同时可以拿起 5 个叉子（并发度是 5）。如果当前没有人拿起叉子，那么可以自己拿起。 如果叉子属于其他哲学家，就需要判断对方的状态。只要对方不在<code>EATING</code>，就可以考虑转让叉子。</p>
<p>最后是对 LiveLock 的思考，为了避免叉子在两个哲学家之间来回转让，我们为每个叉子增加了一个<code>dirty</code>属性。一开始叉子的<code>dirty</code>是<code>true</code>，每次转让后，哲学家会把自己的叉子擦干净给另一个哲学家。转让的前置条件是叉子是<code>dirty</code>的，所以叉子在两个哲学家之间只会转让一次。</p>
<p>通过上面算法，我们就可以避免死锁、饥饿以及提高读取数据（获取叉子）的并发度。最后完整的程序如下，给你做参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class DiningPhilosophers &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    enum PHIS &#123;</span><br><span class="line"></span><br><span class="line">        THINKING,</span><br><span class="line"></span><br><span class="line">        HUNGRY,</span><br><span class="line"></span><br><span class="line">        EATING</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Philosopher implements Runnable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private static Philosopher[] philosophers;</span><br><span class="line"></span><br><span class="line">        private static Integer[] forks;</span><br><span class="line"></span><br><span class="line">        private static boolean[] dirty;</span><br><span class="line"></span><br><span class="line">        private PHIS state = PHIS.THINKING;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line"></span><br><span class="line">            philosophers = new Philosopher[5];</span><br><span class="line"></span><br><span class="line">            forks = new Integer[5];</span><br><span class="line"></span><br><span class="line">            dirty = new boolean[5];</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line"></span><br><span class="line">                philosophers[i] = new Philosopher(i);</span><br><span class="line"></span><br><span class="line">                forks[i] = -1;</span><br><span class="line"></span><br><span class="line">                dirty[i] = true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private static int LEFT(int i) &#123;</span><br><span class="line"></span><br><span class="line">            return i == 0 ? 4 : i-1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public Philosopher(int id) &#123;</span><br><span class="line"></span><br><span class="line">            this.id = id;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private int id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        void think() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(String.format(&quot;Philosopher %d thinking...&quot;, id));</span><br><span class="line"></span><br><span class="line">            Thread.sleep((long) Math.floor(Math.random()*1000));</span><br><span class="line"></span><br><span class="line">            this.state = PHIS.HUNGRY;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">             System.out.println(Arrays.toString(forks));</span><br><span class="line"></span><br><span class="line">                    //System.out.println(Arrays.toString(dirty));</span><br><span class="line"></span><br><span class="line">                    if(forks[LEFT(id)] == id &amp;&amp; forks[id] == id) &#123;</span><br><span class="line"></span><br><span class="line">                        this.state = PHIS.EATING;</span><br><span class="line"></span><br><span class="line">                    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                        return;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(String.format(&quot;Philosopher %d eating...&quot;, id));</span><br><span class="line"></span><br><span class="line">            Thread.sleep((long) Math.floor(Math.random()*1000));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            synchronized (forks) &#123;</span><br><span class="line"></span><br><span class="line">                dirty[LEFT(id)] = true;</span><br><span class="line"></span><br><span class="line">                dirty[id] = true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            var lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">            lock.tryLock(5, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            state = PHIS.THINKING;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        void _take(int i) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(10);</span><br><span class="line"></span><br><span class="line">            forks[i] = id;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        void _transfer(int fork, int philosopher) &#123;</span><br><span class="line"></span><br><span class="line">            forks[fork] = philosopher;</span><br><span class="line"></span><br><span class="line">            dirty[fork] = false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        void _putdown(int i) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(10);</span><br><span class="line"></span><br><span class="line">            forks[i] = -1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        void take(int i) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            synchronized (forks[i]) &#123;</span><br><span class="line"></span><br><span class="line">                if(forks[i] == -1) &#123;</span><br><span class="line"></span><br><span class="line">                    _take(id);</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    Philosopher other = philosophers[forks[i]];</span><br><span class="line"></span><br><span class="line">                    if(other.state != PHIS.EATING &amp;&amp; dirty[i]) &#123;</span><br><span class="line"></span><br><span class="line">                        other._transfer(i, forks[i]);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void takeForks() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            take(LEFT(id));</span><br><span class="line"></span><br><span class="line">            take(id);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line"></span><br><span class="line">                while(true) &#123;</span><br><span class="line"></span><br><span class="line">                    think();</span><br><span class="line"></span><br><span class="line">                    while (state == PHIS.HUNGRY) &#123;</span><br><span class="line"></span><br><span class="line">                        takeForks();</span><br><span class="line"></span><br><span class="line">                        System.out.println(&quot;here--&quot; + Math.random());</span><br><span class="line"></span><br><span class="line">                        eat();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line"></span><br><span class="line">            new Thread(new Philosopher(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么情况下会触发饥饿和死锁？</strong></p>
<p><strong>【解析】</strong> 线程需要资源没有拿到，无法进行下一步，就是饥饿。死锁（Deadlock）和活锁（Livelock）都是饥饿的一种形式。 非抢占的系统中，互斥的资源获取，形成循环依赖就会产生死锁。死锁发生后，如果利用抢占解决，导致资源频繁被转让，有一定概率触发活锁。死锁、活锁，都可以通过设计并发控制算法解决，比如哲学家就餐问题。</p>
<h3 id="进程间通信都有哪些方法？"><a href="#进程间通信都有哪些方法？" class="headerlink" title="进程间通信都有哪些方法？"></a><strong>进程间通信都有哪些方法？</strong></h3><p>在上一讲中，我们提到过，凡是面试官问“<strong>什么情况下</strong>”的时候，面试官实际想听的是你经过理解，整理得到的认知。回答应该是概括的、简要的。而不是真的去列举每一种 case。</p>
<p>另外，<strong>面试官考察进程间通信，有一个非常重要的意义——进程间通信是架构复杂系统的基石</strong>。复杂系统往往是分成各种子系统、子模块、微服务等等，按照 Unix 的设计哲学，系统的每个部分应该是稳定、独立、简单有效，而且强大的。系统本身各个模块就像人的器官，可以协同工作。而这个协同的枢纽，就是我们今天的主题——进程间通信。</p>
<h4 id="什么是进程间通信？"><a href="#什么是进程间通信？" class="headerlink" title="什么是进程间通信？"></a>什么是进程间通信？</h4><p>进程间通信（Intermediate Process Communication，IPC）。所谓通信就是交换数据。所以，狭义地说，就是操作系统创建的进程们之间在交换数据。 我们今天不仅讨论狭义的通信，还要讨论 IPC 更广泛的意义——程序间的通信。 程序可以是进程，可以是线程，可以是一个进程的两个部分（进程自己发送给自己），也可以是分布式的——总之，今天讨论的是广义的交换数据。</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>之前我们在“<strong>07 | 进程、重定向和管道指令：xargs 指令的作用是</strong>？”中讲解过管道和命名管道。 管道提供了一种非常重要的能力，就是组织计算。进程不用知道有管道存在，因此管道的设计是非侵入的。程序员可以先着重在程序本身的设计，只需要预留响应管道的接口，就可以利用管道的能力。比如用<code>shell</code>执行MySQL语句，可能会这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程1 | 进程2 | 进程3 | mysql -u... -p | 爬虫进程</span><br></pre></td></tr></table></figure>

<p>我们可以由进程 1、进程 2、进程 3 计算出 MySQL 需要的语句，然后直接通过管道执行。MySQL经过计算将结果传给一个爬虫进程，爬虫就开始工作。MySQL并不是设计用于管道，爬虫进程也不是设计专门用于管道，只是程序员恰巧发现可以这样用，完美地解决了自己的问题，比如：用管道构建一个微型爬虫然后把结果入库。</p>
<p>我们还学过一个词叫作<strong>命名管道</strong>。命名管道并没有改变管道的用法。相比匿名管道，命名管道提供了更多的编程手段。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程1 &gt; namedpipe</span><br><span class="line">进程2 &gt; namedpipe</span><br></pre></td></tr></table></figure>

<p>上面的程序将两个进程的临时结果都同时重定向到 namedpipe，相当于把内容合并了再找机会处理。再比如说，你的进程要不断查询本地的 MySQL，也可以考虑用命名管道将查询传递给 MySQL，再用另一个命名管道传递回来。这样可以省去和 localhost 建立 TCP 3 次握手的时间。 当然，现在数据库都是远程的了，这里只是一个例子。</p>
<p>管道的核心是不侵入、灵活，不会增加程序设计负担，又能组织复杂的计算过程。</p>
<h4 id="本地内存共享"><a href="#本地内存共享" class="headerlink" title="本地内存共享"></a>本地内存共享</h4><p>同一个进程的多个线程本身是共享进程内存的。 这种情况不需要特别考虑共享内存。如果是跨进程的线程（或者理解为跨进程的程序），可以考虑使用共享内存。内存共享是现代操作系统提供的能力， Unix 系操作系统，包括 Linux 中有 POSIX 内存共享库——shmem。（如果你感兴趣可以参考<a href="https://www.man7.org/linux/man-pages/man7/shm_overview.7.html" target="_blank" rel="noopener">网页中的内容</a>，这里不做太深入地分析。）Linux 内存共享库的实现原理是以虚拟文件系统的形式，从内存中划分出一块区域，供两个进程共同使用。看上去是文件，实际操作是内存。</p>
<p>共享内存的方式，速度很快，但是程序不是很好写，因为这是一种侵入式的开发，也就是说你需要为此撰写大量的程序。比如如果修改共享内存中的值，需要调用 API。如果考虑并发控制，还要处理同步问题等。因此，只要不是高性能场景，进程间通信通常不考虑共享内存的方式。</p>
<h4 id="本地消息-队列"><a href="#本地消息-队列" class="headerlink" title="本地消息/队列"></a>本地消息/队列</h4><p>内存共享不太好用，因此本地消息有两种常见的方法。一种是用消息队列——现代操作系统都会提供类似的能力。Unix 系可以使用 POSIX 标准的 mqueue。另一种方式，就是直接用网络请求，比如 TCP/IP 协议，也包括建立在这之上的更多的通信协议（这些我们在下文中的“<strong>远程调用</strong>”部分详细讲解）。</p>
<p>本质上，这些都是收/发消息的模式。进程将需要传递的数据封装成格式确定的消息，这对写程序非常有帮助。程序员可以根据消息类型，分门别类响应消息；也可以根据消息内容，触发特殊的逻辑操作。在消息体量庞大的情况下，也可以构造生产者队列和消费者队列，用并发技术进行处理。</p>
<h4 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h4><p>远程调用（Remote Procedure Call，RPC）是一种通过本地程序调用来封装远程服务请求的方法。</p>
<p>程序员调用 RPC 的时候，程序看上去是在调用一个本地的方法，或者执行一个本地的任务，但是后面会有一个服务程序（通常称为 stub），将这种本地调用转换成远程网络请求。 同理，服务端接到请求后，也会有一个服务端程序（stub），将请求转换为一个真实的服务端方法调用。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628170950.png" alt="image-20210628170949931"></p>
<p>你可以观察上面这张图，表示客户端和服务端通信的过程，一共是 10 个步骤，分别是：</p>
<ol>
<li>客户端调用函数（方法）；</li>
<li>stub 将函数调用封装为请求；</li>
<li>客户端 socket 发送请求，服务端 socket 接收请求；</li>
<li>服务端 stub 处理请求，将请求还原为函数调用；</li>
<li>执行服务端方法；</li>
<li>返回结果传给 stub；</li>
<li>stub 将返回结果封装为返回数据；</li>
<li>服务端 socket 发送返回数据，客户端 socket 接收返回数据；</li>
<li>客户端 socket 将数据传递给客户端 stub；</li>
<li>客户端 stub 把返回数据转义成函数返回值。</li>
</ol>
<p>RPC 调用过程有很多约定， 比如函数参数格式、返回结果格式、异常如何处理。还有很多细粒度的问题，比如处理 TCP 粘包、处理网络异常、I/O 模式选型——其中有很多和网络相关的知识比较复杂，你可以参考我将在拉勾教育上线的《<strong>计算机网络》专栏</strong>。</p>
<p>上面这些问题比较棘手，因此在实战中通常的做法是使用框架。比如 Thrift 框架（Facebook 开源）、Dubbo 框架（阿里开源）、grpc（Google 开源）。这些 RPC 框架通常支持多种语言，这需要一个接口定义语言支持在多个语言间定义接口（IDL）。</p>
<p>RPC 调用的方式比较适合微服务环境的开发，当然 RPC 通常需要专业团队的框架以支持高并发、低延迟的场景。不过，硬要说 RPC 有额外转化数据的开销（主要是序列化），也没错，但这不是 RPC 的主要缺点。<strong>RPC 真正的缺陷是增加了系统间的耦合</strong>。<strong>当系统主动调用另一个系统的方法时</strong>，<strong>就意味着在增加两个系统的耦合</strong>。<strong>长期增加 RPC 调用</strong>，<strong>会让系统的边界逐渐腐</strong>化。这才是使用 RPC 时真正需要注意的东西。</p>
<p><strong>进程间通信都有哪些方法？</strong></p>
<p><strong>【解析】</strong> 你可以从<strong>单机和分布式角度</strong>给面试管阐述。</p>
<ul>
<li>如果考虑单机模型，有管道、内存共享、消息队列。这三个模型中，内存共享程序最难写，但是性能最高。管道程序最好写，有标准接口。消息队列程序也比较好写，比如用发布/订阅模式实现具体的程序。</li>
<li>如果考虑分布式模型，就有远程调用、消息队列和网络请求。直接发送网络请求程序不好写，不如直接用实现好的 RPC 调用框架。RPC 框架会增加系统的耦合，可以考虑 消息队列，以及发布订阅事件的模式，这样可以减少系统间的耦合。</li>
</ul>
<h3 id="服务应该开多少个进程、多少个线程？"><a href="#服务应该开多少个进程、多少个线程？" class="headerlink" title="服务应该开多少个进程、多少个线程？"></a><strong>服务应该开多少个进程、多少个线程？</strong></h3><h4 id="计算密集型和-I-O-密集型"><a href="#计算密集型和-I-O-密集型" class="headerlink" title="计算密集型和 I/O 密集型"></a>计算密集型和 I/O 密集型</h4><p>通常我们会遇到两种任务，一种是计算、一种是 I/O。</p>
<p><strong>计算</strong>，就是利用 CPU 处理算数运算。比如深度神经网络（Deep Neural Networks），需要大量的计算来计算神经元的激活和传播。再比如，根据营销规则计算订单价格，虽然每一个订单只需要少量的计算，但是在并发高的时候，所有订单累计加起来就需要大量计算。如果一个应用的主要开销在计算上，我们称为<strong>计算密集型</strong>。</p>
<p>再看看 <strong>I/O 密集型</strong>，I/O 本质是对设备的读写。读取键盘的输入是 I/O，读取磁盘（SSD）的数据是 I/O。通常 CPU 在设备 I/O 的过程中会去做其他的事情，当 I/O 完成，设备会给 CPU 一个中断，告诉 CPU 响应 I/O 的结果。比如说从硬盘读取数据完成了，那么硬盘给 CPU 一个中断。如果操作对 I/O 的依赖强，比如频繁的文件操作（写日志、读写数据库等），可以看作<strong>I/O 密集型</strong>。</p>
<p>你可能会有一个疑问，<strong>读取硬盘数据到内存中这个过程，CPU 需不需要一个个字节处理</strong>？</p>
<p>通常是不用的，因为在今天的计算机中有一个叫作 Direct Memory Access（DMA）的模块，这个模块允许硬件设备直接通过 DMA 写内存，而不需要通过 CPU（占用 CPU 资源）。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628171637.png" alt="image-20210628171637337"></p>
<p>很多情况下我们没法使用 DMA，比如说你想把一个数组拷贝到另一个数组内，执行的 memcpy 函数内部实现就是一个个 byte 拷贝，这种情况也是一种<strong>CPU 密集的操作</strong>。</p>
<p>可见，区分是计算密集型还是 I/O 密集型这件事比较复杂。按说查询数据库是一件 I/O 密集型的事情，但是如果存储设备足够好，比如用了最好的固态硬盘阵列，I/O 速度很快，反而瓶颈会在计算上（对缓存的搜索耗时成为主要部分）。因此，需要一些可衡量指标，来帮助我们确认应用的特性。</p>
<h4 id="衡量-CPU-的工作情况的指标"><a href="#衡量-CPU-的工作情况的指标" class="headerlink" title="衡量 CPU 的工作情况的指标"></a>衡量 CPU 的工作情况的指标</h4><p>我们先来看一下 CPU 关联的指标。如下图所示：CPU 有 2 种状态，忙碌和空闲。此外，CPU 的时间还有一种被偷走的情况。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628171759.png" alt="image-20210628171758977"></p>
<p>忙碌就是 CPU 在执行有意义的程序，空闲就是 CPU 在执行让 CPU 空闲（空转）的指令。通常让 CPU 空转的指令能耗更低，因此让 CPU 闲置时，我们会使用特别的指令，最终效果和让 CPU 计算是一样的，都可以把 CPU 执行时间填满，只不过这类型指令能耗低一些而已。除了忙碌和空闲，CPU 的时间有可能被宿主偷走，比如一台宿主机器上有 10 个虚拟机，宿主可以偷走给任何一台虚拟机的时间。</p>
<p>如上图所示，CPU 忙碌有 3 种情况：</p>
<ol>
<li>执行用户空间程序；</li>
<li>执行内核空间程序；</li>
<li>执行中断程序。</li>
</ol>
<p>CPU 空闲有 2 种情况。</p>
<ol>
<li>CPU 无事可做，执行空闲指令（注意，不能让 CPU 停止工作，而是执行能耗更低的空闲指令）。</li>
<li>CPU 因为需要等待 I/O 而空闲，比如在等待磁盘回传数据的中断，这种我们称为 I/O Wait。</li>
</ol>
<p>下图是我们执行 top 指令看到目前机器状态的快照，接下来我们仔细研究一下这些指标的含义：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628171907.png" alt="image-20210628171906894"></p>
<p>如上图所示，你可以细看下 <strong>%CPU(s)</strong> 开头那一行（第 3 行）：</p>
<ol>
<li>us（user），即用户空间 CPU 使用占比。</li>
<li>sy（system），即内核空间 CPU 使用占比。</li>
<li>ni（nice），nice 是 Unix 系操作系统控制进程优先级用的。-19 是最高优先级， 20 是最低优先级。这里代表了调整过优先级的进程的 CPU 使用占比。</li>
<li>id（idle），闲置的 CPU 占比。</li>
<li>wa（I/O Wait），I/O Wait 闲置的 CPU 占比。</li>
<li>hi（hardware interrupts），响应硬件中断 CPU 使用占比。</li>
<li>si（software interrrupts），响应软件中断 CPU 使用占比。</li>
<li>st（stolen），如果当前机器是虚拟机，这个指标代表了宿主偷走的 CPU 时间占比。对于一个宿主多个虚拟机的情况，宿主可以偷走任何一台虚拟机的 CPU 时间。</li>
</ol>
<p>上面我们用 top 看的是一个平均情况，如果想看所有 CPU 的情况可以 top 之后，按一下<code>1</code>键。结果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628172018.png" alt="image-20210628172018226"></p>
<p>当然，对性能而言，CPU 数量也是一个重要因素。可以看到我这台虚拟机一共有 16 个核心。</p>
<h3 id="负载指标"><a href="#负载指标" class="headerlink" title="负载指标"></a>负载指标</h3><p>上面的指标非常多，在排查问题的时候，需要综合分析。其实还有一些更简单的指标，比如上图中 top 指令返回有一项叫作<code>load average</code>——平均负载。 负载可以理解成某个时刻正在排队执行的进程数除以 CPU 核数。平均负载需要多次采样求平均值。 如果这个值大于<code>1</code>，说明 CPU 相当忙碌。因此如果你想发现问题，可以先检查这个指标。</p>
<p>具体来说，如果平均负载很高，CPU 的 I/O Wait 也很高， 那么就说明 CPU 因为需要大量等待 I/O 无法处理完成工作。产生这个现象的原因可能是：线上服务器打日志太频繁，读写数据库、网络太频繁。你可以考虑进行批量读写优化。</p>
<p>到这里，你可能会有一个疑问：为什么批量更快呢？我们知道一次写入 1M 的数据，就比写一百万次一个 byte 快。因为前者可以充分利用 CPU 的缓存、复用发起写操作程序的连接和缓冲区等。</p>
<p>如果想看更多<code>load average</code>，你可以看<code>/proc/loadavg</code>文件。</p>
<h3 id="通信量（Traffic）"><a href="#通信量（Traffic）" class="headerlink" title="通信量（Traffic）"></a>通信量（Traffic）</h3><p>如果怀疑瓶颈发生在网络层面，或者想知道当前网络状况。可以查看<code>/proc/net/dev</code>，下图是在我的虚拟机上的查询结果：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628174552.png" alt="image-20210628174552044"></p>
<p>我们来一起看一下上图中的指标。表头分成了 3 段：</p>
<ul>
<li>Interface（网络接口），可以理解成网卡</li>
<li>Receive：接收的数据</li>
<li>Transmit：发送的数据</li>
</ul>
<p>然后再来看具体的一些参数：</p>
<ul>
<li>byte 是字节数</li>
<li>package 是封包数</li>
<li>erros 是错误数</li>
<li>drop 是主动丢弃的封包，比如说时间窗口超时了</li>
<li>fifo: FIFO 缓冲区错误（<strong>如果想了解更多可以关注我即将推出的《计算机网络》专栏</strong>）</li>
<li>frame: 底层网络发生了帧错误，代表数据出错了</li>
</ul>
<p>如果你怀疑自己系统的网络有故障，可以查一下通信量部分的参数，相信会有一定的收获。</p>
<h4 id="衡量磁盘工作情况"><a href="#衡量磁盘工作情况" class="headerlink" title="衡量磁盘工作情况"></a>衡量磁盘工作情况</h4><p>有时候 I/O 太频繁导致磁盘负载成为瓶颈，这个时候可以用<code>iotop</code>指令看一下磁盘的情况，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628174702.png" alt="image-20210628174702314"></p>
<p>上图中是磁盘当前的读写速度以及排行较靠前的进程情况。</p>
<p>另外，如果磁盘空间不足，可以用<code>df</code>指令：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628174718.png" alt="image-20210628174718444"></p>
<p>其实 df 是按照挂载的文件系统计算空间。图中每一个条目都是一个文件系统。有的文件系统直接挂在了一个磁盘上，比如图中的<code>/dev/sda5</code>挂在了<code>/</code>上，因此这样可以看到各个磁盘的使用情况。</p>
<p>如果想知道更细粒度的磁盘 I/O 情况，可以查看<code>/proc/diskstats</code>文件。 这里有 20 多个指标我就不细讲了，如果你将来怀疑自己系统的 I/O 有问题，可以查看这个文件，并阅读相关手册。</p>
<h4 id="监控平台"><a href="#监控平台" class="headerlink" title="监控平台"></a>监控平台</h4><p>Linux 中有很多指令可以查看服务器当前的状态，有 CPU、I/O、通信、Nginx 等维度。如果去记忆每个指令自己搭建监控平台，会非常复杂。这里你可以用市面上别人写好的开源系统帮助你收集这些资料。 比如 Taobao System Activity Report（tsar）就是一款非常好用的工具。它集成了大量诸如上面我们使用的工具，并且帮助你定时收集服务器情况，还能记录成日志。你可以用 logstash 等工具，及时将日志收集到监控、分析服务中，比如用 ELK 技术栈。</p>
<h4 id="决定进程-线程数量"><a href="#决定进程-线程数量" class="headerlink" title="决定进程/线程数量"></a>决定进程/线程数量</h4><p>最后我们讲讲如何决定线程、进程数量。 上面观察指标是我们必须做的一件事情，通过观察上面的指标，可以对我们开发的应用有一个基本的认识。</p>
<p>下面请你思考一个问题：<strong>如果线程或进程数量 = CPU 核数，是不是一个好的选择</strong>？</p>
<p>有的应用不提供线程，比如 PHP 和 Node.js。</p>
<p>Node.js 内部有一个事件循环模型，这个模型可以理解成协程（Coroutine），相当于大量的协程复用一个进程，可以达到比线程池更高的效率（减少了线程切换）。PHP 模型相对则差得多。Java 是一个多线程的模型，线程和内核线程对应比 1：1；Go 有轻量级线程，多个轻量级线程复用一个内核级线程。</p>
<p>以 Node.js 为例，如果现在是 8 个核心，那么开 8 个 Node 进程，是不是就是最有效利用 CPU 的方案呢？ 乍一看——8 个核、8 个进程，每个进程都可以使用 1 个核，CPU 利用率很高——其实不然。 你不要忘记，CPU 中会有一部分闲置时间是 I/O Wait，这个时候 CPU 什么也不做，主要时间用于等待 I/O。</p>
<p>假设我们应用执行的期间只用 50% CPU 的执行时间，其他 50% 是 I/O Wait。那么 1 个 CPU 同时就可以执行两个进程/线程。</p>
<p>我们考虑一个更一般的模型，如果你的应用平均 I/O 时间占比是 P，假设现在内存中有 n 个这样的线程，那么 CPU 的利用率是多少呢？</p>
<p>假设我们观察到一个应用 （进程），I/O 时间占比是 P，那么可以认为这个进程等待 I/O 的概率是 P。那么如果有 n 个这样的线程，n 个线程都在等待 I/O 的概率是Pn。而满负荷下，CPU 的利用率就是 CPU 不能空转——也就是不能所有进程都在等待 I/O。因此 CPU 利用率 = 1 -Pn。</p>
<p>理论上，如果 P = 50%，两个这样的进程可以达到满负荷。 但是从实际出发，何时运行线程是一个分时的调度行为，实际的 CPU 利用率还要看开了多少个这样的线程，如果是 2 个，那么还是会有一部分闲置资源。</p>
<p>因此在实际工作中，开的线程、进程数往往是超过 CPU 核数的。<strong>你可能会问，具体是多少最好呢</strong>？——这里没有具体的算法，要以实际情况为准。比如：你先以 CPU 核数 3 倍的线程数开始，然后进行模拟真实线上压力的测试，分析压测的结果。</p>
<ul>
<li>如果发现整个过程中，瓶颈在 CPU，比如<code>load average</code>很高，那么可以考虑优化 I/O Wait，让 CPU 有更多时间计算。</li>
<li>当然，如果 I/O Wait 优化不动了，算法都最优了，就是磁盘读写速度很高达到瓶颈，可以考虑延迟写、延迟读等等技术，或者优化减少读写。</li>
<li>如果发现 idle 很高，CPU 大面积闲置，就可以考虑增加线程。</li>
</ul>
<p><strong>我的服务应该开多少个进程、多少个线程？</strong></p>
<p><strong>【解析】</strong> 计算密集型一般接近核数，如果负载很高，建议留一个内核专门给操作系统。I/O 密集型一般都会开大于核数的线程和进程。 但是无论哪种模型，都需要实地压测，以压测结果分析为准；另一方面，还需要做好监控，观察服务在不同并发场景的情况，避免资源耗尽。</p>
<p>然后具体语言的特性也要考虑，Node.js 每个进程内部实现了大量类似协程的执行单元，因此 Node.js 即便在 I/O 密集型场景下也可以考虑长期使用核数 -1 的进程模型。而 Java 是多线程模型，线程池通常要大于核数才能充分利用 CPU 资源。</p>
<p>所以核心就一句，眼见为实，上线前要进行压力测试。</p>
<h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628204545.png" alt="image-20210628204545448"></p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628204612.png" alt="image-20210628204612785"></p>
<p><strong>如果考虑到 CPU 缓存的存在，会对上面我们讨论的算法有什么影响</strong>？</p>
<p>这是一道需要大家查一些资料的题目。这里涉及一个叫作内存一致性模型的概念。具体就是说，在同一时刻，多线程之间，对内存中某个地址的数据认知是否一致（简单理解，就是多个线程读取同一个内存地址能不能读到一致的值）。</p>
<p>对某个地址，和任意时刻，如果所有线程读取值，得到的结果都一样，是一种强一致性，我们称为线性一致性（Sequencial Consistency），含义就是所有线程对这个地址中数据的历史达成了一致，历史没有分差，有一条大家都能认可的主线，因此称为线性一致。 如果只有部分时刻所有线程的理解是一致的，那么称为弱一致性（Weak Consistency）。</p>
<p>那么为什么会有内存不一致问题呢? 这就是因为 CPU 缓存的存在。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210628210820.png" alt="image-20210628210820412"></p>
<p>如上图所示：假设一开始 A=0,B=0。两个不在同一个 CPU 核心执行的 Thread1、Thread2 分别执行上图中的简单程序。在 CPU 架构中，Thread1,Thread2 在不同核心，因此它们的 L1\L2 缓存不共用， L3 缓存共享。</p>
<p>在这种情况下，如果 Thread1 发生了写入 A=1，这个时候会按照 L1,L2,L3 的顺序写入缓存，最后写内存。而对于 Thread2 而言，在 Thread1 刚刚发生写入时，如果去读取 A 的值，就需要去内存中读，这个时候 A=1 可能还没有写入内存。但是对于线程 1 来说，它只要发生了写入 A=1，就可以从 L1 缓存中读取到这次写入。所以在线程 1 写入 A=1 的瞬间，线程 1 线程 2 无法对 A 的值达成一致，造成内存不一致。这个结果会导致 print 出来的 A 和 B 结果不确定，可能是 0 也可能是 1，取决于具体线程执行的时机。</p>
<p>考虑一个锁变量，和 cas 上锁操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lock = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!cas(&amp;lock, <span class="number">0</span>, <span class="number">1</span>))&#123;</span><br><span class="line">    <span class="comment">// CPU降低功耗的指令</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序构成了一个简单的自旋锁（spin-lock）。如果考虑到内存一致性模型，线程 1 通过 cas 操作将 lock 从 0 置 1。这个操作会先发生在线程所在 CPU 的 L1 缓存中。cas 函数通过底层 CPU 指令保证了原子性，cas 执行完成之前，线程 2 的 cas 无法执行。当线程 1 开始临界区的时候，假设这个时候线程 2 开始执行，尝试获取锁。如果这个过程切换非常短暂，线程 2 可能会从内存中读取 lock 的值（而这个值可能还没有写入，还在 Thread 所在 CPU 的 L1、L2 中），线程 2 可能也会通过 cas 拿到锁。两个线程同时进入了临界区，造成竞争条件。</p>
<p>这个时候，就需要强制让线程 2的读取指令一定等到写入指令彻底完成之后再执行，避免使用 CPU 缓存。Java 提供了一个 volatile 关键字实现这个能力，只需要这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> lock = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>就可以避免从读取不到对lock的写入问题。</p>
<p><strong>举例各 2 个悲观锁和乐观锁的应用场景</strong>？</p>
<p>乐观锁、悲观锁都能够实现避免竞争条件，实现数据的一致性。 比如减少库存的操作，无论是乐观锁、还是悲观锁都能保证最后库存算对（一致性）。 但是对于并发减库存的各方来说，体验是不一样的。悲观锁要求各方排队等待。 乐观锁，希望各方先各自进步。所以进步耗时较长，合并耗时较短的应用，比较适合乐观锁。 比如协同创作（写文章、视频编辑、写程序等），协同编辑（比如共同点餐、修改购物车、共同编辑商品、分布式配置管理等），非常适合乐观锁，因为这些操作需要较长的时间进步（比如写文章要思考、配置管理可能会连续修改多个配置）。乐观锁可以让多个协同方不急于合并自己的版本，可以先 focus 在进步上。</p>
<p>相反，悲观锁适用在进步耗时较短的场景，比如锁库存刚好是进步（一次库存计算）耗时少的场景。这种场景使用乐观锁，不但没有足够的收益，同时还会导致各个等待方（线程、客户端等）频繁读取库存——而且还会面临缓存一致性的问题（类比内存一致性问题）。这种进步耗时短，频繁同步的场景，可以考虑用悲观锁。类似的还有银行的交易，订单修改状态等。</p>
<p>再比如抢购逻辑，就不适合乐观锁。抢购逻辑使用乐观锁会导致大量线程频繁读取缓存确认版本（类似 cas 自旋锁），这种情况下，不如用队列（悲观锁实现）。</p>
<p>综上：有一个误区就是悲观锁对冲突持有悲观态度，所以性能低；乐观锁，对冲突持有乐观态度，鼓励线程进步，因此性能高。 这个不能一概而论，要看具体的场景。最后补充一下，悲观锁性能最高的一种实现就是阻塞队列，你可以参考 Java 的 7 种继承于 BlockingQueue 阻塞队列类型。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629101758.png" alt="image-20210629101758701"></p>
<p><strong>用你最熟悉的语言模拟分级队列调度的模型</strong>？</p>
<p>我用 Java 实现了一个简单的 yield 框架。 没有到协程的级别，但是也初具规模。考虑到协程实现需要更复杂一些，所以我用 PriorityQueue 来放高优任务；然后我用 LinkedList 来作为放普通任务的队列。Java 语言中的<code>add</code>和<code>remove</code>方法刚好构成了入队和出队操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private PriorityQueue&lt;Task&gt; urgents;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;LinkedList&lt;Task&gt;&gt; multLevelQueues;</span><br></pre></td></tr></table></figure>

<p>我实现了一个<code>submit</code>方法用于提交任务，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  var scheduler = new MultiLevelScheduler();</span><br><span class="line"></span><br><span class="line">  scheduler.submit((IYieldFunction yield) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;Urgent&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;, 10);</span><br></pre></td></tr></table></figure>

<p>普通任务我的程序中默认是 3 级队列。提交的任务优先级小于 100 的会放入紧急队列。每个任务就是一个简单的函数。我构造了一个 next() 方法用于决定下一个执行的任务，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    private Task next()&#123;</span><br><span class="line"></span><br><span class="line">        if(this.urgents.size() &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            return this.urgents.remove();</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; this.level; i++) &#123;</span><br><span class="line"></span><br><span class="line">                var queue = this.multLevelQueues.get(i);</span><br><span class="line"></span><br><span class="line">                if(queue.size() &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">                    return queue.remove();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先判断高优队列，然后再逐级看普通队列。</p>
<p>执行的程序就是递归调用 runNext() 方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> private void runNext()&#123;</span><br><span class="line"></span><br><span class="line">        var nextTask = this.next();</span><br><span class="line"></span><br><span class="line">        if(nextTask == null) &#123;return;&#125;</span><br><span class="line"></span><br><span class="line">        if(nextTask.isYield()) &#123;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nextTask.run(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            // yiled 内容……省略</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        this.runNext();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面程序中，如果当前任务在<code>yield</code>状态，那么终止当前程序。<code>yield</code>相当于函数调用，从<code>yield</code>函数调用中返回相当于继续执行。<code>yield</code>相当于任务主动让出执行时间。使用<code>yield</code>模式不需要线程切换，可以最大程度利用单核效率。</p>
<p>最后是<code>yield</code>的实现，nextTask.run 后面的匿名函数就是<code>yield</code>方法，它像一个调度程序一样，先简单保存当前的状态，然后将当前任务放到对应的位置（重新入队，或者移动到下一级队列）。如果当前任务是高优任务，<code>yield</code>程序会直接返回，因为高优任务没有必要<code>yield</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">nextTask.run(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    if(nextTask.level == -1) &#123;</span><br><span class="line"></span><br><span class="line">        // high-priority forbid yield</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextTask.setYield(true);</span><br><span class="line"></span><br><span class="line">    if(nextTask.level &lt; this.level - 1) &#123;</span><br><span class="line"></span><br><span class="line">        multLevelQueues.get(nextTask.level + 1).add(nextTask);</span><br><span class="line"></span><br><span class="line">        nextTask.setLevel(nextTask.level + 1);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        multLevelQueues.get(nextTask.level).add(nextTask);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.runNext();</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面是完成的程序，你可以在自己的 IDE 中尝试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line">import java.util.function.Function;</span><br><span class="line"></span><br><span class="line">public class MultiLevelScheduler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"></span><br><span class="line">     * High-priority</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private PriorityQueue&lt;Task&gt; urgents;</span><br><span class="line"></span><br><span class="line">    private ArrayList&lt;LinkedList&lt;Task&gt;&gt; multLevelQueues;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"></span><br><span class="line">     * Levels of Scheduler</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private int level = 3;</span><br><span class="line"></span><br><span class="line">    public MultiLevelScheduler()&#123;</span><br><span class="line"></span><br><span class="line">        this.init();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MultiLevelScheduler(int level) &#123;</span><br><span class="line"></span><br><span class="line">        this.level = level;</span><br><span class="line"></span><br><span class="line">        this.init();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init()&#123;</span><br><span class="line"></span><br><span class="line">        urgents = new PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        multLevelQueues = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; this.level; i++) &#123;</span><br><span class="line"></span><br><span class="line">            multLevelQueues.add(new LinkedList&lt;Task&gt;());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @FunctionalInterface</span><br><span class="line"></span><br><span class="line">    interface IYieldFunction &#123;</span><br><span class="line"></span><br><span class="line">        void yield();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @FunctionalInterface</span><br><span class="line"></span><br><span class="line">    interface ITask&#123;</span><br><span class="line"></span><br><span class="line">        void run(IYieldFunction yieldFunction);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Task implements Comparable&lt;Task&gt;&#123;</span><br><span class="line"></span><br><span class="line">        int level = -1;</span><br><span class="line"></span><br><span class="line">        ITask task;</span><br><span class="line"></span><br><span class="line">        int priority;</span><br><span class="line"></span><br><span class="line">        private boolean yield;</span><br><span class="line"></span><br><span class="line">        public Task(ITask task, int priority) &#123;</span><br><span class="line"></span><br><span class="line">           this.task = task;</span><br><span class="line"></span><br><span class="line">           this.priority = priority;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line"></span><br><span class="line">        public int compareTo(Task o) &#123;</span><br><span class="line"></span><br><span class="line">            return this.priority - o.priority;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getLevel() &#123;</span><br><span class="line"></span><br><span class="line">            return level;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setLevel(int level) &#123;</span><br><span class="line"></span><br><span class="line">            this.level = level;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run(IYieldFunction f) &#123;</span><br><span class="line"></span><br><span class="line">            this.task.run(f);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setYield(boolean yield) &#123;</span><br><span class="line"></span><br><span class="line">            this.yield = yield;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean isYield() &#123;</span><br><span class="line"></span><br><span class="line">            return yield;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void submit(ITask itask, int priority) &#123;</span><br><span class="line"></span><br><span class="line">        var task = new Task(itask, priority);</span><br><span class="line"></span><br><span class="line">        if(priority &gt;= 100) &#123;</span><br><span class="line"></span><br><span class="line">           this.multLevelQueues.get(0).add(task);</span><br><span class="line"></span><br><span class="line">           task.setLevel(0);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            this.urgents.add(task);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void submit(ITask t) &#123;</span><br><span class="line"></span><br><span class="line">        this.submit(t, 100);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Task next()&#123;</span><br><span class="line"></span><br><span class="line">        if(this.urgents.size() &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            return this.urgents.remove();</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; this.level; i++) &#123;</span><br><span class="line"></span><br><span class="line">                var queue = this.multLevelQueues.get(i);</span><br><span class="line"></span><br><span class="line">                if(queue.size() &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">                    return queue.remove();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void runNext()&#123;</span><br><span class="line"></span><br><span class="line">        var nextTask = this.next();</span><br><span class="line"></span><br><span class="line">        if(nextTask == null) &#123;return;&#125;</span><br><span class="line"></span><br><span class="line">        if(nextTask.isYield()) &#123;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nextTask.run(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            if(nextTask.level == -1) &#123;</span><br><span class="line"></span><br><span class="line">                // high-priority forbid yield</span><br><span class="line"></span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nextTask.setYield(true);</span><br><span class="line"></span><br><span class="line">            if(nextTask.level &lt; this.level - 1) &#123;</span><br><span class="line"></span><br><span class="line">                multLevelQueues.get(nextTask.level + 1).add(nextTask);</span><br><span class="line"></span><br><span class="line">                nextTask.setLevel(nextTask.level + 1);</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                multLevelQueues.get(nextTask.level).add(nextTask);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.runNext();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        this.runNext();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        this.runNext();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        var scheduler = new MultiLevelScheduler();</span><br><span class="line"></span><br><span class="line">        scheduler.submit((IYieldFunction yield) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Urgent&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;, 10);</span><br><span class="line"></span><br><span class="line">        scheduler.submit((IYieldFunction yield) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Most Urgent&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;, 0);</span><br><span class="line"></span><br><span class="line">        scheduler.submit((IYieldFunction yield) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;A1&quot;);</span><br><span class="line"></span><br><span class="line">            yield.yield();</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;A2&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        scheduler.submit((IYieldFunction yield) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        scheduler.submit((IYieldFunction f) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        scheduler.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是执行结果如下：</p>
<p><em>Most Urgent</em></p>
<p><em>Urgent</em></p>
<p><em>A1</em></p>
<p><em>B</em></p>
<p><em>C</em></p>
<p><em>A2</em></p>
<p><em>Process finished with exit code 0</em></p>
<p>我们看到结果中任务 1 发生了<code>yield</code>在打印 A2 之前交出了控制权导致任务 B,C 先被执行。如果你想在 yield 出上增加定时的功能，可以考虑 yield 发生后将任务移出队列，并在定时结束后重新插入回来。</p>
<p>什么情况下会触发饥饿和死锁？</p>
<p><strong>如果哲学家就餐问题拿起叉子、放下叉子，只需要微小的时间，主要时间开销集中在 think 需要计算资源（CPU 资源）上，那么使用什么模型比较合适</strong>？</p>
<p>哲学家就餐问题最多允许两组哲学家就餐，如果开销集中在计算上，那么只要同时有两组哲学家可以进入临界区即可。不考虑 I/O 成本，问题就很简化了，也失去了讨论的意义。比如简单要求哲学家们同时拿起左右手的叉子的做法就可以达到 2 组哲学家同时进餐。</p>
<p><strong>还有哪些我没有讲到的进程间通信方法</strong>？</p>
<p> 我看到有同学提到了 Android 系统的 OpenBinder 机制——允许不同进程的线程间调用（类似 RPC）。底层是 Linux 的文件系统和内核对 Binder 的驱动。</p>
<p>我还有没讲到的进程间的通信方法，比如说：</p>
<ul>
<li>使用数据库</li>
<li>使用普通文件</li>
<li>还有一种是信号，一个进程可以通过操作系统提供的信号。举个例子，假如想给某个进程（pid=9999）发送一个 USR1 信号，那么可以用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -s USR1 9999</span><br></pre></td></tr></table></figure>

<p>进程 9999 可以通过写程序接收这个信号。 上述过程除了用<code>kill</code>指令外，还可以调用操作系统 API 完成。</p>
<p><strong>如果磁盘坏了，通常会是怎样的情况</strong>？</p>
<p>磁盘如果彻底坏了，服务器可能执行程序报错，无法写入，甚至死机。这些情况非常容易发现。而比较不容易观察的是坏道，坏道是磁盘上某个小区域数据无法读写了。有可能是硬损坏，就是物理损坏了，相当于永久损坏。也有可能是软损坏，比如数据写乱了。导致磁盘坏道的原因很多，比如电压不稳、灰尘、磁盘质量等问题。</p>
<p>磁盘损坏之前，往往还伴随性能整体的下降；坏道也会导致读写错误。所以在出现问题前，通常是可以在监控系统中观察到服务器性能指标变化的。比如 CPU 使用量上升，I/O Wait 增多，相同并发量下响应速度变慢等。</p>
<p>如果在工作中你怀疑磁盘坏了，可以用下面这个命令检查坏道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo badblocks -v /dev/sda5</span><br></pre></td></tr></table></figure>

<p>我的机器上是 /dev/sda5，你可以用<code>df</code>命令查看自己的文件系统。</p>
<h3 id="一个程序最多能使用多少内存？"><a href="#一个程序最多能使用多少内存？" class="headerlink" title="一个程序最多能使用多少内存？"></a><strong>一个程序最多能使用多少内存？</strong></h3><h4 id="为什么内存不够用？"><a href="#为什么内存不够用？" class="headerlink" title="为什么内存不够用？"></a>为什么内存不够用？</h4><p>总体来说，<strong>虚拟化技术是为了解决内存不够用的问题</strong></p>
<p>历史上有过不少的解决方案，但最终沉淀下的是虚拟化技术。接下来我为你介绍一种历史上存在过的 Swap 技术以及虚拟化技术。</p>
<h4 id="交换（Swap）技术"><a href="#交换（Swap）技术" class="headerlink" title="交换（Swap）技术"></a>交换（Swap）技术</h4><p>Swap 技术允许一部分进程使用内存，不使用内存的进程数据先保存在磁盘上。注意，这里提到的数据，是完整的进程数据，包括正文段（程序指令）、数据段、堆栈段等。轮到某个进程执行的时候，尝试为这个进程在内存中找到一块空闲的区域。如果空间不足，就考虑把没有在执行的进程交换（Swap）到磁盘上，把空间腾挪出来给需要的进程。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629102827.png" alt="image-20210629102827535"></p>
<p>上图中，内存被拆分成多个区域。 内核作为一个程序也需要自己的内存。另外每个进程独立得到一个空间——我们称为地址空间（<strong>Address Space）</strong>。你可以认为地址空间是一块连续分配的内存块。每个进程在不同地址空间中工作，构成了一个原始的虚拟化技术。</p>
<p>比如：当进程 A 想访问地址 100 的时候，实际上访问的地址是基于地址空间本身位置（首字节地址）计算出来的。另外，当进程 A 执行时，CPU 中会保存它地址空间的开始位置和结束位置，当它想访问超过地址空间容量的地址时，CPU 会检查然后报错。</p>
<p>上图描述的这种方法，是一种比较原始的虚拟化技术，进程使用的是基于地址空间的虚拟地址。但是这种方案有很多明显的缺陷，比如：</p>
<ol>
<li><strong>碎片问题</strong>：上图中我们看到进程来回分配、回收交换，内存之间会产生很多缝隙。经过反反复复使用，内存的情况会变得十分复杂，导致整体性能下降。</li>
<li><strong>频繁切换问题</strong>：如果进程过多，内存较小，会频繁触发交换。</li>
</ol>
<p>你可以先思考这两个问题的解决方案，接下来我会带你进行一些更深入地思考——首先重新 Review 下我们的设计目标。</p>
<ol>
<li>隔离：每个应用有自己的地址空间，互不影响。</li>
<li>性能：高频使用的数据保留在内存中、低频使用的数据持久化到磁盘上。</li>
<li>程序好写（降低程序员心智负担）：让程序员不用关心底层设施。</li>
</ol>
<p>现阶段，Swap 技术已经初步解决了问题 1。关于问题 2，Swap 技术在性能上存在着碎片、频繁切换等明显劣势。关于问题 3，使用 Swap 技术，程序员需要清楚地知道自己的应用用多少内存，并且小心翼翼地使用内存，避免需要重新申请，或者研发不断扩容的算法——这让程序心智负担较大。</p>
<p>经过以上分析，需要更好的解决方案，就是我们接下来要学习的虚拟化技术。</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟化技术中，操作系统设计了虚拟内存（理论上可以无限大的空间），受限于 CPU 的处理能力，通常 64bit CPU，就是 264 个地址。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103056.png" alt="image-20210629103056529"></p>
<p>虚拟化技术中，应用使用的是虚拟内存，操作系统管理虚拟内存和真实内存之间的映射。操作系统将虚拟内存分成整齐小块，每个小块称为一个<strong>页（Page）</strong>。之所以这样做，原因主要有以下两个方面。</p>
<ul>
<li><p>一方面应用使用内存是以页为单位，整齐的页能够避免内存碎片问题。</p>
</li>
<li><p>另一方面，每个应用都有高频使用的数据和低频使用的数据。这样做，操作系统就不必从应用角度去思考哪个进程是高频的，仅需思考哪些页被高频使用、哪些页被低频使用。如果是低频使用，就将它们保存到硬盘上；如果是高频使用，就让它们保留在真实内存中。</p>
</li>
</ul>
<p>如果一个应用需要非常大的内存，应用申请的是虚拟内存中的很多个页，真实内存不一定需要够用。</p>
<h4 id="页（Page）和页表"><a href="#页（Page）和页表" class="headerlink" title="页（Page）和页表"></a>页（Page）和页表</h4><p>接下来，我们详细讨论下这个设计。操作系统将虚拟内存分块，每个小块称为一个页（Page）；真实内存也需要分块，每个小块我们称为一个 Frame。Page 到 Frame 的映射，需要一种叫作页表的结构。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103155.png" alt="image-20210629103155027"></p>
<p>上图展示了 Page、Frame 和页表 （PageTable）三者之间的关系。 Page 大小和 Frame 大小通常相等，页表中记录的某个 Page 对应的 Frame 编号。页表也需要存储空间，比如虚拟内存大小为 10G， Page 大小是 4K，那么需要 10G/4K = 2621440 个条目。如果每个条目是 64bit，那么一共需要 20480K = 20M 页表。操作系统在内存中划分出小块区域给页表，并负责维护页表。</p>
<p>页表维护了虚拟地址到真实地址的映射。每次程序使用内存时，需要把虚拟内存地址换算成物理内存地址，换算过程分为以下 3 个步骤：</p>
<ol>
<li>通过虚拟地址计算 Page 编号；</li>
<li>查页表，根据 Page 编号，找到 Frame 编号；</li>
<li>将虚拟地址换算成物理地址。</li>
</ol>
<p>下面我通过一个例子给你讲解上面这个换算的过程：如果页大小是 4K，假设程序要访问地址：100,000。那么计算过程如下。</p>
<ol>
<li>页编号（Page Number） = 100,000/4096 = 24 <strong>余</strong>1619。 24 是页编号，1619 是地址偏移量（Offset）。</li>
<li>查询页表，得到 24 关联的 Frame 编号（假设查到 Frame 编号 = 10）。</li>
<li>换算：通常 Frame 和 Page 大小相等，替换 Page Number 为 Frame Number 物理地址 = 4096 * 10 + 1619 = 42579。</li>
</ol>
<h4 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h4><p>上面的过程发生在 CPU 中一个小型的设备——内存管理单元（Memory Management Unit， MMU）中。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103532.png" alt="image-20210629103532025"></p>
<p>当 CPU 需要执行一条指令时，如果指令中涉及内存读写操作，CPU 会把虚拟地址给 MMU，MMU 自动完成虚拟地址到真实地址的计算；然后，MMU 连接了地址总线，帮助 CPU 操作真实地址。</p>
<p>这样的设计，就不需要在编写应用程序的时候担心虚拟地址到物理地址映射的问题。我们把全部难题都丢给了操作系统——操作系统要确定MMU 可以读懂自己的页表格式。所以，操作系统的设计者要看 MMU 的说明书完成工作。</p>
<p>难点在于不同 CPU 的 MMU 可能是不同的，因此这里会遇到很多跨平台的问题。解决跨平台问题不但有繁重的工作量，更需要高超的编程技巧，Unix 最初期的移植性（跨平台）是 C 语言作者丹尼斯·里奇实现的。</p>
<p>学到这里，细心的同学可能会有疑问：MMU 需要查询页表（这是内存操作），而 CPU 执行一条指令通过 MMU 获取内存数据，难道可以容忍在执行一条指令的过程中，发生多次内存读取（查询）操作？难道一次普通的读取操作，还要附加几次查询页表的开销吗？当然不是，这里还有一些高速缓存的设计，这部分我们放到“<strong>25 讲</strong>”中详细讨论。</p>
<h4 id="页表条目"><a href="#页表条目" class="headerlink" title="页表条目"></a>页表条目</h4><p>上面我们笼统介绍了页表将 Page 映射到 Frame。那么，页表中的每一项（<strong>页表条目</strong>）长什么样子呢？下图是一个页表格式的一个演示。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103643.png" alt="image-20210629103643243"></p>
<p>页表条目本身的编号可以不存在页表中，而是通过偏移量计算。 比如地址 100,000 的编号，可以用 100,000 除以页大小确定。</p>
<ul>
<li>Absent（“在”）位，是一个 bit。0 表示页的数据在磁盘中（不再内存中），1 表示在内存中。如果读取页表发现 Absent = 0，那么会触发缺页中断，去磁盘读取数据。</li>
<li>Protection（保护）字段可以实现成 3 个 bit，它决定页表用于读、写、执行。比如 000 代表什么都不能做，100 代表只读等。</li>
<li>Reference（访问）位，代表这个页被读写过，这个记录对回收内存有帮助。</li>
<li>Dirty（“脏”）位，代表页的内容被修改过，如果 Dirty =1，那么意味着页面必须回写到磁盘上才能置换（Swap)。如果 Dirty = 0，如果需要回收这个页，可以考虑直接丢弃它（什么也不做，其他程序可以直接覆盖）。</li>
<li>Caching（缓存位），描述页可不可以被 CPU 缓存。CPU 缓存会造成内存不一致问题，在上个模块的加餐中我们讨论了内存一致性问题，具体你可以参考“<strong>模块四</strong>”的加餐内容。</li>
<li>Frame Number（Frame 编号），这个是真实内存的位置。用 Frame 编号乘以页大小，就可以得到 Frame 的基地址。</li>
</ul>
<p>在 64bit 的系统中，考虑到 Absent、Protection 等字段需要占用一定的位，因此不能将 64bit 都用来描述真实地址。但是 64bit 可以寻址的空间已经远远超过了 EB 的级别（1EB = 220TB），这已经足够了。在真实世界，我们还造不出这么大的内存呢。</p>
<h4 id="大页面问题"><a href="#大页面问题" class="headerlink" title="大页面问题"></a>大页面问题</h4><p>最后，我们讨论一下大页面的问题。假设有一个应用，初始化后需要 12M 内存，操作系统页大小是 4K。那么应该如何设计呢？</p>
<p>为了简化模型，下图中，假设这个应用只有 3 个区域（3 个段）——正文段（程序）、数据段（常量、全局变量）、堆栈段。一开始我们 3 个段都分配了 4M 的空间。随着程序执行，堆栈段的空间会继续增加，上不封顶。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103850.png" alt="image-20210629103850384"></p>
<p>上图中，进程内部需要一个页表存储进程的数据。如果进程的内存上不封顶，那么页表有多少个条目合适呢？ 进程分配多少空间合适呢？ 如果页表大小为 1024 个条目，那么可以支持 1024*4K = 4M 空间。按照这个计算，如果进程需要 1G 空间，则需要 256K 个条目。我们预先为进程分配这 256K 个条目吗？ 创建一个进程就划分这么多条目是不是成本太高了？</p>
<p>为了减少条目的创建，可以考虑进程内部用一个更大的页表（比如 4M），操作系统继续用 4K 的页表。这就形成了一个二级页表的结构，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629103924.png" alt="image-20210629103924287"></p>
<p>这样 MMU 会先查询 1 级页表，再查询 2 级页表。在这个模型下，进程如果需要 1G 空间，也只需要 1024 个条目。比如 1 级页编号是 2， 那么对应 2 级页表中 [2* 1024, 3*1024-1] 的部分条目。而访问一个地址，需要同时给出一级页编号和二级页编号。整个地址，还可以用 64bit 组装，如下图所示：<img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629104016.png" alt="image-20210629104015892"></p>
<p>MMU 根据 1 级编号找到 1 级页表条目，1 级页表条目中记录了对应 2 级页表的位置。然后 MMU 再查询 2 级页表，找到 Frame。最后通过地址偏移量和 Frame 编号计算最终的物理地址。这种设计是一个递归的过程，因此还可增加 3 级、4 级……每增加 1 级，对空间的利用都会提高——当然也会带来一定的开销。这对于大应用非常划算，比如需要 1T 空间，那么使用 2 级页表，页表的空间就节省得多了。而且，这种多级页表，顶级页表在进程中可以先只创建需要用到的部分，就这个例子而言，一开始只需要 3 个条目，从 256K 个条目到 3 个，这就大大减少了进程创建的成本。</p>
<p><strong>一个程序最多能使用多少内存</strong>？</p>
<p>目前我们主要都是在用 64bit 的机器。因为 264 数字过于大，即便是虚拟内存都不需要这么大的空间。因此通常操作系统会允许进程使用非常大，但是不到 264 的地址空间。通常是几十到几百 EB（1EB = 106TB = 109GB)。</p>
<h3 id="什么情况下使用大内存分页？"><a href="#什么情况下使用大内存分页？" class="headerlink" title="什么情况下使用大内存分页？"></a><strong>什么情况下使用大内存分页</strong>？</h3><p>虚拟地址到物理地址的转换过程：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629142514.png" alt="image-20210629142514130"></p>
<p>MMU: Memory Management Unit</p>
<p>你可以把虚拟地址看成由页号和偏移量组成，把物理地址看成由 Frame Number 和偏移量组成。在 CPU 中有一个完成虚拟地址到物理地址转换的小型设备，叫作内存管理单元（Memory Management Unit(MMU）。</p>
<p>在程序执行的时候，指令中的地址都是虚拟地址，虚拟地址会通过 MMU，MMU 会查询页表，计算出对应的 Frame Number，然后偏移量不变，组装成真实地址。然后 MMU 通过地址总线直接去访问内存。所以 MMU 承担了虚拟地址到物理地址的转换以及 CPU 对内存的操作这两件事情。</p>
<p>如下图所示，从结构上 MMU 在 CPU 内部，并且直接和地址总线连接。因此 MMU 承担了 CPU 和内存之间的代理。对操作系统而言，MMU 是一类设备，有多种型号，就好比显卡有很多型号一样。操作系统需要理解这些型号，会使用 MMU。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629142927.png" alt="image-20210629142926877"></p>
<h4 id="TLB-和-MMU-的性能问题"><a href="#TLB-和-MMU-的性能问题" class="headerlink" title="TLB 和 MMU 的性能问题"></a>TLB 和 MMU 的性能问题</h4><p>上面的过程，会产生一个问题：指令的执行速度非常快，而 MMU 还需要从内存中查询页表。最快的内存查询页需要从 CPU 的缓存中读取，假设缓存有 95% 的命中率，比如读取到 L2 缓存，那么每次操作也需要几个 CPU 周期。你可以回顾一下 CPU 的指令周期，如下图所示，有 fetch/decode/execute 和 store。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629142948.png" alt="image-20210629142948243"></p>
<p>在 fetch、execute 和 store 这 3 个环节中都有可能发生内存操作，因此内存操作最好能在非常短的时间内完成，尤其是 Page Number 到 Frame Number 的映射，我们希望尽快可以完成，最好不到 0.2 个 CPU 周期，这样就不会因为地址换算而增加指令的 CPU 周期。</p>
<p>因此，在 MMU 中往往还有一个微型的设备，叫作转置检测缓冲区（Translation Lookaside Buffer，TLB）。</p>
<p>缓存的设计，通常是一张表，所以 TLB 也称作快表。TLB 中最主要的信息就是 Page Number到 Frame Number 的映射关系。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629143035.png" alt="image-20210629143035212"></p>
<p>如上表所示，最简单的表达就是一个二维表格，每一行是一个 Page Number 和一个 Frame Number。我们把这样的每一行称为一个缓存行（Cache Line），或者缓存条目（Entry）。</p>
<p><strong>TLB 的作用就是根据输入的 Page Number，找到 Frame Numbe</strong>r。TLB 是硬件实现的，因此速度很快。因为用户的局部程序，往往会反复利用相同的内存地址。比如说 for 循环会反复利用循环变量，因此哪怕是只有几十个缓存行的 TLB，也会有非常高的命中率。而且现在的多核 CPU，会为每个核心提供单独的 TLB。这样，相当于减少了 TLB 的冲突。比如酷睿 i7 CPU 当中，每个核心都有自己的 TLB，而且 TLB 还进行了类似 CPU 缓存的分级策略。在 i7 CPU 中，L1 级 TLB 一共 64 个，L2 级 TLB 一共 1024 个。通过这样的设计，绝大多数的页表查询就可以用 TLB 实现了。</p>
<h4 id="TLB-Miss-问题"><a href="#TLB-Miss-问题" class="headerlink" title="TLB Miss 问题"></a>TLB Miss 问题</h4><p>如果 Page Number 在 TLB 总没有找到，我们称为<strong>TLB 失效（Miss）</strong>。这种情况，分成两种。</p>
<p>一种是<strong>软失效</strong>（Soft Miss），这种情况 Frame 还在内存中，只不过 TLB 缓存中没有。那么这个时候需要刷新 TLB 缓存。如果 TLB 缓存已经满了，就需要选择一个已经存在的缓存条目进行覆盖。具体选择哪个条目进行覆盖，我们称为缓存置换（缓存不够用了，需要置换）。缓存置换时，通常希望高频使用的数据保留，低频使用的数据被替换。比如常用的 LRU（Least Recently Used）算法就是基于这种考虑，每次置换最早使用的条目。</p>
<p>另一种情况是<strong>硬失效（Hard Miss)**，这种情况下对应的 Frame 没有在内存中，需要从磁盘加载。这种情况非常麻烦，首先操作系统要触发一个缺页中断（原有需要读取内存的线程被休眠），然后中断响应程序开始从磁盘读取对应的 Frame 到内存中，读取完成后，再次触发中断通知更新 TLB，并且唤醒被休眠的线程去排队。</strong>注意，线程不可能从休眠态不排队就进入执行态，因此 Hard Miss 是相对耗时的**。</p>
<p><strong>无论是软失效、还是硬失效，都会带来性能损失，这是我们不希望看到的。因此缓存的设计，就非常重要了</strong>。</p>
<h4 id="TLB-缓存的设计"><a href="#TLB-缓存的设计" class="headerlink" title="TLB 缓存的设计"></a>TLB 缓存的设计</h4><p>每个缓存行可以看作一个映射，TLB 的缓存行将 Page Number 映射到 Frame Number，通常我们设计这种基于缓存行（Cache Line）的缓存有 3 种映射方案：</p>
<ul>
<li>全相联映射（Fully Associative Mapping）</li>
<li>直接映射（Direct Mapping）</li>
<li>n 路组相联映射（n-way Set-Associative Mapping）</li>
</ul>
<p>所谓相联（Associative），讲的是缓存条目和缓存数据之间的映射范围。如果是全相联，那么一个数据，可能在任何条目。如果是组相联（Set-Associative），意味对于一个数据，只能在一部分缓存条目中出现（比如前 4 个条目）。</p>
<p><strong>方案一：全相联映射（Fully Associative Mapping）</strong></p>
<p>如果 TLB 用全相联映射实现，那么一个 Frame，可能在任何缓存行中。虽然名词有点复杂，但是通常新人设计缓存时，会本能地想到全相联。因为在给定的空间下，最容易想到的就是把缓存数据都放进一个数组里。</p>
<p>对于 TLB 而言，如果是全相联映射，给定一个具体的 Page Number，想要查找 Frame，需要遍历整个缓存。当然作为硬件实现的缓存，如果缓存条目少的情况下，可以并行查找所有行。这种行为在软件设计中是不存在的，软件设计通常需要循环遍历才能查找行，但是利用硬件电路可以实现这种并行查找到过程。可是如果条目过多，比如几百个上千个，硬件查询速度也会下降。所以，全相联映射，有着明显性能上的缺陷。我们不考虑采用。</p>
<p><strong>方案二：直接映射（Direct Mapping）</strong></p>
<p>对于水平更高一些的同学，马上会想到直接映射。直接映射类似一种哈希函数的形式，给定一个内存地址，可以通过类似于哈希函数计算的形式，去计算它在哪一个缓存条目。假设我们有 64 个条目，那么可以考虑这个计算方法：<strong>缓存行号 = Page Number % 64</strong>。</p>
<p>当然在这个方法中，假如实际的虚拟地址空间大小是 1G，页面大小是 4K，那么一共有 1G/4K = 262144 个页，平均每 262144/64 = 4096 个页共享一个条目。这样的共享行为是很正常的，本身缓存大小就不可能太大，之前我们讲过，性能越高的存储离 CPU 越近，成本越高，空间越小。</p>
<p>上面的设计解决了全相联映射的性能缺陷，那么缓存命中率如何呢？</p>
<p>一种最简单的思考就是能不能基于直接映射实现 LRU 缓存。仔细思考，其实是不可能实现的。因为当我们想要置换缓存的时候（新条目进来，需要寻找一个旧条目出去），会发现每次都只有唯一的选择，因为对于一个确定的虚拟地址，它所在的条目也是确定的。这导致直接映射不支持各种缓存置换算法，因此 TLB Miss 肯定会更高。</p>
<p>综上，我们既要解决直接映射的缓存命中率问题，又希望解决全相联映射的性能问题。而核心就是需要能够实现类似 LRU 的算法，让高频使用的缓存留下来——最基本的要求，就是一个被缓存的值，必须可以存在于多个位置——于是人们就发明了 n 路组相联映射。</p>
<p><strong>方案三：n 路组相联映射（n-way Set-Associative Mapping）</strong></p>
<p>组相联映射有点像哈希表的开放寻址法，但是又有些差异。组相联映射允许一个虚拟页号（Page Number）映射到固定数量的 n 个位置。举个例子，比如现在有 64 个条目，要查找地址 100 的位置，可以先用一个固定的方法计算，比如 100%64 = 36。这样计算出应该去条目 36 获取 Frame 数据。但是取出条目 36 看到条目 36 的 Page Number 不是 100，这个时候就顺延一个位置，去查找 37,38,39……如果是 4 路组相联，那么就只看 36,37,38,39，如果是8 路组相联，就只看 36-43 位置。</p>
<p>这样的方式，一个 Page Number 可以在 n 个位置出现，这样就解决了 LRU 算法的问题。每次新地址需要置换进来的时候，可以从 n 个位置中选择更新时间最早的条目置换出去。至于具体 n 设置为多少，需要实战的检验。而且缓存是一个模糊、基于概率的方案，本身对 n 的要求不是很大。比如：i7 CPU 的 L1 TLB 采用 4-way 64 条目的设计；L2 TLB 采用 8-way 1024 条目的设计。Intel 选择了这样的设计，背后有大量的数据支撑。这也是缓存设计的一个要点，在做缓存设计的时候，你一定要收集数据实际验证。</p>
<p>以上，我们解决了 TLB 的基本设计问题，最后选择采用 n 路组相联映射。 然后还遗留了一个问题，如果一个应用（进程）对内存的需求比较大，比如 1G，而默认分页 4K 比较小。 这种情况下会有 262144 个页。考虑到 1024 个条目的 TLB，那么 262144/1024 = 256，如果 256 个地址复用 1 个缓存，很容易冲突。这个问题如何解决呢？</p>
<h4 id="大内存分页"><a href="#大内存分页" class="headerlink" title="大内存分页"></a>大内存分页</h4><p>解决上面的遗留问题，可以考虑采用大内存分页（Large Page 或 Huge Page）。 这里我们先复习一下上一讲学习的多级页表。 多层页面就是进程内部维护一张页表，比如说 4M 一个页表（一级），然后每个一级页表关联 1024 个二级页表。 这样会给 MMU 带来一定的负担，因为 MMU 需要先检查一级页表，再检查二级页表。 但是 MMU 仍然可以利用 TLB 进行加速。因为 TLB 是缓存，所有根据值查找结果的逻辑，都可以用 TLB。</p>
<p>但是这没有解决我们提出的页表太多的问题，最终这种多级页表的设计还是需要查询大小为 4K 的页（这里请你思考上面的例子，如果是 1G 空间有 262144 个页）。如果我们操作系统能够提供大小为 4M 的页，那么是不是就减少了 1024 倍的页数呢？ ——这样就大大提高了 TLB 的查询性能。</p>
<p>因此 Linux 内核 2.6 版之后就开始提供大内存分页（HugeTable），默认是不开启的。如果你有应用需要使用大内存分页，可以考虑用下面的语句开启它：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w vm.nr_hugepages=2048</span><br></pre></td></tr></table></figure>

<p><code>sysctl</code>其实就是修改一下配置项，上面我们允许应用使用最多 2048 个大内存页。上面语句执行后，你可以按照下方截图的方式去查看自己大内存页表使用的情况。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629144737.png" alt="image-20210629144736821"></p>
<p>从上图中你可以看到我总共有 2048 个大内存页，每个大小是 2048KB。具体这个大小是不可以调整的，这个和机器用的 MMU 相关。</p>
<p>打开大内存分页后如果有应用需要使用，就会去申请大内存分页。比如 Java 应用可以用<code>-XX:+UseLargePages</code>开启使用大内存分页。 下图是我通过一个 Java 程序加上 UseLargePages 参数的结果。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629144754.png" alt="image-20210629144754602"></p>
<p>注意：我的 Java 应用使用的分页数 = Total-Free+Rsvd = 2048-2032+180 = 196。Total 就是总共的分页数，Free 代表空闲的（包含 Rsvd，Reserved 预留的）。因此是上面的计算关系。</p>
<p><strong>什么情况下使用大内存分页</strong>？</p>
<p>通常应用对内存需求较大时，可以考虑开启大内存分页。比如一个搜索引擎，需要大量在内存中的索引。有时候应用对内存的需求是隐性的。比如有的机器用来抗高并发访问，虽然平时对内存使用不高，但是当高并发到来时，应用对内存的需求自然就上去了。虽然每个并发请求需要的内存都不大， 但是总量上去了，需求总量也会随之提高高。这种情况下，你也可以考虑开启大内存分页。</p>
<h3 id="LRU-用什么数据结构实现更合理？"><a href="#LRU-用什么数据结构实现更合理？" class="headerlink" title="LRU 用什么数据结构实现更合理？"></a><strong>LRU 用什么数据结构实现更合理？</strong></h3><p>LRU（最近最少使用），是一种缓存置换算法。缓存是用来存储常用的数据，加速常用数据访问的数据结构。有软件实现，比如数据库的缓存；也有硬件实现，比如我们上一讲学的 TLB。<strong>缓存设计中有一个重要的环节：当缓存满了，新的缓存条目要写入时，哪个旧条目被置换出去呢</strong>？</p>
<p>这就需要用到缓存置换算法（Cache Replacement Algorithm）。缓存置换应用场景非常广，比如发生缺页中断后，操作系统需要将磁盘的页导入内存，那么已经在内存中的页就需要置换出去。CDN 服务器为了提高访问速度，需要决定哪些 Web 资源在内存中，哪些在磁盘上。CPU 缓存每次写入一个条目，也就相当于一个旧的条目被覆盖。数据库要决定哪些数据在内存中，应用开发要决定哪些数据在 Redis 中，而空间是有限的，这些都关联着缓存的置换。</p>
<p>今天我们就以 LRU 用什么数据结构实现更合理，这道缓存设计题目为引，为你讲解缓存设计中（包括置换算法在内）的一些通用的思考方法。</p>
<h4 id="理想状态"><a href="#理想状态" class="headerlink" title="理想状态"></a>理想状态</h4><p><strong>设计缓存置换算法的期望是：每次将未来使用频率最低的数据置换出去</strong>。假设只要我们知道未来的所有指令，就可以计算出哪些内存地址在未来使用频率高，哪些内存地址在未来使用频率低。这样，我们总是可以开发出理论上最高效的缓存置换算法。</p>
<p>再复习下缓存的基本概念，在缓存中找到数据叫作一次命中（Hit），没有找到叫作穿透（Miss）。假设穿透的概率为 M，缓存的访问时间（通常叫作延迟）是 L，穿透的代价（访问到原始数据，比如 Redis 穿透，访问到 DB）也就是穿透后获取数据的平均时间是 T，那么 M*T+L 可以看作是接近缓存的平均响应时间。L 通常是不变的，这个和我们使用了什么缓存相关。这样，如果我们知道未来访问数据的顺序，就可以把 M 降到最低，让缓存平均响应时间降到最低。</p>
<p>当然这只是美好的愿望，在实际工作中我们还不可能预知未来。</p>
<h4 id="随机-FIFO-FILO"><a href="#随机-FIFO-FILO" class="headerlink" title="随机/FIFO/FILO"></a>随机/FIFO/FILO</h4><p>接下来我要和你讨论的 3 种策略，是对理想状态的一种悲观表达，或者说不好的设计。</p>
<p>比如说随机置换，一个新条目被写入，随机置换出去一个旧条目。这种设计，具有非常朴素的公平，但是性能会很差（穿透概率高），因为可能置换出去未来非常需要的数据。</p>
<p>再比如先进先出（First In First Out）。设计得不好的电商首页，每次把离现在时间最久的产品下线，让新产品有机会展示，而忽略销量、热度、好评等因素。这也是一种朴素的公平，但是和我们设计缓存算法的初衷——预估未来使用频率更高的数据保留在缓存中，相去甚远。所以，FIFO 的结构也是一种悲观的设计。</p>
<p>FIFO 的结构使用一个链表就能实现，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145239.png" alt="image-20210629145239118"></p>
<p>为了方便你理解本讲后面的内容，我在这里先做一个知识铺垫供你参考。上图中，新元素从链表头部插入，旧元素从链表尾部离开。 这样就构成了一个队列（Queue），队列是一个经典的 FIFO 模型。</p>
<p>还有一种策略是先进后出（First In Last Out）。但是这种策略和 FIFO、随机一样，没有太强的实际意义。因为先进来的元素、后进来的元素，还是随机的某个元素，和我们期望的未来使用频率，没有任何本质联系。</p>
<p>同样 FILO 的策略也可以用一个链表实现，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145400.png" alt="image-20210629145400071"></p>
<p>新元素从链表头部插入链表，旧元素从链表头部离开链表，就构成了一个栈（Stack），栈是一种天然的 FILO 数据结构。这里仅供参考了，我们暂时还不会用到这个方法。</p>
<p>当然我们不可能知道未来，但是可以考虑基于历史推测未来。经过前面的一番分析，接下来我们开始讨论一些更有价值的置换策略。</p>
<h4 id="最近未使用（NRU）"><a href="#最近未使用（NRU）" class="headerlink" title="最近未使用（NRU）"></a>最近未使用（NRU）</h4><p>一种非常简单、有效的缓存实现就是优先把最近没有使用的数据置换出去（Not Recently Used)。从概率上说，最近没有使用的数据，未来使用的概率会比最近经常使用的数据低。缓存设计本身也是基于概率的，一种方案有没有价值必须经过实践验证——在内存缺页中断后，如果采用 NRU 置换页面，可以提高后续使用内存的命中率，这是实践得到的结论。</p>
<p>而且 NRU 实现起来比较简单，下图是我们在“<strong>24 讲</strong>”中提到的页表条目设计。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145457.png" alt="image-20210629145457762"></p>
<p>在页表中有一个访问位，代表页表有被读取过。还有一个脏位，代表页表被写入过。无论是读还是写，我们都可以认为是访问过。 为了提升效率，一旦页表被使用，可以用硬件将读位置 1，然后再设置一个定时器，比如 100ms 后，再将读位清 0。当有内存写入时，就将写位置 1。过一段时间将有内存写入的页回写到磁盘时，再将写位清 0。这样读写位在读写后都会置为 1，过段时间，也都会回到 0。</p>
<p>上面这种方式，就构成了一个最基本的 NRU 算法。每次置换的时候，操作系统尽量选择读、写位都是 0 的页面。而一个页面如果在内存中停留太久，没有新的读写，读写位会回到 0，就可能会被置换。</p>
<p>这里多说一句，NRU 本身还可以和其他方法结合起来工作，比如我们可以利用读、写位的设计去改进 FIFO 算法。</p>
<p>每次 FIFO 从队列尾部找到一个条目要置换出去的时候，就检查一下这个条目的读位。如果读位是 0，就删除这个条目。如果读位中有 1，就把这个条目从队列尾部移动到队列的头部，并且把读位清 0，相当于多给这个条目一次机会，因此也被称为<strong>第二次机会算法</strong>。多给一次机会，就相当于发生访问的页面更容易存活。而且，这样的算法利用天然的数据结构优势（队列），保证了 NRU 的同时，节省了去扫描整个缓存寻找读写位是 0 的条目的时间。</p>
<p>第二次机会算法还有一个更巧妙的实现，就是利用循环链表。这个实现可以帮助我们节省元素从链表尾部移动到头部的开销。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629145715.png" alt="image-20210629145715823"></p>
<p>如上图所示，我们可以将从尾部移动条目到头部的这个操作简化为头指针指向下一个节点。每次移动链表尾部元素到头部，只需要操作头指针指向下一个元素即可。这个方法非常巧妙，而且容易实现，你可以尝试在自己系统的缓存设计中尝试使用它。</p>
<p><strong>以上，是我们学习的第一个比较有价值的缓存置换算法。基本可用，能够提高命中率</strong>。缺点是只考虑了最近用没用过的情况，没有充分考虑综合的访问情况。优点是简单有效，性能好。缺点是考虑不周，对缓存的命中率提升有限。但是因为简单，容易实现，NRU 还是成了一个被广泛使用的算法。</p>
<h4 id="最近使用最少（LRU）"><a href="#最近使用最少（LRU）" class="headerlink" title="最近使用最少（LRU）"></a>最近使用最少（LRU）</h4><p>一种比 NRU 考虑更周密，实现成本更高的算法是最近最少使用（Least Recently Used， LRU）算法，它会置换最久没有使用的数据。和 NRU 相比，LRU 会考虑一个时间范围内的数据，对数据的参考范围更大。LRU 认为，最近一段时间最少使用到的数据应该被淘汰，把空间让给最近频繁使用的数据。这样的设计，即便数据都被使用过，还是会根据使用频次多少进行淘汰。比如：CPU 缓存利用 LUR 算法将空间留给频繁使用的内存数据，淘汰使用频率较低的内存数据。</p>
<p><strong>常见实现方案</strong></p>
<p>LRU 的一种常见实现是链表，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629153904.png" alt="image-20210629153903931"></p>
<p>用双向链表维护缓存条目。如果链表中某个缓存条目被使用到，那么就将这个条目重新移动到表头。如果要置换缓存条目出去，就直接从双线链表尾部删除一个条目。</p>
<p>通常 LRU 缓存还要提供查询能力，这里我们可以考虑用类似 Java 中 LinkedHashMap 的数据结构，同时具备双向链表和根据 Key 查找值的能力。</p>
<p>以上是常见的实现方案，但是这种方案在缓存访问量非常大的情况下，需要同时维护一个链表和一个哈希表，因此开销较高。</p>
<p><strong>举一个高性能场景的例子，比如页面置换算法。</strong> 如果你需要维护一个很大的链表来存储所有页，然后经常要删除大量的页面（置换缓存），并把大量的页面移动到链表头部。这对于页面置换这种高性能场景来说，是不可以接受的。</p>
<p><strong>另外一个需要 LRU 高性能的场景是 CPU 的缓存</strong>，CPU 的多路组相联设计，比如 8-way 设计，需要在 8 个地址中快速找到最久未使用的数据，不可能再去内存中建立一个链表来实现。</p>
<p>正因为有这么多困难，才需要不断地优化迭代，让缓存设计成为一门艺术。接下来我选取了内存置换算法中数学模拟 LRU 的算法，分享给你。</p>
<p><strong>如何描述最近使用次数？</strong></p>
<p><strong>设计 LRU 缓存第一个困难是描述最近使用次数</strong>。 因为“最近”是一个模糊概念，没有具体指出是多长时间？按照 CPU 周期计算还是按照时间计算？还是用其他模糊的概念替代？</p>
<p>比如说页面置换算法。在实际的设计中，可以考虑把页表的读位利用起来。做一个定时器，每隔一定的 ms 数，就把读位累加到一个计数器中。相当于在每个页表条目上再增加一个累计值。</p>
<p>例如：现在某个页表条目的累计值是 0， 接下来在多次计数中看到的读位是：1,0,0,1,1，那么累计值就会变成 3。这代表在某段时间内（5 个计数器 Tick 中）有 3 次访问操作。</p>
<p>通过这种方法，就解决了描述使用次数的问题。如果单纯基于使用次数最少判断置换，我们称为最少使用（Least Frequently Used,，LFU）算法。<strong>LFU 的劣势在于它不会忘记数据，累计值不会减少</strong>。比如如果有内存数据过去常常被用到，但是现在已经有很长一段时间没有被用到了，在这种情况下它并不会置换出去。那么我们该如何描述“最近”呢？</p>
<p>有一个很不错的策略就是利用一个叫作“老化”（Aging）的算法。比起传统的累加计数的方式，Aging 算法的累加不太一样。</p>
<p>比如用 8 位来描述累计数（A），那么每次当读位的值（R）到来的时候，我们都考虑将 A 的值右移，然后将 R 放到 A 的最高位。</p>
<p>例如 A 目前的值是<code>00000000</code>，在接下来的 5 个 Tick 中 R 来临的序列是<code>11100</code>，那么 A 的值变更顺序为：</p>
<ol>
<li>10000000</li>
<li>11000000</li>
<li>11100000</li>
<li>01110000</li>
<li>00111000</li>
</ol>
<p>你可以看到随着 Aging 算法的执行，有访问操作的时候 A 的值上升，没有访问操作的时候，A的值逐渐减少。如果一直没有访问操作，A 的值会回到 0。</p>
<p>这样的方式就巧妙地用数学描述了“最近”。然后操作系统每次页面置换的时候，都从 A 值最小的集合中取出一个页面放入磁盘。这个算法是对 LRU 的一种模拟，也被称作 LFUDA（动态老化最少使用，其中 D 是 Dynamic,，A 是 Aging）。</p>
<p>而计算 Aging（累计值）的过程，可以由硬件实现，这样就最大程度提升了性能。</p>
<p>相比写入操作，查询是耗时相对较少的。这是因为有 CPU 缓存的存在，我们通常不用直接去内存中查找数据，而是在缓存中进行。对于发生缺页中断的情况，并不需要追求绝对的精确，可以在部分页中找到一个相对累计值较小的页面进行置换。不过即便是模拟的 LRU 算法，也不是硬件直接支持的，总有一部分需要软件实现，因此还是有较多的时间开销。</p>
<p><strong>是否采用 LRU，一方面要看你所在场景的性能要求，有没有足够的优化措施（比如硬件提速）；另一方面，就要看最终的结果是否能够达到期望的命中率和期望的使用延迟了</strong>。</p>
<p>本讲我们讨论的频次较高、频次较低，是基于历史的。 历史在未来并不一定重演。比如读取一个大型文件，无论如何操作都很难建立一个有效的缓存。甚至有的时候，最近使用频次最低的数据被缓存，使用频次最高的数据被置换，效率会更高。比如说有的数据库设计同时支持 LRU 缓存和 MRU（ Most Recently Used）缓存。MRU 是 LRU 的对立面，这看似茅盾，但其实是为了解决不同情况下的需求。</p>
<p>这并不是说缓存设计无迹可寻，而是经过思考和预判，还得以事实的命中率去衡量缓存置换算法是否合理。</p>
<p><strong>LRU 用什么数据结构实现更合理</strong>？</p>
<p>最原始的方式是用数组，数组的每一项中有数据最近的使用频次。数据的使用频次可以用计时器计算。每次置换的时候查询整个数组实现。</p>
<p>另一种更好的做法是利用双向链表实现。将使用到的数据移动到链表头部，每次置换时从链表尾部拿走数据。链表头部是最近使用的，链表尾部是最近没有被使用到的数据。</p>
<p>但是在应对实际的场景的时候，有时候不允许我们建立专门用于维护缓存的数据结构（内存大小限制、CPU 使用限制等），往往需要模拟 LRU。比如在内存置换场景有用“老化”技术模拟 LRU 计算的方式。</p>
<h3 id="如何解决内存的循环引用问题？"><a href="#如何解决内存的循环引用问题？" class="headerlink" title="如何解决内存的循环引用问题？"></a><strong>如何解决内存的循环引用问题？</strong></h3><p>内存泄漏一直是很多大型系统故障的根源，也是一个面试热点。那么在编程语言层面已经提供了内存回收机制，为什么还会产生内存泄漏呢？</p>
<p>这是因为应用的内存管理一直处于一个和应用程序执行并发的状态，如果应用程序申请内存的速度，超过内存回收的速度，内存就会被用满。当内存用满，操作系统就开始需要频繁地切换页面，进行频繁地磁盘读写。</p>
<p><strong>所以我们观察到的系统性能下降，往往是一种突然的崩溃，因为一旦内存被占满，系统性能就开始雪崩式下降</strong>。</p>
<p>特别是有时候程序员不懂内存回收的原理，错误地使用内存回收器，导致部分对象没有被回收。而在高并发场景下，每次并发都产生一点不能回收的内存，不用太长时间内存就满了，这就是泄漏通常的成因。</p>
<p>这一块知识点关联着很多常见的面试题，比如。</p>
<ul>
<li>这一讲关联的题目：如何解决循环引用问题？</li>
<li>下节课关联的题目：三色标记-清除算法的工作原理？生代算法等。</li>
<li>还有一些题目会考察你对内存回收器整体的理解，比如如何在吞吐量、足迹和暂停时间之间选择？</li>
</ul>
<p>接下来，我会用 27 和 28 两讲和你探讨内存回收技术，把这些问题一网打尽。</p>
<h4 id="什么是-GC"><a href="#什么是-GC" class="headerlink" title="什么是 GC"></a>什么是 GC</h4><p>通常意义上我们说的垃圾回收器（Garbage Collector，GC），和多数同学的理解会有出入。你可能认为 GC 是做内存回收用的模块，而事实上程序语言提供的 GC 往往是应用的实际内存管理者。刚刚入门咱们就遇到了一个容易出现理解偏差的问题，所以 GC 是值得花时间细学的。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629161923.png" alt="image-20210629161923118"></p>
<p>如上图所示，一方面 GC 要承接操作系统虚拟内存的架构，另一方面 GC 还要为应用提供内存管理。GC 有一个含义，就是 Garbage Collection 内存回收的具体动作。无论是名词的回收器，还是动词的回收行为，在下文中我都称作 GC。</p>
<p>下面我们具体来看一下 GC 都需要承担哪些“工作”，这里我总结为以下 4 种。</p>
<ol>
<li>GC 要和操作系统进行交互，负责申请内存，并把不用的内存还给操作系统（释放内存）。</li>
<li>应用会向 GC 申请内存。</li>
<li>GC 要承担我们通常意义上说的垃圾回收能力，标记不用的对象，并回收他们。</li>
<li>GC 还需要针对应用特性进行动态的优化。</li>
</ol>
<p>所以现在程序语言实现的 GC 模块通常是实际负责应用内存管理的模块。在程序语言实现 GC 的时候，会关注下面这几个指标。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629163221.png" alt="image-20210629163221753"></p>
<ul>
<li><strong>吞吐量（Throughput）</strong>：执行程序（不包括 GC 执行的时间）和总是间的占比。注意这个吞吐量和通常意义上应用去处理作业的吞吐量是不一样的，这是从 GC 的角度去看应用。只要不在 GC，就认为是吞吐量的一部分。</li>
<li><strong>足迹（FootPrint）</strong>： 一个程序使用了多少硬件的资源，也称作程序在硬件上的足迹。GC 里面说的足迹，通常就是应用对内存的占用情况。比如说应用运行需要 2G 内存，但是好的 GC 算法能够帮助我们减少 500MB 的内存使用，满足足迹这个指标。</li>
<li><strong>暂停时间（Pause Time）</strong>： GC 执行的时候，通常需要停下应用（避免同步问题），这称为 Stop The World，或者暂停。不同应用对某次内存回收可以暂停的时间需求是不同的，比如说一个游戏应用，暂停了几毫秒用户都可能有很大意见；而看网页的用户，稍微慢了几毫秒是没有感觉的。</li>
</ul>
<p>GC 目标的思考</p>
<p>如果单纯从让 GC 尽快把工作做完的角度来讲，其实是提升吞吐量。比如利用好多核优势就是一种最直观的方法。</p>
<p>因为涉及并行计算，我这里给你讲讲并行计算领域非常重要的阿姆达定律，这个定律用来衡量并行计算对原有算法的改进，公式如下：</p>
<p>S = 1 / (1- P)</p>
<p>你现在看到的是一个简化版的阿姆达定律，P 是任务中可以并发执行部分的占比，S 是并行带来的理论提速倍数的极限。比如说 P 是 0.9，代入公式可得：</p>
<p>S = 1 / （1 - 0.9） = 10</p>
<p>上面表达式代表着有 90% 的任务可以并行，只有 10% 的任务不能够并行。假设我们拥有无限多的 CPU 去分担 90% 可以并行的任务，其实就相当于并行的任务可以在非常短的时间内完成。但是还有 10% 的任务不能并行，因此理论极限是 1/0.1=10 倍。</p>
<p>通常我们设计 GC，都希望它能够支持并行处理任务。因为 GC 本身也有着繁重的工作量，需要扫描所有的对象，对内存进行标记清除和整理等。</p>
<p><strong>经过上述分析，那么我们在设计算法的时候是不是应该尽量做到高并发呢？</strong></p>
<p>很可惜并不是这样。如果算法支持的并发度非常高，那么和单线程算法相比，它也会带来更多的其他开销。比如任务拆分的开销、解决同步问题的开销，还有就是空间开销，GC 领域空间开销通常称为 FootPrint。理想情况下当然是核越多越好，但是如果考虑计算本身的成本，就需要找到折中的方案。</p>
<p>还有一个问题是，GC 往往不能拥有太长的暂停时间（Pause Time），因为 GC 和应用是并发的执行。如果 GC 导致应用暂停（Stop The World，STL）太久，那么对有的应用来说是灾难性的。 比如说你用鼠标的时候，如果突然卡了你会很抓狂。如果一个应用提供给百万级的用户用，假设这个应用帮每个用户每天节省了 1s 的等待时间，那么按照乔布斯的说法每天就为用户节省了 11 天的时间，每年是 11 年——5 年就相当于拯救了一条生命。</p>
<p>如果暂停时间只允许很短，那么 GC 和应用的交替就需要非常频繁。这对 GC 算法要求就会上升，因为每次用户程序执行后，会产生新的变化，甚至会对已有的 GC 结果产生影响。后面我们在讨论标记-清除算法的时候，你会感受到这种情况。</p>
<p>所以说，吞吐量高，不代表暂停时间少，也不代表空间使用（FootPrint）小。 同样的，使用空间小的 GC 算法，吞吐量反而也会下降。<strong>正因为三者之间存在类似相同成本代价下不可兼得的关系，往往编程语言会提供参数让你选择根据自己的应用特性决定 GC 行为</strong>。</p>
<h4 id="引用计数算法（Reference-Counter）"><a href="#引用计数算法（Reference-Counter）" class="headerlink" title="引用计数算法（Reference Counter）"></a>引用计数算法（Reference Counter）</h4><p>接下来我们说说，具体怎么去实现 GC。实现 GC 最简单的方案叫作引用计数，下图中节点的引用计数是 2，代表有两个节点都引用了它。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629164711.png" alt="image-20210629164710950"></p>
<p>如果一个节点的引用计数是 0，就意味着没有任何一个节点引用它——此时，理论上这个节点应该被回收。GC 不断扫描引用计数为 0 的节点进行回收，就构成了最简单的一个内存回收算法。</p>
<p>但是，这个算法可能会出现下图中循环引用的问题（我们写程序的过程中经常会遇到这样的引用关系）。下图中三个节点，因为循环引用，引用计数都是 1。</p>
<p>引用计数是 1，因此就算这 3 个对象不会再使用了，GC 不会回收它们。</p>
<p>另一个考虑是在多线程环境下引用计数的算法一旦算错 1 次（比如因为没有处理好竞争条件），那么就无法再纠正了。而且处理竞争条件本身也比较耗费性能。</p>
<p>还有就是引用计数法回收内存会产生碎片，当然碎片不是只有引用计数法才有的问题，所有的 GC 都需要面对碎片。下图中内存回收的碎片可以通过整理的方式，清理出更多空间出来。关于内存空间的碎片，下一讲会有专门的一个小节讨论。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629164820.png" alt="image-20210629164820264"></p>
<p>综上，<strong>引用计数法出错概率大</strong>，比如我们编程时会有对象的循环引用；另一方面，<strong>引用计数法容错能力差</strong>，一旦计算错了，就会导致内存永久无法被回收，因此我们需要更好的方式。</p>
<h4 id="Root-Tracing-算法"><a href="#Root-Tracing-算法" class="headerlink" title="Root Tracing 算法"></a>Root Tracing 算法</h4><p>下面我再给你介绍一种更好的方式—— Root Tracing 算法。这是一类算法，后面我们会讲解的标记-清除算法和 3 色标记-清除算法都属于这一类。</p>
<p>Root Tracing 的原理是：从引用路径上，如果一个对象的引用链中包括一个根对象（Root Object），那么这个对象就是活动的。根对象是所有引用关系的源头。比如用户在栈中创建的对象指针；程序启动之初导入数据区的全局对象等。在 Java 中根对象就包括在栈上创建指向堆的对象；JVM 的一些元数据，包括 Method Area 中的对象等。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629164948.png" alt="image-20210629164948046"></p>
<p>在 Root Tracing 工作过程中，如果一个对象和根对象间有连通路径，也就是从根节点开始遍历可以找到这个对象，代表有对象可以引用到这个对象，那么这个节点就不需要被回收。所以算法的本质还是引用，只不过判断条件从引用计数变成了有根对象的引用链。</p>
<p>如果一个对象从根对象不可达，那么这个对象就应该被回收，即便这个对象存在循环引用。可以看到，上图中红色的 3 个对象循环引用，并且到根集合没有引用链，因此需要被回收。这样就解决了循环引用的问题。</p>
<p>Root Tracing 的容错性很好，GC 通过不断地执行 Root Tracing 算法找到需要回收的元素。如果在这个过程中，有一些本来应该回收的元素没有被计算出（比如并发原因），也不会导致这些对象永久无法回收。因为在下次执行 Root Tracing 的时候，GC 就会通过执行 Root Tracing 算法找到这些元素。不像引用计数法，一旦算错就很难恢复。</p>
<h4 id="标记-清除（Mark-Sweep）算法"><a href="#标记-清除（Mark-Sweep）算法" class="headerlink" title="标记-清除（Mark Sweep）算法"></a>标记-清除（Mark Sweep）算法</h4><p>下面我为你具体介绍一种 Root Tracing 的算法， 就是标记清除-算法。标记-清除算法中，用白色代表一种不确定的状态：可能被回收。 黑色代表一种确定的状态：不会被回收。算法的实现，就是为所有的对象染色。算法执行结束后，所有是白色的对象就需要被回收。</p>
<p>算法实现过程中，假设有两个全局变量是已知的：</p>
<ul>
<li>heapSet 中拥有所有对象</li>
<li>rootSet 中拥有所有 Root Object</li>
</ul>
<p>算法执行的第一步，就是将所有的对象染成白色，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> obj in heapSet &#123;</span><br><span class="line"></span><br><span class="line">    obj.color = white</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们定义一个标记函数，它会递归地将一个对象的所有子对象染成黑色，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func mark(obj) &#123;</span><br><span class="line"></span><br><span class="line">  if obj.color == white &#123;</span><br><span class="line"></span><br><span class="line">    obj.color = black</span><br><span class="line"></span><br><span class="line">    for v in references(obj) &#123;</span><br><span class="line"></span><br><span class="line">      mark(v)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629165508.png" alt="image-20210629165508334"></p>
<h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><p>上面的 mark 函数对 obj 进行了深度优先搜索。深度优先搜索，就是自然的递归序。随着递归函数执行，遇到子元素就遍历子元素，就构成了天然的深度优先搜索。还有一个相对的概念是广度优先搜索（Breadth First Serach），如果你不知道深度优先搜索和广度优先搜索，可以看下我下面的图例。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629165525.png" alt="image-20210629165525502"></p>
<p>上图中，深度优先搜索优先遍历完整的子树（递归），广度优先搜索优先遍历所有的子节点（逐层）。</p>
<p>然后我们从所有的 Root Object 开始执行 mark 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for root in rootSet &#123;</span><br><span class="line"></span><br><span class="line">  mark(root)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序执行结束后，所有和 Root Object 连通的对象都已经被染成了黑色。然后我们遍历整个 heapSet 找到白色的对象进行回收，这一步开始是<strong>清除（Sweep）阶段</strong>，以上是<strong>标记（Mark）阶段</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for obj in heapSet &#123;</span><br><span class="line"></span><br><span class="line">  if obj.color == white &#123;</span><br><span class="line"></span><br><span class="line">    free(obj)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上算法就是一个简单的标记-清除算法。相比引用计数，这个算法不需要维护状态。算法执行开始所有节点都被标记了一遍。结束的时候，算法找到的垃圾就被清除了。 算法有两个阶段，标记阶段（Mark），还有清除阶段（Sweep），因此被称为标记-清除算法。</p>
<p>这里请你思考：如果上面的 GC 程序在某个时刻暂停了下来，然后开始执行用户程序。如果用户程序删除了对某个已经标记为黑色对象的所有引用，用户程序没办法通知 GC 程序。这个节点就会变成浮动垃圾（Floating Garbage），需要等待下一个 GC 程序执行。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629165616.png" alt="image-20210629165616789"></p>
<p>假设用户程序和 GC 交替执行，用户程序不断进行修改（Mutation），而 GC 不断执行标记-清除算法。那么这中间会产生大量浮动垃圾影响 GC 的效果。</p>
<p>另一方面，考虑到 GC 是一个非常消耗性能程序，在某些情况下，我们希望 GC 能够增量回收。 比如说，用户仅仅是高频删除了一部分对象，那么是否可以考虑设计不需要从整个 Root 集合进行遍历，而是增量的只处理最近这一批变更的算法呢？答案是可以的，我们平时可以多执行增量 GC，偶尔执行一次全量 GC。具体增量的方式会在下一讲为你讲解。</p>
<p>我们发现双色标记-清除算法有一个明显的问题，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170014.png" alt="image-20210629170014302"></p>
<p>你可以把 GC 的过程看作标记、清除及程序不断对内存进行修改的过程，分成 3 种任务：</p>
<p>标记程序（Mark）</p>
<p>清除程序（Sweep）</p>
<p>变更程序（Mutation）</p>
<p>标记（Mark）就是找到不用的内存，清除（Sweep）就是回收不用的资源，而修改（Muation）则是指用户程序对内存进行了修改。通常情况下，在 GC 的设计中，上述 3 种程序不允许并行执行（Simultaneously）。对于 Mark、Sweep、Mutation 来说内存是共享的。如果并行执行相当于需要同时处理大量竞争条件的手段，这会增加非常多的开销。当然你可以开多个线程去 Mark、Mutation 或者 Sweep，但前提是每个过程都是独立的。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170109.png" alt="image-20210629170108855"></p>
<p>因为 Mark 和 Sweep 的过程都是 GC 管理，而 Mutation 是在执行应用程序，在实时性要求高的情况下可以允许一边 Mark，一边 Sweep 的情况； 优秀的算法设计也可能会支持一边 Mark、一边 Mutation 的情况。这种算法通常使用了 Read On Write 技术，本质就是先把内存拷贝一份去 Mark/Sweep，让 Mutation 完全和 Mark 隔离。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170301.png" alt="image-20210629170301428"></p>
<p>上图中 GC 开始后，拷贝了一份内存的原本，进行 Mark 和 Sweep，整理好内存之后，再将原本中所有的 Mutation 合并进新的内存。 这种算法设计起来会非常复杂，但是可以保证实时性 GC。</p>
<p>上图的这种 GC 设计比较少见，通常 GC 都会发生 STL（Stop The World）问题，Mark/Sweep/Mutation 只能够交替执行。也就是说， 一种程序执行的时候，另一种程序必须停止。</p>
<p>对于双色标记-清除算法，如果 Mark 和 Sweep 之间存在 Mutation，那么 Mutation 的伤害是比较大的。比如 Mutation 新增了一个白色的对象，这个白色的对象就可能会在 Sweep 启动后被清除。当然也可以考虑新增黑色的对象，这样对象就不会在 Sweep 启动时被回收。但是会发生下面这个问题，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170357.png" alt="image-20210629170357311"></p>
<p>如果一个新对象指向了一个已经删除的对象，一个新的黑色对象指向了一个白色对象，这个时候 GC 不会再遍历黑色对象，也就是白色的对象还是会被清除。因此，我们希望创建一个在并发环境更加稳定的程序，让 Mark/Mutation/Sweep 可以交替执行，不用特别在意它们之间的关联。</p>
<p>有一个非常优雅地实现就是再增加一种中间的灰色，把灰色看作可以增量处理的工作，来重新定义白色的含义。</p>
<h4 id="三色标记-清除算法（Tri-Color-Mark-Sweep）"><a href="#三色标记-清除算法（Tri-Color-Mark-Sweep）" class="headerlink" title="三色标记-清除算法（Tri-Color Mark Sweep）"></a>三色标记-清除算法（Tri-Color Mark Sweep）</h4><p>接下来，我会和你讨论这种有三个颜色标记的算法，通常称作三色标记-清除算法。首先，我们重新定义黑、白、灰三种颜色的含义：</p>
<p>白色代表需要 GC 的对象；</p>
<p>黑色代表确定不需要 GC 的对象；</p>
<p>灰色代表可能不需要 GC 的对象，但是还未完成标记的任务，也可以认为是增量任务。</p>
<p>在三色标记-清除算法中，一开始所有对象都染成白色。初始化完成后，会启动标记程序。在标记的过程中，是可以暂停标记程序执行 Mutation。</p>
<p>算法需要维护 3 个集合，白色集合、黑色集合、灰色集合。3 个集合是互斥的，对象只能在一个集合中。执行之初，所有对象都放入白色集合，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170534.png" alt="image-20210629170534268"></p>
<p>第一次执行，算法将 Root 集合能直接引用的对象加入灰色集合，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629170619.png" alt="image-20210629170618902"></p>
<p>接下来算法会不断从灰色集合中取出元素进行标记，主体标记程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while greySet.size() &gt; 0 &#123;</span><br><span class="line"></span><br><span class="line">  var item = greySet.remove();</span><br><span class="line"></span><br><span class="line">  mark(item);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标记的过程主要分为 3 个步骤：</p>
<ol>
<li>如果对象在白色集合中，那么先将对象放入灰色集合；</li>
<li>然后遍历节点的所有的引用对象，并递归所有引用对象；</li>
<li>当一个对象的所有引用对象都在灰色集合中，就把这个节点放入为黑色集合。</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func mark(obj) &#123;</span><br><span class="line"></span><br><span class="line">  if obj in whiteSet &#123;</span><br><span class="line"></span><br><span class="line">    greySet.add(obj)</span><br><span class="line"></span><br><span class="line">    for v in refs(obj) &#123;</span><br><span class="line"></span><br><span class="line">      mark(v)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    greySet.remove(obj)</span><br><span class="line"></span><br><span class="line">    blackSet.add(obj)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以观察下上面的程序，这是一个 DFS 的过程。如果多个线程对不同的 Root Object 并发执行这个算法，我们需要保证 3 个集合都是线程安全的，可以考虑利用 ConcurrentSet（这样性能更好），或者对临界区上锁。并发执行这个算法的时候，如果发现一个灰色节点说明其他线程正在处理这个节点，就忽略这个节点。这样，就解决了标记程序可以并发执行的问题。</p>
<p>当标记算法执行完成的时候，所有不需要 GC 的元素都会涂黑：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172322.png" alt="image-20210629172322359"></p>
<p>标记算法完成后，白色集合内就是需要回收的对象。</p>
<p>以上，是类似双色标记-清除算法的全量 GC 程序，我们从 Root 集合开始遍历，完成了对所有元素的标记（将它们放入对应的集合）。</p>
<p>接下来我们来考虑增加 GC（Incremental GC）的实现。首先对用户的修改进行分类，有这样 3 类修改（Mutation）需要考虑：</p>
<ol>
<li>创建新对象</li>
<li>删除已有对象</li>
<li>调整已有引用</li>
</ol>
<p>如果用户程序创建了新对象，可以考虑把新对象直接标记为灰色。虽然，也可以考虑标记为黑色，但是标记为灰色可以让 GC 意识到新增了未完成的任务。比如用户创建了新对象之后，新对象引用了之前删除的对象，就需要重新标记创建的部分。</p>
<p>如果用户删除了已有的对象，通常做法是等待下一次全量 Mark 算法处理。下图中我们删除了 Root Object 到 A 的引用，这个时候如果把 A 标记成白色，那么还需要判断是否还有其他路径引用到 A，而且 B,C 节点的颜色也需要重新计算。关键的问题是，虽然可以实现一个基于 A 的 DFS 去解决这个问题，但实际情况是我们并不着急解决这个问题，因为内存空间往往是有富余的。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172756.png" alt="image-20210629172756625"></p>
<p><strong>在调整已有的引用关系时，三色标记算法的表现明显更好</strong>。下图是对象 B 将对 C 的引用改成了对 F 的引用，C,F 被加入灰色集合。接下来 GC 会递归遍历 C,F，最终然后 F,E,G 都会进入灰色集合。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172811.png" alt="image-20210629172811414"></p>
<p>内存回收就好比有人在随手扔垃圾，清洁工需要不停打扫。如果清洁工能够跟上人们扔垃圾的速度，那么就不需要太多的 STL（Stop The World）。如果清洁工跟不上扔垃圾的速度，最终环境就会被全部弄乱，这个时候清洁工就会要求“Stop The World”。<strong>三色算法的优势就在于它支持多一些情况的 Mutation，这样能够提高“垃圾”被并发回收的概率</strong>。</p>
<p>目前的 GC 主要都是基于三色标记算法。 至于清除算法，有原地回收算法，也有把存活下来的对象（黑色对象）全部拷贝到一个新的区域的算法。</p>
<h4 id="碎片整理和生代技术"><a href="#碎片整理和生代技术" class="headerlink" title="碎片整理和生代技术"></a>碎片整理和生代技术</h4><p>三色标记-清除算法，还没有解决内存回收产生碎片的问题。通常，我们会在三色标记-清除算法之上，再构建一个整理内存（Compact）的算法。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172930.png" alt="image-20210629172930467"></p>
<p>Compact 算法将对象重新挤压到一起，让更多空间可以被使用。我们在设计这个算法时，观察到了一个现象：新创建出来的对象，死亡（被回收）概率会更高，而那些已经存在了一段时间的对象，往往更不容易死亡。这有点类似 LRU 缓存，其实是一个概率问题。接下来我们考虑针对这个现象进行优化。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629172919.png" alt="image-20210629172919695"></p>
<p>如上图所示，你可以把新创建的对象，都先放到一个统一的区域，在 Java 中称为伊甸园（Eden）。这个区域因为频繁有新对象死亡，因此需要经常 GC。考虑整理使用中的对象成本较高，因此可以考虑将存活下来的对象拷贝到另一个区域，Java 中称为存活区（Survior）。存活区生存下来的对象再进入下一个区域，Java 中称为老生代。</p>
<p>上图展示的三个区域，<strong>Eden、Survior 及老生代之间的关系是对象的死亡概率逐级递减，对象的存活周期逐级增加</strong>。三个区域都采用三色标记-清除算法。每次 Eden 存活下来的对象拷贝到 Survivor 区域之后，Eden 就可以完整的回收重利用。Eden 可以考虑和 Survivor 用 1:1 的空间，老生代则可以用更大的空间。Eden 中全量 GC 可以频繁执行，也可以增量 GC 混合全量 GC 执行。老生代中的 GC 频率可以更低，偶尔执行一次全量的 GC。</p>
<h4 id="GC-的选择"><a href="#GC-的选择" class="headerlink" title="GC 的选择"></a>GC 的选择</h4><p>最后我们来聊聊 GC 的选择。<strong>通常选择 GC 会有实时性要求（最大容忍的暂停时间），需要从是否为高并发场景、内存实际需求等维度去思考</strong>。<strong>在选择 GC 的时候，复杂的算法并不一定更有效。下面是一些简单有效的思考和判断</strong>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629173135.png" alt="image-20210629173135074"></p>
<ol>
<li>如果你的程序内存需求较小，GC 压力小，这个时候每次用双色标记-清除算法，等彻底标记-清除完再执行应用程序，用户也不会感觉到多少延迟。双色标记-清除算法在这种场景可能会更加节省时间，因为程序简单。</li>
<li>对于一些对暂停时间不敏感的应用，比如说数据分析类应用，那么选择一个并发执行的双色标记-清除算法的 GC 引擎，是一个非常不错的选择。因为这种应用 GC 暂停长一点时间都没有关系，关键是要最短时间内把整个 GC 执行完成。</li>
<li>如果内存的需求大，同时对暂停时间也有要求，就需要三色标记清除算法，让部分增量工作可以并发执行。</li>
<li>如果在高并发场景，内存被频繁迭代，这个时候就需要生代算法。将内存划分出不同的空间，用作不同的用途。</li>
<li>如果实时性要求非常高，就需要选择专门针对实时场景的 GC 引擎，比如 Java 的 Z。</li>
</ol>
<p><strong>当然，并不是所有的语言都提供多款 GC 选择。但是通常每个语言都会提供很多的 GC 参数</strong>。这里也有一些最基本的思路，下面我为你介绍一下。</p>
<p><strong>如果内存不够用，有两种解决方案。一种是降低吞吐量——相当于 GC 执行时间上升；另一种是增加暂停时间，暂停时间较长，GC 更容易集中资源回收内存</strong>。那么通常语言的 GC 都会提供设置吞吐量和暂停时间的 API。</p>
<p><strong>如果内存够用，有的 GC 引擎甚至会选择当内存达到某个阈值之后，再启动 GC 程序</strong>。通常阈值也是可以调整的。因此如果内存够用，就建议让应用使用更多的内存，提升整体的效率。</p>
<ul>
<li><strong>如何解决内存的循环引用问题？</strong></li>
<li><strong>三色标记清除算法的工作原理？</strong></li>
</ul>
<p>解决循环引用的问题可以考虑利用 Root Tracing 类的 GC 算法。从根集合利用 DFS 或者 BFS 遍历所有子节点，最终不能和根集合连通的节点都是需要回收的。</p>
<p>三色标记算法利用三种颜色进行标记。白色代表需要回收的节点；黑色代表不需要回收的节点；灰色代表会被回收，但是没有完成标记的节点。</p>
<p>初始化的时候所有节点都标记为白色，然后利用 DFS 从 Root 集合遍历所有节点。每遍历到一个节点就把这个节点放入灰色集合，如果这个节点所有的子节点都遍历完成，就把这个节点放入黑色的集合。最后白色集合中剩下的就是需要回收的元素。</p>
<p><strong>可不可以利用哈希表直接将页编号映射到 Frame 编号</strong>？</p>
<p>按照普通页表的设计，如果页大小是 4K，1G 空间内存需要 262144 个页表条目，如果每个条目用 4 个字节来存储，就需要 1M 的空间。那么创建 1T 的虚拟内存，就需要 1G 的空间。这意味着操作系统需要在启动时，就把这块需要的内存空间预留出来。</p>
<p>正因为我们设计的虚拟内存往往大于实际的内存，因此在历史上出现过各种各样节省页表空间的方案，其中就有用 HashTable 存储页表的设计。HashTable 是一种将键（Key）映射到值（Value）的数据结构。在页表的例子中，键是页编号，值是 Frame 编号。 你可以把这个 HashTable 看作存储了很多 &lt;PageId, FrameId&gt; 键值对的数据结构。</p>
<p>为了方便你理解下面的内容，我绘制了一张图。下图使用了一个有 1024 个条目的 HashTable。当查找页面 50000 的时候，先通过哈希函数 h 计算出 50000 对应的 HashTable 条目是 24。HashTable 的每个条目都是一个链表，链表的每个节点是一个 PageId 和 FrameId 的组合。接下来，算法会遍历条目 24 上的链表，然后找到 Page = 50000 的节点。取出 Frame 编号为 1232。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210629174119.png" alt="image-20210629174118903"></p>
<p>通常虚拟内存会有非常多的页，但是只有少数的页会被使用到。这种情况下，用传统的页表，会导致过多的空间被预分配。而基于 HashTable 的设计则不同，可以先分配少量的项，比如在上图中，先只分配了 1024 个项。每次查找一个页表编号发现不存在的情况，再去对应位置的链表中添加一个具体的键-值对。 这样就大大节省了内存。</p>
<p>当然节省空间也是有代价的，这会直接导致性能下降，因为比起传统页表我们可以直接通过页的编号知道页表条目，基于 HashTable 的做法需要先进行一次 Hash 函数的计算，然后再遍历一次链表。 最后，HashTable 的时间复杂度可以看作 O(k)，k 为 HashTable 表中总共的 &lt;k,v&gt; 数量除以哈希表的条目数。当 k 较小的时候 HashTable 的时间复杂度趋向于 O(1)。</p>
<p><strong>Java 和 Go 默认需不需要开启大内存分页?</strong></p>
<p>在回答什么情况下使用前，我们先说说这两个语言对大内存分页的支持。</p>
<p>当然，两门语言能够使用大内存分页的前提条件，是通过“<strong>25 讲”</strong>中演示的方式，开启了操作系统的大内存分页。满足这个条件后，我们再来说说两门语言还需要做哪些配置。</p>
<p><strong>Go 语言</strong></p>
<p>Go 是一门编译执行的语言。在 Go 编译器的前端，源代码被转化为 AST；在 Go 编译器的后端，AST 经过若干优化步骤，转化为目标机器代码。因此 Go 的内存分配程序基本上可以直接和操作系统的 API 对应。因为 Go 没有虚拟机。</p>
<p>而且 Go 提供了一个底层的库 syscall，直接支持上百个系统调用。 具体请参考<a href="https://golang.org/pkg/syscall/" target="_blank" rel="noopener">Go 的官方文档</a>。其中的 syscall.madvise 系统调用，可以直接提示操作系统某个内存区间的程序是否使用大内存分页技术加速 TLB 的访问。具体可以参考 Linux 中<a href="https://www.man7.org/linux/man-pages/man2/madvise.2.html" target="_blank" rel="noopener">madise 的文档</a>，这个工具的作用主要是提示操作系统如何使用某个区域的内存，开启大内存分页是它之中的一个选项。</p>
<p>下面的程序通过 malloc 分配内存，然后用 madvise 提示操作系统使用大内存分页的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line"></span><br><span class="line">size_t size = 256*1024*1024;</span><br><span class="line"></span><br><span class="line">char* mymemory = malloc(size);</span><br><span class="line"></span><br><span class="line">madvise(mymemory, size, MADV_HUGEPAGE);</span><br></pre></td></tr></table></figure>

<p>如果放到 Go 语言，那么需要用的是<code>runtime.sysAlloc</code>和<code>syscall.Madvise</code>函数。</p>
<p><strong>Java 语言</strong></p>
<p>JVM 是一个虚拟机，应用了Just-In-Time 在虚拟指令执行的过程中，将虚拟指令转换为机器码执行。 JVM 自己有一套完整的动态内存管理方案，而且提供了很多内存管理工具可选。在使用 JVM 时，虽然 Java 提供了 UnSafe 类帮助我们执行底层操作，但是通常情况下我们不会使用UnSafe 类。一方面 UnSafe 类功能不全，另一方面看名字就知道它过于危险。</p>
<p>Java 语言在“<strong>25 讲”中</strong>提到过有一个虚拟机参数：XX:+UseLargePages，开启这个参数，JVM 会开始尝试使用大内存分页。</p>
<p><strong>那么到底该不该用大内存分页</strong>？</p>
<p>首先可以分析下你应用的特性，看看有没有大内存分页的需求。通常 OS 是 4K，思考下你有没有需要反复用到大内存分页的场景。</p>
<p>另外你可以使用<code>perf</code>指令衡量你系统的一些性能指标，其中就包括<code>iTLB-load-miss</code>可以用来衡量 TLB Miss。 如果发现自己系统的 TLB Miss 较高，那么可以深入分析是否需要开启大内存分页。</p>
<p><strong>在 TLB 多路组相联缓存设计中（比如 8-way），如何实现 LRU 缓存</strong>？</p>
<p>TLB 是 CPU 的一个“零件”，在 TLB 的设计当中不可能再去内存中创建数据结构。因此在 8 路组相联缓存设计中，我们每次只需要从 8 个缓存条目中选择 Least Recently Used 缓存。</p>
<p><strong>增加累计值</strong></p>
<p>先说一种方法， 比如用硬件同时比较 8 个缓存中记录的缓存使用次数。这种方案需要做到 2 点：</p>
<ol>
<li>缓存条目中需要额外的空间记录条目的使用次数（累计位）。类似我们在页表设计中讨论的基于计时器的读位操作——每过一段时间就自动将读位累计到一个累计位上。</li>
<li>硬件能够实现一个快速查询最小值的算法。</li>
</ol>
<p>第 1 种方法会产生额外的空间开销，还需要定时器配合，成本较高。 注意缓存是很贵的，对于缓存空间利用自然能省则省。而第 2 种方法也需要额外的硬件设计。那么，有没有更好的方案呢？</p>
<p><strong>1bit 模拟 LRU</strong></p>
<p>一个更好的方案就是模拟 LRU，我们可以考虑继续采用上面的方式，但是每个缓存条目只拿出一个 LRU 位（bit）来描述缓存近期有没有被使用过。 缓存置换时只是查找 LRU 位等于 0 的条目置换。</p>
<p>还有一个基于这种设计更好的方案，可以考虑在所有 LRU 位都被置 1 的时候，清除 8 个条目中的 LRU 位（置零），这样可以节省一个计时器。 相当于发生内存操作，LRU 位置 1；8 个位置都被使用，LRU 都置 0。</p>
<p><strong>搜索树模拟 LRU</strong></p>
<p>最后我再介绍一个巧妙的方法——用搜索树模拟 LRU。</p>
<p>对于一个 8 路组相联缓存，这个方法需要 8-1 = 7bit 去构造一个树。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630074809.png" alt="image-20210630074808921"></p>
<p>8 个缓存条目用 7 个节点控制，每个节点是 1 位。0 代表节点指向左边，1 代表节点指向右边。</p>
<p>初始化的时候，所有节点都指向左边，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630074921.png" alt="image-20210630074921098"></p>
<p>接下来每次写入，会从根节点开始寻找，顺着箭头方向（0 向左，1 向右），找到下一个更新方向。比如现在图中下一个要更新的位置是 0。更新完成后，所有路径上的节点箭头都会反转，也就是 0 变成 1，1 变成 0。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630074952.png" alt="image-20210630074952274"></p>
<p>上图是<code>read a</code>后的结果，之前路径上所有的箭头都被反转，现在看到下一个位置是 4，我用橘黄色进行了标记。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630075950.png" alt="image-20210630075950806"></p>
<p>上图是发生操作<code>read b</code>之后的结果，现在橘黄色可以更新的位置是 2。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080008.png" alt="image-20210630080008756"></p>
<p>上图是读取 c 后的情况。后面我不一一绘出，假设后面的读取顺序是<code>d,e,f,g,h</code>，那么缓存会变成如下图所示的结果：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080027.png" alt="image-20210630080027636"></p>
<p>这个时候用户如果读取了已经存在的值，比如说<code>c</code>，那么指向<code>c</code>那路箭头会被翻转，下图是<code>read c</code>的结果：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080043.png" alt="image-20210630080043461"></p>
<p>这个结果并没有改变下一个更新的位置，但是翻转了指向 c 的路径。 如果要读取<code>x</code>，那么这个时候就会覆盖橘黄色的位置。</p>
<p><strong>因此，本质上这种树状的方式，其实是在构造一种先入先出的顺序。任何一个节点箭头指向的子节点，应该被先淘汰（最早被使用）</strong>。</p>
<p>这是一个我个人觉得非常天才的设计，因为如果在这个地方构造一个队列，然后每次都把命中的元素的当前位置移动到队列尾部。就至少需要构造一个链表，而链表的每个节点都至少要有当前的值和 next 指针，这就需要创建复杂的数据结构。在内存中创建复杂的数据结构轻而易举，但是在 CPU 中就非常困难。 所以这种基于 bit-tree，就轻松地解决了这个问题。当然，这是一个模拟 LRU 的情况，你还是可以构造出违反 LRU 缓存的顺序。</p>
<p><strong>如果内存太大了，无论是标记还是清除速度都很慢，执行一次完整的 GC 速度下降该如何处理</strong>？</p>
<p>当应用申请到的内存很大的时候，如果其中内部对象太多。只简单划分几个生代，每个生代占用的内存都很大，这个时候使用 GC 性能就会很糟糕。</p>
<p>一种参考的解决方案就是将内存划分成很多个小块，类似在应用内部再做一个虚拟内存层。 每个小块可能执行不同的内存回收策略。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080147.png" alt="image-20210630080147261"></p>
<p>上图中绿色、蓝色和橘黄色代表 3 种不同的区域。绿色区域中对象存活概率最低（类似 Java 的 Eden），蓝色生存概率上升，橘黄色最高（类似 Java 的老生代）。灰色区域代表应用从操作系统中已经申请了，但尚未使用的内存。通过这种划分方法，每个区域中进行 GC 的开销都大大减少。Java 目前默认的内存回收器 G1，就是采用上面的策略。</p>
<p><strong>通过内存管理的学习，我希望你开始理解虚拟化的价值，内存管理部分的虚拟化，是一种应对资源稀缺、增加资源流动性的手段</strong>（听起来那么像银行印的货币）。</p>
<h3 id="Linux-下的各个目录有什么作用？"><a href="#Linux-下的各个目录有什么作用？" class="headerlink" title="Linux 下的各个目录有什么作用？"></a><strong>Linux 下的各个目录有什么作用？</strong></h3><p>学习文件系统的意义在于文件系统有很多设计思路可以迁移到实际的工作场景中，比如：</p>
<ul>
<li>MySQL 的 binlog 和 Redis AOF 都像极了日志文件系统的设计；</li>
<li>B Tree 用于加速磁盘数据访问的设计，对于索引设计也有通用的意义。</li>
</ul>
<p>特别是近年来分布式系统的普及，学习分布式文件系统，也是理解分布式架构最核心的一个环节。其实文件系统最精彩的还是虚拟文件系统的设计，比如 Linux 可以支持每个目录用不同的文件系统。这些文件看上去是一个个目录和文件，实际上可能是磁盘、内存、网络文件系统、远程磁盘、网卡、随机数产生器、输入输出设备等，这样虚拟文件系统就成了整合一切设备资源的平台。大量的操作都可以抽象成对文件的操作，程序的书写就会完整而统一，且扩展性强。</p>
<p>这一讲，我会从 Linux 的目录结构和用途开始，带你认识 Linux 的文件系统。Linux 所有的文件都建立在虚拟文件系统（Virtual File System ，VFS）之上，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080417.png" alt="image-20210630080417018"></p>
<h4 id="分区结构"><a href="#分区结构" class="headerlink" title="分区结构"></a>分区结构</h4><p>在 Linux 中，<code>/</code>是根目录。之前我们在“<strong>08 讲</strong>”提到过，每个目录可以是不同的文件系统（不同的磁盘或者设备）。你可能会问我，<code>/</code>是对应一个磁盘还是多个磁盘呢？在<code>/</code>创建目录的时候，目录属于哪个磁盘呢？</p>
<p>当你访问一个目录或者文件，虽然用的是 Linux 标准的文件 API 对文件进行操作，但实际操作的可能是磁盘、内存、网络或者数据库等。<strong>因此，Linux 上不同的目录可能是不同的磁盘，不同的文件可能是不同的设备</strong>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080512.png" alt="image-20210630080512118"></p>
<p>你可以用<code>df -h</code>查看上面两个问题的答案，在上图中我的<code>/</code>挂载到了<code>/dev/sda5</code>上。如果你想要看到更多信息，可以使用<code>df -T</code>，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080549.png" alt="image-20210630080549828"></p>
<p><code>/</code>的文件系统类型是<code>ext4</code>。这是一种常用的日志文件系统。关于日志文件系统，我会在“<strong>30 讲”</strong>为你介绍。然后你可能还会有一个疑问，<code>/dev/sda5</code>究竟是一块磁盘还是别的什么？这个时候你可以用<code>fdisk -l</code>查看，结果如下图：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080610.png" alt="image-20210630080610257"></p>
<p>你可以看到我的 Linux 虚拟机上，有一块 30G 的硬盘（当然是虚拟的）。然后这块硬盘下有 3 个设备（Device）：/dev/sda1, /dev/sda2 和 /dev/sda5。在 Linux 中，数字 1~4 结尾的是主分区，通常一块磁盘最多只能有 4 个主分区用于系统启动。主分区之下，还可以再分成若干个逻辑分区，4 以上的数字都是逻辑分区。因此<code>/dev/sda2</code>和<code>/dev/sda5</code>是主分区包含逻辑分区的关系。</p>
<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>分区结构最终需要最终挂载到目录上。上面例子中<code>/dev/sda5</code>分区被挂载到了<code>/</code>下。 这样在<code>/</code>创建的文件都属于这个<code>/dev/sda5</code>分区。 另外，<code>/dev/sda5</code>采用<code>ext4</code>文件系统。可见<strong>不同的目录可以采用不同的文件系统</strong>。</p>
<p>将一个文件系统映射到某个目录的过程叫作挂载（Mount）。当然这里的文件系统可以是某个分区、某个 USB 设备，也可以是某个读卡器等。你可以用<code>mount -l</code>查看已经挂载的文件系统。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080742.png" alt="image-20210630080742427"></p>
<p>上图中的<code>sysfs``proc``devtmpfs``tmpfs``ext4</code>都是不同的文件系统，下面我们来说说它们的作用。</p>
<ul>
<li><code>sysfs</code>让用户通过文件访问和设置设备驱动信息。</li>
<li><code>proc</code>是一个虚拟文件系统，让用户可以通过文件访问内核中的进程信息。</li>
<li><code>devtmpfs</code>在内存中创造设备文件节点。</li>
<li><code>tmpfs</code>用内存模拟磁盘文件。</li>
<li><code>ext4</code>是一个通常意义上我们认为的文件系统，也是管理磁盘上文件用的系统。</li>
</ul>
<p>你可以看到挂载记录中不仅有文件系统类型，挂载的目录（on 后面部分），还有读写的权限等。你也可以用<code>mount</code>指令挂载一个文件系统到某个目录，比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda6 /abc</span><br></pre></td></tr></table></figure>

<p>上面这个命令将<code>/dev/sda6</code>挂载到目录<code>abc</code>。</p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>因为 Linux 内文件系统较多，用途繁杂，Linux 对文件系统中的目录进行了一定的归类，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630080849.png" alt="image-20210630080849295"></p>
<p><strong>最顶层的目录称作根目录，</strong> 用<code>/</code>表示。<code>/</code>目录下用户可以再创建目录，但是有一些目录随着系统创建就已经存在，接下来我会和你一起讨论下它们的用途。</p>
<p><strong>/bin（二进制</strong>）包含了许多所有用户都可以访问的可执行文件，如 ls, cp, cd 等。这里的大多数程序都是二进制格式的，因此称作<code>bin</code>目录。<code>bin</code>是一个命名习惯，比如说<code>nginx</code>中的可执行文件会在 Nginx 安装目录的 bin 文件夹下面。</p>
<p><strong>/dev（设备文件）</strong> 通常挂载在<code>devtmpfs</code>文件系统上，里面存放的是设备文件节点。通常直接和内存进行映射，而不是存在物理磁盘上。</p>
<p>值得一提的是其中有几个有趣的文件，它们是虚拟设备。</p>
<p><strong>/dev/null</strong>是可以用来销毁任何输出的虚拟设备。你可以用<code>&gt;</code>重定向符号将任何输出流重定向到<code>/dev/null</code>来忽略输出的结果。</p>
<p><strong>/dev/zero</strong>是一个产生数字 0 的虚拟设备。无论你对它进行多少次读取，都会读到 0。</p>
<p><strong>/dev/ramdom</strong>是一个产生随机数的虚拟设备。读取这个文件中数据，你会得到一个随机数。你不停地读取这个文件，就会得到一个随机数的序列。</p>
<p><strong>/etc（配置文件），</strong><code>/etc</code>名字的含义是<code>and so on……</code>，也就是“等等及其他”，Linux 用它来保管程序的配置。比如说<code>mysql</code>通常会在<code>/etc/mysql</code>下创建配置。再比如说<code>/etc/passwd</code>是系统的用户配置，存储了用户信息。</p>
<p><strong>/proc（进程和内核文件）</strong> 存储了执行中进程和内核的信息。比如你可以通过<code>/proc/1122</code>目录找到和进程<code>1122</code>关联的全部信息。还可以在<code>/proc/cpuinfo</code>下找到和 CPU 相关的全部信息。</p>
<p><strong>/sbin（系统二进制）</strong> 和<code>/bin</code>类似，通常是系统启动必需的指令，也可以包括管理员才会使用的指令。</p>
<p><strong>/tmp（临时文件）</strong> 用于存放应用的临时文件，通常用的是<code>tmpfs</code>文件系统。因为<code>tmpfs</code>是一个内存文件系统，系统重启的时候清除<code>/tmp</code>文件，所以这个目录不能放应用和重要的数据。</p>
<p><strong>/var （Variable data file,，可变数据文件）</strong> 用于存储运行时的数据，比如日志通常会存放在<code>/var/log</code>目录下面。再比如应用的缓存文件、用户的登录行为等，都可以放到<code>/var</code>目录下，<code>/var</code>下的文件会长期保存。</p>
<p><strong>/boot（启动）</strong> 目录下存放了 Linux 的内核文件和启动镜像，通常这个目录会写入磁盘最头部的分区，启动的时候需要加载目录内的文件。</p>
<p><strong>/opt（Optional Software，可选软件）</strong> 通常会把第三方软件安装到这个目录。以后你安装软件的时候，可以考虑在这个目录下创建。</p>
<p><strong>/root（root 用户家目录）</strong> 为了防止误操作，Linux 设计中 root 用户的家目录没有设计在<code>/home/root</code>下，而是放到了<code>/root</code>目录。</p>
<p><strong>/home（家目录）</strong> 用于存放用户的个人数据，比如用户<code>lagou</code>的个人数据会存放到<code>/home/lagou</code>下面。并且通常在用户登录，或者执行<code>cd</code>指令后，都会在家目录下工作。 用户通常会对自己的家目录拥有管理权限，而无法访问其他用户的家目录。</p>
<p><strong>/media（媒体）</strong> 自动挂载的设备通常会出现在<code>/media</code>目录下。比如你插入 U 盘，通常较新版本的 Linux 都会帮你自动完成挂载，也就是在<code>/media</code>下创建一个目录代表 U 盘。</p>
<p><strong>/mnt（Mount，挂载）</strong> 我们习惯把手动挂载的设备放到这个目录。比如你插入 U 盘后，如果 Linux 没有帮你完成自动挂载，可以用<code>mount</code>命令手动将 U 盘内容挂载到<code>/mnt</code>目录下。</p>
<p><strong>/svr（Service Data,，服务数据）</strong> 通常用来存放服务数据，比如说你开发的网站资源文件（脚本、网页等）。不过现在很多团队的习惯发生了变化， 有的团队会把网站相关的资源放到<code>/www</code>目录下，也有的团队会放到<code>/data</code>下。总之，在存放资源的角度，还是比较灵活的。</p>
<p><strong>/usr（Unix System Resource）</strong> 包含系统需要的资源文件，通常应用程序会把后来安装的可执行文件也放到这个目录下，比如说</p>
<ul>
<li><code>vim</code>编辑器的可执行文件通常会在<code>/usr/bin</code>目录下，区别于<code>ls</code>会在<code>/bin</code>目录下</li>
<li><code>/usr/sbin</code>中会包含有通常系统管理员才会使用的指令。</li>
<li><code>/usr/lib</code>目录中存放系统的库文件，比如一些重要的对象和动态链接库文件。</li>
<li><code>/usr/lib</code>目录下会有大量的<code>.so</code>文件，这些叫作<code>Shared Object</code>，类似<code>windows</code>下的<code>dll</code>文件。</li>
<li><code>/usr/share</code>目录下主要是文档，比如说 man 的文档都在<code>/usr/share/man</code>下面。</li>
</ul>
<h3 id="FAT、NTFS-和-Ext3-文件系统有什么区别？"><a href="#FAT、NTFS-和-Ext3-文件系统有什么区别？" class="headerlink" title="FAT、NTFS 和 Ext3 文件系统有什么区别？"></a><strong>FAT、NTFS 和 Ext3 文件系统有什么区别</strong>？</h3><p>10 年前 FAT 文件系统还是常见的格式，而现在 Windows 上主要是 NTFS，Linux 上主要是 Ext3、Ext4 文件系统。关于这块知识，一般资料只会从支持的磁盘大小、数据保护、文件名等各种维度帮你比较，但是最本质的内容却被一笔带过。<strong>它们最大的区别是文件系统的实现不同，具体怎么不同</strong>？<strong>文件系统又有哪些实现</strong>？这一讲，我将带你一起来探索和学习这部分知识。</p>
<h4 id="硬盘分块"><a href="#硬盘分块" class="headerlink" title="硬盘分块"></a>硬盘分块</h4><p>在了解文件系统实现之前，我们先来了解下操作系统如何使用硬盘。</p>
<p><strong>使用硬盘和使用内存有一个很大的区别，内存可以支持到字节级别的随机存取，而这种情况在硬盘中通常是不支持的</strong>。过去的机械硬盘内部是一个柱状结构，有扇区、柱面等。读取硬盘数据要转动物理的磁头，每转动一次磁头时间开销都很大，因此一次只读取一两个字节的数据，非常不划算。</p>
<p>随着 SSD 的出现，机械硬盘开始逐渐消失（还没有完全结束），现在的固态硬盘内部是类似内存的随机存取结构。但是硬盘的读写速度还是远远不及内存。而连续读多个字节的速度，还远不如一次读一个硬盘块的速度。</p>
<p>因此，<strong>为了提高性能，通常会将物理存储（硬盘）划分成一个个小块</strong>，比如每个 4KB。这样做也可以让硬盘的使用看起来非常整齐，方便分配和回收空间。况且，数据从磁盘到内存，需要通过电子设备，比如 DMA、总线等，如果一个字节一个字节读取，速度较慢的硬盘就太耗费时间了。过去的机械硬盘的速度可以比内存慢百万倍，现在的固态硬盘，也会慢几十到几百倍。即便是最新的 NvMe 接口的硬盘，和内存相比速度仍然有很大的差距。因此，一次读/写一个块（Block）才是可行的方案。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082207.png" alt="image-20210630082206967"></p>
<p>如上图所示，操作系统会将磁盘分成很多相等大小的块。这样做还有一个好处就是如果你知道块的序号，就可以准确地计算出块的物理位置。</p>
<h4 id="文件的描述"><a href="#文件的描述" class="headerlink" title="文件的描述"></a>文件的描述</h4><p>我们将硬盘分块后，如何利用上面的硬盘存储文件，就是文件系统（File System）要负责的事情了。当然目录也是一种文件，因此我们先讨论文件如何读写。不同的文件系统利用方式不同，今天会重点讨论 3 种文件系统：</p>
<ul>
<li>早期的 FAT 格式</li>
<li>基于 inode 的传统文件系统</li>
<li>日志文件系统（如 NTFS, EXT2、3、4）</li>
</ul>
<h4 id="FAT-表"><a href="#FAT-表" class="headerlink" title="FAT 表"></a>FAT 表</h4><p>早期人们找到了一种方案就是文件分配表（File Allocate Table，FAT）。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082256.png" alt="image-20210630082256398"></p>
<p><strong>一个文件，最基本的就是要描述文件在硬盘中到底对应了哪些块。FAT 表通过一种类似链表的结构描述了文件对应的块</strong>。上图中：文件 1 从位置 5 开始，这就代表文件 1 在硬盘上的第 1 个块的序号是 5 的块 。然后位置 5 的值是 2，代表文件 1 的下一个块的是序号 2 的块。顺着这条链路，我们可以找到 5 → 2 → 9 → 14 → 15 → -1。-1 代表结束，所以文件 1 的块是：5,2,9,14,15。同理，文件 2 的块是 3,8,12。</p>
<p><strong>FAT 通过一个链表结构解决了文件和物理块映射的问题，算法简单实用，因此得到过广泛的应用，到今天的 Windows/Linux/MacOS 都还支持 FAT 格式的文件系统</strong>。FAT 的缺点就是非常占用内存，比如 1T 的硬盘，如果块的大小是 1K，那么就需要 1G 个 FAT 条目。通常一个 FAT 条目还会存一些其他信息，需要 2~3 个字节，这就又要占用 2-3G 的内存空间才能用 FAT 管理 1T 的硬盘空间。显然这样做是非常浪费的，问题就出在了 FAT 表需要全部维护在内存当中。</p>
<h4 id="索引节点（inode）"><a href="#索引节点（inode）" class="headerlink" title="索引节点（inode）"></a>索引节点（inode）</h4><p>为了改进 FAT 的容量限制问题，可以考虑为每个文件增加一个索引节点（inode）。这样，随着虚拟内存的使用，当文件导入内存的时候，先导入索引节点（inode），然后索引节点中有文件的全部信息，包括文件的属性和文件物理块的位置。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082432.png" alt="image-20210630082432563"></p>
<p>如上图，索引节点除了属性和块的位置，还包括了一个指针块的地址。这是为了应对文件非常大的情况。一个大文件，一个索引节点存不下，需要通过指针链接到其他的块去描述文件。</p>
<p>这种文件索引节点（inode）的方式，完美地解决了 FAT 的缺陷，一直被沿用至今。FAT 要把所有的块信息都存在内存中，索引节点只需要把用到的文件形成数据结构，而且可以使用虚拟内存分配空间，随着页表置换，这就解决了 FAT 的容量限制问题。</p>
<h4 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h4><p>有了文件的描述，接下来我们来思考如何实现目录（Directory）。目录是特殊的文件，所以每个目录都有自己的 inode。目录是文件的集合，所以目录的内容中必须有所有其下文件的 inode 指针。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082520.png" alt="image-20210630082520140"></p>
<p>文件名也最好不要放到 inode 中，而是放到文件夹中。这样就可以灵活设置文件的别名，及实现一个文件同时在多个目录下。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082535.png" alt="image-20210630082535220"></p>
<p>如上图，/foo 和 /bar 两个目录中的 b.txt 和 c.txt 其实是一个文件，但是拥有不同的名称。这种形式我们称作“硬链接”，就是多个文件共享 inode。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082642.png" alt="image-20210630082642563"></p>
<p>硬链接有一个非常显著的特点，硬链接的双方是平等的。上面的程序我们用<code>ln</code>指令为文件 a 创造了一个硬链接<code>b</code>。如果我们创造完删除了 a，那么 b 也是可以正常工作的。如果要删除掉这个文件的 inode，必须 a,b 同时删除。这里你可以看出 a,b 是平等的。</p>
<p>和硬链接相对的是软链接，软链接的原理如下图：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630082707.png" alt="image-20210630082707436"></p>
<p>图中<code>c.txt</code>是<code>b.txt</code>的一个软链接，软链接拥有自己的<code>inode</code>，但是文件内容就是一个快捷方式。因此，如果我们删除了<code>b.txt</code>，那么<code>b.txt</code>对应的 inode 也就被删除了。但是<code>c.txt</code>依然存在，只不过指向了一个空地址（访问不到）。如果删除了<code>c.txt</code>，那么不会对<code>b.txt</code>造成任何影响。</p>
<p>在 Linux 中可以通过<code>ln -s</code>创造软链接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s a b # 将b设置为a的软链接(b是a的快捷方式)</span><br></pre></td></tr></table></figure>

<p>以上，我们对文件系统的实现有了一个初步的了解。从<strong>整体设计上，本质还是将空间切块，然后划分成目录和文件管理这些分块</strong>。读、写文件需要通过 inode 操作磁盘。操作系统提供的是最底层读写分块的操作，抽象成文件就交给文件系统。比如想写入第 10001 个字节，那么会分成这样几个步骤：</p>
<ol>
<li>修改内存中的数据</li>
<li>计算要写入第几个块</li>
<li>查询 inode 找到真实块的序号</li>
<li>将这个块的数据完整的写入一次磁盘</li>
</ol>
<p><strong>你可以思考一个问题，如果频繁读写磁盘，上面这个模型会有什么问题</strong>？可以把你的思考和想法写在留言区，我们在本讲后面会详细讨论。</p>
<h4 id="解决性能和故障：日志文件系统"><a href="#解决性能和故障：日志文件系统" class="headerlink" title="解决性能和故障：日志文件系统"></a>解决性能和故障：日志文件系统</h4><p><strong>在传统的文件系统实现中，inode 解决了 FAT 容量限制问题，但是随着 CPU、内存、传输线路的速度越来越快，对磁盘读写性能的要求也越来越高</strong>。传统的设计，每次写入操作都需要进行一次持久化，所谓“持久化”就是将数据写入到磁盘，这种设计会成为整个应用的瓶颈。因为磁盘速度较慢，内存和 CPU 缓存的速度非常快，如果 CPU 进行高速计算并且频繁写入磁盘，那么就会有大量线程阻塞在等待磁盘 I/O 上。磁盘的瓶颈通常在写入上，因为通常读取数据的时候，会从缓存中读取，不存在太大的瓶颈。</p>
<p>加速写入的一种方式，就是利用缓冲区。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630084651.png" alt="image-20210630084651264"></p>
<p>上图中所有写操作先存入缓冲区，然后每过一定的秒数，才进行一次持久化。 这种设计，是一个很好的思路，但最大的问题在于容错。 比如上图的步骤 1 或者步骤 2 只执行了一半，如何恢复？如果步骤 2 只写入了一半，那么数据就写坏了。如果步骤 1 只写入了一半，那么数据就丢失了。无论出现哪种问题，都不太好处理。更何况写操作和写操作之间还有一致性问题，比如说一次删除 inode 的操作后又发生了写入……</p>
<p>解决上述问题的一个非常好的方案就是利用日志。假设 A 是文件中某个位置的数据，比起传统的方案我们反复擦写 A，日志会帮助我们把 A 的所有变更记录下来，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A=1</span><br><span class="line"></span><br><span class="line">A=2</span><br><span class="line"></span><br><span class="line">A=3</span><br></pre></td></tr></table></figure>

<p>上面 A 写入了 3 次，因此有 3 条日志。日志文件系统文件中存储的就是像上面那样的日志，而不是文件真实的内容。当用户读取文件的时候，文件内容会在内存中还原，所以内存中 A 的值是 3，但实际磁盘上有 3 条记录。</p>
<p>从性能上分析，如果日志造成了 3 倍的数据冗余，那么读取的速度并不会真的慢三倍。因为我们多数时候是从内存和 CPU 缓存中读取数据。而写入的时候，因为采用日志的形式，可以考虑下图这种方式，在内存缓冲区中积累一批日志才写入一次磁盘。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630084827.png" alt="image-20210630084827466"></p>
<p>上图这种设计可以让写入变得非常快速，多数时间都是写内存，最后写一次磁盘。<strong>而上图这样的设计成不成立，核心在能不能解决容灾问题</strong>。</p>
<p>你可以思考一下这个问题——<strong>丢失一批日志和丢失一批数据的差别大不大</strong>。其实它们之间最大的差别在于，如果丢失一批日志，只不过丢失了近期的变更；但如果丢失一批数据，那么就可能造成永久伤害。</p>
<p>举个例子，比如说你把最近一天的订单数据弄乱了，你可以通过第三方支付平台的交易流水、系统的支付记录等帮助用户恢复数据，还可以通过订单关联的用户信息查询具体是哪些用户的订单出了问题。但是如果你随机删了一部分订单， 那问题就麻烦了。你要去第三发支付平台调出所有流水，用大数据引擎进行分析和计算。</p>
<p>为了进一步避免损失，一种可行的方案就是创建还原点（Checkpoint），比如说系统把最近 30s 的日志都写入一个区域中。下一个 30s 的日志，写入下一个区域中。每个区域，我们称作一个还原点。创建还原点的时候，我们将还原点涂成红色，写入完成将还原点涂成绿色。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630084959.png" alt="image-20210630084959570"></p>
<p>如上图，当日志文件系统写入磁盘的时候，每隔一段时间就会把这段时间内的所有日志写入一个或几个连续的磁盘块，我们称为还原点（Checkpoint）。操作系统读入文件的时候，依次读入还原点的数据，如果是绿色，那么就应用这些日志，如果是红色，就丢弃。所以上图中还原点 3 的数据是不完整的，这个时候会丢失不到 30s 的数据。如果将还原点的间隔变小，就可以控制风险的粒度。另外，我们还可以对还原点 3 的数据进行深度恢复，这里可以有人工分析，也可以通过一些更加复杂的算法去恢复。</p>
<ul>
<li>FAT 的设计简单高效，如果你要自己管理一定的空间，可以优先考虑这种设计。</li>
<li>inode 的设计在内存中创造了一棵树状结构，对文件、目录进行管理，并且索引到磁盘中的数据。这是一种经典的数据结构，这种思路会被数据库设计、网络资源管理、缓存设计反复利用。</li>
<li>日志文件系统——日志结构简单、容易存储、按时间容易分块，这样的设计非常适合缓冲、批量写入和故障恢复。</li>
</ul>
<p>现在我们很多分布式系统的设计也是基于日志，比如 MySQL 同步数据用 binlog，Redis 的 AOF，著名的分布式一致性算法 Paxos ，因此 Zookeeper 内部也在通过实现日志的一致性来实现分布式一致性。</p>
<p><strong>FAT、NTFS 和 Ext3 有什么区别</strong>？</p>
<p>FAT 通过内存中一个类似链表的结构，实现对文件的管理。<strong>NTFS 和 Ext3 是日志文件系统，它们和 FAT 最大的区别在于写入到磁盘中的是日志，而不是数据</strong>。日志文件系统会先把日志写入到内存中一个高速缓冲区，定期写入到磁盘。日志写入是追加式的，不用考虑数据的覆盖。一段时间内的日志内容，会形成还原点。这种设计大大提高了性能，当然也会有一定的数据冗余。</p>
<h3 id="MySQL-中-B-树和-B-树有什么区别？"><a href="#MySQL-中-B-树和-B-树有什么区别？" class="headerlink" title="MySQL 中 B 树和 B+ 树有什么区别？"></a><strong>MySQL 中 B 树和 B+ 树有什么区别？</strong></h3><p>B 树和 B+ 树是两种数据结构（关于它们的名字为什么以 B 开头，因为众说纷纭，本讲我就不介绍了），构建了磁盘中的高速索引结构，因此不仅 MySQL 在用，MongoDB、Oracle 等也在用，基本属于数据库的标配常规操作。</p>
<p>数据库要经常和磁盘与内存打交道，为了提升性能，通常需要自己去构建类似文件系统的结构。这一讲的内容有限，我只是先带你入一个门，如果你感兴趣后续可以自己深入学习。下面我们一起来探讨数据库如何利用磁盘空间设计索引。</p>
<h4 id="行存储和列存储"><a href="#行存储和列存储" class="headerlink" title="行存储和列存储"></a>行存储和列存储</h4><p>在学习构建磁盘数据的索引结构前，我们先通过行存储、列存储的学习来了解一些基本的存储概念，帮助你建立一个基本的认知。</p>
<p>目前数据库存储一张表格主要是行存储（Row Storage）和列存储（Column Storage）两种存储方式。行存储将表格看作一个个记录，每个记录是一行。以包含订单号、金额、下单时间 3 项的表为例，行存储如下图所示：</p>
<p><img src="C:\Users\flyho\AppData\Roaming\Typora\typora-user-images\image-20210630090802588.png" alt="image-20210630090802321"></p>
<p>如上图所示，在计算机中没有真正的行的概念。行存储本质就是数据一个接着一个排列，一行数据后面马上跟着另一行数据。如果订单表很大，一个磁盘块（Block）存不下，那么实际上就是每个块存储一定的行数。 类似下图这样的结构：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630090928.png" alt="image-20210630090928389"></p>
<p>行存储更新一行的操作，往往可以在一个块（Block）中进行。而查询数据，聚合数据（比如求 4 月份的订单数），往往需要跨块（Block）。因此，<strong>行存储优点很明显，更新快、单条记录的数据集中，适合事务。但缺点也很明显，查询慢</strong>。</p>
<p>还有一种表格的存储方式是列存储（Column Storage），列存储中数据是一列一列存的。还以订单表为例，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630091007.png" alt="image-20210630091007790"></p>
<p>你可以看到订单号在一起、姓名在一起、时间在一起、金额也在一起——每个列的数据都聚集在一起。乍一看这样的结构很低效，比如说你想取出第一条订单，需要取第 1 列的第 1 个数据<code>1001</code>，然后取第 2 列的第 1 个数据<code>小明</code>，以此类推，需要 4 次磁盘读取。特别是更新某一条记录的时候，需要更新多处，速度很慢。那么列存储优势在哪里呢？<strong>优势其实是在查询和聚合运算</strong>。</p>
<p>在列存储中同一列数据总是存放在一起，比如要查找某个时间段，很有可能在一个块中就可以找到，因为时间是集中存储的。假设磁盘块的大小是 4KB，一条记录是 100 字节， 那么 4KB 可以存 40 条记录；但是存储时间戳只需要一个 32 位整数，4KB 可以存储 1000 个时间。更关键的是，我们可以把一片连续的硬盘空间通过 DMA 技术直接映射到内存，这样就大大减少了搜索需要的时间。所以有时候在行存储需要几分钟的搜索操作，在列存储中只需几秒钟就可以完成。</p>
<p><strong>总结一下，行存储、列存储，最终都需要把数据存到磁盘块</strong>。行存储记录一个接着一个，列存储一列接着一列。前面我们提到行存储适合更新及事务处理，更新好理解，因为一个订单可以在相同的 Block 中更新，那么为什么适合事务呢？</p>
<p>其实适合不适合是相对的，说行存储适合是因为列存储非常不适合事务。试想一下，你更新一个表的若干个数据，如果要在不同块中更新，就可能产生多次更新操作。更新次数越多，保证一致性越麻烦。在单机环境我们可以上锁，可以用阻塞队列，可以用屏障……但是分布式场景中保证一致性（特别是强一致性）开销很大。因此我们说行存储适合事务，而列存储不适合。</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><strong>接下来，我们在行存储、列存储的基础上，讨论如何创建一些更高效的查询结构，这种结构通常称为索引</strong>。我们经常会遇到根据一个订单编号查订单的情况，比如说<code>select * from order where id=1000000</code>，这个时候就需要用到索引。而下面我将试图通过二分查找的场景，和你一起讨论<strong>索引是什么。</strong></p>
<p>在亿级的订单 ID 中查找某个编号，很容易想到二分查找。要理解二分查找，最需要关心的是算法的进步机制。这个算法每进行一次查找，都会让问题的规模减半。当然，也有场景限制，二分查找只能应用在排序好的数据上。</p>
<p>比如我们要在下面排序好的数组中查找 3：</p>
<p>1,3,5,8,11,12,15,19,21,25</p>
<p>数组中一共有 10 个元素，因此我们第一次查找从数组正中间的元素找起。如果数组正中间有两个元素，就取左边的那个——对于这个例子是 11。我们比较 11 和 3 的值，因为 11 大于 3，因此可以排除包括 11 在内的所有 11 右边的元素。相当于我们通过一次运算将数据的规模减半。假设我们有 240 （1T 数据）个元素需要查询（规模已经相当大了，万亿级别），用二分查找只需要 40 次运算。</p>
<p>所以按照这个思路，我们需要做的是将数据按照订单 ID 排好序，查询的时候就可以应用二分查找了。而且按照二分查找的思路，也可以进行范围查找。比如要查找 [a,b] 之间的数据，可以先通过二分查找找到 a 的序号，再二分找到 b 的序号，两个序号之间的数据就是目标结果。</p>
<p>但是直接在原始数据上排序，我们可能会把数据弄乱，常规做法是设计冗余数据描述这种排序关系——这就是索引。下面我通过一个简单的例子告诉你为什么不能在原始数据上直接排序。</p>
<p>假设我们有一个订单表，里面有订单 ID 和金额。使用列存储做演示如下：</p>
<p>订单 ID 列：</p>
<p>10005 10001 ……</p>
<p>订单金额列：</p>
<p>99.00 100.00 ……</p>
<p>可以看到，订单（10001）是第 2 个订单。但是进行排序后，订单（10001）会到第 1 个位置。这样会弄乱订单 ID（10001）和 金额（100.00）对应的关系。</p>
<p>因此我们必须用空间换时间，额外将订单列拷贝一份排序：</p>
<p>10001，2，10005， 1</p>
<p>以上这种<strong>专门用来进行数据查询的额外数据，就是索引</strong>。<strong>索引中的一个数据，也称作索引条目</strong>。上面的索引条目一个接着一个，每个索引条目是 &lt;订单 ID, 序号&gt; 的二元组。</p>
<p>如果你考虑是行存储（比如 MySQL），那么依然可以生成上面的索引，订单 ID 和序号（行号）关联。如果有多个索引，就需要创造多个上面的数据结构。如果有复合索引，比如 &lt;订单状态、日期、序号&gt; 作为一个索引条目，其实就是先按照订单状态，再按照日期排序的索引。</p>
<p>所以复合索引，无非就是多消耗一些空间，排序维度多一些。而且你可以看出复合索引和单列索引完全是独立关系，所以我们可以认为每创造一组索引，就创造了一份冗余的数据。也创造了一种特别的查询方式。关于索引还有很多有趣的知识，我们先介绍这些，如果感兴趣可以自己查资料深挖。</p>
<p>接下来，请分析一个非常<strong>核心的问题：上面的索引是一个连续的、从小到大的索引，那么应不应该使用这种从小到大排序的索引呢</strong>？例如，我们需要查询订单，就事先创建另一个根据订单 ID 从小到大排序的索引，当用户查找某个订单的时候，无论是行存储、还是列存储，我们就用二分查找查询对应的索引条目。这种方式，我们姑且称为线性排序索引——看似很不错的一个方式，但是并不是非常好的一种做法，请看我接下来的讨论。</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>线性排序的数据虽然好用，但是插入新元素的时候性能太低。如果是内存操作，插入一个元素，需要将这个元素之后的所有元素后移一位。但如果这个操作发生在磁盘中呢？这必然是灾难性的。因为磁盘的速度比内存慢至少 10-1000 倍，如果是机械硬盘可能慢几十万到百万倍。</p>
<p>所以我们不能用一种线性结构将磁盘排序。那么树呢？ 比如二叉搜索树（Binary Serach Tree）行不行呢？利用磁盘的空间形成一个二叉搜索树，例如将订单 ID 作为二叉搜索树的 Key。</p>
<p>如下图所示，二叉搜索树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点。而且，因为索引条目较少，确实可以考虑在查询的时候，先将足够大的树导入内存，然后再进行搜索。搜索的算法是递归的，与二分查找非常类似，每次计算可以将问题规模减半。当然，具体有多少数据可以导入内存，受实际可以使用的内存数量的限制。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630114725.png" alt="image-20210630114725249"></p>
<p>在上面的二叉搜索树中，每个节点的数据分成 Key 和 Value。Key 就是索引值，比如订单 ID 创建索引，那么 Key 就是订单 ID。值中至少需要序号（对行存储也就是行号）。这样，如果们想找 18 对应的行，就可以先通过二叉搜索树找到对应的行号，然后再去对应的行读取数据。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630114822.png" alt="image-20210630114822531"></p>
<p>二叉搜索树是一个天生的二分查找结构，每次查找都可以减少一半的问题规模。而且二叉搜索树解决了插入新节点的问题，因为二叉搜索树是一个跳跃结构，不必在内存中连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。</p>
<p><strong>那么回到本质问题，在使用磁盘的时候，二叉搜索树是不是一种合理的查询结构</strong>？</p>
<p>当然还不算，因此还需要继续优化我们的算法。二叉搜索树，在内存中是一个高效的数据结构。这是因为内存速度快，不仅可以随机存取，还可以高频操作。注意 CPU 缓存的穿透率只有 5% 左右，也就是 95% 的操作是在更快的 CPU 缓存中执行的。而且即便穿透，内存操作也是在纳秒级别可以完成。</p>
<p>但是，这个逻辑在磁盘中是不存在的，磁盘的速度慢太多了。我们可以尝试把尽可能多的二叉搜索树读入磁盘，但是如果数据量大，只能读入一部分呢？因此我们还需要继续改进算法。</p>
<h4 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B 树和 B+ 树"></a>B 树和 B+ 树</h4><p>二叉搜索树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。但是，当需要索引的数据量很大，无法在一个磁盘 Block 中存下整棵二叉搜索树的时候。每一次递归向下的搜索，实际都是读取不同的磁盘块。这个时候二叉搜索树的开销很大。</p>
<p>试想一个一万亿条订单的表，进行 40 次查找找到答案，在内存中不是问题，要考虑到 CPU 缓存有 90% 以上的命中率（当然前提是内存足够大）。通常情况下我们没有这么大的内存空间，如果 40 次查找发生在磁盘上，也是非常耗时的。那么有没有更好的方案呢？</p>
<p><strong>一个更好的方案，就是继续沿用树状结构，利用好磁盘的分块让每个节点多一些数据，并且允许子节点也多一些，树就会更矮。因为树的高度决定了搜索的次数</strong>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115010.png" alt="image-20210630115010402"></p>
<p><strong>上图中我们构造的树被称为 B 树</strong>（<strong>B-Tree</strong>），开头说过，B 这个字母具体是哪个单词或者人名的缩写，至今有争议，具体你可以查查资料。</p>
<p>B-Tree 是一种递归的搜索结构，与二叉搜索树非常类似。不同的是，B 树中的父节点中的数据会对子树进行区段分割。比如上图中节点 1 有 3 个子节点，并用数字 9,30 对子树的区间进行了划分。</p>
<p>上图中的 B 树是一个 3-4 B 树，3 指的是每个非叶子节点允许最大 3 个索引，4 指的是每个节点最多允许 4 个子节点，4 也指每个叶子节点可以存 4 个索引。上面只是一个例子，在实际的操作中，子节点有几十个、甚至上百个索引也很常见，因为我们希望树变矮，好减少磁盘操作。</p>
<p>B 树的每个节点是一个索引条目（例如：一个 &lt;订单 ID，序号&gt; 的组合），如果是行数据库可以索引到一条存储在磁盘上的记录。</p>
<h4 id="继承-B-树：B-树"><a href="#继承-B-树：B-树" class="headerlink" title="继承 B 树：B+ 树"></a>继承 B 树：B+ 树</h4><p>为了达到最高的效率，实战中我们往往使用的是一种继承于 B 树设计的结构，称为 B+ 树。B+ 树只有叶子节点才映射数据，下图中是对 B 树设计的一种改进，节点 1 为冗余节点，它不存储数据，只划定子树数据的范围。你可以看到节点 1 的索引 Key：12 和 30，在节点 3 和 4 中也有一份。</p>
<h4 id="树的形成：插入"><a href="#树的形成：插入" class="headerlink" title="树的形成：插入"></a>树的形成：插入</h4><p>下面我以一棵 2-3 B+ 树来演示 B+ 树的插入过程。2 指的是 B+ 树每个非叶子节点允许 2 个数据，叶子节点最多允许 3 个索引，每个节点允许最多 3 个子节点。我们要在 2-3 B+ 树中依次插入 3,6,9,12,19,15,26,8,30。下图是演示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115403.gif"></p>
<p>插入 3,6,9 过程很简单，都写入一个节点即可，因为叶子节点最多允许每个 3 个索引。接下来我们插入 12，会发生一次过载，然后节点就需要拆分，这个时候按照 B+ 树的设计会产生冗余节点。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115722.png" alt="image-20210630115722136"></p>
<p>然后插入 15 非常简单，直接加入即可：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115733.png" alt="image-20210630115733217"></p>
<p>接下来插入 19， 这个时候下图中红色部分发生过载：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115747.png" alt="image-20210630115747830"></p>
<p>因此需要拆分节点数据，我们从中间把红色的节点拆开，15 作为冗余的索引写入父节点，就形成下图的情况：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115757.png" alt="image-20210630115757351"></p>
<p>接着插入 26， 写入到对应位置即可。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115809.png" alt="image-20210630115809252"></p>
<p>接下来，插入 8 到对应位置即可。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115820.png" alt="image-20210630115820343"></p>
<p>然后我们插入 30，此时右边节点发生过载：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115834.png" alt="image-20210630115834408"></p>
<p>解决完一次过载问题之后，因为 26 会浮上去，根节点又发生了过载：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115846.png" alt="image-20210630115846288"></p>
<p>再次解决过载，拆分红色部分，得到最后结果：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630115857.png" alt="image-20210630115857267"></p>
<p>在上述过程中，B+ 树始终可以保持平衡状态，而且所有叶子节点都在同一层级。更复杂的数学证明，我就不在这里讲解了。不过建议对算法感兴趣对同学，可以学习《算法导论》中关于树的部分。</p>
<h4 id="插入和删除效率"><a href="#插入和删除效率" class="headerlink" title="插入和删除效率"></a>插入和删除效率</h4><p>B+ 树有大量的冗余节点，比如删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点。这样删除非常快。B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂。比如删除根节点中的数据，可能涉及复杂的树的变形。</p>
<p>B+ 树的插入也是一样，有冗余节点，插入可能存在节点的拆分（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要更多复杂的算法，类似红黑树的旋转操作等。</p>
<p>因此，<strong>B+ 树的插入和删除效率更高</strong>。</p>
<h4 id="搜索：链表的作用"><a href="#搜索：链表的作用" class="headerlink" title="搜索：链表的作用"></a>搜索：链表的作用</h4><p>B 树和 B+ 树搜索原理基本一致。先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。</p>
<p>你可能会注意到，B+ 树所有叶子节点间还有一个链表进行连接。这种设计对范围查找非常有帮助，比如说我们想知道 1 月 20 日和 1 月 22 日之间的订单，这个时候可以先查找到 1 月 20 日所在的叶子节点，然后利用链表向右遍历，直到找到 1 月22 日的节点。这样我们就进一步节省搜索需要的时间。</p>
<p>这一讲我们学习了在数据库中如何利用文件系统造索引。无论是行存储还是列存储，构造索引的过程都是类似的。索引有很多做法，除了 B+ 树，还有 HashTable、倒排表等。<strong>如果是存储海量数据的数据库，我们的思考点需要放在 I/O 的效率上</strong>。<strong>如果把今天的知识放到分布式数据库上，那除了需要节省磁盘读写还需要节省网络 I/O</strong>。</p>
<h3 id="MySQL-中的-B-树和-B-树有什么区别？"><a href="#MySQL-中的-B-树和-B-树有什么区别？" class="headerlink" title="MySQL 中的 B 树和 B+ 树有什么区别？"></a><strong>MySQL 中的 B 树和 B+ 树有什么区别？</strong></h3><p>B+ 树继承于 B 树，都限定了节点中数据数目和子节点的数目。B 树所有节点都可以映射数据，B+ 树只有叶子节点可以映射数据。</p>
<p>单独看这部分设计，看不出 B+ 树的优势。为了只有叶子节点可以映射数据，B+ 树创造了很多冗余的索引（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，而且可以自动平衡，因此 B+ 树的所有叶子节点总是在一个层级上。所以 B+ 树可以用一条链表串联所有的叶子节点，也就是索引数据，这让 B+ 树的范围查找和聚合运算更快。</p>
<h3 id="分布式文件系统是怎么回事？"><a href="#分布式文件系统是怎么回事？" class="headerlink" title="分布式文件系统是怎么回事？"></a><strong>分布式文件系统是怎么回事？</strong></h3><p>们讨论大数据环境下的数据管理——分布式文件系统和分布式数据库。分布式文件系统通过计算机网络连接大量物理节点，将不同机器、不同磁盘、不同逻辑分区的数据组织在一起，提供海量的数据存储（一般是 Petabytes 级别，1PB = 1024TB）。分布式数据库则在分布式文件系统基础上，提供应对具体场景的海量数据解决方案。</p>
<p>说起大数据，就不得不提历史上在存储领域影响深远的两篇 Paper。</p>
<ul>
<li>Google File System</li>
<li>BigTable：A Distributed Storage System for Structured Data</li>
</ul>
<p>Google File System 是一个分布式文件系统，构成了今天大数据生态的底层存储，也是我们本讲主角 HDFS 的原型。HDFS（Hadoop Distributed File System）是 Google File System 的一个重要实现。</p>
<p>后者 BigTable 是一个分布式数据库。BigTable 本身是 Google 内部的项目，建立在 Google File System 之上，为 Google 的搜索引擎提供数据支撑。它是 2005 年公布的第一个版本，而且通过 Paper 公布了实现，在那个大数据还处于萌芽阶段的时代，BigTable 成为了启明星，今天我们常用的 HBase 还沿用着 BigTable 的设计。</p>
<p>因为两个重量级的 Paper 都是 Google 的产物，所以这一讲，我会结合搜索引擎的设计，带你走进分布式存储和数据库的世界。</p>
<h4 id="存储所有的网页"><a href="#存储所有的网页" class="headerlink" title="存储所有的网页"></a>存储所有的网页</h4><p>作为搜索引擎最核心的一个能力，就是要存储所有的网页。目前世界上有 20 多亿个网站，每个网站还有大量的页面。搜索引擎不单单要存下这些页面，而且搜索引擎还需要存储这些网页的历史版本。</p>
<p>这里请你思考下，网站所有页面加起来有多大？举个例子，豆瓣所有页面加起来会有多大？如果把所有的变更都算上，比如一张页面经过 200 次迭代，就存 200 份，那么需要多少空间？Google 要把这些数据都存储下来，肯定是 PB 级别的数据。而且这个庞大的数据还需要提供给 Google 内部的分布式计算引擎等去计算，为网站打分、为用户生成索引，如果没有强大的存储能力是做不到的。</p>
<h4 id="模型的选择"><a href="#模型的选择" class="headerlink" title="模型的选择"></a>模型的选择</h4><p>我们先来思考应该用何种模型存下这个巨大的网页表。</p>
<p>网页的历史版本，可以用 URL+ 时间戳进行描述。但是为了检索方便，网页不仅有内容，还有语言、外链等。在存储端可以先不考虑提供复杂的索引，比如说提供全文搜索。但是我们至少应该提供合理的数据读写方式。</p>
<p>网页除了内容，还有外链，外链就是链接到网页的外部网站。链接到一个网站的外链越多，那就说明这个网站在互联网中扮演的角色越重要。Google 创立之初就在基于外链的质量和数量为网站打分。外链可能是文字链接、图片链接等，因此外链也可以有版本，比如外链文本调整了，图片换了。除了外链还有标题、Logo，也需要存储。其实要存储的内容有很多，我不一一指出了。</p>
<p>我们先看看行存储，可不可以满足需求。比如每个网页（ URL） 的数据是一行。 看似这个方案可行，可惜列不是固定。比如外链可能有很多个，如下表：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630120634.png" alt="image-20210630120634095"></p>
<p>列不固定，不仅仅是行的大小不好确定，而是表格画不出来。何况每一列内容还可能有很多版本，不同版本是搜索引擎的爬虫在不同时间收录的内容，再加上内容本身也很大，有可能一个磁盘 Block 都存不下。看来行存储困难重重。</p>
<p>那么列存储行不行呢？ 当然不行，我们都不确定到底有多少列？ 有的网站有几千个外链，有的一个都没有，外链到底用多少列呢？</p>
<p>所以上表只可以作为我们存储设计的一个逻辑概念——这种逻辑概念在设计系统的时候，还有一个名词，叫作领域语言。领域语言是我们的思考方式，从搜索引擎的职责上讲，数据需要按照上面的结构聚合。况且根据 URL 拿数据，这是必须提供的能力。但是底层如何持久化，还需要进一步思考。</p>
<p>因为列是不确定的，这种情况下只能考虑用 Key-Value 结构，也就是 Map 存储。Map 是一种抽象的数据结构，本质是 Key-Value 数据的集合。 作为搜索引擎的支撑，Key 可以考虑设计为 &lt;URL, Column，时间戳&gt; 的三元组，值就是对应版本的数据。</p>
<p>列名（Column）可以考虑分成两段，用<code>:</code>分隔开。列名包括列家族（Family) 、列标识（Qualifier）。这样设计是因为有时候多个列描述的是相似的数据，比如说外链（Anchor），就是一个列家族。然后百度、搜狐是外链家族的具体的标识（Qualifier）。比如来自百度页面 a 外链的列名是<code>anchor:baidu.com/a</code>。分成家族还有一个好处就是<strong>权限控制</strong>，比如不同部门的内部人员可以访问不同列家族的数据。当然有的列家族可能只有一个列，比如网页语言；有的列家族可能有很多列，比如外链。</p>
<p><strong>接下来，我们思考：这个巨大的 Map（Key-Value）的集合应该用什么数据结构呢？——数组？链表？树？哈希表</strong>？</p>
<p><em>小提示：Map 只是 Key-Value 的集合。并没有约定具体如何实现，比如 HashMap 就是用哈希表实现 Map，ArrayMap 就是用数组实现 Map。LinkedMap 就是用链表实现 Map。LinkedJumpMap 就是用跳表实现 Map……</em></p>
<p>考虑到一行的数据并不会太大，我们可以用 URL 作为行的索引。当用户想用 Key 查找 Value 时，先使用 Key 中 URL 帮用户找到完整的行。这里可以考虑使用上一讲学习的 B+ 树去存储所有的 URL，建立一个 URL 到行号的索引。你看看，知识总是被重复利用，再次证明了人类的本质是复读机，其实就是学好基础很重要。通过 B+ 树，这样即便真的有海量的数据，也可以在少数几次、几十次查询内完成找到 URL 对应的数据。况且，我们还可以设计缓存。</p>
<p>B+ 树需要一种顺序，比较好的做法是 URL 以按照字典序排列。这是因为，相同域名的网页资源同时被用到的概率更高，应该安排从物理上更近，尽量把相同域名的数据放到相邻的存储块中（节省磁盘操作）。</p>
<p>那么行内的数据应该如何存储呢？可以考虑分列存储。那么行内用什么数据结构呢？如果列非常多，也可以考虑继续用 B+ 树。还有一种设计思路，是先把大表按照行拆分，比如若干行形成一个小片称作 Tablet，然后 Tablet 内部再使用列存储，这个设计我们会在后面一点讨论。</p>
<h4 id="查询和写入"><a href="#查询和写入" class="headerlink" title="查询和写入"></a>查询和写入</h4><p>当客户端查询的时候，请求参数中会包含 &lt;URL, 列名&gt;，这个时候我们可以通过 B+ 树定位到具体的行（也就是 URL 对应的数据）所在的块，再根据列名找到具体的列。然后，将一列数据导入到内存中，最后在内存中找到对应版本的数据。</p>
<p>客户端写入时，也是按照行→列的顺序，先找到列，再在这一列最后面追加数据。</p>
<p>对于修改、删除操作可以考虑不支持，因为所有的变更已经记录下来了。</p>
<h4 id="分片（Tablet）的抽象"><a href="#分片（Tablet）的抽象" class="headerlink" title="分片（Tablet）的抽象"></a>分片（Tablet）的抽象</h4><p>上面我们提到了可以把若干行组合在一起存储的设计。这个设计比较适合数据在集群中分布。假设存储网页的表有几十个 PB，那么先水平分表，就是通过 行（URL） 分表。URL 按照字典排序，相邻的 URL 数据从物理上也会相近。水平分表的结果，字典序相近的行（URL）数据会形成分片（Tablet），Tablet 这个单词类似药片的含义。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122049.png" alt="image-20210630122049634"></p>
<p>如上图所示：每个分片中含有一部分的行，视情况而定。分片（Tablet），可以作为数据分布的最小单位。分片内部可以考虑图上的行存储，也可以考虑内部是一个 B+ 树组织的列存储。</p>
<p>为了实现分布式存储，每个分片可以对应一个分布式文件系统中的文件。假设这个分布式文件系统接入了 Linux 的虚拟文件系统，使用和操作会同 Linux 本地文件并无二致。其实不一定会这样实现，这只是一个可行的方案。</p>
<p>为了存储安全，一个分片最少应该有 2 个副本，也就是 3 份数据。3 份数据在其中一份数据不一致后，可以对比其他两份的结果修正数据。这 3 份数据，我们不考虑跨数据中心。因为跨地域成本太高，吞吐量不好保证，假设它们还在同一地域的机房内，只不过在不同的机器、磁盘上。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122159.png" alt="image-20210630122159671"></p>
<h4 id="块（Chunk）的抽象"><a href="#块（Chunk）的抽象" class="headerlink" title="块（Chunk）的抽象"></a>块（Chunk）的抽象</h4><p>比分片更小的单位是块（Chunk），这个单词和磁盘的块（Block）区分开。Chunk 是一个比 Block 更大的单位。Google File System 把数据分成了一个个 Chunk，然后每个 Chunk 会对应具体的磁盘块（Block）。</p>
<p>如下图，Table 是最顶层的结构，它里面含有许多分片（Tablets）。从数据库层面来看，每个分片是一个文件。数据库引擎维护到这个层面即可，至于这个文件如何在分布式系统中工作，就交给底层的文件系统——比如 Google File System 或者 Hadoop Distributed File System。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122235.png" alt="image-20210630122235204"></p>
<p>分布式文件系统通常会在磁盘的 Block 上再抽象一层 Chunk。一个 Chunk 通常比 Block 大很多，比如 Google File System 是 64KB，而通常磁盘的 Block 大小是 4K；HDFS 则是 128MB。这样的设计是为了减少 I/O 操作的频率，分块太小 I/O 频率就会上升，分块大 I/O 频率就减小。 比如一个 Google 的爬虫积攒了足够多的数据再提交到 GFS 中，就比爬虫频繁提交节省网络资源。</p>
<h4 id="分布式文件的管理"><a href="#分布式文件的管理" class="headerlink" title="分布式文件的管理"></a>分布式文件的管理</h4><p>接下来，我们来讨论一个完整的分布式系统设计。和单机文件系统一样，一个文件必须知道自己的数据（Chunk）存放在哪里。下图展示了一种最简单的设计，文件中包含了许多 Chunk 的 ID，然后每个 ChunkID 可以从 Chunk 的元数据中找到 Chunk 对应的位置。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122328.png" alt="image-20210630122327998"></p>
<p>如果 Chunk 比较大，比如说 HDFS 中 Chunk 有 128MB，那么 1PB 的数据需要 8,388,608 个条目。如果每个条目用 64bit 描述，也就是 8 个字节，只需要 64M 就可以描述清楚。考虑到一个 Chunk 必然会有冗余存储，也就是多个位置，实际会比 64M 多几倍，但也不会非常大了。</p>
<p>因此像 HDFS 和 GFS 等，为了简化设计会把所有文件目录结构信息，加上 Chunk 的信息，保存在一个单点上，通常称为 Master 节点。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122411.png" alt="image-20210630122411827"></p>
<p>下图中，客户端想要读取<code>/foo/bar</code>中某个 Chunk 中某段内容（Byterange）的数据，会分成 4 个步骤：</p>
<ol>
<li>客户端向 Master 发送请求，将想访问的文B件名、Chunk 的序号（可以通过 Chunk 大小和内容位置计算）；</li>
<li>Master 响应请求，返回 Chunk 的地址和 Chunk 的句柄（ID）；</li>
<li>客户端向 Chunk 所在的地址（一台 ChunkServer）发送请求，并将句柄（ID）和内容范围（Byterange）作为参数；</li>
<li>ChunkServer 将数据返回给客户端。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122600.png" alt="image-20210630122600057"></p>
<p>在上面这个模型中，有 3 个实体。</p>
<ol>
<li>客户端（Client）或者应用（Application），它们是数据的实际使用方，比如说 BigTable 数据库是 GFS 的 Client。</li>
<li>Master 节点，它存储了所有的文件信息、Chunk 信息，权限信息等。</li>
<li>ChunkServer 节点，它存储了实际的 Chunk 数据。</li>
</ol>
<p>Master 只有一台，ChunkServer 可以有很多台。上图中的 namespace 其实就是文件全名（含路径）的集合。Chunk 的 namespace 存储的是含文件全名 + ChunkLocation + ChunkID 的组合。文件的命名空间、Chunk 的命名空间，再加上文件和 Chunk 的对应关系，因为需要频繁使用，可以把它们全部都放到 Master 节点的内存中，并且利用 B 树等在内存中创建索引结构。ChunkServer 会和 Master 保持频繁的联系，将自己的变更告知 Master。这样就构成了一个完整的过程。</p>
<h4 id="读和写"><a href="#读和写" class="headerlink" title="读和写"></a>读和写</h4><p>读取文件的过程需要两次往返（Round Trip），第一次是客户端和 Master 节点，第二次是客户端和某个 ChunkServer。</p>
<p>写入某个 Chunk 的时候，因为所有存储了这个 Chunk 的服务器都需要更新，所以需要将数据推送给所有的 ChunkServer。这里 GFS 设计中使用了一个非常巧妙的方案，先由客户端将数据推送给所有 ChunkServer 并缓存，而不马上更新。直到所有 ChunkServer 都收到数据后，再集中更新。这样的做法减少了数据不一致的时间。</p>
<p>下图是具体的更新步骤：</p>
<ol>
<li>客户端要和服务器签订租约，得到一个租期（Lease）。其实就是 Chunk 和 Chunk 所有复制品的修改权限。如果一个客户端拿到租期，在租期内，其他客户端能不能修改这个 Chunk。</li>
<li>Master 告诉客户端该 Chunk 所有的节点位置。包括 1 台主节点（Primary）和普通节点（Secondary）。当然主节点和普通节点，都是 ChunkServer。主 ChunkServer 的作用是协助更新所有从 ChunkServer 的数据。</li>
<li>这一步是设计得最巧妙的地方。客户端接下来将要写入的数据同时推送给所有关联的 ChunkServer。这些 ChunkServer 不会更新数据，而是把数据先缓存起来。</li>
<li>图中的所有 ChunkServer 都收到了数据，并且给客户端回复后，客户端向主 ChunkServer 请求写入。</li>
<li>主 ChunkServer 通知其他节点写入数据。因为数据已经推送过来了，所以这一步很快完成。</li>
<li>写入完数据的节点，所有节点给主 ChunkServer 回复。</li>
<li>主 ChunkServer 通知客户端成功。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630122821.png" alt="image-20210630122821044"></p>
<p>以上，就是 GFS 的写入过程。这里有个规律，实现强一致性（所有时刻、所有客户端读取到的数据是一致的）就需要停下所有节点的工作牺牲可用性；或者牺牲分区容错性，减少节点。GFS 和 HDFS 的设计，牺牲的是一致性本身，允许数据在一定时间范围内是不一致的，从而提高吞吐量。</p>
<h4 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h4><p>在 HDFS 设计中，Master 节点也被称为 NameNode，用于存储命名空间数据。ChunkServer 也被称为 DataNode，用来存储文件数据。在 HDFS 的设计中，还有一个特殊的节点叫作辅助节点（Secondary Node）。辅助节点本身更像一个客户端，它不断和 NameNode 交流，并把 NameNode 最近的变更写成日志，存放到 DataNode 中。类似日志文件系统，每过一段时间，在 HDFS 中这些日志会形成一个还原点文件，这个机制和上一讲我们提到的日志文件系统类似。如果 Master 节点发生了故障，就可以通过这些还原点进行还原。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>在分布式文件系统和分布式数据库的设计中，还有很多有趣的知识，比如缓存的设计、空间的回收。如果你感兴趣，你可以进一步阅读我开篇给出的两篇论文。</p>
<ul>
<li>Google File System</li>
<li>BigTable：A Distributed Storage System for Structured Data</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>现在，我们已经可以把所有的场景都串联起来。Google 需要的是一个分布式数据库，存储的数据是包括内容、外链、Logo、标题等在内的网页的全部版本和描述信息。为了描述这些信息，一台机器磁盘不够大，吞吐量也不够大。因此 Google 需要将数据分布存储，将这个大表（BigTable）拆分成很多小片（Tablet）。当然，这并不是直接面向用户的架构。给几十亿用户提供高效查询，还需要分布式计算，计算出给用户使用的内容索引。</p>
<p>Google 团队发现将数据分布出去是一个通用需求。不仅仅是 BigTable 数据库需要，很多其他数据库也可以在这个基础上构造。按照软件设计的原则，每个工具应该尽可能的专注和简单， Google 的架构师意识到需要一个底层的文件系统，就是 Google File System。这样，BigTable 使用 Tablet 的时候，只需要当成文件在使用，具体的分布式读写，就交给了 GFS。</p>
<p>后来，Hadoop 根据 GFS 设计了 Hadoop 分布式文件系统，用于处理大数据，仍然延续了整个 GFS 的设计。</p>
<p>以上，是一个完整的，分布式数据库、分布式存储技术的一个入门级探讨。</p>
<p><strong>分布式文件系统是怎么回事</strong>？</p>
<p>分布式文件系统通过网络将不同的机器、磁盘、逻辑分区等存储资源利用起来，提供跨平台、跨机器的文件管理。通过这种方式，我们可以把很多相对廉价的服务器组合起来形成巨大的存储力量。</p>
<p><strong>socket 文件都存在哪里</strong>？</p>
<p>socket 没有实体文件，只有 inode，所以 socket 是没有名字的文件。</p>
<p>你可以在 /proc/net/tcp 目录下找到所有的 TCP 连接，在 /proc/[pid]/fd 下也可以找到这些 socket 文件，都是数字代号，数字就是 socket 文件的 fd，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630123321.png" alt="image-20210630123321474"></p>
<p>你也可以用<code>lsof -i -a -p [pid</code>查找某个进程的 socket 使用情况。下面结果和你用<code>ls /proc/[pid]/fd</code>看到的 fd 是一致的，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630123348.png" alt="image-20210630123348380"></p>
<p><strong>思考日志文件系统的数据冗余如何处理</strong>？</p>
<p>日志系统产生冗余几乎是必然发生的。 只要发生了修改、删除，肯定就会有数据冗余。日志系统通常不会主动压缩，但是日志文件系统通常会对磁盘碎片进行整理，这种机制和内存的管理非常相似。</p>
<p>首先我们把这个磁盘切割成很多等大的小块，大文件可能需要分配多个小块，多个小文件共用一个小块。而当很多文件被删除之后，磁盘中的小块会产生碎片，文件系统会进行碎片整理，比如把多个有很多碎片的区域拷贝到一起，使存储空间更加紧凑。</p>
<p>回到正题，最终的答案就是不压缩、不处理冗余，空间换时间，提升写入速度。</p>
<p><strong>按照应该尽量减少磁盘读写操作的原则，是不是哈希表的索引更有优势</strong>？</p>
<p>哈希表是一种稀疏的离散结构，通常使用键查找值。给定一个键，哈希表会通过数学计算的方式找到值的内存地址。因此，从这个角度去分析，哈希表的查询速度非常快。单独查找某一个数据速度超过了 B+ 树（比如根据姓名查找用户）。因此，包括 MySQL 在内的很多数据库，在支持 B+ 树索引的同时，也支持哈希表索引。</p>
<p><strong>这两种索引最大的区别是：B+ 树是对范围的划分，其中的数据还保持着连续性；而哈希表是一种离散的查询结构，数据已经分散到不同的空间中去了</strong>。所以当数据要进行<strong>范围查找</strong>时，比如查找某个区间内的订单，或者进行聚合运算，这个时候哈希表的性能就非常低了。</p>
<p>哈希表有一个设计约束，如果我们用了 m 个桶（Bucket，比如链表）去存储哈希表中的数据，再假设总共需要存储 N 个数据。那么平均查询次数 k = N/m。为了让 k 不会太大，当数据增长到一定规模时，哈希表需要增加桶的数目，这个时候就需要重新计算所有节点的哈希值（重新分配所有节点属于哪个桶）。</p>
<p>综上，对于大部分的操作 B+ 树都有较好的性能，比如说 &gt;,&lt;, =,BETWEEN，LIKE 等，哈希表只能用于等于的情况。</p>
<p><strong>Master 节点如果宕机了，影响有多大，如何恢复</strong>？</p>
<p>在早期的设计中，Master 是一个单点（Single Point），如果发生故障，系统就会停止运转，这就是所谓的单点故障（Single Point of Failure）。由此带来的后果会非常严重。发生故障后，虽然我们可以设置第二节点不断备份还原点，通过还原点加快系统恢复的速度，但是在数据的恢复期间，整个系统是不可用的。</p>
<p>在一个高可用的设计当中，我们不希望发生任何的单点故障（SPoF），因此所有的节点都至少有两份。于是在 Hadoop 后来的设计当中，增加了一种主从结构。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630123725.png" alt="image-20210630123725692"></p>
<p>如上图所示，我们同时维护两个 Master 节点（在 Hadoop 中称为 NameNode，NN）——一个活动（Active）的 NN 节点，一个待命（StandBy）的 NN 节点。</p>
<p>为了保证在系统出现故障的时候，可以迅速切换节点，我们需要一个故障控制单元。因为是分布式的设计，控制单元在每个 NN 中都必须有一个，这个单元可以考虑 NN 节点进程中的一个线程。控制单元不断地检测节点的状态，并且不断探测其他 NN 节点的状态。一旦检测到故障，控制单元随时准备切换节点。</p>
<p>一方面，因为我们不能信任任何的 NN 节点不出现故障，所以不能将节点的状态存在任何一个 NN 节点中。并且节点的状态也不适合存在数据节点中，因为大数据集群的数据节点实时性不够，它是用来存储大文件的。因此，可以考虑将节点的状态放入一个第三方的存储当中，通常就是 ZooKeeper。</p>
<p>另一方面，因为活动 NN 节点和待命 NN 节点数据需要完全一致，所以数据节点也会把自己的状态同时发送给活动节点和待命节点（比如命名空间变动等）。最后客户端会把请求发送给活动节点，因此活动节点会产生操作日志。不可以把活动节点的操作日志直接发送给待命节点，是因为我们不确定待命节点是否可用。</p>
<p>而且，为了保证日志数据不丢失，它们应该存储至少 3 份。即使其中一份数据发生损坏，也可以通过对比半数以上的节点（2 个）恢复数据。因此，这里需要设计专门的日志节点（Journal Node）存储日志。至少需要 3 个日志节点，而且必须是奇数。活动节点将自己的日志发送给日志节点，待命节点则从日志节点中读取日志，同步自己的状态。</p>
<p>我们再来回顾一下这个高可用的设计。<strong>为了保证可用性，我们增加了备用节点待命，随时替代活动节点</strong>。为了达成这个目标。有 3 类数据需要同步。</p>
<ul>
<li><strong>数据节点同步给主节点的日志</strong>。这类数据由数据节点同时同步给活动、待命节点。</li>
<li><strong>活动节点同步给待命节点的操作记录</strong>。这类数据由活动节点同步给日志节点，再由日志节点同步给待命节点。日志又至少有 3 态机器的集群保管，每个上放一个日志节点。</li>
<li><strong>记录节点本身状态的数据</strong>（比如节点有没有心跳）。这类数据存储在分布式应用协作引擎上，比如 ZooKeeper。</li>
</ul>
<p>有了这样的设计，当活动节点发生故障的时候，只需要迅速切换节点即可修复故障。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>这个模块我们对文件系统进行了系统的学习，下面我来总结一下文件系统的几块核心要点。</p>
<ul>
<li>理解虚拟文件系统的设计，理解在一个目录树结构当中，可以拥有不同的文件系统——一切皆文件的设计。基于这种结构，设备、磁盘、分布式文件系、网络请求都可以是文件。</li>
<li>将空间分块管理是一种高效的常规手段。方便分配、方便回收、方便整理——除了文件系统，内存管理和分布式文件系统也会用到这种手段。</li>
<li>日志文件系统的设计是重中之重，日志文件系统通过空间换时间，牺牲少量的读取性能，提升整体的写入效率。除了单机文件系统，这种设计在分布式文件系统和很多数据库当中也都存在。</li>
<li>分层架构：将数据库系统、分布式文件系搭建在单机文件管理之上——知识是死的、思路是活的。希望你能将这部分知识运用到日常开发中，提升自己系统的性能。</li>
</ul>
<h3 id="互联网协议群（TCP-IP）：多路复用是怎么回事？"><a href="#互联网协议群（TCP-IP）：多路复用是怎么回事？" class="headerlink" title="互联网协议群（TCP/IP）：多路复用是怎么回事？"></a><strong>互联网协议群（TCP/IP）：多路复用是怎么回事？</strong></h3><p>现在来看，“计算机网络”也许是一个过时的词汇，它讲的是怎么用计算实现通信。今天我们已经发展到了一个互联网、物联网的时代，社交网络、云的时代，再来看网络，意义已经发生转变。但这里面还是有很多经典的知识依旧在传承。比如说 TCP/IP 协议，问世后就逐渐成为占有统治地位的通信协议。虽然后面诞生出了许许多多的协议，但是我们仍然习惯性地把整个互联网的架构称为 TCP/IP 协议群，也叫作互联网协议群（Internet Protocol Suit）。</p>
<h4 id="协议的分层"><a href="#协议的分层" class="headerlink" title="协议的分层"></a>协议的分层</h4><p>对于多数的<strong>应用</strong>和<strong>用户</strong>而言，使用互联网的一个基本要求就是数据可以无损地到达。用户通过应用进行网络通信，应用启动之后就变成了进程。因此，<strong>所有网络通信的本质目标就是进程间通信</strong>。世界上有很多进程需要通信，我们要找到一种通用的，每个进程都能认可和接受的通信方式，这就是<strong>协议</strong>。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>从分层架构上看，应用工作在应用层（<strong>Application Layer</strong>）。应用的功能，都在应用层实现。所以应用层很好理解，说的就是应用本身。当两个应用需要通信的时候，应用（进程中的线程）就调用传输层进行通信。从架构上说，应用层只专注于为用户提供价值即可，没有必要思考数据如何传输。而且应用的开发商和传输库的提供方也不是一个团队。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630132054.png" alt="image-20210630132054214"></p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>为应用层提供网络支持的，就是传输层（<strong>Transport Layer</strong>）。</p>
<p>传输层控制协议（Transmission Control Protocol）是目前世界上应用最广泛的传输层协议。传输层为应用提供通信能力。比如浏览器想访问服务器，浏览器程序就会调用传输层程序；Web 服务接收浏览器的请求，Web 服务程序就会调用传输层程序接收数据。</p>
<p>考虑到应用需要传输的数据可能会非常大，直接传输不好控制。传输层需要将数据切块，即使一个分块传丢了、损坏了，可以重新发一个分块，而不用重新发送整体。在 TCP 协议中，我们把每个分块称为一个 TCP 段（TCP Segment）。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630132147.png" alt="image-20210630132147250"></p>
<p>传输层负责帮助应用传输数据给应用。考虑到一台主机上可能有很多个应用在传输数据，而一台服务器上可能有很多个应用在接收数据。因此，我们需要一个编号将应用区分开。这个编号就是<strong>端口号</strong>。比如 80 端口通常是 Web 服务器在使用；22 端口通常是远程登录服务在使用。而桌面浏览器，可能每个打开的标签栏都是一个独立的进程，每个标签栏都会使用临时分配的端口号。TCP 封包（TCP Segment）上携带了端口号，接收方可以识别出封包发送给哪个应用。</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p><strong>接下来你要思考的问题是：传输层到底负不负责将数据从一个设备传输到另一个设备</strong>（主机到主机，Host To Host）。仔细思考这个过程，你会发现如果这样设计，传输层就会违反简单、高效、专注的设计原则。</p>
<p>我们从一个主机到另一个主机传输数据的网络环境是非常复杂的。中间会通过各种各样的线路，有形形色色的交叉路口——有各式各样的路径和节点需要选择。<strong>核心的设计原则是，我们不希望一层协议处理太多的问题。传输层作为应用间数据传输的媒介，服务好应用即可</strong>。对应用层而言，传输层帮助实现应用到应用的通信。而实际的传输功能交给传输层的下一层，也就是<strong>网络层（Internet Layer）</strong> 会更好一些。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630132331.png" alt="image-20210630132331789"></p>
<p>IP 协议（Internet Protocol）是目前起到统治地位的网络层协议。IP 协议会将传输层的封包再次切分，得到 IP 封包。网络层负责实际将数据从一台主机传输到另一台主机（Host To Host），因此网络层需要区分主机的编号。</p>
<p>在互联网上，我们用 IP 地址给主机进行编号。例如 IPv4 协议，将地址总共分成了四段，每段是 8 位，加起来是 32 位。寻找地址的过程类似我们从国家、城市、省份一直找到区县。当然还有特例，比如有的城市是直辖市，有的省份是一个特别行政区。而且国与国体制还不同，像美国这样的国家，一个州其实可以相当于一个国家。</p>
<p>IP 协议里也有这个问题，类似行政区域划分，IP 协议中具体如何划分子网，需要配合<strong>子网掩码</strong>才能够明确。每一级网络都需要一个子网掩码，来定义网络子网的性质，相当于告诉物流公司到这一级网络该如何寻找目标地址，也就是寻址（Addressing）。关于更多子网掩码如何工作，及更多原理类的知识我会在拉勾教育的《<strong>计算机网络</strong>》专栏中和你分享。</p>
<p>除了<strong>寻址</strong>（<strong>Addressing</strong>），IP 协议还有一个非常重要的能力就是路由。在实际传输过程当中，数据并不是从主机直接就传输到了主机。而是会经过网关、基站、防火墙、路由器、交换机、代理服务器等众多的设备。而网络的路径，也称作链路，和现实生活中道路非常相似，会有岔路口、转盘、高速路、立交桥等。</p>
<p>因此，当封包到达一个节点，需要通过算法决定下一步走哪条路径。我们在现实生活中经常会碰到多条路径都可以到达同一个目的地的情况，在网络中也是如此。总结一下。<strong>寻址告诉我们去往下一个目的地该朝哪个方向走，路由则是根据下一个目的地选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p>
<h4 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h4><p>考虑到现实的情况，网络并不是一个完整的统一体。比如一个基站覆盖的周边就会形成一个网络。一个家庭的所有设备，一个公司的所有设备也会形成一个网络。所以在现实的情况中，数据在网络中设备间或者跨网络进行传输。而数据一旦需要跨网络传输，就需要有一个设备同时在两个网络当中。通过路由，我们知道了下一个要去的 IP 地址，可是当前的网络中哪个设备对应这个 IP 地址呢？</p>
<p>为了解决这个问题，我们需要有一个专门的层去识别网络中的设备，让数据在一个链路（网络中的路径）中传递，这就是<strong>数据链路层</strong>（<strong>Data Link Layer</strong>）<strong>。数据链路层为网络层提供链路级别传输的支持</strong>。</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>当数据在实际的设备间传递时，可能会用电线、电缆、光纤、卫星、无线等各种通信手段。因此，还需要一层将光电信号、设备差异封装起来，为数据链路层提供二进制传输的服务。这就是<strong>物理层（Physical Layer）。</strong></p>
<p>因此，从下图中你可以看到，由上到下，互联网协议可以分成五层，分别是应用层、传输层、网络层、数据链路层和物理层。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630133938.png" alt="image-20210630133938525"></p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>在上述的分层模型当中，一台机器上的应用可以有很多。但是实际的出口设备，比如说网卡、网线通常只有一份。因此这里需要用到一个叫作多路复用（Multiplex）的技术。多路复用，就是多个信号，复用一个信道。</p>
<h4 id="传输层多路复用"><a href="#传输层多路复用" class="headerlink" title="传输层多路复用"></a>传输层多路复用</h4><p>对应用而言，应用层抽象应用之间通信的模型——比如说请求返回模型。一个应用可能会同时向服务器发送多个请求。因为建立一个连接也是需要开销的，所以可以多个请求复用一个 TCP 连接。复用连接一方面可以节省流量，另一方面能够降低延迟。如果应用<strong>串行地</strong>向服务端发送请求，那么假设第一个请求体积较大，或者第一个请求发生了故障，就会阻塞后面的请求。</p>
<p>而使用多路复用技术，如下图所示，多个请求相当于并行的发送请求。即使其中某个请求发生故障，也不会阻塞其他请求。从这个角度看，多路复用实际上是一种 Non-Blocking（非阻塞）的技术。我们再来看下面这张图，不同的请求被传输层切片，我用不同的颜色区分出来，如果其中一个数据段（TCP Segment）发生异常，只影响其中一个颜色的请求，其他请求仍然可以到达服务。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630134225.png" alt="image-20210630134225434"></p>
<h4 id="网络层多路复用"><a href="#网络层多路复用" class="headerlink" title="网络层多路复用"></a>网络层多路复用</h4><p>传输层是一个虚拟的概念，但是网络层是实实在在的。两个应用之间的传输，可以建立无穷多个传输层连接，前提是你的资源足够。但是两个应用之间的线路、设备，需要跨越的网络往往是固定的。在我们的互联网上，每时每刻都有大量的应用在互发消息。而这些应用要复用同样的基础建设——网线、路由器、网关、基站等。</p>
<p>网络层没有连接这个概念。你可以把网络层理解成是一个巨大的物流公司。不断从传输层接收数据，然后进行打包，每一个包是一个 IP 封包。然后这个物流公司，负责 IP 封包的收发。所以，是很多很多的传输层在共用底下同一个网络层，这就是网络层的多路复用。</p>
<p>总结一下。<strong>应用层的多路复用，如多个请求使用同一个信道并行的传输，实际上是传输层提供的多路复用能力</strong>。<strong>传输层的多路复用，比如多个 TCP 连接复用一条线路，实际上是网络层在提供多路复用能力</strong>。你可以把网络层想象成一个不断收发包裹的机器，在网络层中并没有连接这个概念，所以网络层天然就是支持多路复用的。</p>
<h4 id="多路复用的意义"><a href="#多路复用的意义" class="headerlink" title="多路复用的意义"></a>多路复用的意义</h4><p>在工作当中，我们经常会使用到多路复用的能力。多路复用让多个信号（例如：请求/返回等）共用一个信道（例如：一个 TCP 连接），那么在这个信道上，信息密度就会增加。在密度增加的同时，通过并行发送信号的方式，可以减少阻塞。比如说应用层的 HTTP 协议，浏览器打开的时候就会往服务器发送很多个请求，多个请求混合在一起，复用相同连接，数据紧密且互相隔离（不互相阻塞）。同理，服务之间的远程调用、消息队列，这些也经常需要多路复用。</p>
<p><strong>多路复用是怎么回事</strong>？</p>
<p>【<strong>解析</strong>】多路复用让多个信号（例如：请求/返回等）共用一个信道（例如：一个 TCP 连接）。它有两个明显的优势。</p>
<ol>
<li>提升吞吐量。多一个信号被紧密编排在一起（例如：TCP 多路复用节省了多次连接的数据），这样网络不容易空载。</li>
<li>多个信号间隔离。信号间并行传输，并且隔离，不会互相影响。</li>
</ol>
<h3 id="UDP-协议：UDP-和-TCP-相比快在哪里？"><a href="#UDP-协议：UDP-和-TCP-相比快在哪里？" class="headerlink" title="UDP 协议：UDP 和 TCP 相比快在哪里？"></a><strong>UDP 协议：UDP 和 TCP 相比快在哪里？</strong></h3><p>TCP 和 UDP 是目前使用最广泛的两个传输层协议，同时也是面试考察的重点内容。今天我会初步带你认识这两个协议，一起探寻它们之间最大的区别。</p>
<p>在开始本讲的重点内容前，我们先来说说 RFC 文档（Request For Comments，请求评论），互联网的很多基础建设都是以 RFC 的形式文档化，它给用户提供了阅读和学习的权限。在给大家准备《<strong>计算机网络</strong>》专栏的时候，我也经常查阅 RFC 文档。</p>
<p>如果你查阅 TCP 和 UDP 的 RFC 文档，会发现一件非常有趣的事情。TCP 协议的 RFC 很长，我足足读了好几天才把它们全部弄明白。UDP 的 RFC 非常短，只有短短的两页，一个小时就能读明白。这让我不禁感叹，如果能穿越到当时那个年代，我就去发明 UDP 协议，因为实在是太简单了。但即使是这个简单协议，也同样主宰着计算机网络协议的半壁江山。</p>
<p>那么这一讲我们就以 TCP 和 UDP 的区别为引，带你了解这两个在工作中使用频率极高、极为重要的传输层协议。</p>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>首先我们比较一下这两个协议在<strong>可靠性（Reliablility）\</strong>上的区别。如果一个网络协议是可靠的，那么它能够保证数据被**无损**地传送到目的地。当应用的设计者选择一个具有可靠性的协议时，通常意味着这个应用不能容忍数据在传输过程中被损坏。</p>
<p>如果你是初学者，可能会认为所有的应用都需要可靠性。其实不然，比如说一个视频直播服务。如果在传输过程当中，视频图像发生了一定的损坏，用户看到的只是某几个像素、颜色不准确了，或者某几帧视频丢失了——这对用户来说是可以容忍的。但在观看视频的时候，用户最怕的不是实时数据发生一定的损坏，而是吞吐量得不到保证。比如视频看到一半卡住了，要等很久，或者丢失了一大段视频数据，导致错过精彩的内容。</p>
<p><strong>TCP 协议，是一个支持可靠性的协议。UDP 协议，是一个不支持可靠性的协议</strong>。接下来我们讨论几个常见实现可靠性的手段。</p>
<h4 id="校验和（Checksum）"><a href="#校验和（Checksum）" class="headerlink" title="校验和（Checksum）"></a>校验和（Checksum）</h4><p>首先我们来说说<strong>校验和</strong>。<strong>这是一种非常常见的可靠性检查手段</strong>。</p>
<p>尽管 UDP 不支持可靠性，但是像校验和（Checksum）这一类最基本的数据校验，它还是支持的。<strong>不支持可靠性，并不意味着完全放弃可靠性。TCP 和 UDP 都支持最基本的校验和算法</strong>。</p>
<p>下面我为你举例<strong>一种最简单的校验和算法：纵向冗余检查</strong>。伪代码如下：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte c = 0;</span><br><span class="line">for(byte x in bytes) &#123;</span><br><span class="line">  c = c xor x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>xor</code>是异或运算。上面的程序在计算字节数组 bytes 的校验和。<code>c</code>是最终的结果。你可以看到将所有<code>bytes</code>两两异或，最终的结果就是校验和。假设我们要传输 bytes，如果在传输过程中<code>bytes</code>发生了变化，校验和有<strong>很大概率</strong>也会跟着变化。当然也可能存在<code>bytes</code>发生变化，校验和没有变化的特例，不过校验和可以很大程度上帮助我们识别数据是否损坏了。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630143310.png" alt="image-20210630143310841"></p>
<p>当要传输数据的时候，数据会被分片，我们把每个分片看作一个字节数组。然后在分片中，预留几个字节去存储校验和。校验和随着数据分片一起传输到目的地，目的地会用同样的算法再次计算校验和。如果二者校验和不一致，代表中途数据发生了损坏。</p>
<p><strong>对于 TCP 和 UDP，都实现了校验和算法，但二者的区别是，TCP 如果发现校验核对不上，也就是数据损坏，会主动丢失这个封包并且重发。而 UDP 什么都不会处理，UDP 把处理的权利交给使用它的程序员</strong>。</p>
<h4 id="请求-应答-连接模型"><a href="#请求-应答-连接模型" class="headerlink" title="请求/应答/连接模型"></a>请求/应答/连接模型</h4><p>另一种保证可靠性的方法是<strong>请求响应和连接的模型</strong>。TCP 实现了请求、响应和连接的模型，UDP 没有实现这个模型。</p>
<p>在通信当中，我们可以把通信双方抽象成两个人用电话通信一样，需要先建立联系（保持连接）。发起会话的人是发送请求，对方需要应答（或者称为响应）。会话双方保持一个连接，直到双方说再见。</p>
<p>在 TCP 协议当中，任何一方向另一方发送信息，另一方都需要给予一个应答。如果发送方在一定的时间内没有获得应答，发送方就会认为自己的信息没有到达目的地，中途发生了损坏或者丢失等，因此发送方会选择重发这条消息。</p>
<p>这样一个模式也造成了 TCP 协议的三次握手和四次挥手，下面我们一起来具体分析一下。</p>
<p><strong>1. TCP 的三次握手</strong></p>
<p>在 TCP 协议当中。我们假设 Alice 和 Bob 是两个通信进程。当 Alice 想要和 Bob 建立连接的时候，Alice 需要发送一个请求建立连接的消息给 Bob。这种请求建立连接的消息在 TCP 协议中称为<strong>同步</strong>（<strong>Synchronization， SYN</strong>）。而 Bob 收到 SYN，必须马上给 Alice 一个响应。这个响应在 TCP 协议当中称为<strong>响应</strong>（<strong>Acknowledgement，ACK</strong>）。请你务必记住这两个单词。不仅是 TCP 在用，其他协议也会复用这样的概念，来描述相同的事情。</p>
<p>当 Alice 给 Bob SYN，Bob 给 Alice ACK，这个时候，对 Alice 而言，连接就建立成功了。但是 TCP 是一个双工协议。所谓双工协议，代表数据可以双向传送。虽然对 Alice 而言，连接建立成功了。但是对 Bob 而言，连接还没有建立。为什么这么说呢？你可以这样思考，如果这个时候，Bob 马上给 Alice 发送信息，信息可能先于 Bob 的 ACK 到达 Alice，但这个时候 Alice 还不知道连接建立成功。 所以解决的办法就是 Bob 再给 Alice 发一次 SYN ，Alice 再给 Bob 一个 ACK。以上就是 TCP 的三次握手内容。</p>
<p>你可能会问，这明明是<strong>四次握手，哪里是三次握手</strong>呢？这是因为，Bob 给 Alice 的 ACK ，可以和 Bob 向 Alice 发起的 SYN 合并，称为一条 SYN-ACK 消息。TCP 协议以此来减少握手的次数，减少数据的传输，于是 TCP 就变成了三次握手。下图中绿色标签状是 Alice 和 Bob 的状态，完整的 TCP 三次握手的过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630143358.png" alt="image-20210630143358324"></p>
<p><strong>2. TCP 的四次挥手</strong></p>
<p>四次挥手（TCP 断开连接）的原理类似。中断连接的请求我们称为 Finish（用 FIN 表示）；和三次握手过程一样，需要分析成 4 步：</p>
<ul>
<li>第 1 步是 Alice 发送 FIN</li>
<li>第 2 步是 Bob 给 ACK</li>
<li>第 3 步是 Bob 发送 FIN</li>
<li>第 4 步是 Alice 给 ACK</li>
</ul>
<p>之所以是四次挥手，是因为第 2 步和 第 3 步在挥手的过程中不能合并为 FIN-ACK。原因是在挥手的过程中，Alice 和 Bob 都可能有未完成的工作。比如对 Bob 而言，可能还存在之前发给 Alice 但是还没有收到 ACK 的请求。因此，Bob 收到 Alice 的 FIN 后，就马上给 ACK。但是 Bob 会在自己准备妥当后，再发送 FIN 给 Alice。完整的过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630143425.png" alt="image-20210630143425650"></p>
<p><strong>3. 连接</strong></p>
<p>连接是一个虚拟概念，连接的目的是让连接的双方达成默契，倾尽资源，给对方最快的响应。经历了三次握手，Alice 和 Bob 之间就建立了连接。<strong>连接也是一个很好的编程模型。当连接不稳定的时候，可以中断连接后再重新连接。这种模式极大地增加了两个应用之间的数据传输的可靠性</strong>。</p>
<p>以上就是 TCP 中存在的，而 UDP 中没有的机制，你可以仔细琢磨琢磨。</p>
<h4 id="封包排序"><a href="#封包排序" class="headerlink" title="封包排序"></a>封包排序</h4><p><strong>可靠性有一个最基本的要求是数据有序发出、无序传输，并且有序组合。TCP 协议保证了这种可靠性，UDP 则没有保证</strong>。</p>
<p>在传输之前，数据被拆分成分块。在 TCP 中叫作一个<strong>TCP Segment</strong>。在 UDP 中叫作一个<strong>UDP Datagram</strong>。Datagram 单词的含义是数据传输的最小单位。在到达目的地之后，尽管所有的数据分块可能是乱序到达的，但为了保证可靠性，乱序到达的数据又需要被重新排序，恢复到原有数据的顺序。</p>
<p><strong>在这个过程当中，TCP 利用了滑动窗口、快速重传等算法，保证了数据的顺序。而 UDP，仅仅是为每个 Datagram 标注了序号，并没有帮助应用程序进行数据的排序</strong>，<strong>这也是 TCP 和 UDP 在保证可靠性上一个非常重要的区别。</strong></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>上面的内容中，我们比较了 TCP 和 UDP 在可靠性上的区别，接下来我们看看两个协议的使用场景。</p>
<p><strong>我们先来看一道面试题：如果客户端和服务器之间的单程平均延迟是 30 毫秒，那么客户端 Ping 服务端需要多少毫秒</strong>？</p>
<p>【<strong>分析</strong>】这个问题最核心的点是需要思考 Ping 服务应该由 TCP 实现还是 UDP 实现？请你思考：Ping 需不需要保持连接呢？答案是不需要，Ping 服务器的时候把数据发送过去即可，并不需要特地建立一个连接。</p>
<p>请你再思考，Ping 需不需要保证可靠性呢？答案依然是不需要，如果发生了丢包， Ping 将丢包计入丢包率即可。所以从这个角度来看，Ping 使用 UDP 即可。</p>
<p>所以这道面试题应该是 Round Trip 最快需要在 60 毫秒左右。一个来回的时间，我们也通常称为 Round Trip 时间。</p>
<p>通过分析上面的例子，我想告诉你，TCP 和 UDP 的使用场景是不同的。<strong>TCP 适用于需要可靠性，需要连接的场景</strong>。UDP 因为足够简单，只对数据进行简单加工处理，就调用底层的网络层（IP 协议）传输数据去了。<strong>因此 UDP 更适合对可靠性要求不高的场景</strong>。</p>
<p>另外很多需要定制化的场景，非常需要 UDP。以 HTTP 协议为例，在早期的 HTTP 协议的设计当中就选择了 TCP 协议。因为在 HTTP 的设计当中，请求和返回都是需要可靠性的。但是随着 HTTP 协议的发展，到了 HTTP 3.0 的时候，就开始基于 UDP 进行传输。这是因为，在 HTTP 3.0 协议当中，在 UDP 之上有另一个QUIC 协议在负责可靠性。UDP 足够简单，在其上构建自己的协议就很方便。</p>
<p><strong>你可以再思考一个问题：文件上传应该用 TCP 还是 UDP 呢</strong>？乍一看肯定是 TCP 协议，因为文件上传当然需要可靠性，防止数据损坏。但是如果你愿意在 UDP 上去实现一套专门上传文件的可靠性协议，性能是可以超越 TCP 协议的。因为你只需要解决文件上传一种需求，不用像 TCP 协议那样解决通用需求。</p>
<p>所以时至今日，到底什么情况应该用 TCP，什么情况用 UDP？这个问题边界的确在模糊化。<strong>总体来说，需要可靠性，且不希望花太多心思在网络协议的研发上，就使用 TCP 协议</strong>。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>最后我们再来总结一下，大而全的协议用起来舒服，比如 TCP；灵活的协议方便定制和扩展，比如 UDP。二者不分伯仲，各有千秋。</p>
<p>这一讲我们深入比较了 TCP 和 UDP 的可靠性及它们的使用场景。关于原理部分，比如具体 TCP 的滑动窗口算法、数据的切割算法、数据重传算法；TCP、UDP 的封包内部究竟有哪些字段，格式如何等。如果你感兴趣，可以来学习我将在拉勾教育推出的《<strong>计算机网络</strong>》专栏。</p>
<p><strong>你现在可以尝试来回答本讲关联的面试题目：UDP 比 TCP 快在哪里</strong>？</p>
<p>【<strong>解析</strong>】使用 UDP 传输数据，不用建立连接，数据直接丢过去即可。至于接收方，有没有在监听？会不会接收？那就是接收方的事情了。UDP 甚至不考虑数据的可靠性。至于发送双方会不会基于 UDP 再去定制研发可靠性协议，那就是开发者的事情了。所以 UDP 快在哪里？UDP 快在它足够简单。因为足够简单，所以 UDP 对计算性能、对网络占用都是比 TCP 少的。</p>
<h3 id="select-poll-epoll-有什么区别？"><a href="#select-poll-epoll-有什么区别？" class="headerlink" title="select/poll/epoll 有什么区别？"></a><strong>select/poll/epoll 有什么区别？</strong></h3><p>我们总是想方设法地提升系统的性能。操作系统层面不能给予处理业务逻辑太多帮助，但对于 I/O 性能，操作系统可以通过底层的优化，帮助应用做到极致。</p>
<p>这一讲我将和你一起讨论 I/O 模型。为了引发你更多的思考，我将同步/异步、阻塞/非阻塞等概念滞后讲解。<strong>我们先回到一个最基本的问题：如果有一台服务器，需要响应大量的请求，操作系统如何去架构以适应这样高并发的诉求</strong>。</p>
<p>说到架构，就离不开操作系统提供给应用程序的系统调用。我们今天要介绍的 select/poll/epoll 刚好是操作系统提供给应用的三类处理 I/O 的系统调用。这三类系统调用有非常强的代表性，这一讲我会围绕它们，以及处理并发和 I/O 多路复用，为你讲解操作系统的 I/O 模型。</p>
<h4 id="从网卡到操作系统"><a href="#从网卡到操作系统" class="headerlink" title="从网卡到操作系统"></a>从网卡到操作系统</h4><p>为了弄清楚高并发网络场景是如何处理的，我们先来看一个最基本的内容：<strong>当数据到达网卡之后，操作系统会做哪些事情</strong>？</p>
<p>网络数据到达网卡之后，首先需要把数据拷贝到内存。拷贝到内存的工作往往不需要消耗 CPU 资源，而是通过 DMA 模块直接进行内存映射。之所以这样做，是因为网卡没有大量的内存空间，只能做简单的缓冲，所以必须赶紧将它们保存下来。</p>
<p>Linux 中用一个双向链表作为缓冲区，你可以观察下图中的 Buffer，看上去像一个有很多个凹槽的线性结构，每个凹槽（节点）可以存储一个封包，这个封包可以从网络层看（IP 封包），也可以从传输层看（TCP 封包）。操作系统不断地从 Buffer 中取出数据，数据通过一个协议栈，你可以把它理解成很多个协议的集合。协议栈中数据封包找到对应的协议程序处理完之后，就会形成 Socket 文件。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630151654.png" alt="image-20210630151653941"></p>
<p>如果高并发的请求量级实在太大，有可能把 Buffer 占满，此时，操作系统就会拒绝服务。网络上有一种著名的攻击叫作<strong>拒绝服务攻击</strong>，就是利用的这个原理。<strong>操作系统拒绝服务，实际上是一种保护策略。通过拒绝服务，避免系统内部应用因为并发量太大而雪崩</strong>。</p>
<p>如上图所示，传入网卡的数据被我称为 Frames。一个 Frame 是数据链路层的传输单位（或封包）。现代的网卡通常使用 DMA 技术，将 Frame 写入缓冲区（Buffer），然后在触发 CPU 中断交给操作系统处理。操作系统从缓冲区中不断取出 Frame，通过协进栈（具体的协议）进行还原。</p>
<p>在 UNIX 系的操作系统中，一个 Socket 文件内部类似一个双向的管道。因此，非常适用于进程间通信。在网络当中，本质上并没有发生变化。网络中的 Socket 一端连接 Buffer， 一端连接应用——也就是进程。网卡的数据会进入 Buffer，Buffer 经过协议栈的处理形成 Socket 结构。通过这样的设计，进程读取 Socket 文件，可以从 Buffer 中对应节点读走数据。</p>
<p>对于 TCP 协议，Socket 文件可以用源端口、目标端口、源 IP、目标 IP 进行区别。不同的 Socket 文件，对应着 Buffer 中的不同节点。进程们读取数据的时候从 Buffer 中读取，写入数据的时候向 Buffer 中写入。通过这样一种结构，无论是读和写，进程都可以快速定位到自己对应的节点。</p>
<p>以上就是我们对操作系统和网络接口交互的一个基本讨论。接下来，我们讨论一下作为一个编程模型的 Socket。</p>
<h4 id="Socket-编程模型"><a href="#Socket-编程模型" class="headerlink" title="Socket 编程模型"></a>Socket 编程模型</h4><p>通过前面讲述，我们知道 Socket 在操作系统中，有一个非常具体的从 Buffer 到文件的实现。但是对于进程而言，Socket 更多是一种编程的模型。接下来我们讨论作为编程模型的 Socket。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630152655.png" alt="image-20210630152655321"></p>
<p>如上图所示，Socket 连接了应用和协议，如果应用层的程序想要传输数据，就创建一个 Socket。应用向 Socket 中写入数据，相当于将数据发送给了另一个应用。应用从 Socket 中读取数据，相当于接收另一个应用发送的数据。而具体的操作就是由 Socket 进行封装。具体来说，<strong>对于 UNIX 系的操作系统，是利用 Socket 文件系统，Socket 是一种特殊的文件——每个都是一个双向的管道。一端是应用，一端是缓冲</strong>区。</p>
<p>那么作为一个服务端的应用，如何知道有哪些 Socket 呢？也就是，哪些客户端连接过来了呢？这是就需要一种特殊类型的 Socket，也就是服务端 Socket 文件。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164233.png" alt="image-20210630164233524"></p>
<p>如上图所示，当有客户端连接服务端时，服务端 Socket 文件中会写入这个客户端 Socket 的文件描述符。进程可以通过 accept() 方法，从服务端 Socket 文件中读出客户端的 Socket 文件描述符，从而拿到客户端的 Socket 文件。</p>
<p>程序员实现一个网络服务器的时候，会先手动去创建一个服务端 Socket 文件。服务端的 Socket 文件依然会存在操作系统内核之中，并且会绑定到某个 IP 地址和端口上。以后凡是发送到这台机器、目标 IP 地址和端口号的连接请求，在形成了客户端 Socket 文件之后，文件的文件描述符都会被写入到服务端的 Socket 文件中。应用只要调用 accept 方法，就可以拿到这些客户端的 Socket 文件描述符，这样服务端的应用就可以方便地知道有哪些客户端连接了进来。</p>
<p>而每个客户端对这个应用而言，都是一个文件描述符。如果需要读取某个客户端的数据，就读取这个客户端对应的 Socket 文件。如果要向某个特定的客户端发送数据，就写入这个客户端的 Socket 文件。</p>
<p>以上就是 Socket 的编程模型。</p>
<h4 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h4><p>在上面的讨论当中，进程拿到了它关注的所有 Socket，也称作关注的集合（Intersting Set）。如下图所示，这种过程相当于进程从所有的 Socket 中，筛选出了自己关注的一个子集，但是这时还有一个问题没有解决：<strong>进程如何监听关注集合的状态变化，比如说在有数据进来，如何通知到这个进程</strong>？</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164829.png" alt="image-20210630164829024"></p>
<p>其实更准确地说，一个线程需要处理所有关注的 Socket 产生的变化，或者说消息。实际上一个线程要处理很多个文件的 I/O。<strong>所有关注的 Socket 状态发生了变化，都由一个线程去处理，构成了 I/O 的多路复用问题</strong>。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164854.png" alt="image-20210630164854049"></p>
<p>处理 I/O 多路复用的问题，需要操作系统提供内核级别的支持。Linux 下有三种提供 I/O 多路复用的 API，分别是：</p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<p>如下图所示，内核了解网络的状态。因此不难知道具体发生了什么消息，比如内核知道某个 Socket 文件状态发生了变化。但是内核如何知道该把哪个消息给哪个进程呢？</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630164918.png" alt="image-20210630164918730"></p>
<p><strong>一个 Socket 文件，可以由多个进程使用；而一个进程，也可以使用多个 Socket 文件</strong>。进程和 Socket 之间是多对多的关系。<strong>另一方面，一个 Socket 也会有不同的事件类型</strong>。因此操作系统很难判断，将哪样的事件给哪个进程。</p>
<p>这样<strong>在进程内部就需要一个数据结构来描述自己会关注哪些 Socket 文件的哪些事件（读、写、异常等</strong>）。通常有两种考虑方向，<strong>一种是利用线性结构</strong>，比如说数组、链表等，这类结构的查询需要遍历。每次内核产生一种消息，就遍历这个线性结构。看看这个消息是不是进程关注的？<strong>另一种是索引结构</strong>，内核发生了消息可以通过索引结构马上知道这个消息进程关不关注。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h4><p>select 和 poll 都采用线性结构，select 允许用户传入 3 个集合。如下面这段程序所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fd_set read_fd_set, write_fd_set, error_fd_set;</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line"></span><br><span class="line">  select(..., &amp;read_fd_set, &amp;write_fd_set, &amp;error_fd_set); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每次 select 操作会阻塞当前线程，在阻塞期间所有操作系统产生的每个消息，都会通过遍历的手段查看是否在 3 个集合当中</strong>。上面程序<code>read_fd_set</code>中放入的是当数据可以读取时进程关心的 Socket；<code>write_fd_set</code>是当数据可以写入时进程关心的 Socket；<code>error_fd_set</code>是当发生异常时进程关心的 Socket。</p>
<p><strong>用户程序可以根据不同集合中是否有某个 Socket 判断发生的消息类型，</strong>程序如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fd_set read_fd_set, write_fd_set, error_fd_set;</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line"></span><br><span class="line">  select(..., &amp;read_fd_set, &amp;write_fd_set, &amp;error_fd_set); </span><br><span class="line"></span><br><span class="line">  for (i = 0; i &lt; FD_SETSIZE; ++i)</span><br><span class="line"></span><br><span class="line">        if (FD_ISSET (i, &amp;read_fd_set))&#123;</span><br><span class="line"></span><br><span class="line">          // Socket可以读取</span><br><span class="line"></span><br><span class="line">        &#125; else if(FD_ISSET(i, &amp;write_fd_set)) &#123;</span><br><span class="line"></span><br><span class="line">          // Socket可以写入</span><br><span class="line"></span><br><span class="line">        &#125; else if(FD_ISSET(i, &amp;error_fd_set)) &#123;</span><br><span class="line"></span><br><span class="line">          // Socket发生错误</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序中的 FD_SETSIZE 是一个系统的默认设置，通常是 1024。可以看出，select 模式能够一次处理的文件描述符是有上限的，也就是 FD_SETSIZE。当并发请求过多的时候， select 就无能为力了。但是对单台机器而言，1024 个并发已经是一个非常大的流量了。</p>
<p>接下来我给出一个完整的、用 select 实现的服务端程序供你参考，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/Socket.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line"></span><br><span class="line">#define PORT    5555</span><br><span class="line"></span><br><span class="line">#define MAXMSG  512</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line"></span><br><span class="line">read_from_client (int filedes)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  char buffer[MAXMSG];</span><br><span class="line"></span><br><span class="line">  int nbytes;</span><br><span class="line"></span><br><span class="line">  nbytes = read (filedes, buffer, MAXMSG);</span><br><span class="line"></span><br><span class="line">  if (nbytes &lt; 0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      /* Read error. */</span><br><span class="line"></span><br><span class="line">      perror (&quot;read&quot;);</span><br><span class="line"></span><br><span class="line">      exit (EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  else if (nbytes == 0)</span><br><span class="line"></span><br><span class="line">    /* End-of-file. */</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      /* Data read. */</span><br><span class="line"></span><br><span class="line">      fprintf (stderr, &quot;Server: got message: `%s&apos;\n&quot;, buffer);</span><br><span class="line"></span><br><span class="line">      return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line"></span><br><span class="line">main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  extern int make_Socket (uint16_t port);</span><br><span class="line"></span><br><span class="line">  int sock;</span><br><span class="line"></span><br><span class="line">  fd_set active_fd_set, read_fd_set;</span><br><span class="line"></span><br><span class="line">  int i;</span><br><span class="line"></span><br><span class="line">  struct sockaddr_in clientname;</span><br><span class="line"></span><br><span class="line">  size_t size;</span><br><span class="line"></span><br><span class="line">  /* Create the Socket and set it up to accept connections. */</span><br><span class="line"></span><br><span class="line">  sock = make_Socket (PORT);</span><br><span class="line"></span><br><span class="line">  if (listen (sock, 1) &lt; 0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      perror (&quot;listen&quot;);</span><br><span class="line"></span><br><span class="line">      exit (EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* Initialize the set of active Sockets. */</span><br><span class="line"></span><br><span class="line">  FD_ZERO (&amp;active_fd_set);</span><br><span class="line"></span><br><span class="line">  FD_SET (sock, &amp;active_fd_set);</span><br><span class="line"></span><br><span class="line">  while (1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      /* Block until input arrives on one or more active Sockets. */</span><br><span class="line"></span><br><span class="line">      read_fd_set = active_fd_set;</span><br><span class="line"></span><br><span class="line">      if (select (FD_SETSIZE, &amp;read_fd_set, NULL, NULL, NULL) &lt; 0)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          perror (&quot;select&quot;);</span><br><span class="line"></span><br><span class="line">          exit (EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /* Service all the Sockets with input pending. */</span><br><span class="line"></span><br><span class="line">      for (i = 0; i &lt; FD_SETSIZE; ++i)</span><br><span class="line"></span><br><span class="line">        if (FD_ISSET (i, &amp;read_fd_set))</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">            if (i == sock)</span><br><span class="line"></span><br><span class="line">              &#123;</span><br><span class="line"></span><br><span class="line">                /* Connection request on original Socket. */</span><br><span class="line"></span><br><span class="line">                int new;</span><br><span class="line"></span><br><span class="line">                size = sizeof (clientname);</span><br><span class="line"></span><br><span class="line">                new = accept (sock,</span><br><span class="line"></span><br><span class="line">                              (struct sockaddr *) &amp;clientname,</span><br><span class="line"></span><br><span class="line">                              &amp;size);</span><br><span class="line"></span><br><span class="line">                if (new &lt; 0)</span><br><span class="line"></span><br><span class="line">                  &#123;</span><br><span class="line"></span><br><span class="line">                    perror (&quot;accept&quot;);</span><br><span class="line"></span><br><span class="line">                    exit (EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                fprintf (stderr,</span><br><span class="line"></span><br><span class="line">                         &quot;Server: connect from host %s, port %hd.\n&quot;,</span><br><span class="line"></span><br><span class="line">                         inet_ntoa (clientname.sin_addr),</span><br><span class="line"></span><br><span class="line">                         ntohs (clientname.sin_port));</span><br><span class="line"></span><br><span class="line">                FD_SET (new, &amp;active_fd_set);</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            else</span><br><span class="line"></span><br><span class="line">              &#123;</span><br><span class="line"></span><br><span class="line">                /* Data arriving on an already-connected Socket. */</span><br><span class="line"></span><br><span class="line">                if (read_from_client (i) &lt; 0)</span><br><span class="line"></span><br><span class="line">                  &#123;</span><br><span class="line"></span><br><span class="line">                    close (i);</span><br><span class="line"></span><br><span class="line">                    FD_CLR (i, &amp;active_fd_set);</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><p>从写程序的角度来看，select 并不是一个很好的编程模型。一个好的编程模型应该直达本质，当网络请求发生状态变化的时候，核心是会发生事件。<strong>一个好的编程模型应该是直接抽象成消息：用户不需要用 select 来设置自己的集合，而是可以通过系统的 API 直接拿到对应的消息，从而处理对应的文件描述符</strong>。</p>
<p>比如下面这段伪代码就是一个更好的编程模型，具体的分析如下：</p>
<ul>
<li>poll 是一个阻塞调用，它将某段时间内操作系统内发生的且进程关注的消息告知用户程序；</li>
<li>用户程序通过直接调用 poll 函数拿到消息；</li>
<li>poll 函数的第一个参数告知内核 poll 关注哪些 Socket 及消息类型；</li>
<li>poll 调用后，经过一段时间的等待（阻塞），就拿到了是一个消息的数组；</li>
<li>通过遍历这个数组中的消息，能够知道关联的文件描述符和消息的类型；</li>
<li>通过消息类型判断接下来该进行读取还是写入操作；</li>
<li>通过文件描述符，可以进行实际地读、写、错误处理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">while(true) &#123;</span><br><span class="line"></span><br><span class="line">  events = poll(fds, ...)</span><br><span class="line"></span><br><span class="line">  for(evt in events) &#123;</span><br><span class="line"></span><br><span class="line">    fd = evt.fd;</span><br><span class="line"></span><br><span class="line">    type = evt.revents;</span><br><span class="line"></span><br><span class="line">    if(type &amp; POLLIN ) &#123;</span><br><span class="line"></span><br><span class="line">       // 有数据需要读，读取fd中的数据</span><br><span class="line"></span><br><span class="line">    &#125; else if(type &amp; POLLOUT) &#123;</span><br><span class="line"></span><br><span class="line">       // 可以写入数据</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    else ...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poll 虽然优化了编程模型，但是从性能角度分析，它和 select 差距不大。因为内核在产生一个消息之后，依然需要遍历 poll 关注的所有文件描述符来确定这条消息是否跟用户程序相关。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>为了解决上述问题，<strong>epoll 通过更好的方案实现了从操作系统订阅消息。epoll 将进程关注的文件描述符存入一棵二叉搜索树，通常是红黑树的实现</strong>。在这棵红黑树当中，Key 是 Socket 的编号，值是这个 Socket 关注的消息。因此，当内核发生了一个事件：比如 Socket 编号 1000 可以读取。这个时候，可以马上从红黑树中找到进程是否关注这个事件。</p>
<p><strong>另外当有关注的事件发生时，epoll 会先放到一个队列当中。当用户调用</strong><code>epoll_wait</code>时候，就会从队列中返回一个消息。epoll 函数本身是一个构造函数，只用来创建红黑树和队列结构。<code>epoll_wait</code>调用后，如果队列中没有消息，也可以马上返回。因此<code>epoll</code>是一个非阻塞模型。</p>
<p><strong>总结一下，select/poll 是阻塞模型，epoll 是非阻塞模型</strong>。<strong>当然，并不是说非阻塞模型性能就更好。在多数情况下，epoll 性能更好是因为内部有红黑树的实现</strong>。</p>
<p>最后我再贴一段用 epoll 实现的 Socket 服务给你做参考，这段程序的作者将这段代码放到了 Public Domain，你以后看到公有领域的代码可以放心地使用。</p>
<p>下面这段程序跟之前 select 的原理一致，对于每一个新的客户端连接，都使用 accept 拿到这个连接的文件描述符，并且创建一个客户端的 Socket。然后通过<code>epoll_ctl</code>将客户端的文件描述符和关注的消息类型放入 epoll 的红黑树。操作系统每次监测到一个新的消息产生，就会通过红黑树对比这个消息是不是进程关注的（当然这段代码你看不到，因为它在内核程序中）。</p>
<p><strong>非阻塞模型的核心价值，并不是性能更好。当真的高并发来临的时候，所有的 CPU 资源，所有的网络资源可能都会被用完。这个时候无论是阻塞还是非阻塞，结果都不会相差太大</strong>。（前提是程序没有写错）。</p>
<p><code>epoll</code>有 2 个最大的优势：</p>
<ol>
<li>内部使用红黑树减少了内核的比较操作；</li>
<li>对于程序员而言，非阻塞的模型更容易处理各种各样的情况。程序员习惯了写出每一条语句就可以马上得到结果，这样不容易出 Bug。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br></pre></td><td class="code"><pre><span class="line">// Asynchronous Socket server - accepting multiple clients concurrently,</span><br><span class="line"></span><br><span class="line">	// multiplexing the connections with epoll.</span><br><span class="line"></span><br><span class="line">	//</span><br><span class="line"></span><br><span class="line">	// Eli Bendersky [http://eli.thegreenplace.net]</span><br><span class="line"></span><br><span class="line">	// This code is in the public domain.</span><br><span class="line"></span><br><span class="line">	#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">	#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">	#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">	#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">	#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">	#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">	#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">	#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">	#include &lt;sys/Socket.h&gt;</span><br><span class="line"></span><br><span class="line">	#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">	#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	#include &quot;utils.h&quot;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	#define MAXFDS 16 * 1024</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	typedef enum &#123; INITIAL_ACK, WAIT_FOR_MSG, IN_MSG &#125; ProcessingState;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	#define SENDBUF_SIZE 1024</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	typedef struct &#123;</span><br><span class="line"></span><br><span class="line">	  ProcessingState state;</span><br><span class="line"></span><br><span class="line">	  uint8_t sendbuf[SENDBUF_SIZE];</span><br><span class="line"></span><br><span class="line">	  int sendbuf_end;</span><br><span class="line"></span><br><span class="line">	  int sendptr;</span><br><span class="line"></span><br><span class="line">	&#125; peer_state_t;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	// Each peer is globally identified by the file descriptor (fd) it&apos;s connected</span><br><span class="line"></span><br><span class="line">	// on. As long as the peer is connected, the fd is unique to it. When a peer</span><br><span class="line"></span><br><span class="line">	// disconnects, a new peer may connect and get the same fd. on_peer_connected</span><br><span class="line"></span><br><span class="line">	// should initialize the state properly to remove any trace of the old peer on</span><br><span class="line"></span><br><span class="line">	// the same fd.</span><br><span class="line"></span><br><span class="line">	peer_state_t global_state[MAXFDS];</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	// Callbacks (on_XXX functions) return this status to the main loop; the status</span><br><span class="line"></span><br><span class="line">	// instructs the loop about the next steps for the fd for which the callback was</span><br><span class="line"></span><br><span class="line">	// invoked.</span><br><span class="line"></span><br><span class="line">	// want_read=true means we want to keep monitoring this fd for reading.</span><br><span class="line"></span><br><span class="line">	// want_write=true means we want to keep monitoring this fd for writing.</span><br><span class="line"></span><br><span class="line">	// When both are false it means the fd is no longer needed and can be closed.</span><br><span class="line"></span><br><span class="line">	typedef struct &#123;</span><br><span class="line"></span><br><span class="line">	  bool want_read;</span><br><span class="line"></span><br><span class="line">	  bool want_write;</span><br><span class="line"></span><br><span class="line">	&#125; fd_status_t;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	// These constants make creating fd_status_t values less verbose.</span><br><span class="line"></span><br><span class="line">	const fd_status_t fd_status_R = &#123;.want_read = true, .want_write = false&#125;;</span><br><span class="line"></span><br><span class="line">	const fd_status_t fd_status_W = &#123;.want_read = false, .want_write = true&#125;;</span><br><span class="line"></span><br><span class="line">	const fd_status_t fd_status_RW = &#123;.want_read = true, .want_write = true&#125;;</span><br><span class="line"></span><br><span class="line">	const fd_status_t fd_status_NORW = &#123;.want_read = false, .want_write = false&#125;;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	fd_status_t on_peer_connected(int sockfd, const struct sockaddr_in* peer_addr,</span><br><span class="line"></span><br><span class="line">	                              socklen_t peer_addr_len) &#123;</span><br><span class="line"></span><br><span class="line">	  assert(sockfd &lt; MAXFDS);</span><br><span class="line"></span><br><span class="line">	  report_peer_connected(peer_addr, peer_addr_len);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  // Initialize state to send back a &apos;*&apos; to the peer immediately.</span><br><span class="line"></span><br><span class="line">	  peer_state_t* peerstate = &amp;global_state[sockfd];</span><br><span class="line"></span><br><span class="line">	  peerstate-&gt;state = INITIAL_ACK;</span><br><span class="line"></span><br><span class="line">	  peerstate-&gt;sendbuf[0] = &apos;*&apos;;</span><br><span class="line"></span><br><span class="line">	  peerstate-&gt;sendptr = 0;</span><br><span class="line"></span><br><span class="line">	  peerstate-&gt;sendbuf_end = 1;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  // Signal that this Socket is ready for writing now.</span><br><span class="line"></span><br><span class="line">	  return fd_status_W;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	fd_status_t on_peer_ready_recv(int sockfd) &#123;</span><br><span class="line"></span><br><span class="line">	  assert(sockfd &lt; MAXFDS);</span><br><span class="line"></span><br><span class="line">	  peer_state_t* peerstate = &amp;global_state[sockfd];</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  if (peerstate-&gt;state == INITIAL_ACK ||</span><br><span class="line"></span><br><span class="line">	      peerstate-&gt;sendptr &lt; peerstate-&gt;sendbuf_end) &#123;</span><br><span class="line"></span><br><span class="line">	    // Until the initial ACK has been sent to the peer, there&apos;s nothing we</span><br><span class="line"></span><br><span class="line">	    // want to receive. Also, wait until all data staged for sending is sent to</span><br><span class="line"></span><br><span class="line">	    // receive more data.</span><br><span class="line"></span><br><span class="line">	    return fd_status_W;</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  uint8_t buf[1024];</span><br><span class="line"></span><br><span class="line">	  int nbytes = recv(sockfd, buf, sizeof buf, 0);</span><br><span class="line"></span><br><span class="line">	  if (nbytes == 0) &#123;</span><br><span class="line"></span><br><span class="line">	    // The peer disconnected.</span><br><span class="line"></span><br><span class="line">	    return fd_status_NORW;</span><br><span class="line"></span><br><span class="line">	  &#125; else if (nbytes &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">	    if (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line"></span><br><span class="line">	      // The Socket is not *really* ready for recv; wait until it is.</span><br><span class="line"></span><br><span class="line">	      return fd_status_R;</span><br><span class="line"></span><br><span class="line">	    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">	      perror_die(&quot;recv&quot;);</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  bool ready_to_send = false;</span><br><span class="line"></span><br><span class="line">	  for (int i = 0; i &lt; nbytes; ++i) &#123;</span><br><span class="line"></span><br><span class="line">	    switch (peerstate-&gt;state) &#123;</span><br><span class="line"></span><br><span class="line">	    case INITIAL_ACK:</span><br><span class="line"></span><br><span class="line">	      assert(0 &amp;&amp; &quot;can&apos;t reach here&quot;);</span><br><span class="line"></span><br><span class="line">	      break;</span><br><span class="line"></span><br><span class="line">	    case WAIT_FOR_MSG:</span><br><span class="line"></span><br><span class="line">	      if (buf[i] == &apos;^&apos;) &#123;</span><br><span class="line"></span><br><span class="line">	        peerstate-&gt;state = IN_MSG;</span><br><span class="line"></span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	      break;</span><br><span class="line"></span><br><span class="line">	    case IN_MSG:</span><br><span class="line"></span><br><span class="line">	      if (buf[i] == &apos;$&apos;) &#123;</span><br><span class="line"></span><br><span class="line">	        peerstate-&gt;state = WAIT_FOR_MSG;</span><br><span class="line"></span><br><span class="line">	      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">	        assert(peerstate-&gt;sendbuf_end &lt; SENDBUF_SIZE);</span><br><span class="line"></span><br><span class="line">	        peerstate-&gt;sendbuf[peerstate-&gt;sendbuf_end++] = buf[i] + 1;</span><br><span class="line"></span><br><span class="line">	        ready_to_send = true;</span><br><span class="line"></span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	      break;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  // Report reading readiness iff there&apos;s nothing to send to the peer as a</span><br><span class="line"></span><br><span class="line">	  // result of the latest recv.</span><br><span class="line"></span><br><span class="line">	  return (fd_status_t)&#123;.want_read = !ready_to_send,</span><br><span class="line"></span><br><span class="line">	                       .want_write = ready_to_send&#125;;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	fd_status_t on_peer_ready_send(int sockfd) &#123;</span><br><span class="line"></span><br><span class="line">	  assert(sockfd &lt; MAXFDS);</span><br><span class="line"></span><br><span class="line">	  peer_state_t* peerstate = &amp;global_state[sockfd];</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  if (peerstate-&gt;sendptr &gt;= peerstate-&gt;sendbuf_end) &#123;</span><br><span class="line"></span><br><span class="line">	    // Nothing to send.</span><br><span class="line"></span><br><span class="line">	    return fd_status_RW;</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  int sendlen = peerstate-&gt;sendbuf_end - peerstate-&gt;sendptr;</span><br><span class="line"></span><br><span class="line">	  int nsent = send(sockfd, &amp;peerstate-&gt;sendbuf[peerstate-&gt;sendptr], sendlen, 0);</span><br><span class="line"></span><br><span class="line">	  if (nsent == -1) &#123;</span><br><span class="line"></span><br><span class="line">	    if (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line"></span><br><span class="line">	      return fd_status_W;</span><br><span class="line"></span><br><span class="line">	    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">	      perror_die(&quot;send&quot;);</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  if (nsent &lt; sendlen) &#123;</span><br><span class="line"></span><br><span class="line">	    peerstate-&gt;sendptr += nsent;</span><br><span class="line"></span><br><span class="line">	    return fd_status_W;</span><br><span class="line"></span><br><span class="line">	  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">	    // Everything was sent successfully; reset the send queue.</span><br><span class="line"></span><br><span class="line">	    peerstate-&gt;sendptr = 0;</span><br><span class="line"></span><br><span class="line">	    peerstate-&gt;sendbuf_end = 0;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    // Special-case state transition in if we were in INITIAL_ACK until now.</span><br><span class="line"></span><br><span class="line">	    if (peerstate-&gt;state == INITIAL_ACK) &#123;</span><br><span class="line"></span><br><span class="line">	      peerstate-&gt;state = WAIT_FOR_MSG;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    return fd_status_R;</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	int main(int argc, const char** argv) &#123;</span><br><span class="line"></span><br><span class="line">	  setvbuf(stdout, NULL, _IONBF, 0);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  int portnum = 9090;</span><br><span class="line"></span><br><span class="line">	  if (argc &gt;= 2) &#123;</span><br><span class="line"></span><br><span class="line">	    portnum = atoi(argv[1]);</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  printf(&quot;Serving on port %d\n&quot;, portnum);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  int listener_sockfd = listen_inet_Socket(portnum);</span><br><span class="line"></span><br><span class="line">	  make_Socket_non_blocking(listener_sockfd);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  int epollfd = epoll_create1(0);</span><br><span class="line"></span><br><span class="line">	  if (epollfd &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">	    perror_die(&quot;epoll_create1&quot;);</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  struct epoll_event accept_event;</span><br><span class="line"></span><br><span class="line">	  accept_event.data.fd = listener_sockfd;</span><br><span class="line"></span><br><span class="line">	  accept_event.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">	  if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listener_sockfd, &amp;accept_event) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">	    perror_die(&quot;epoll_ctl EPOLL_CTL_ADD&quot;);</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  struct epoll_event* events = calloc(MAXFDS, sizeof(struct epoll_event));</span><br><span class="line"></span><br><span class="line">	  if (events == NULL) &#123;</span><br><span class="line"></span><br><span class="line">	    die(&quot;Unable to allocate memory for epoll_events&quot;);</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  while (1) &#123;</span><br><span class="line"></span><br><span class="line">	    int nready = epoll_wait(epollfd, events, MAXFDS, -1);</span><br><span class="line"></span><br><span class="line">	    for (int i = 0; i &lt; nready; i++) &#123;</span><br><span class="line"></span><br><span class="line">	      if (events[i].events &amp; EPOLLERR) &#123;</span><br><span class="line"></span><br><span class="line">	        perror_die(&quot;epoll_wait returned EPOLLERR&quot;);</span><br><span class="line"></span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	      if (events[i].data.fd == listener_sockfd) &#123;</span><br><span class="line"></span><br><span class="line">	        // The listening Socket is ready; this means a new peer is connecting.</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        struct sockaddr_in peer_addr;</span><br><span class="line"></span><br><span class="line">	        socklen_t peer_addr_len = sizeof(peer_addr);</span><br><span class="line"></span><br><span class="line">	        int newsockfd = accept(listener_sockfd, (struct sockaddr*)&amp;peer_addr,</span><br><span class="line"></span><br><span class="line">	                               &amp;peer_addr_len);</span><br><span class="line"></span><br><span class="line">	        if (newsockfd &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">	          if (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line"></span><br><span class="line">	            // This can happen due to the nonblocking Socket mode; in this</span><br><span class="line"></span><br><span class="line">	            // case don&apos;t do anything, but print a notice (since these events</span><br><span class="line"></span><br><span class="line">	            // are extremely rare and interesting to observe...)</span><br><span class="line"></span><br><span class="line">	            printf(&quot;accept returned EAGAIN or EWOULDBLOCK\n&quot;);</span><br><span class="line"></span><br><span class="line">	          &#125; else &#123;</span><br><span class="line"></span><br><span class="line">	            perror_die(&quot;accept&quot;);</span><br><span class="line"></span><br><span class="line">	          &#125;</span><br><span class="line"></span><br><span class="line">	        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">	          make_Socket_non_blocking(newsockfd);</span><br><span class="line"></span><br><span class="line">	          if (newsockfd &gt;= MAXFDS) &#123;</span><br><span class="line"></span><br><span class="line">	            die(&quot;Socket fd (%d) &gt;= MAXFDS (%d)&quot;, newsockfd, MAXFDS);</span><br><span class="line"></span><br><span class="line">	          &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	          fd_status_t status =</span><br><span class="line"></span><br><span class="line">	              on_peer_connected(newsockfd, &amp;peer_addr, peer_addr_len);</span><br><span class="line"></span><br><span class="line">	          struct epoll_event event = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">	          event.data.fd = newsockfd;</span><br><span class="line"></span><br><span class="line">	          if (status.want_read) &#123;</span><br><span class="line"></span><br><span class="line">	            event.events |= EPOLLIN;</span><br><span class="line"></span><br><span class="line">	          &#125;</span><br><span class="line"></span><br><span class="line">	          if (status.want_write) &#123;</span><br><span class="line"></span><br><span class="line">	            event.events |= EPOLLOUT;</span><br><span class="line"></span><br><span class="line">	          &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	          if (epoll_ctl(epollfd, EPOLL_CTL_ADD, newsockfd, &amp;event) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">	            perror_die(&quot;epoll_ctl EPOLL_CTL_ADD&quot;);</span><br><span class="line"></span><br><span class="line">	          &#125;</span><br><span class="line"></span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">	        // A peer Socket is ready.</span><br><span class="line"></span><br><span class="line">	        if (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"></span><br><span class="line">	          // Ready for reading.</span><br><span class="line"></span><br><span class="line">	          int fd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">	          fd_status_t status = on_peer_ready_recv(fd);</span><br><span class="line"></span><br><span class="line">	          struct epoll_event event = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">	          event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">	          if (status.want_read) &#123;</span><br><span class="line"></span><br><span class="line">	            event.events |= EPOLLIN;</span><br><span class="line"></span><br><span class="line">	          &#125;</span><br><span class="line"></span><br><span class="line">	          if (status.want_write) &#123;</span><br><span class="line"></span><br><span class="line">	            event.events |= EPOLLOUT;</span><br><span class="line"></span><br><span class="line">	          &#125;</span><br><span class="line"></span><br><span class="line">	          if (event.events == 0) &#123;</span><br><span class="line"></span><br><span class="line">	            printf(&quot;Socket %d closing\n&quot;, fd);</span><br><span class="line"></span><br><span class="line">	            if (epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">	              perror_die(&quot;epoll_ctl EPOLL_CTL_DEL&quot;);</span><br><span class="line"></span><br><span class="line">	            &#125;</span><br><span class="line"></span><br><span class="line">	            close(fd);</span><br><span class="line"></span><br><span class="line">	          &#125; else if (epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">	            perror_die(&quot;epoll_ctl EPOLL_CTL_MOD&quot;);</span><br><span class="line"></span><br><span class="line">	          &#125;</span><br><span class="line"></span><br><span class="line">	        &#125; else if (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line"></span><br><span class="line">	          // Ready for writing.</span><br><span class="line"></span><br><span class="line">	          int fd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">	          fd_status_t status = on_peer_ready_send(fd);</span><br><span class="line"></span><br><span class="line">	          struct epoll_event event = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">	          event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	          if (status.want_read) &#123;</span><br><span class="line"></span><br><span class="line">	            event.events |= EPOLLIN;</span><br><span class="line"></span><br><span class="line">	          &#125;</span><br><span class="line"></span><br><span class="line">	          if (status.want_write) &#123;</span><br><span class="line"></span><br><span class="line">	            event.events |= EPOLLOUT;</span><br><span class="line"></span><br><span class="line">	          &#125;</span><br><span class="line"></span><br><span class="line">	          if (event.events == 0) &#123;</span><br><span class="line"></span><br><span class="line">	            printf(&quot;Socket %d closing\n&quot;, fd);</span><br><span class="line"></span><br><span class="line">	            if (epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">	              perror_die(&quot;epoll_ctl EPOLL_CTL_DEL&quot;);</span><br><span class="line"></span><br><span class="line">	            &#125;</span><br><span class="line"></span><br><span class="line">	            close(fd);</span><br><span class="line"></span><br><span class="line">	          &#125; else if (epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">	            perror_die(&quot;epoll_ctl EPOLL_CTL_MOD&quot;);</span><br><span class="line"></span><br><span class="line">	          &#125;</span><br><span class="line"></span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	  return 0;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重新思考：I-O-模型"><a href="#重新思考：I-O-模型" class="headerlink" title="重新思考：I/O 模型"></a>重新思考：I/O 模型</h4><p>在上面的模型当中，select/poll 是阻塞（Blocking）模型，epoll 是非阻塞（Non-Blocking）模型。<strong>阻塞和非阻塞强调的是线程的状态</strong>，所以阻塞就是触发了线程的阻塞状态，线程阻塞了就停止执行，并且切换到其他线程去执行，直到触发中断再回来。</p>
<p>还有一组概念是同步（Synchrounous）和异步（Asynchrounous），select/poll/epoll 三者都是同步调用。</p>
<p><strong>同步强调的是顺序，</strong>所谓同步调用，就是可以确定程序执行的顺序的调用。比如说执行一个调用，知道调用返回之前下一行代码不会执行。这种顺序是确定的情况，就是同步。</p>
<p>而异步调用则恰恰相反，<strong>异步调用不明确执行顺序</strong>。比如说一个回调函数，不知道何时会回来。异步调用会加大程序员的负担，因为我们习惯顺序地思考程序。因此，我们还会发明像协程的 yield 、迭代器等将异步程序转为同步程序。</p>
<p>由此可见，<strong>非阻塞不一定是异步，阻塞也未必就是同步</strong>。比如一个带有回调函数的方法，阻塞了线程 100 毫秒，又提供了回调函数，那这个方法是异步阻塞。例如下面的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">asleep(100ms, () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 100ms 或更多后到这里</span><br><span class="line"></span><br><span class="line">  // ...do some thing</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 100 ms 后到这里</span><br></pre></td></tr></table></figure>

<p>总结下，操作系统给大家提供各种各样的 API，是希望满足各种各样程序架构的诉求。但总体诉求其实是一致的：希望程序员写的单机代码，能够在多线程甚至分布式的环境下执行。这样你就不需要再去学习复杂的并发控制算法。从这个角度去看，非阻塞加上同步的编程模型确实省去了我们编程过程当中的很多思考。</p>
<p>但可惜的是，至少在今天这个时代，<strong>多线程、并发编程依然是程序员们的必修课</strong>。因此你在思考 I/O 模型的时候，还是需要结合自己的业务特性及系统自身的架构特点，进行选择。<strong>I/O 模型并不是选择效率，而是选择编程的手段</strong>。试想一个所有资源都跑满了的服务器，并不会因为是异步或者非阻塞模型就获得更高的吞吐量。</p>
<p><strong>select/poll/epoll 有什么区别</strong>？</p>
<p>这三者都是处理 I/O 多路复用的编程手段。select/poll 模型是一种阻塞模型，epoll 是非阻塞模型。select/poll 内部使用线性结构存储进程关注的 Socket 集合，因此每次内核要判断某个消息是否发送给 select/poll 需要遍历进程关注的 Socket 集合。</p>
<p>而 epoll 不同，epoll 内部使用二叉搜索树（红黑树），用 Socket 编号作为索引，用关注的事件类型作为值，这样内核可以在非常快的速度下就判断某个消息是否需要发送给使用 epoll 的线程。</p>
<h3 id="公私钥体系和网络安全：什么是中间人攻击？"><a href="#公私钥体系和网络安全：什么是中间人攻击？" class="headerlink" title="公私钥体系和网络安全：什么是中间人攻击？"></a><strong>公私钥体系和网络安全：什么是中间人攻击？</strong></h3><p>设想你和一个朋友签订了合同，双方各执一份。如果朋友恶意篡改了合同内容，比如替换了合同中的条款，最后大家闹到法院、各执一词。这个时候就需要专业鉴定机构去帮你鉴定合同的真伪，朋友花越多心思去伪造合同，那么鉴定的成本就会越高。</p>
<p>在网络安全领域有个说法：没有办法杜绝网络犯罪，只能想办法提高网络犯罪的成本。我们的目标是提高作案的成本，并不是杜绝这种现象。今天我将带你初探网络安全的世界，学习网络安全中最重要的一个安全体系——公私钥体系。</p>
<h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>一家具有公信力的机构对内部需要严格管理。那么当合同存储下来之后，为了防止内部人员篡改合同，这家机构需要做什么呢？</p>
<p>很显然，这家机构需要证明合同没有被篡改。一种可行的做法，就是将<strong>合同原文</strong>和<strong>摘要</strong>一起存储。你可以把摘要算法理解成一个函数，原文经过一系列复杂的计算后，产生一个<strong>唯一的散列值</strong>。只要原文发生一丁点的变动，这个散列值就会发生变化。</p>
<p>目前比较常见的摘要算法有<strong>消息摘要算法（\</strong>Message Digest Algorithm, MD5）和**安全散列算法**（Secure Hash Algorithm, SHA）。MD5 可以将任意长度的文章转化为一个 128 位的散列值。2004 年，MD5 被证实会发生碰撞，发生碰撞就是两篇原文产生了相同的摘要。这是非常危险的事情，这将允许黑客进行多种攻击手段，甚至可以伪造摘要。</p>
<p>因此在这之后，我们通常首选 SHA 算法。你不需要知道算法的准确运算过程，只需要知道 SHA 系的算法更加安全即可。在实现普通应用的时候可以使用 MD5，在计算对安全性要求极高的摘要时，就应该使用 SHA，比如订单、账号信息、证书等。</p>
<h4 id="安全保存的困难"><a href="#安全保存的困难" class="headerlink" title="安全保存的困难"></a>安全保存的困难</h4><p>采用摘要算法，从理论上来说就杜绝了篡改合同的内容的做法。但在现实当中，公司也有可能出现内鬼。我们不能假定所有公司内部员工的行为就是安全的。因此可以考虑将合同和摘要分开存储，并且设置不同的权限。这样就确保在机构内部，没有任何一名员工同时拥有合同和摘要的权限。但是即便如此，依然留下了巨大的安全隐患。比如两名员工串通一气，或者员工利用安全漏洞，和外部的不法分子进行非法交易。</p>
<p>那么现在请你思考这个问题：<strong>如何确保公司内部的员工不会篡改合同呢</strong>？当然从理论上来说是做不到的。没有哪个系统能够杜绝内部人员接触敏感信息，除非敏感信息本身就不存在。因此，可以考虑将原文存到合同双方的手中，第三方机构中只存摘要。但是这又产生了一个新的问题，会不会有第三方机构的员工和某个用户串通一气修改合同呢？</p>
<p>至此，事情似乎陷入了僵局。由第三方平台保存合同，背后同样有很大的风险。而由用户自己保存合同，就是签约双方交换合同原文及摘要。但是这样的形式中，摘要本身是没有公信力的，无法证明合同和摘要确实是对方给的。</p>
<p>因此我们还要继续思考最终的解决方案：类比我们交换合同，在现实世界当中，还伴随着签名的交换。那么在计算机的世界中，签名是什么呢？</p>
<h4 id="数字签名和证书"><a href="#数字签名和证书" class="headerlink" title="数字签名和证书"></a>数字签名和证书</h4><p>在计算机中，数字签名是一种很好的实现签名（模拟现实世界中签名）的方式。 所谓数字签名，就是对摘要进行加密形成的密文。</p>
<p>举个例子：现在 Alice 和 Bob 签合同。Alice 首先用 SHA 算法计算合同的摘要，然后用自己私钥将摘要加密，得到数字签名。Alice 将合同原文、签名，以及公钥三者都交给 Bob。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630170647.png" alt="image-20210630170647285"></p>
<p>Bob 如果想证明合同是 Alice 的，就要用 Alice 的公钥，将签名解密得到摘要 X。然后，Bob 计算原文的 SHA 摘要 Y。Bob 对比 X 和 Y，如果 X = Y 则说明数据没有被篡改过。</p>
<p>在这样的一个过程当中，Bob 不能篡改 Alice 合同。因为篡改合同不但要改原文还要改摘要，而摘要被加密了，如果要重新计算摘要，就必须提供 Alice 的私钥。所谓私钥，就是 Alice 独有的密码。所谓公钥，就是 Alice 公布给他人使用的密码。</p>
<p><strong>公钥加密的数据，只有私钥才可以解密。私钥加密的数据，只有公钥才可以解密</strong>。这样的加密方法我们称为<strong>非对称加密</strong>，基于非对称加密算法建立的安全体系，也被称作<strong>公私钥体系</strong>。用这样的方法，签约双方都不可以篡改合同。</p>
<h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>但是在上面描述的过程当中，仍然存在着一个非常明显的信任风险。这个风险在于，Alice 虽然不能篡改合同，但是可以否认给过 Bob 的公钥和合同。这样，尽管合同双方都不可以篡改合同本身，但是双方可以否认签约行为本身。</p>
<p>如果要解决这个问题，那么 Alice 提供的公钥，必须有足够的信誉。这就需要引入第三方机构和证书机制。</p>
<p><strong>证书为公钥提供方提供公正机制</strong>。证书之所以拥有信用，是因为证书的签发方拥有信用。假设 Alice 想让 Bob 承认自己的公钥。Alice 不能把公钥直接给 Bob，而是要提供第三方公证机构签发的、含有自己公钥的证书。如果 Bb 也信任这个第三方公证机构，信任关系和签约就成立。当然，法律也得承认，不然没法打官司。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630173215.png" alt="image-20210630173215247"></p>
<p>如上图所示，Alice 将自己的申请提交给机构，产生证书的原文。机构用自己的私钥签名 Alice 的申请原文（先根据原文内容计算摘要，再用私钥加密），得到带有签名信息的证书。Bob 拿到带签名信息的证书，通过第三方机构的公钥进行解密，获得 Alice 证书的摘要、证书的原文。有了 Alice 证书的摘要和原文，Bob 就可以进行验签。验签通过，Bob 就可以确认 Alice 的证书的确是第三方机构签发的。</p>
<p>用上面这样一个机制，合同的双方都无法否认合同。这个解决方案的核心在于<strong>需要第三方信用服务机构提供信用背书</strong>。这里产生了一个最基础的信任链，如果第三方机构的信任崩溃，比如被黑客攻破，那整条信任链条也就断裂了。</p>
<h4 id="信任链"><a href="#信任链" class="headerlink" title="信任链"></a>信任链</h4><p>为了固化信任关系，减少风险。最合理的方式就是<strong>在互联网中打造一条更长的信任链，环环相扣，避免出现单点的信任风险</strong>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630173421.png" alt="image-20210630173420927"></p>
<p>上图中，由信誉最好的根证书机构提供根证书，然后根证书机构去签发二级机构的证书；二级机构去签发三级机构的证书；最后有由三级机构去签发 Alice 证书。</p>
<ul>
<li>如果要验证 Alice 证书的合法性，就需要用三级机构证书中的公钥去解密 Alice 证书的数字签名。</li>
<li>如果要验证三级机构证书的合法性，就需要用二级机构的证书去解密三级机构证书的数字签名。</li>
<li>如果要验证二级结构证书的合法性，就需要用根证书去解密。</li>
</ul>
<p>以上，就构成了一个相对长一些的信任链。如果其中一方想要作弊是非常困难的，除非链条中的所有机构同时联合起来，进行欺诈。</p>
<h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p>最后我们再来说说中间人攻击。在 HTTPS 协议当中，客户端需要先从服务器去下载证书，然后再通过信任链验证服务器的证书。当证书被验证为有效且合法时，客户端和服务器之间会利用非对称加密协商通信的密码，双方拥有了一致的密码和加密算法之后，客户端和服务器之间会进行对称加密的传输。</p>
<p>在上述过程当中，要验证一个证书是否合法，就必须依据信任链，逐级的下载证书。但是根证书通常不是下载的，它往往是随着操作系统预安装在机器上的。如果黑客能够通过某种方式在你的计算机中预装证书，那么黑客也可以伪装成中间节点。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630173726.png" alt="image-20210630173726736"></p>
<p>一方面，黑客向客户端提供伪造的证书，并且这个伪造的证书会在客户端中被验证为合法。因为黑客已经通过其他非法手段在客户端上安装了证书。举个例子，比如黑客利用 U 盘的自动加载程序，偷偷地将 U 盘插入客户端机器上一小段时间预装证书。</p>
<p>安装证书后，黑客一方面和客户端进行正常的通信，另一方面黑客和服务器之间也建立正常的连接。这样黑客在中间就可以拿到客户端到服务器的所有信息，并从中获利。</p>
<p><strong>什么是中间人攻击</strong>？</p>
<p>【<strong>解析</strong>】中间人攻击中，一方面，黑客利用不法手段，让客户端相信自己是服务提供方。另一方面，黑客伪装成客户端和服务器交互。这样黑客就介入了客户端和服务之间的连接，并从中获取信息，从而获利。在上述过程当中，黑客必须攻破信任链的体系，比如直接潜入对方机房现场暴力破解、诱骗对方员工在工作电脑中安装非法的证书等。</p>
<p>另外，有很多的网络调试工具的工作原理，和中间人攻击非常类似。为了调试网络的请求，必须先在客户端装上自己的证书。这样作为中间人节点的调试工具，才可以获取客户端和服务端之间的传输。</p>
<h3 id="IPv4-和-IPv6-有什么区别？"><a href="#IPv4-和-IPv6-有什么区别？" class="headerlink" title="IPv4 和 IPv6 有什么区别？"></a><strong>IPv4 和 IPv6 有什么区别</strong>？</h3><p> IPv4 和 IPv6 最大的区别是<strong>地址空间大小不同</strong>。</p>
<ul>
<li>IPv4 是用 32 位描述 IP 地址，理论极限约在 40 亿 IP 地址；</li>
<li>IPv6 是用 128 位描述 IP 地址，IPv6 可以大到给每个人都分配 40 亿个 IP 地址，甚至更多的 IP 地址。</li>
</ul>
<p><strong>IPv4 地址不够用，因此需要划分子网</strong>。比如公司的几千台机器（计算机、手机），复用一个出口 IP 地址。子网内部，就用 192.168 开头的 IP 地址。</p>
<p><strong>而 IPv6 地址够用</strong>，可以给全世界每台设备都分配一个地址，也可以给每一个组织（甚至家庭）都分配数以亿计的地址，目前不存在地址枯竭的问题。因此<strong>不需要像 IPv4 那样通过网络地址转换协议</strong>（NAT）去连接子网和外部网络。</p>
<p>因为<strong>地址数目的不同导致这两个协议在分配 IP 地址的时候行为也不一样</strong>。</p>
<p>IPv4 地址，空间小，如果没有一个中心的服务为所有设备分配地址，那么产生的冲突非常严重。所以<strong>IPv4 地址分配，是一种中心化的请求/返回的模式</strong>。客户端向服务端请求，分配地址。服务端，将计算好可以分配的地址返回给客户端。</p>
<p><strong>而 IPv6 可以采用先计算，再申请的模式</strong>。由客户端自己随机抽取得出一个 IP 地址（能这样做是因为闲置的 IP 地址太多，随机抽取一个大概率没有设备使用），然后再向这个 IP 地址发送信息。如果没有得到返回，那么说明这个 IP 地址还没有设备使用。大体来说，这就是 IPv6 邻居发现协议，但上述内容只是其中该协议的一小部分。</p>
<p>以上是 IPv4 和 IPv6 最重要的几个区别。如果你对这块内容比较感兴趣，比如 IPv6 具体的地址格式？127.0.0.1 是什么 IP 地址？封包有什么区别？可以查阅更多的资料，比如 IPv6 的 RFC 文档。</p>
<p><strong>SSH（Secure Shell）工具可不可以用 UDP 实现</strong>？</p>
<p><strong>SSH</strong>（<strong>Secure Shell</strong>）<strong>是一种网络加密协议，可以帮助我们在不安全的网络上构建安全的传输</strong>。和 HTTPS 类似，SSH 先用非对称加密。协商密钥和参数，在目标机器登录后。利用对称加密，建立加密通道（Channel）传输数据。</p>
<p><strong>通常的 SSH 协议的底层要求是 TCP 协议</strong>。但是如果你愿意用 UDP 实现 SSH 需要的可靠性，就可以替代原有 TCP 协议的能力。只不过因为 SSH 协议对吞吐量要求并不高，而 TCP 的延迟也足够用，所以这样做的收益也不会非常的高。<strong>如果想构建安全的远程桌面，可以考虑在 UDP 上实现专门的安全传输协议来提高吞吐量、降低延迟</strong>。</p>
<p>事实上，安全传输协议也有建立在 UDP 之上的。比如说IBM 的FASP（Fast and Secure Protocol）协议，它不像 TCP 一样自动去判断封包丢失，也不会给每一个封包一个响应，它只重传接收方显示指定没有收到的封包。因而这个协议在传输文件的时候，有更快的速度。</p>
<p><strong>如果用 epoll 架构一个Web 服务器应该是一个怎样的架构</strong>？</p>
<p>每一个客户端连接进来之后都是一个 Socket 文件。接下来，对于 Web 服务器而言，要处理的是文件的 I/O，以及在 I/O 结束之后进行数据、业务逻辑的处理。</p>
<ul>
<li><strong>I/O</strong>：这部分的主要开销在于从 Socket 文件中读出数据到用户空间。比如说读取出 HTTP 请求的数据并把它们存储到一个缓冲区当中。</li>
<li>**处理部分（Processing)**：这部分的开销有很多个部分。比如说，需要将 HTTP 请求从字节的表示转化为字符串的表示，然后再解析。还需要将 HTTP 请求的字符串，分成各个部分。头部（Header）是一个 Key-Value 的映射（Map）。Body 部分，可能是 QueryString，JSON,XML 等。完成这些处理之后，可能还会进行读写数据库、业务逻辑计算、远程调用等。</li>
</ul>
<p>我们先说<strong>处理部分（Processing）</strong> 的开销，目前主要有下面这样几种架构。</p>
<ol>
<li>为每一次处理创建一个线程。</li>
</ol>
<p>这样做<strong>线程之间的相互影响最小</strong>。只要有足够多的资源，就可以并发完成足够多的工作。但是缺点在于线程的、创建和销毁成本。虽然单次成本不高，但是积累起来非常也是一个不小的数字——比如每秒要处理 1 万个请求的情况。更关键的问题在于，在并发高的场景下，这样的设计可能会导致创建的线程太多，导致线程切换太频繁，最终大量线程阻塞，系统资源耗尽，最终引发雪崩。</p>
<ol start="2">
<li>通过线程池管理线程。</li>
</ol>
<p>这样做最大的优势在于<strong>拥有反向压力</strong>。所谓反向压力（Back-Presure）就是当系统资源不足的时候可以阻塞生产者。对任务处理而言，生产者就是接收网络请求的 I/O 环节。当压力太大的时候，拒绝掉部分请求，从而缓解整个系统的压力。比如说我们可以控制线程池中最大的线程数量，一般会多于 CPU 的核数，小于造成系统雪崩的数量，具体数据需要通过压力测试得出。</p>
<ol start="3">
<li>利用协程。</li>
</ol>
<p>在一个主线程中实现更轻量级的线程，通常是实现协程或者类似的东西。将一个内核级线程的执行时间分片，分配给 n 个协程。协程之间会互相转让执行资源，比如一个协程等待 I/O，就会将计算资源转让给其他的协程。转换过程不需要线程切换，类似函数调用的机制。这样最大程度地利用了计算资源，因此性能更好。</p>
<p>最后强调一下，GO 语言实现的不是协程，是轻量级的线程，但是效果也非常好。Node.js 实现了类似协程的单位，称为任务，效果也很不错。Java 新标准也在考虑支持协程，目前也有一些讨论——考虑用 Java 的异常处理机制实现协程。你可以根据自己的研究或者工作方向去查阅更多相关的资料。</p>
<p>接下来我们说说 I/O 部分的架构。I/O 部分就是将数据从 Socket 文件中读取出来存储到用户空间的内存中去。我们将所有需要监听的 Socket 文件描述符，都放到 epoll 红黑树当中，就进入了一种高性能的处理状态。但是读取文件的操作，还有几种选择。</p>
<ol>
<li><strong>单线程读取所有文件描述符的数据。</strong> 读取的过程利用异步 I/O，所以这个线程只需要发起 I/O 和响应中断。每次中断的时候，数据拷贝到用户空间，这个线程就将接收数据的缓冲区传递给处理模块。虽然这个线程要处理很多的 I/O，但因为只需要处理中断，所以压力并不大。</li>
<li><strong>多线程同步 I/O。</strong> 用很多个线程通过同步 I/O 的模式去处理文件描述符。这个方式在通常的情况下，可以完成工作。但是在高并发的场景下，会浪费很多的 CPU 资源。</li>
<li><strong>零拷贝技术，</strong> 通常和异步 I/O 结合使用。比如 mmap 处理过程——数据从磁盘文件读取到内核的过程不需要 CPU 的参与（DMA 技术），因此节省了大量开销。内核也不将数据再向用户空间拷贝，而是直接将缓冲区共享给用户空间，这样又节省了一次拷贝。但是需要注意，并不是所有的操作系统都支持这种模式。</li>
</ol>
<p><strong>由此可见，优化 Web 服务器底层是在优化 I/O 的模型；中间层是在优化处理数据、远程调用等的模型</strong>。这两个过程要分开来看，都需要优化。</p>
<p><strong>如何预防中间人攻击</strong>？</p>
<p><strong>中间人攻击最核心的就是要攻破信任链</strong>。比如说替换掉目标计算机中的验证程序，在目标计算机中安装证书，都可以作为中间人攻击的方式。因此在公司工作的时候，我们经常强调，要将电脑锁定再离开工位，防止有人物理破解。不要接收来历不明的邮件，防止一不小心被安装证书。也不要使用盗版的操作系统，以及盗版的软件。这些都是非法证书的来源。</p>
<p><strong>另外一种情况就是服务器被攻破</strong>。比如内部员工机器中毒，密码泄露，导致黑客远程拿到服务器的私钥。再比如说，数据库被攻击、网站被挂码，导致系统被 Root。在这种情况下，黑客就可以作为中间人解密所有消息，为所欲为了。</p>
<p>安全无小事，在这里我再多说一句，平时大家不要将密码交给同事，也不要在安全的细节上掉以轻心。安全是所有公司的一条红线，需要大家一同去努力维护。</p>
<h3 id="VMware-和-Docker-的区别？"><a href="#VMware-和-Docker-的区别？" class="headerlink" title="VMware 和 Docker 的区别？"></a><strong>VMware 和 Docker 的区别？</strong></h3><p>都说今天是一个云时代，其实云的本质就是由基础架构提供商提供基础架构，应用开发商不再关心基础架构。我们可以类比人类刚刚发明电的时候，工厂需要自己建电站，而现在只需要电线和插座就可以使用电。</p>
<p>云时代让我们可以在分钟、甚至秒级时间内获得计算、存储、操作系统等资源。设备不再论个卖，而是以一个虚拟化单位售卖，比如：</p>
<ul>
<li>用户可以买走一个 64 核 CPU 机器中的 0.25 个 CPU；</li>
<li>也可以买走一个 128GB 内存机器中的 512M 内存；</li>
<li>还可以买走 1/2 台机器三个小时了执行时间。</li>
</ul>
<p>实现以上这些，就需要虚拟化技术。这一讲我将以虚拟化技术中两种最具代表性的设计——VMware 和 Docker，为你解读解虚拟化技术。</p>
<h4 id="什么是“虚拟化”"><a href="#什么是“虚拟化”" class="headerlink" title="什么是“虚拟化”"></a>什么是“虚拟化”</h4><p>顾名思义，虚拟是相对于现实而言。虚拟化（Virutualization）通常是指构造真实的虚拟版本。不严谨地说，用软件模拟计算机，就是虚拟机；用数字模拟价值，就是货币；用存储空间模拟物理存储，就是虚拟磁盘。</p>
<p>VMware 和 Docker 是目前虚拟化技术中最具代表性的两种设计。<strong>VMware 为应用提供虚拟的计算机</strong>（<strong>虚拟机</strong>）；<strong>Docker 为应用提供虚拟的空间，被称作容器</strong>（<strong>Containe</strong>r），关于空间的含义，我们会在下文中详细讨论。</p>
<p><strong>VMware</strong>在 1998 年诞生，通过 Hypervisor 的设计彻底改变了虚拟化技术。2005 年，VMware 不断壮大，在全球雇用了 1000 名员工，<strong>成为世界上最大的云基础架构提供商</strong>。</p>
<p><strong>Docker</strong>则是 2013 年发布的一个社区产品，后来逐渐在程序员群体中流行了起来。大量程序员开始习惯使用 Docker，所以各大公司才决定使用它。在“<strong>38 讲</strong>”中我们要介绍的 Kubernates（K8s）容器编排系统，一开始也是将 Docker 作为主要容器。虽然业内不时有传出二者即将分道扬镳的消息，但是目前（2021 年）K8s 下的容器主要还是 Docker。</p>
<h4 id="虚拟机的设计"><a href="#虚拟机的设计" class="headerlink" title="虚拟机的设计"></a>虚拟机的设计</h4><p>接下来我们说说虚拟机设计。要虚拟一台计算机，要满足三个条件：<strong>隔离、仿真、高效</strong>。</p>
<p><strong>隔离（Isolation），</strong> 很好理解，<strong>指的是一台实体机上的所有的虚拟机实例不能互相影响</strong>。这也是早期设计虚拟机的一大动力，比如可以在一台实体机器上同时安装 Linux、Unix、Windows、MacOS 四种操作系统，那么一台实体机器就可以执行四种操作系统上的程序，这就节省了采购机器的开销。</p>
<p><strong>仿真（Simulation）指的是用起来像一台真的机器那样，包括开机、关机，以及各种各样的硬件设备</strong>。在虚拟机上执行的操作系统认为自己就是在实体机上执行。<strong>仿真主要的贡献是让进程可以无缝的迁移，也就是让虚拟机中执行的进程，真实地感受到和在实体机上执行是一样的</strong>——这样程序从虚拟机到虚拟机、实体机到虚拟机的应用迁移，就不需要修改源代码。</p>
<p><strong>高效（Efficient）的目标是减少虚拟机对 CPU、对硬件资源的占用</strong>。通常在虚拟机上执行指令需要额外负担 10~15% 的执行成本，这个开销是相对较低的。因为应用通常很少将 CPU 真的用满，在容器中执行 CPU 指令开销会更低更接近在本地执行程序的速度。</p>
<p>为了实现上述的三种诉求，最直观的方案就是将虚拟机管理程序 Hypervisor 作为操作系统，在虚拟机管理程序（Hypervisor）之上再去构建更多的虚拟机。像这种管理虚拟机的架构，也称为 Type-1 虚拟机，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184343.png" alt="image-20210630184343343"></p>
<p>我们通常把虚拟机管理程序（Virtual Machine Monitor，VMM）称为 Hypervisor。在 Type-1 虚拟机中，Hypervisor 一方面作为操作系统管理硬件，另一方面作为虚拟机的管理程序。在 Hypervisor 之上创建多个虚拟机，每个虚拟机可以拥有不同的操作系统（Guest OS）。</p>
<h4 id="二进制翻译"><a href="#二进制翻译" class="headerlink" title="二进制翻译"></a>二进制翻译</h4><p>通常硬件的设计假定是由单操作系统管理的。如果多个操作系统要共享这些设备，就需要通过 Hypervisor。当操作系统需要执行程序的时候，程序的指令就通过 Hypervisor 执行。早期的虚拟机设计当中，Hypervisor 不断翻译来自虚拟机的程序指令，将它们翻译成可以适配在目标硬件上执行的指令。这样的设计，我们称为二进制翻译。</p>
<p><strong>二进制翻译的弱点在于性能，所有指令都需要翻译</strong>。相当于在执行所有指令的时候，都会产生额外的开销。当然可以用动态翻译技术进行弥补，比如说预读指令进行翻译，但是依然会产生较大的性能消耗。</p>
<h4 id="世界切换和虚拟化支持"><a href="#世界切换和虚拟化支持" class="headerlink" title="世界切换和虚拟化支持"></a>世界切换和虚拟化支持</h4><p>另一种方式就是当虚拟机上的应用需要执行程序的时候，进行一次世界切换（World Switch）。<strong>所谓世界切换就是交接系统的控制权，比如虚拟机上的操作系统，进入内核接管中断，成为实际的机器的控制者</strong>。在这样的条件下，虚拟机上程序的执行就变成了本地程序的执行。相对来说，这种切换行为相较于二进制翻译，成本是更低的。</p>
<p>为了实现世界切换，虚拟机上的操作系统需要使用硬件设备，比如内存管理单元（MMR）、TLB、DMA 等。这些设备都需要支持虚拟机上操作系统的使用，比如说 TLB 需要区分是虚拟机还是实体机程序。虽然可以用软件模拟出这些设备给虚拟机使用，但是如果能让虚拟机使用真实的设备，性能会更好。现在的 CPU 通常都支持虚拟化技术，比如 Intel 的 VT-X 和 AMD 的 AMD-V（也称作 Secure Virtual Machine）。如果你对硬件虚拟化技术非常感兴趣，可以阅读<a href="https://www.mimuw.edu.pl/~vincent/lecture6/sources/amd-pacifica-specification.pdf" target="_blank" rel="noopener">这篇文档</a>。</p>
<h4 id="Type-2-虚拟机"><a href="#Type-2-虚拟机" class="headerlink" title="Type-2 虚拟机"></a>Type-2 虚拟机</h4><p>Type-1 虚拟机本身是一个操作系统，所以需要用户预装。为了方便用户的使用，VMware 还推出了 Type-2 虚拟机，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184512.png" alt="image-20210630184512346"></p>
<p>在第二种设计当中，虚拟机本身也作为一个进程。它和操作系统中执行的其他进程并没有太大的区别。但是<strong>为了提升性能，有一部分 Hypervisor 程序会作为内核中的驱动执行</strong>。<strong>当虚拟机操作系统（Guest OS）执行程序的时候，会通过 Hypervisor 实现世界切换</strong>。因此，虽然和 Type-1 虚拟机有一定的区别，但是从本质上来看差距不大，同样是需要二进制翻译技术和虚拟化技术。</p>
<h4 id="Hyper-V"><a href="#Hyper-V" class="headerlink" title="Hyper-V"></a>Hyper-V</h4><p>随着虚拟机的发展，现在也出现了很多混合型的虚拟机，比如微软的 Hyper-v 技术。从下图中你会看到，虚拟机的管理程序（Parent Partition）及 Windows 的核心程序，都会作为一个虚拟化的节点，拥有一个自己的 VMBus，并且通过 Hypervisor 实现虚拟化。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184649.png" alt="image-20210630184648970"></p>
<p>在 Hyper-V 的架构当中不存在一个主的操作系统。实际上，用户开机之后就在使用虚拟机，Windows 通过虚拟机执行。在这种架构下，其他的虚拟机，比如用 VMware 管理的虚拟机也可以复用这套架构。当然，你也可以直接把 Linux 安装在 Hyper-V 下，只不过安装过程没有 VMWare 傻瓜化，其实也是很不错的选择。</p>
<h4 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h4><p><strong>虚拟机虚拟的是计算机，容器虚拟的是执行环境</strong>。每个容器都是一套独立的执行环境，如下图所示，容器直接被管理在操作系统之内，并不需要一个虚拟机监控程序。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630184722.png" alt="image-20210630184722320"></p>
<p><strong>和虚拟机有一个最大的区别就是：容器是直接跑在操作系统之上的，容器内部是应用，应用执行起来就是进程</strong>。这个进程和操作系统上的其他进程也没有本质区别，但这个架构设计没有了虚拟机监控系统。当然，容器有一个更轻量级的管理程序，用户可以从网络上下载镜像，启动起来就是容器。容器中预装了一些程序，比如说一个 Python 开发环境中，还会预装 Web 服务器和数据库。因为没有了虚拟机管理程序在中间的开销，因而性能会更高。而且因为不需要安装操作系统，因此容器安装速度更快，可以达到 ms 级别。</p>
<p><strong>容器依赖操作系统的能力直接实现，比如：</strong></p>
<ul>
<li><strong>Linux 的 Cgroups（Linux Control Groups）能力，可以用来限制某组进程使用的 CPU 资源和内存资源，控制进程的资源能使用；</strong></li>
<li>另外<strong>Linux 的 Namespace 能力，可以设置每个容器能看到能够使用的目录和文件</strong>。</li>
</ul>
<p>有了这两个能力，就可以基本控制容器间的隔离，容器中的应用直接以进程的身份执行即可。进程间的目录空间、 CPU 资源已经被隔离了，所以不用担心互相影响。</p>
<p><strong>VMware 和 Docker 的区别</strong>？</p>
<p><strong>【解析】</strong> VMware 提供虚拟机，Docker 提供容器。 虚拟机是一台完整的计算机，因此需要安装操作系统。虚拟机中的程序执行在虚拟机的操作系统上，为了让多个操作系统可以高效率地同时执行，虚拟机非常依赖底层的硬件架构提供的虚拟化能力。容器则是利用操作系统的能力直接实现隔离，容器中的程序可以以进程的身份直接执行。</p>
<h4 id="如何利用-K8s-和-Docker-Swarm-管理微服务？"><a href="#如何利用-K8s-和-Docker-Swarm-管理微服务？" class="headerlink" title="如何利用 K8s 和 Docker Swarm 管理微服务？"></a><strong>如何利用 K8s 和 Docker Swarm 管理微服务？</strong></h4><p>现在的面试官都喜欢问<strong>微服务相关的内容。微服务（Micro Service），指的是服务从逻辑上不可再分，是宏服务（Mono Service）的反义词。</strong></p>
<p>比如初学者可能认为交易相关的服务都应该属于交易服务，但事实上，交易相关的服务可能会有交易相关的配置服务、交易数据的管理服务、交易履约的服务、订单算价的服务、流程编排服务、前端服务……<br>所以到底什么是不可再分呢？</p>
<p>其实没有不可再分，永远都可以继续拆分下去。只不过从逻辑上讲，系统的拆分，应该结合公司部门组织架构的调整，反映公司的战斗结构编排。但总的来说，互联网上的服务越来越复杂，几个简单的接口就可能形成一个服务，这些服务都要上线。如果用实体机来承载这些服务，开销太大。如果用虚拟机来承载这些服务倒是不错的选择，但是创建服务的速度太慢，不适合今天这个时代的研发者们。</p>
<p>试想你的系统因为服务太多，该如何管理？尤其是在大型的公司，员工通过自发组织架构评审就可以上线微服务——天长日久，微服务越来越多，可能会有几万个甚至几十万个。那么这么多的微服务，如何分布到数万台物理机上工作呢？</p>
<p>如下图所示，为了保证微服务之间是隔离的，且可以快速上线。每个微服务我们都使用一个单独的容器，而一组容器，又包含在一个虚拟机当中，具体的关系如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185319.png" alt="image-20210630185318831"></p>
<p>上图中的微服务 C 因为只有一个实例存在单点风险，可能会引发单点故障。因此需要为微服务 C 增加副本，通常情况下，我们必须保证每个微服务至少有一个副本，这样才能保证可用性。</p>
<p>上述架构的核心就是要解决两个问题：</p>
<ol>
<li>减少 downtime（就是减少服务不可用的时间）；</li>
<li>支持扩容（随时都可以针对某个微服务增加容器）。</li>
</ol>
<p>因此，我们需要容器编排技术。容器编排技术指自动化地对容器进行部署、管理、扩容、迁移、保证安全，以及针对网络负载进行优化等一系列技术的综合体。Kubernetes 和 Docker Swarm 都是出色的容器编排方案。</p>
<h4 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h4><p>Kubernetes（K8s）是一个 Google 开源的容器编排方案。</p>
<h4 id="节点（Master-amp-Worker）"><a href="#节点（Master-amp-Worker）" class="headerlink" title="节点（Master&amp;Worker）"></a>节点（Master&amp;Worker）</h4><p><strong>K8s 通过集群管理容器</strong>。用户可以通过命令行、配置文件管理这个集群——从而编排容器；用户可以增加节点进行扩容，每个节点是一台物理机或者虚拟机。如下图所示，Kubernetes 提供了两种分布式的节点。Master 节点是集群的管理者，Worker 是工作节点，容器就在 Worker 上工作，一个 Worker 的内部可以有很多个容器。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185409.png" alt="image-20210630185409238"></p>
<p>在我们为一个微服务扩容的时候，首选并不是去增加 Worker 节点。可以增加这个微服务的容器数量，也可以提升每个容器占用的 CPU、内存存储资源。只有当整个集群的资源不够用的时候，才会考虑增加机器、添加节点。</p>
<p>Master 节点至少需要 2 个，但并不是越多越好。Master 节点主要是管理集群的状态数据，不需要很大的内存和存储空间。Worker 节点根据集群的整体负载决定，一些大型网站还有弹性扩容的手段，也可以通过 K8s 实现。</p>
<h4 id="单点架构"><a href="#单点架构" class="headerlink" title="单点架构"></a>单点架构</h4><p>接下来我们讨论一下 Worker 节点的架构。所有的 Worker 节点上必须安装 kubelet，它是节点的管理程序，负责在节点上管理容器。</p>
<p>Pod 是 K8s 对容器的一个轻量级的封装，每个 Pod 有自己独立的、随机分配的 IP 地址。Pod 内部是容器，可以 1 个或多个容器。目前，Pod 内部的容器主要是 Docker，但是今后可能还会有其他的容器被大家使用，主要原因是 K8s 和 Docker 的生态也存在着竞争关系。总的来说，如下图所示，kubelet 管理 Pod，Pod 管理容器。当用户创建一个容器的时候，实际上在创建 Pod。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185657.png" alt="image-20210630185657364"></p>
<p>虽然 K8s 允许同样的应用程序（比如微服务），在一个节点上创建多个 Pod。但是为了保证可用性，通常我们会考虑将微服务分散到不同的节点中去。如下图所示，如果其中一个节点宕机了，微服务 A，微服务 B 还能正常工作。当然，有一些微服务。因为程序架构或者编程语言的原因，只能使用单进程。这个时候，我们也可能会在单一的节点上部署多个相同的服务，去利用更多的 CPU 资源。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185709.png" alt="image-20210630185709284"></p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>Pod 的 IP 地址是动态的，如果要将 Pod 作为内部或者外部的服务，那么就需要一个能拥有静态 IP 地址的节点，这种节点我们称为服务（Service），服务不是一个虚拟机节点，而是一个虚拟的概念——或者理解成一段程序、一个组件。请求先到达服务，然后再到达 Pod，服务在这之间还提供负载均衡。当有新的 Pod 加入或者旧的 Pod 被删除，服务可以捕捉到这些状态，这样就大大降低了分布式应用架构的复杂度。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185721.png" alt="image-20210630185720941"></p>
<p>如上图所示，当我们要提供服务给外部使用时，对安全的考虑、对性能的考量是超过内部服务的。 K8s 解决方案：在服务的上方再提供薄薄的一层控制程序，为外部提供服务——这就是 Ingress。</p>
<p>以上，就是 K8s 的整体架构。 在使用的过程当中，相信你会感受到这个工具的魅力。比如说组件非常齐全，有数据加密、网络安全、单机调试、API 服务器等。如果你想了解更多的内容，可以查看<a href="https://kubernetes.io/docs/concepts/overview/" target="_blank" rel="noopener">这些资料</a>。</p>
<h4 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h4><p>Docker Swarm 是 Docker 团队基于 Docker 生态打造的容器编排引擎。下图是 Docker Swarm 整体架构图。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630185800.png" alt="image-20210630185800434"></p>
<p>和 K8s 非常相似，节点被分成了 Manager 和 Worker。Manager 之间的状态数据通过 Raft 算法保证数据的一致性，Worker 内部是 Docker 容器。</p>
<p>和 K8s 的 Pod 类似，Docker Swarm 对容器进行了一层轻量级的封装——任务（Task），然后多个Task 通过服务进行负载均衡。</p>
<h4 id="容器编排设计思考"><a href="#容器编排设计思考" class="headerlink" title="容器编排设计思考"></a>容器编排设计思考</h4><p>这样的设计，用户只需要指定哪些容器开多少个副本，容器编排引擎自动就会在工作节点之中复制这些容器。而服务是容器的分组，多个容器共享一个服务。容器自动被创建，用户在维护的时候不需要维护到容器创建级别，只需要指定容器数目，并指定这类型的容器对应着哪个服务。至于之后，哪一个容器中的程序执行出错，编排引擎就会杀死这个出错的容器，并且重启一个新的容器。</p>
<p>在这样的设计当中，容器最好是<strong>无状态</strong>的，所以容器中最好不要用来运行 MySQL 这样的数据库。对于 MySQL 数据库，并不是多个实例都可以通过负载均衡来使用。有的实例只可以读，有的实例只可以写，中间还有 Binlog 同步。因此，虽然 K8s 提供了状态管理组件，但是使用起来可能不如虚拟机划算。</p>
<p>也是因为这种原因，我们现在倾向于进行无状态服务的开发。所有的状态都是存储在远程，应用本身并没有状态。当然，<strong>在开发测试环境，用容器来管理数据库是一个非常好的方案</strong>。这样可以帮助我们快速搭建、切换开发测试环境，并且可以做到一人一环境，互不影响，也可以做到开发环境、测试环境和线上环境统一。</p>
<p><strong>如何利用 K8s 和 Docker Swarm 管理微服务</strong>？</p>
<p>这两个容器编排引擎都可以用来管理微服务。K8s 和 Docker Swarm 在使用微服务的时候有许多共性的步骤。</p>
<ol>
<li><strong>制作容器镜像</strong>：我们就是要先制作容器，如果使用 Docker 作为容器，那就要写 DockerFile，然后生成容器镜像。</li>
<li><strong>上传镜像</strong>：制作好容器之后，我们往往会将容器上传到容器的托管平台。很多公司内部有自己的容器托管平台，这样下载容器的速度会非常快。</li>
<li><strong>搭建集群</strong>：再接下来，我们要搭建一个 K8s 或者 Docker Swarm 的集群，将节点添加进去。</li>
<li><strong>添加微服务 Pod/Task</strong>：然后我们要在集群中添加 Pod 的或者 Task，可以通过命令行工具，也可以通过书写配置文件。</li>
<li><strong>设置服务</strong>：为 Pod/Task 设置服务，之后都通过服务来访问容器内的应用。</li>
</ol>
<p>以上 5 个步骤是无论用哪个容器编排引擎都需要做的。具体使用过程当中，还有很多差异。比如，有的时候使用图形界面就可以完成上面的管理；不同的引擎配置文件，参数格式都会有差异。但是从整体架构到使用方式，它们都有着很大的相似性。因此你在学习容器编排引擎时，不应该着眼于学习某一个引擎，而是将它们看作一类知识，对比着学习。</p>
<h3 id="Linux-架构优秀在哪里"><a href="#Linux-架构优秀在哪里" class="headerlink" title="Linux 架构优秀在哪里?"></a><strong>Linux 架构优秀在哪里?</strong></h3><p>我们在面试的时候经常会和面试官聊架构，多数同学可能会认为架构是一个玄学问题，讨论的是“玄而又玄”的知识——如同道德经般的开头“玄之又玄、众妙之门”。<strong>其实架构领域也有通用的语言，有自己独有的词汇</strong>。虽然架构师经常为了系统架构争得面红耳赤，但是即使发生争吵，大家也会遵守架构思想准则。</p>
<p>这些优秀的架构思想和准则，很大一部分来自早期的黑客们对程序语言编译器实现的探索、对操作系统实现方案的探索，以及对计算机网络应用发展的思考，并且一直沿用至今。比如现在的面向对象编程、函数式编程、子系统的拆分和组织，以及分层架构设计，依然沿用了早期的架构思路。</p>
<p>其中有一部分非常重要的思想，被著名的计算机科学家、Unix 代码贡献者 Douglas McIlroy 誉为 Unix 哲学，也是 Linux 遵循的设计思想。今天我就和你一起讨论下，这部分前人留下的思想精华，希望可以帮助到你日后的架构工作。</p>
<h4 id="组合性设计（Composability）"><a href="#组合性设计（Composability）" class="headerlink" title="组合性设计（Composability）"></a>组合性设计（Composability）</h4><p><strong>Unix 系设计的哲学，都在和单体设计（Monolithic Design）和中心化唱反调</strong>。作为社区产品，开发者来自全世界不同的地方，这就构成了一个巨大的开发团队，自然会反对中心化。</p>
<p>而一个巨大的开发团队的管理，一定不能是 Mono 的。举个例子，如果代码仓库是Mono的，这意味着所有的代码都存放在一个仓库里。如果要上线项目中的一个功能，那所有项目中的代码都要一起上线，只要一个小地方出了问题，就会影响到全局。在我们设计这个系统的时候，应该允许不同的程序模块通过不同的代码仓库发布。</p>
<p>再比如说，整体的系统架构应该是可以组合的。比如文件系统的设计，每个目录可以有不同的文件系统，我们可以随时替换文件系统、接入新的文件系统。比如接入一个网络的磁盘，或者接入一个内存文件系统。</p>
<p>与其所有的程序工具模块都由自己维护，不如将这项权利分发给需要的人，让更多的人参与进来。让更多的小团队去贡献代码，这样才可以把更多的工具体验做到极致。</p>
<p>这个思想在面向对象以及函数式编程的设计中，同样存在。比如在面向对象中，我们会尽量使用组合去替代继承。<strong>因为继承是一种 Mono 的设计，一旦发生继承关系，就意味着父类和子类之间的强耦合</strong>。<strong>而组合是一种更轻量级的复用</strong>。对于函数式编程，我们有 Monad 设计（单子），本质上是让事物（对象）和处理事物（计算）的函数之间可以进行组合，这样就可以最小粒度的复用函数。</p>
<p>同理，Unix 系操作系统用管道组合进程，也是在最小粒度的复用程序。</p>
<h4 id="管道设计（Pipeline）"><a href="#管道设计（Pipeline）" class="headerlink" title="管道设计（Pipeline）"></a>管道设计（Pipeline）</h4><p>提到最小粒度的复用程序，就必然要提到管道（Pipeline）。Douglas McIlroy 在 Unix 的哲学中提到：<strong>一个应用的输出，应该是另一个应用的输入</strong>。<strong>这句话，其实道出了计算的本质</strong>。</p>
<p>计算其实就是将一个计算过程的输出给另一个计算过程作为输入。在构造流计算、管道运算、Monad 类型、泛型容器体系时——很大程度上，我们希望计算过程间拥有一定的相似性，比如泛型类型的统一。这样才可以把一个过程的输出给到另一个过程的输入。</p>
<h4 id="重构和丢弃"><a href="#重构和丢弃" class="headerlink" title="重构和丢弃"></a>重构和丢弃</h4><p>在 Unix 设计当中有一个非常有趣的哲学。<strong>就是希望每个应用都只做一件事情，并且把这件事情做到极致。如果当一个应用变得过于复杂的时候，就去重构这个应用，或者重新写一个应用。而不是在原有的应用上增加功能。</strong></p>
<p>上述逻辑和商业策略是否有相悖的地方？</p>
<p>关于这个问题，我觉得需要你自己进行思考，我不能给你答案，但欢迎把你的想法和答案写在留言区，我们一起交流。</p>
<p>设想一下，我们把微信的聊天工具、朋友圈、短视频、游戏都做成不同的应用，是不是会更好一些？</p>
<p>这是一个见仁见智的问题。但是目前来看，如果把短视频做成一个单独的应用，比如抖音，它在全球已经拥有 10 几亿的用户了；如果把游戏做成一个单独的应用，比如王者荣耀和 LoL，它们深受程序员们和广大上班族的喜爱。</p>
<p>还有，以我多年从事大型系统开发的经验来看，我宁愿重新做一些微服务，也不愿意去重构巨大的、复杂的系统。换句话说，我更乐意将新功能做到新系统里面，而不是在一个巨大的系统上不断地迭代和改进。这样不仅节省开发成本，还可以把事情做得更好。从这个角度看，我们进入微服务时代，是一个不可逆的过程。</p>
<p>另外多说一句，如果一定要在原有系统上增加功能，也应该多重构。<strong>重构和重写原有的系统有很多的好处</strong>，希望你不要有<strong>畏难情绪</strong>。优秀的团队，总是处在一个代码不断迭代的过程。一方面是因为业务在高速发展，旧代码往往承接不了新需求；另一方面，是因为程序员本身也在不断地追求更好的架构思路。</p>
<p>而重构旧代码，还经常可以看到业务逻辑中出问题的地方，看到潜在的隐患和风险，同时让程序员更加熟悉系统和业务逻辑。而且程序的复杂度，并不是随着需求量线性增长的。<strong>当需求量超过一定的临界值，复杂度增长会变快，类似一条指数曲线</strong>。<strong>因此，控制复杂度也是软件工程的一个核心问题。</strong></p>
<h4 id="写复杂的程序就是写错了"><a href="#写复杂的程序就是写错了" class="headerlink" title="写复杂的程序就是写错了"></a>写复杂的程序就是写错了</h4><p>我们经常听到优秀的架构师说，<strong>程序写复杂了，就是写错了。</strong>在 Unix 哲学中，也提出过这样的说法：<strong>写一个程序的时候，先用几周时间去构造一个简单的版本，如果发现复杂了，就重写它</strong>。</p>
<p>确实实际情景也是如此。我们在写程序的时候，如果一开始没有用对工具、没有分对层、没有选对算法和数据结构、没有用对设计模式，那么写程序的时候，就很容易陷入大量的调试，还会出现很多 Bug。<strong>优秀的程序往往是思考的过程很长，调试的时间很短，能够迅速地在短时间内完成测试和上线。</strong></p>
<p>所以当你发现一段代码，或者一段业务逻辑很消耗时间的时候，可能是你的思维方式出错了。想一想是不是少了必要的工具的封装，或者遗漏了什么中间环节。当然，也有可能是你的架构设计有问题，这就需要重新做架构了。</p>
<h4 id="优先使用工具而不是“熟练”"><a href="#优先使用工具而不是“熟练”" class="headerlink" title="优先使用工具而不是“熟练”"></a>优先使用工具而不是“熟练”</h4><p>关于优先使用工具这个哲学，我深有体会。</p>
<p>很多程序员在工作当中都忽略了去积累工具。比如说：</p>
<ul>
<li>你经常要重新配置自己的开发环境，也不肯做一个 Docker 的镜像；</li>
<li>你经常要重新部署自己的测试环境，而且有时候还会出现使用者太多而不够用的情况。即使这样的情况屡屡发生，也不肯做一下容器化的管理；</li>
<li>Git 的代码提交之后，不会触发自动化测试，需要人工去点鼠标，甚至需要由资深的测试手动去测。</li>
</ul>
<p>很多程序员都认为自己对某项技术足够熟练了。因此，宁愿长年累月投入更多的时间，也不愿意主动跳脱出固化思维。宁愿不断使用某一项技术，而不愿意将重复劳动转化成工具。比如写一个小型的 ORM 框架、缓存引擎、业务容器……总之，养成良好的习惯，可以让开发效率越来越高。</p>
<p>在 Unix 哲学当中，有这样一条规则：<strong>有些人使用“熟练”而不是使用工具来减轻工作，即便是临时需要去构造一个工具，你也应该尽可能去尝试实现。</strong></p>
<p>我们现在每天都用的 Git 版本控制工具，就是基于这样的哲学被构建出来的。当时刚好是 Linux 内核研发团队的商业代码管理工具到期了，Linux 的缔造者们基于这个经验教训，就自主研发了 Git 这款工具，不仅顺利地推进了后续的研发工作，还做成了一个巨大的程序员交友生态。</p>
<p>再给你讲一个我身边的故事：我刚刚工作的时候，我的老板自己写了一个小程序，去判断 HR 发过来简历是否符合他的用人条件。所以他每天可以看完几百份简历，并筛选出面试人选。而那些没有利用工具的技术 Leader，每天都在埋怨简历太多看不过来。</p>
<p>这些故事告诉我们，<strong>作为程序员，不仅仅需要完成工作，还要重视中间过程的工具缔造</strong>。</p>
<h4 id="其他优秀的原则"><a href="#其他优秀的原则" class="headerlink" title="其他优秀的原则"></a>其他优秀的原则</h4><p>我在学习 Unix 哲学的过程中，还看到很多有趣的规则，这里我摘选了一些和你分享。</p>
<p>比如：<strong>不要试图猜测程序可能的瓶颈在哪里，而是试图证明这个瓶颈，因为瓶颈会出现在出乎意料的地方</strong>。这句话告诉我们，要多写性能测试程序并且构造压力测试的场景。只有这样，才能让你的程序更健壮，承载更大的压力。</p>
<p>再比如：<strong>花哨的算法在业务规模小的时候通常运行得很慢，因此业务规模小的时候不要用花哨的算法。简单的算法，往往性能更高。如果你的业务规模很大，可以尝试去测试并证明需要用怎样的算法</strong>。</p>
<p>这也是我们在架构程序的时候经常会出错的地方。我们习惯性地选择用脑海中记忆的时间复杂度最低的算法，但是却忽略了<strong>时间复杂度只是一种增长关系，一个算法在某个场景中到底可不可行，是要以实际执行时收集数据为准的</strong>。</p>
<p>再比如：<strong>数据主导规则。当你的数据结构设计得足够好，那么你的计算方法就会深刻地反映出你系统的逻辑。这也叫作自证明代码。编程的核心是构造好的数据结构，而不是算法。</strong></p>
<p>尽管我们在学习的时候，算法和数据结构是一起学的。但是在大牛们看来，<strong>数据结构的抽象可以深刻反映系统的本质</strong>。比如抽象出文件描述符反应文件、抽象出页表反应内存、抽象出 Socket 反应连接——这些数据结构才是设计系统最核心的东西。</p>
<p>最后，再和你分享一句 Unix 的设计者Ken Thompson 的经典语录：<strong>搞不定就用蛮力</strong>。这是打破所有规则的规则。<strong>在我们开发的过程当中，首先要把事情搞定！只有把事情搞定，才有我们上面谈到的这一大堆哲学产生价值的可能性</strong>。事情没有搞定，一切都尘归尘土归土，毫无意义。</p>
<p>今天所讲的这些哲学，可以作为你平时和架构师们沟通的语言。架构有自己领域的语言，比如设计模式、编程范式、数据结构，等等。还有许多像 Unix 哲学这样——经过历史积淀，充满着人文气息的行业标准和规范。</p>
<p>如果你想仔细看看当时 Unix 的设计者都总结了哪些哲学，可以阅读<a href="http://www.catb.org/~esr/writings/taoup/html/ch01s06.html" target="_blank" rel="noopener">这篇文档</a>。</p>
<h3 id="商业操作系统：电商操作系统是不是一个噱头？"><a href="#商业操作系统：电商操作系统是不是一个噱头？" class="headerlink" title="商业操作系统：电商操作系统是不是一个噱头？"></a><strong>商业操作系统：电商操作系统是不是一个噱头？</strong></h3><p>关于电商操作系统是不是一个噱头？我觉得对于想要哄抬股价、营造风口的资本来说，这无疑是一场盛宴。但是对于从事多年业务架构，为了这件事情努力的架构师们而言，这似乎不是一个遥远的梦想，而是可以通过手中的键盘、白板上的图纸去付诸实践的目标。</p>
<p>我们暂且不为这个问题是不是噱头定性，不如先来聊一聊<strong>什么是商业操作系统</strong>，聊一聊它的设计思路和基本理念。</p>
<h4 id="进程的抽象"><a href="#进程的抽象" class="headerlink" title="进程的抽象"></a>进程的抽象</h4><p>你可以把一个大型的电商公司想象成一个商业操作系统，它的目标是为其中的每个参与者分配资源。这些资源不仅仅是计算资源，还会有市场资源、渠道资源、公关资源、用户资源，等等。</p>
<p>这样操作系统上的进程也被分成了几种类别，比如说内核程序，其实就是电商公司。应用程序就包括商家、供应商、品牌方、第三方支付、大数据分析公司等一系列组织的策略。</p>
<p>接下来，我们以<strong>商家</strong>为例讨论进程。在操作系统中进程是应用程序的执行副本。它不仅仅是在内核的进程表中留下一条记录，<strong>它更像拥有独立思考能力的人</strong>，它需要什么资源就会自己去操作系统申请。它会遵循操作系统的规则，为自己的用户服务，完成自己的商业目的。</p>
<p>所以如果上升到操作系统的高度来设计电商系统。我们不仅要考虑如何在数据库表中记录这个商家、如何实现跟这个商家相关的业务逻辑，还要让商家的行为是定制化的，可以自发地组织营业。同时，也要服从平台制定的规则，共同维护商业秩序，比如定价策略、物流标准、服务水平，等等。</p>
<p>你可能会说，要达到这点其实很容易。实现一个开放平台，将所有的平台能力做成 API。让商家可以自己开发程序，去调用这些 API 来完成自己的服务。商家可以利用这些接口自定义自己的办公自动化软件。</p>
<p>事实上很多电商公司也确实是这样去做的，但我认为这样做没有抓住问题的核心。一方面是系统的开发、对接成本会难住很多中小型商家。但最重要的并不是研发成本，而是开放的 API 平台通常只能提供基础能力——比如说订单查询、商品创建、活动创建，等等。这些能力是电商平台已有能力的一种投影，超不过商家本身能在后台中配置和使用的范畴，基于这样的 API 架构出来的应用程序，可以节省商家的时间，但是不能称为进程。因为独立性不够，且不够智能。</p>
<p>所以真正的发展方向和目标是商业的<strong>智能化</strong>。这里有一个在游戏领域常见的设计模式，可以实现智能化，叫作<strong>代理人</strong>（<strong>Agent</strong>）<strong>模式</strong>。就是为每一个商家提供一个或者多个代理（Agent）程序。这些代理人像机器人一样，会帮助商家运营自己的网店、客服、物流体系，等等。</p>
<p>代理人知道什么时候应该做什么，比如说：</p>
<ul>
<li>帮商家预约物流、为新老用户提供不同的服务；</li>
<li>通过分析数据决定是否需要花钱做活动；</li>
<li>当品牌方有活动的时候，帮助商家联系；</li>
<li>当线上商店经营出现问题的时候，主动帮商家分析；</li>
<li>……</li>
</ul>
<p>你可以把代理人理解成一个游戏的 AI，它们会根据一些配置选项自发地完成任务。而代理人的提供者，也就是<strong>程序员</strong>，只需要证明在某些方面，代理人比人更优秀即可。而在这些优秀的方面，就可以交给代理人处理。</p>
<p>这样，商家放弃了一部分的管理权限，也减轻了很大的负担，成了代理人决策中的某个节点——比如有时候需要邮件确认一些内容、有时候需要支付运营费用、有时候会遵循代理人的建议对商店进行装修等。</p>
<h4 id="资源和权限"><a href="#资源和权限" class="headerlink" title="资源和权限"></a>资源和权限</h4><p>对于一个计算机上的操作系统而言，我们对进程使用了什么样的资源并不是非常的敏感。而对于一个商业操作系统来说，我们就需要设计严格的权限控制。因为权限从某种意义上就代表着收入，代表着金钱。</p>
<p>资源是一个宽泛的概念。广告位是资源，可以带来直接的流量。基于用户的历史行为，每个用户看到的广告位是不同的，这个也叫作“千人千面”，所以一个广告位可以卖给很多个代理人。站内信、用户召回的权限也可以看作资源。 有权利建立自己的会员体系，可以看作资源。数据分析的权限可以看作资源。<strong>如果将商业系统看作一个操作系统，资源就是所有在这个系统中流通的有价值的东西</strong>。</p>
<p>有同学可能会认为，一切资源都可以用数据描述，那么<strong>权限控制</strong>也应该会比较简单。比如说某一个推广位到底给哪个商家、到底推广多长时间……</p>
<p>其实并不是这样，虽然有很多权限可以用数据描述但是并不好控制。比如一个商品，“商家最低可以设置多少价格”就是一件非常不好判断的事情。商品有标品也有非标品，标品的价格好控制，非标品的价格缺少参照。如果平台方不希望花费太多精力在价格治理上，就要想办法让这些不守规则的商家无法盈利。比如说一旦发现恶性价格竞争，或者虚报价格骗钱的情况，需要及时给予商家打击和处罚。</p>
<p><strong>和权限对应的就是资源</strong>。如果让商家以代理人的身份在操作系统中运行，那么这个代理人可以使用多少资源，就需要有一个访问权限控制列表（Access Control List,，ACL）。这里有一个核心的问题，在传统的 ACL 设计中，是基于权限的管控，而不是权限、内容的发现。而对于设计得优秀的代理人 （Agent），应该是订阅所有的可能性，知道如何获取、申请所有的权限，然后不断思考怎样做更好。对代理人而言，这不是一个权限申请的问题，而是一个最优化策略——思考如何盈利。</p>
<h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><p>商家、组织在操作系统上化身成为代理人，也就是进程。商业操作系统的调度不仅仅体现在给这些代理人足够的计算、存储资源，更重要的是为这些代理人的决策提供上下文以及资源。</p>
<p>就好像真实的人一样：听到、看到、触摸到，然后做决策。做决策需要策略，一个好的策略可能是赚钱的，而一个坏的策略可能是灾难性的。从人做决策到机器做决策，有一个中间的过程。一开始的目标可以设立在让机器做少量的决策，比如说，机器通过观察近期来到商店用户的行为，决定哪些商品出现在店铺的首页上。但是在做这个决策之前，机器需要先咨询人的意愿。这样就把人当成了决策节点，机器变成了<strong>工具人</strong>。这样做一方面为人节省了时间，一方面也避免了错误。</p>
<p>再比如说机器可以通过数据预估一个广告位的收益，通过用户集群的画像得知在某个广告位投放店铺广告是否划算。如果机器得到一个正向的结果，可能会通知商家来完成付费和签约。那么问题来了，商家是否可以放心将付费和签约都交给机器呢？</p>
<p>当然不可以。如果家里急着用钱，可能就无法完成这笔看上去是划算的交易。另外，如果有其他的商家也看上了这个广告位。可能就需要竞价排名，所以需要人和机器的混合决策。</p>
<p>上述的模式会长期存在，例如设置价格是一个复杂的模型——疫情来了，口罩的销量会上升。机器可以理解这个口罩销量上升的过程，但是机器很难在疫情刚刚开始、口罩销量还没有上升的时候就预判到这个趋势。如果逻辑是确定的，那机器可以帮人做到极致，但如果逻辑不确定呢？如果很多判断是预判，是基于复杂的现实世界产生的思考，那么这就不是机器擅长的领域了。</p>
<p><strong>所以智能的目标并不是替代人，而是让人更像人、机器更像机器</strong>。</p>
<p>另外再和你聊一下我自己的观点，以自动驾驶为例。如果一个完全自动驾驶的汽车发生车祸，那么应该由汽车制造商、算法的提供方、自动驾驶设备的提供方、保险公司来共同来承担责任。类比下，如果策略可以售卖，那么提供策略的人就要承担相应的责任。比如说策略出现故障，导致营销券被大量套现，那提供策略方就需要承担相应的赔偿。</p>
<p>在可预见到的未来，策略也会成为一种可交易的资源。维护一个网上商店，从原材料到生产加工、渠道、物流体系、获客、销售环节，再到售后——以目前的技术水平，可以实现到一种半人工参与的状态。但这样也产生了很多非常现实的问题，比如说，既然开店变得如此容易，那资本为什么不自己开店。这样去培养合格、服务态度更好的店员不是更加容易吗？</p>
<p>这也是互联网让人深深担忧的原因之一。所有的东西被自动化之后，代表着一种时代的变迁，剩下不能够自动化的，都变成了“节点”。很多过程不需要人参与之后，人就变成了在某些机器无法完成工作的节点上不断重复劳动的工具——这也是近年来小朋友们经常说自己是“工具人”的原因了。</p>
<p>而且，我们程序员是在推动这样的潮流。因此你可以想象，未来对程序员的需求是很大的。一个普通的商店可能会雇佣一名程序员，花上半年匠心打造某个策略，收费标准可能会像现在的住房装修一样贵。这个策略成功之后还会进行微调，这就是后期的服务费用。完全做到配置化的策略，会因为不够差异化，无法永久盈利。最终在商业市场上竞争的，会是大量将人作为决策节点的 AI。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>商业是人类繁荣后的产物，电商是信息时代商业早期形式，未来的发展方向一定是像一个操作系统那样，让每个实体，都可以有自己的策略。用户可以写策略订餐，比如说我每天中午让 AI 帮助我挑选、并订一份午餐。商家写策略运营，比如运营网店。</p>
<p>至于商业操作系统到底是不是一个噱头？我觉得这是商业的发展方向。操作系统上的进程应该是策略，或者说是机器人。这样的未来也让我深深的焦虑过：它可能让人失去工作，让连接变得扁平，焦虑散播在加速——这些问题都需要解决，而解决需要时间、需要探索。</p>
<p>如果你有更多的想法可以把你的想法和方案写到留言区，和我一起交流。</p>
<p>这一讲就到这里，发现求知的乐趣，我是林䭽。感谢你学习本次课程，下一讲我们将学习本专栏的最后一节内容，加餐 | 练习题详解（八）。 再见！</p>
<p><strong>自己尝试用 Docker 执行一个自己方向的 Web 程序：比如 Spring/Django/Express 等？</strong></p>
<p>【<strong>解析</strong>】关于如何安装 Docker，你可以参考<a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">这篇文档</a>。然后这里还有一个不错的 SpringBoot+MySQL+Redis 例子，你可以参考<a href="https://github.com/tomoyane/springboot-bestpractice" target="_blank" rel="noopener">这篇内容</a>。</p>
<p>其他方向可以参考上面例子中的 Compose.yml 去定义自己的环境。 一般开发环境喜欢把所有工具链用 Compose 放到一起，上线的环境数据库一般不会用 Docker 容器。 Docker-Compose 是一个专门用来定义多容器任务的工具，你可以<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">在这里</a>得到。</p>
<p>国内镜像可以用 Aliyun 的，具体你可以参考<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">这篇文档</a>。</p>
<p>（注：需要一个账号并且登录）</p>
<p><strong>为什么会有多个容器共用一个 Pod 的需求</strong>？</p>
<p>【<strong>解析</strong>】Pod 内部的容器共用一个网络空间，可以通过 localhost 进行通信。另外多个容器，还可以共享一个存储空间。</p>
<p>比如一个 Web 服务容器，可以将日志、监控数据不断写入共享的磁盘空间，然后由日志服务、监控服务处理将日志上传。</p>
<p>再比如说一些跨语言的场景，比如一个 Java 服务接收到了视频文件传给一 个 OpenCV 容器进行处理。</p>
<p>以上这种设计模式，我们称为<strong>边车模式</strong>（Sidecar），边车模式将数个容器放入一个分组内（例如 K8s 的 Pod），让它们可以分配到相同的节点上。这样它们彼此间可以共用磁盘、网络等。</p>
<p>在边车模式中，有一类容器，被称为<strong>Ambassador Container</strong>，翻译过来是使节容器。对于一个主容器（Main Container）上的服务，可以通过 Ambassador Container 来连接外部服务。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210630191158.png" alt="image-20210630191158345"></p>
<p>我们在开发的时候经常会配置不同的环境。如果每个 Web 应用都要实现一套环境探测程序，比如判断是开发、测试还是线上环境，从而连接不同的 MySQL、Redis 等服务，那么每个项目都需要引入一个公用的库，或者实现一套逻辑。这样我们可以使用一个边车容器，专门提供数据库连接的服务。让连接服务可以自动探测环境，并且从远程读取全局配置，这样每个项目的开发者不需要再关心数据库有多少套环境、如何配置了。</p>
<h2 id="计算机网络相关"><a href="#计算机网络相关" class="headerlink" title="计算机网络相关"></a>计算机网络相关</h2><h3 id="知识结构"><a href="#知识结构" class="headerlink" title="知识结构"></a>知识结构</h3><p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702155902.png" alt="image-20210702155855223"></p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702160902.png" alt="image-20210702160902182"></p>
<p>模块一：互联网和传输层协议</p>
<p>介绍互联网的体系和整体框架，参与的硬件设备，以及它们的作用。还会介绍传输层协议 TCP 和 UDP，重点讨论它们的工作原理、算法和优化策略。这部分知识是计算机网络的基础，也最能体现网络设计的精髓。</p>
<p>模块二：网络层协议</p>
<p>围绕局域网和 IP 协议展开，包括 ARP、IPv4、IPv6、NAT 等基本概念，探讨 IPv6 的工作原理，以及 IPv6 和 IPv4 的兼容策略。IP 协议几乎是网络层的唯一协议，是大厂面试最为热门的内容之一。模块一和模块二属于基础篇，是计算机网络最底层的基础知识。</p>
<p>模块三：网络编程</p>
<p>围绕 Socket 讨论网络编程，介绍各种网络 I/O 模型和编程方式的优缺点，并以 RPC 框架设计为题去落地学到的这些知识和实现。讨论在不同的并发量、针对不同服务特性选择不同的 I/O 模型，调整 TCP 关联的参数，等等，进而帮助你学习如何优化自己系统的网络。这部分内容会为企业带来实际价值，因此面试官会重点提问。</p>
<p>模块四：Web 技术</p>
<p>讨论平时使用最多且最重要的应用层协议——HTTP 协议（包括 HTTP 2.0），并扩大讨论范围到 Web 技术生态，比如从 DNS 看缓存、从 CDN 看负载均衡、从 HTTP 协议看开发规范、从流媒体技术看协议选择，以及从爬虫技术看网络安全。</p>
<p>模块五：网络安全</p>
<p>讨论网络安全技术，一部分是基础设施，比如证书、加解密、公私钥体系、信任链等；另一部分是具体的攻击手段，比如 DDoS、XSS、SQL 注入、ARP 攻击、中间人攻击等，以及它们的防御手段。安全是所有互联网公司的高压线，学完这块内容能够帮助你屏蔽掉一些高危操作，在工作中避免出现安全问题。</p>
<p>构成应用程序的 7 种基本元素</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702161329.png" alt="image-20210702161329164"></p>
<h3 id="什么是蜂窝移动网络？"><a href="#什么是蜂窝移动网络？" class="headerlink" title="什么是蜂窝移动网络？"></a>什么是蜂窝移动网络？</h3><p>网络的组成<br>我们习惯称今天的时代为云时代，整个世界可以看作一张巨大的、立体的网。在这个时代里产生的各种服务，就好像水和电一样，打开即用。透过这张巨大的网去观察，里面还会有一个个小型的网络。你可以想象，用无数个节点构成一个个小型网络，再用小型网络组成中型网络，再组成大型网络，以此类推，最后组成完整的一个如星河般的世界。</p>
<p>公司内网<br>如果你仔细分析一个小型网络，比如一个公司网络，就会得到下图 1 所示的结构：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702162042.png" alt="image-20210702162042395"></p>
<p>公司网络从本地网络服务提供商 （Internet Service Provider） 接入，然后内部再分成一个个子网。上图 1 中，你看到的线路，也被称作通信链路（Communication Link），用于传输网络信号。你可以观察到，有的网络节点，同时接入了 2 条以上的链路，这个时候因为路径发生了分叉，数据传输到这些节点需要选择方向，因此我们在这些节点需要进行交换（Switch）。</p>
<p>数据发生交换的时候，会先从一条链路进入交换设备，然后缓存下来，再转发（切换）到另一条路径，如下图 2 所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702162145.png" alt="image-20210702162145176"></p>
<p>交换技术的本质，就是让数据切换路径。因为，网络中的数据是以分组或封包（Packet）的形式传输，因此这个技术也称作封包交换技术（Packet Switch）。</p>
<p>比如说，你要传递一首 2Mb 的 MP3 的歌曲，歌曲本身不是一次传输完成的，而是被拆分成很多个封包。每个封包只有歌曲中的一部分数据，而封包一旦遇到岔路口，就需要封包交换技术帮助每个封包选择最合理的路径。</p>
<p>在网络中，常见的具有交换能力的设备是路由器（Router）和链路层交换机（Link-Layer Switch）。通常情况下，两个网络可以通过路由器进行连接，多台设备可以通过交换机进行连接。但是路由器通常也具有交换机的功能。</p>
<p>在上图 1 中，公司内部网络也被分成了多级子网。每个路由器、交换机构成一级子网。最高级的路由器在公司网络的边缘，它可以将网络内部节点连接到其他的网络（网络外部）。本地网络提供商（ISP）提供的互联网先到达边缘的路由器，然后再渗透到内部的网络节点。公司内部的若干服务器可以通过交换机形成一个局域网络；公司内部的办公设备，比如电脑和笔记本，也可以通过无线路由器或者交换机形成局域网络。局域网络之间，可以通过路由器、交换机进行连接，从而构成一个更大的局域网。</p>
<h4 id="移动网络"><a href="#移动网络" class="headerlink" title="移动网络"></a>移动网络</h4><p>前面我们提到，网络传输需要通信链路（Communication Link），而通信链路是一个抽象概念。这里说的抽象，就是面向对象中抽象类和继承类的关系，比如同轴电缆是通信链路，无线信号的发送接收器可以构成通信链路，蓝牙信道也可以构成通信链路。</p>
<p>在移动网络中，无线信号构成了通信链路。在移动网络的设计中，通信的核心被称作蜂窝塔（Cellular Tower），有时候也称作基站（BaseStation）。之所以有这样的名称，是因为每个蜂窝塔只覆盖一个六边形的范围，如果要覆盖一个很大的区域就需要很多的蜂窝塔（六边形）排列在一起，像极了蜜蜂的巢穴。这种六边形的结构，可以让信号无死角地覆盖。想象一下，如果是圆形结构，那么圆和圆之间就会有间隙，造成一部分无法覆盖的信号死角，而六边形就完美地解决了这个问题。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163612.png" alt="image-20210702163612575"></p>
<p>对于构成移动网络最小的网络结构——蜂窝网络来说，构造大体如图</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163639.png" alt="image-20210702163639703"></p>
<p>图 4 中，国家或全球网络提供商将网络供给处于蜂窝网络边缘的路由器，路由器连接蜂窝塔，再通过蜂窝塔（基站）提供给处于六边形地区中的设备。通常是国家级别的网络服务提供商负责部署基站，比如中国电信、中国联通。将网络提供给一个子网的行为，通常称为网络提供（Network Provider），反过来，对一个子网连接提供商的网络，称为网络接入（Network Access）。</p>
<p>随着移动网络的发展，一个蜂窝网格中的设备越来越多，也出现了基站覆盖有重叠关系的网格，如下</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163658.png" alt="image-20210702163658239"></p>
<p>这样设计的好处是，当一个基站过载、出现故障，或者用户设备周边信号出现不稳定，就可以切换到另一个基站的网络，不影响用户继续使用网络服务。</p>
<p>另一方面，在一定范围内的区域，离用户较近的地方还可以部署服务器，帮助用户完成计算。这相当于计算资源的下沉，称为边缘计算。相比中心化的计算，边缘计算延迟低、链路短，能够将更好的体验带给距离边缘计算集群最近的节点。从而让用户享受到更优质、延迟更低、算力更强的服务。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163712.png" alt="image-20210702163712545"></p>
<h4 id="家用网络"><a href="#家用网络" class="headerlink" title="家用网络"></a>家用网络</h4><p>还有一个值得讨论的是家用网络。近些年，家用联网设备越来越多。比如说冰箱、空调、扫地机器人、灯光、电动窗帘……</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210702163732.png" alt="image-20210702163732253"></p>
<p>家用网络现在已经发展成一种网格状的连接。一方面家用网络会通过路由器接入本地 ISP 提供的网络服务。另一方面，一些设备，比如电脑、笔记本、手机、冰箱等都可以直接和路由器连接。路由器也承担了链路层网关的作用，作为家用电器之间信息的交换设备。</p>
<p>还有一些家用设备，比如说 10 多块钱的灯泡，不太适合内部再嵌入一个几十块钱可以接收 WI-FI 的芯片，这个时候就可以考虑用蓝牙控制电灯。路由器提供蓝牙不现实，因此一些家用电器也承担了蓝牙设备的控制器——比如说智能音箱。上图 7 中的智能音箱把家用网络带向了一个网格状，有的设备会同时连接路由器（WI-FI）和智能音箱，这样手机和音箱都可以直接控制这些设备。这样的设计，即便网络断开，仍然可以控制这些家用设备。</p>
<p>最顶部的全球或国家大型的 ISP 之间联网，构成了网络的主干。然后区域性的 ISP 承接主干网络，在这个基础之上再向家庭和公司提供接入服务。移动蜂窝网络因为部署复杂，往往也是由大型 ISP 直接提供。</p>
<h4 id="数据的传输"><a href="#数据的传输" class="headerlink" title="数据的传输"></a>数据的传输</h4><p>上述的网络结构中，由庞大数目的个人、公司、组织、基站，形成一个个网络。在这些网络中，传递数据不是一件容易的事情。</p>
<p>为了传递数据，在网络中有几个特别重要的抽象。最终提供服务或者享受服务的设备，称为终端（Terminal），或者端系统（End System），有时候简单称为主机（Host）。比如说：电脑、手机、冰箱、汽车等，我们都可以看作是一个主机（Host）。</p>
<p>然后，我们可以把网络传输分成两类，一类是端到端（Host-to-Host）的能力，由 TCP/IP 协议群提供。还有一类是广播的能力，是一对多、多对多的能力，可以看作是端到端（Host-to-Host）能力的延伸。</p>
<p>你可以思考一下，一个北京的主机（Host）向一个深圳的主机（Host）发送消息。那么，中间会穿越大量的网络节点，这些节点可以是路由器、交换机、基站等。在发送消息的过程中，可能跨越很多网络、通过很多边缘，也可能会通过不同的网络提供商提供的网络……而且，传输过程中，可能会使用不同材质的通信链路（Communication Link），比如同轴电缆、双绞线、光纤，或者通过无线传输的 WI-FI、卫星等。</p>
<p>网络基础设施往往不能一次性传输太大的数据量，因此通常会将数据分片传输。比如传输一个 MP3，我们会将 MP3 内容切分成很多个组，每个组也称作一个封包，英文都是 Packet。这样，如果一个封包损坏，只需要重发损坏的封包，而不需要重发所有数据。你可以类比下中文的活字印刷技术。</p>
<p>另一方面，网络中两点间的路径非常多，如果一条路径阻塞了，部分封包可以考虑走其他路径。发送端将数据拆分成封包（Packet），封包在网络中遇到岔路，由交换器和路由器节点决定走向，图 9 中是对封包交换技术的一个演示。</p>
<p><img src="https://s0.lgstatic.com/i/image6/M00/38/82/Cgp9HWB5WbqAVlGaAHeNbdcL7hg030.gif" alt="Packet_Switching.gif"></p>
<h3 id="TCP-为什么握手是-3-次、挥手是-4-次？"><a href="#TCP-为什么握手是-3-次、挥手是-4-次？" class="headerlink" title="TCP 为什么握手是 3 次、挥手是 4 次？"></a>TCP 为什么握手是 3 次、挥手是 4 次？</h3><p>TCP 协议<br>要想把开篇这道面试题回答得漂亮，我们有必要先说一下概念，然后我再逐字给你解读。</p>
<p>TCP（Transport Control Protocol）是一个传输层协议，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。</p>
<p>这里面牵涉很多概念，比如主机到主机、连接、会话、双工/单工及可靠性等，接下来我会为你逐一解释。</p>
<p>主机到主机（Host-To-Host）<br>TCP 提供的是 Host-To-Host 传输，一台主机通过 TCP 发送数据给另一台主机。这里的主机（Host）是一个抽象的概念，可以是手机、平板、手表等。收发数据的设备都是主机，所以双方是平等的。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703190417.png" alt="image-20210703190410119"></p>
<p>TCP 协议往上是应用到应用（Application-To-Application）的协议。什么是应用到应用的协议呢？比如你用微信发信息给张三，你的微信客户端、微信聊天服务都是应用。微信有自己的聊天协议，微信的聊天协议是应用到应用的协议；如果微信的聊天协议想要工作，就需要一个主机到主机的协议帮助它实现通信。</p>
<p>而 TCP 上层有太多的应用，不仅仅有微信，还有原神、抖音、网易云音乐……因此 TCP 上层的应用层协议使用 TCP 能力的时候，需要告知 TCP 是哪个应用——这就是端口号。端口号用于区分应用，下文中我们还会详细讨论。</p>
<p>TCP 要实现主机到主机通信，就需要知道主机们的网络地址（IP 地址），但是 TCP 不负责实际地址到地址（Address-To-Address）的传输，因此 TCP 协议把 IP 地址给底层的互联网层处理。</p>
<p>互联网层，也叫网络层（Network Layer），提供地址到地址的通信，IP 协议就在这一层工作。互联网层解决地址到地址的通信，但是不负责信号在具体两个设备间传递。因此，网络层会调用下方的链路层在两个相邻设备间传递信息。当信号在两个设备间传递的时候，科学家又设计出了物理层封装最底层的物理设备、传输介质等，由最下方的物理层提供最底层的传输能力。</p>
<p>以上的 5 层架构，我们称为互联网协议群，也称作 TCP/IP 协议群。总结下，主机到主机（Host-To-Host）为应用提供应用间通信的能力。</p>
<p>什么是连接和会话？<br>下一个关联的概念是连接（Connection）——连接是数据传输双方的契约。</p>
<p>连接是通信双方的一个约定，目标是让两个在通信的程序之间产生一个默契，保证两个程序都在线，而且尽快地响应对方的请求，这就是连接（Connection）。</p>
<p>设计上，连接是一种传输数据的行为。传输之前，建立一个连接。具体来说，数据收发双方的内存中都建立一个用于维护数据传输状态的对象，比如双方 IP 和端口是多少？现在发送了多少数据了？状态健康吗？传输速度如何？等。所以，连接是网络行为状态的记录。</p>
<p>和连接关联的还有一个名词，叫作会话（Session），会话是应用的行为。比如微信里张三和你聊天，那么张三和你建立一个会话。你要和张三聊天，你们创建一个聊天窗口，这个就是会话。你开始 Typing，开始传输数据，你和微信服务器间建立一个连接。如果你们聊一段时间，各自休息了，约定先不要关微信，1 个小时后再回来。那么连接会断开，因为聊天窗口没关，所以会话还在。</p>
<p>在有些系统设计中，会话会自动重连（也就是重新创建连接），或者帮助创建连接。 此外，会话也负责在多次连接中保存状态，比如 HTTP Session 在多次 HTTP 请求（连接）间保持状态（如用户信息）。</p>
<p>总结下，会话是应用层的概念，连接是传输层的概念。</p>
<p>双工/单工问题<br>接下来我们聊聊什么是双工/单工。</p>
<p>在任何一个时刻，如果数据只能单向发送，就是单工，所以单工需要至少一条线路。如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。最后，如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。当然这里的线路，是一个抽象概念，你可以并发地处理信号，达到模拟双工的目的。</p>
<p>TCP 是一个双工协议，数据任何时候都可以双向传输。这就意味着客户端和服务端可以平等地发送、接收信息。正因为如此，客户端和服务端在 TCP 协议中有一个平等的名词——Host（主机）。</p>
<p>什么是可靠性？<br>上文提到 TCP 提供可靠性，那么可靠性是什么？</p>
<p>可靠性指数据保证无损传输。如果发送方按照顺序发送，然后数据无序地在网络间传递，就必须有一种算法在接收方将数据恢复原有的顺序。另外，如果发送方同时要把消息发送给多个接收方，这种情况叫作多播，可靠性要求每个接收方都无损收到相同的副本。多播情况还有强可靠性，就是如果有一个消息到达任何一个接收者，那么所有接受者都必须收到这个消息。说明一下，本专栏中，我们都是基于单播讨论可靠性。</p>
<p>TCP 的握手和挥手<br>TCP 是一个连接导向的协议，设计有建立连接（握手）和断开连接（挥手）的过程。TCP 没有设计会话（Session），因为会话通常是一个应用的行为。</p>
<p>TCP 协议的基本操作<br>TCP 协议有这样几个基本操作：</p>
<p>如果一个 Host 主动向另一个 Host 发起连接，称为 SYN（Synchronization），请求同步；</p>
<p>如果一个 Host 主动断开请求，称为 FIN（Finish），请求完成；</p>
<p>如果一个 Host 给另一个 Host 发送数据，称为 PSH（Push），数据推送。</p>
<p>以上 3 种情况，接收方收到数据后，都需要给发送方一个 ACK（Acknowledgement）响应。请求/响应的模型是可靠性的要求，如果一个请求没有响应，发送方可能会认为自己需要重发这个请求。</p>
<p>建立连接的过程（三次握手）<br>因为要保持连接和可靠性约束，TCP 协议要保证每一条发出的数据必须给返回，返回数据叫作 ACK（也就是响应）。</p>
<p>按照这个思路，你可以看看建立连接是不是需要 3 次握手：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703190820.png" alt="image-20210703190819940"></p>
<p>客户端发消息给服务端（SYN）</p>
<p>服务端准备好进行连接</p>
<p>服务端针对客户端的 SYN 给一个 ACK</p>
<p>你可以能会问，到这里不就可以了吗？2 次握手就足够了。但其实不是，因为服务端还没有确定客户端是否准备好了。比如步骤 3 之后，服务端马上给客户端发送数据，这个时候客户端可能还没有准备好接收数据。因此还需要增加一个过程。</p>
<p>接下来还会发生以下操作：</p>
<p>服务端发送一个 SYN 给客户端</p>
<p>客户端准备就绪</p>
<p>客户端给服务端发送一个 ACK</p>
<p>你可能会问，上面不是 6 个步骤吗？ 怎么是 3 次握手呢？下面我们一起分析一下其中缘由。</p>
<p>步骤 1 是 1 次握手；</p>
<p>步骤 2 是服务端的准备，不是数据传输，因此不算握手；</p>
<p>步骤 3 和步骤 4，因为是同时发生的，可以合并成一个 SYN-ACK 响应，作为一条数据传递给客户端，因此是第 2 次握手；</p>
<p>步骤 5 不算握手；</p>
<p>步骤 6 是第 3 次握手。</p>
<p>为了方便你理解步骤 3 和步骤 4，这里我画了一张图。可以看到下图中 SYN 和 ACK 被合并了，因此建立连接一共需要 3 次握手，过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703190919.png" alt="image-20210703190919804"></p>
<p>从上面的例子中，你可以进一步思考 SYN、ACK、PSH 这些常见的标识位（Flag）在传输中如何表示。</p>
<p>一种思路是为 TCP 协议增加协议头。在协议头中取多个位（bit），其中 SYN、ACK、PSH 都占有 1 个位。比如 SYN 位，1 表示 SYN 开启，0 表示关闭。因此，SYN-ACK 就是 SYN 位和 ACK 位都置 1。这种设计，我们也称为标识（Flag）。标识位是放在 TCP 头部的，关于标识位和 TCP 头的内容，我会在“04 | TCP 的稳定性：滑动窗口和流速控制是怎么回事？”中详细介绍。</p>
<h4 id="断开连接的过程（4-次挥手）"><a href="#断开连接的过程（4-次挥手）" class="headerlink" title="断开连接的过程（4 次挥手）"></a>断开连接的过程（4 次挥手）</h4><p>继续上面的思路，如果断开连接需要几次握手？给你一些提示，你可以在脑海中这样构思。</p>
<p>客户端要求断开连接，发送一个断开的请求，这个叫作（FIN）。</p>
<p>服务端收到请求，然后给客户端一个 ACK，作为 FIN 的响应。</p>
<p>这里你需要思考一个问题，可不可以像握手那样马上传 FIN 回去？<br>其实这个时候服务端不能马上传 FIN，因为断开连接要处理的问题比较多，比如说服务端可能还有发送出去的消息没有得到 ACK；也有可能服务端自己有资源要释放。因此断开连接不能像握手那样操作——将两条消息合并。所以，服务端经过一个等待，确定可以关闭连接了，再发一条 FIN 给客户端。</p>
<p>客户端收到服务端的 FIN，同时客户端也可能有自己的事情需要处理完，比如客户端有发送给服务端没有收到 ACK 的请求，客户端自己处理完成后，再给服务端发送一个 ACK。</p>
<p>经过以上分析，就可以回答上面这个问题了。是不是刚刚好 4 次挥手？过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191322.png" alt="image-20210703191322634"></p>
<p>总结<br>在学习 3 次握手、4 次挥手时，你一定要理解为什么这么设计，而不是死记硬背。最后。我们一起总结一下今天的重点知识。</p>
<p>TCP 提供连接（Connection），让双方的传输更加稳定、安全。</p>
<p>TCP 没有直接提供会话，因为应用对会话的需求多种多样，比如聊天程序会话在保持双方的聊天记录，电商程序会话在保持购物车、订单一致，所以会话通常在 TCP 连接上进一步封装，在应用层提供。</p>
<p>TCP 是一个面向连接的协议（Connection -oriented Protocol），说的就是 TCP 协议参与的双方（Host）在收发数据之前会先建立连接。后面我们还会学习 UDP 协议，UDP 是一个面向报文（Datagram-oriented）的协议——协议双方不需要建立连接，直接传送报文（数据）。</p>
<p>最后，连接需要消耗更多的资源。比如说，在传输数据前，必须先协商建立连接。因此，不是每种场景都应该用连接导向的协议。像视频播放的场景，如果使用连接导向的协议，服务端每向客户端推送一帧视频，客户端都要给服务端一次响应，这是不合理的。</p>
<p>TCP 为什么是 3 次握手，4 次挥手？</p>
<p>【解析】TCP 是一个双工协议，为了让双方都保证，建立连接的时候，连接双方都需要向对方发送 SYC（同步请求）和 ACK（响应）。</p>
<p>握手阶段双方都没有烦琐的工作，因此一方向另一方发起同步（SYN）之后，另一方可以将自己的 ACK 和 SYN 打包作为一条消息回复，因此是 3 次握手——需要 3 次数据传输。</p>
<p>到了挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上响应（ACK），表示接收到了挥手请求。类比现实世界中，你收到一个 Offer，出于礼貌你先回复考虑一下，然后思考一段时间再回复 HR 最后的结果。最后等所有工作结束，再发送请求中断连接（FIN），因此是 4 次挥手。</p>
<h4 id="一台内存在-8G-左右的服务器，可以同时维护多少个连接？"><a href="#一台内存在-8G-左右的服务器，可以同时维护多少个连接？" class="headerlink" title="一台内存在 8G 左右的服务器，可以同时维护多少个连接？"></a>一台内存在 8G 左右的服务器，可以同时维护多少个连接？</h4><blockquote>
<p>tcp连接数上限其实受限于机器的内存，以8G内存为例，假设一个tcp连接需要占用的最小内存是8k（发送接收缓存各4k，当然还要考虑socket描述符），那么最大连接数为：8<em>1024</em>1024/8=1048576个，即约100万个tcp长连接。不过这只是理论数值，并未考虑实际业务。</p>
</blockquote>
<blockquote>
<p>http为什么是单工，ws是双工？</p>
<p>http应用层设计就请求/响应模型。这个模型比较好理解，或者说符合用户打开一次浏览器，开一张页面的逻辑。ws应用层设计是聊天用的，当然就得是双工。是需求解决的了最终的选择，而不能反过来思考。</p>
</blockquote>
<h3 id="TCP-为什么要粘包和拆包？"><a href="#TCP-为什么要粘包和拆包？" class="headerlink" title="TCP 为什么要粘包和拆包？"></a>TCP 为什么要粘包和拆包？</h3><p>如今，大半个互联网都建立在 TCP 协议之上，我们使用的 HTTP 协议、消息队列、存储、缓存，都需要用到 TCP 协议——这是因为 TCP 协议提供了可靠性。简单来说，可靠性就是让数据无损送达。但若是考虑到成本，就会变得非常复杂——因为还需要尽可能地提升吞吐量、降低延迟、减少丢包率。</p>
<p>TCP 协议具有很强的实用性，而可靠性又是 TCP 最核心的能力，所以理所当然成为面试官们津津乐道的问题。具体来说，从一个终端有序地发出多个数据包，经过一个复杂的网络环境，到达目的地的时候会变得无序，而可靠性要求数据恢复到原始的顺序。这里我先给你提出两个问题：</p>
<p>TCP 协议是如何恢复数据的顺序的？</p>
<p>拆包和粘包的作用是什么？</p>
<p>下面请你带着这两个问题开始今天的学习。</p>
<p>TCP 的拆包和粘包<br>TCP 是一个传输层协议。TCP 发送数据的时候，往往不会将数据一次性发送，像下图这样：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191719.png" alt="image-20210703191719119"></p>
<p>而是将数据拆分成很多个部分，然后再逐个发送。像下图这样：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191730.png" alt="image-20210703191730616"></p>
<p>同样的，在目的地，TCP 协议又需要逐个接收数据。请你思考，TCP 为什么不一次发送完所有的数据？比如我们要传一个大小为 10M 的文件，对于应用层而言，就是一次传送完成的。而传输层的协议为什么不选择将这个文件一次发送完呢？</p>
<p>这里有很多原因，比如为了稳定性，一次发送的数据越多，出错的概率越大。再比如说为了效率，网络中有时候存在着并行的路径，拆分数据包就能更好地利用这些并行的路径。再有，比如发送和接收数据的时候，都存在着缓冲区。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703191833.png" alt="image-20210703191833025"></p>
<p>缓冲区是在内存中开辟的一块区域，目的是缓冲。因为大量的应用频繁地通过网卡收发数据，这个时候，网卡只能一个一个处理应用的请求。当网卡忙不过来的时候，数据就需要排队，也就是将数据放入缓冲区。如果每个应用都随意发送很大的数据，可能导致其他应用实时性遭到破坏。</p>
<p>还有一些原因我们在《重学操作系统》专栏的“24 | 虚拟内存 ：一个程序最多能使用多少内存？”中讨论过。比如内存的最小分配单位是页表，如果数据的大小超过一个页表，可能会存在页面置换问题，造成性能的损失。如果你对这一部分的知识感兴趣，可以学习我在拉勾教育推出的《重学操作系统》专栏。</p>
<p>总之，方方面面的原因：在传输层封包不能太大。这种限制，往往是以缓冲区大小为单位的。也就是 TCP 协议，会将数据拆分成不超过缓冲区大小的一个个部分。每个部分有一个独特的名词，叫作 TCP 段（TCP Segment）。</p>
<p>在接收数据的时候，一个个 TCP 段又被重组成原来的数据。</p>
<p>像这样，数据经过拆分，然后传输，然后在目的地重组，俗称拆包。所以拆包是将数据拆分成多个 TCP 段传输。那么粘包是什么呢？有时候，如果发往一个目的地的多个数据太小了，为了防止多次发送占用资源，TCP 协议有可能将它们合并成一个 TCP 段发送，在目的地再还原成多个数据，这个过程俗称粘包。所以粘包是将多个数据合并成一个 TCP 段发送。</p>
<p>TCP Segment<br>那么一个 TCP 段长什么样子呢？下图是一个 TCP 段的格式：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703192001.png" alt="image-20210703192000920"></p>
<p>我们可以看到，TCP 的很多配置选项和数据粘在了一起，作为一个 TCP 段。</p>
<p>显然，让你把每一部分都记住似乎不太现实，但是我会带你把其中最主要的部分理解。TCP 协议就是依靠每一个 TCP 段工作的，所以你每认识一个 TCP 的能力，几乎都会找到在 TCP Segment 中与之对应的字段。接下来我先带你认识下它们。</p>
<p>Source Port/Destination Port 描述的是发送端口号和目标端口号，代表发送数据的应用程序和接收数据的应用程序。比如 80 往往代表 HTTP 服务，22 往往是 SSH 服务……</p>
<p>Sequence Number 和 Achnowledgment Number 是保证可靠性的两个关键。具体见下文的讨论。</p>
<p>Data Offset 是一个偏移量。这个量存在的原因是 TCP Header 部分的长度是可变的，因此需要一个数值来描述数据从哪个字节开始。</p>
<p>Reserved 是很多协议设计会保留的一个区域，用于日后扩展能力。</p>
<p>URG/ACK/PSH/RST/SYN/FIN 是几个标志位，用于描述 TCP 段的行为。也就是一个 TCP 封包到底是做什么用的？</p>
<p>1）URG 代表这是一个紧急数据，比如远程操作的时候，用户按下了 Ctrl+C，要求终止程序，这种请求需要紧急处理。</p>
<p>2）ACK 代表响应，我们在“02 | 传输层协议 TCP：TCP 为什么握手是 3 次、挥手是 4 次？”讲到过，所有的消息都必须有 ACK，这是 TCP 协议确保稳定性的一环。</p>
<p>3）PSH 代表数据推送，也就是在传输数据的意思。</p>
<p>4）SYN 同步请求，也就是申请握手。</p>
<p>5）FIN 终止请求，也就是挥手。</p>
<p>特别说明一下：以上这 5 个标志位，每个占了一个比特，可以混合使用。比如 ACK 和 SYN 同时为 1，代表同步请求和响应被合并了。这也是 TCP 协议，为什么是三次握手的原因之一。</p>
<p>6） Window 也是 TCP 保证稳定性并进行流量控制的工具，我们会在“04 | TCP 的稳定性：滑动窗口和流速控制是怎么回事？”中详细介绍。</p>
<p>7）Checksum 是校验和，用于校验 TCP 段有没有损坏。</p>
<p>8）Urgent Pointer 指向最后一个紧急数据的序号（Sequence Number）。它存在的原因是：有时候紧急数据是连续的很多个段，所以需要提前告诉接收方进行准备。</p>
<p>9）Options 中存储了一些可选字段，比如接下来我们要讨论的 MSS（Maximun Segment Size）。<br>10）Padding 存在的意义是因为 Options 的长度不固定，需要 Pading 进行对齐。</p>
<h4 id="Sequence-Number-和-Acknowledgement-Number"><a href="#Sequence-Number-和-Acknowledgement-Number" class="headerlink" title="Sequence Number 和 Acknowledgement Number"></a>Sequence Number 和 Acknowledgement Number</h4><p>在 TCP 协议的设计当中，数据被拆分成很多个部分，部分增加了协议头。合并成为一个 TCP 段，进行传输。这个过程，我们俗称拆包。这些 TCP 段经过复杂的网络结构，由底层的 IP 协议，负责传输到目的地，然后再进行重组。</p>
<p>这里请你思考一个问题：稳定性要求数据无损地传输，也就是说拆包获得数据，又需要恢复到原来的样子。而在复杂的网络环境当中，即便所有的段是顺序发出的，也不能保证它们顺序到达，因此，发出的每一个 TCP 段都需要有序号。这个序号，就是 Sequence Number（Seq）。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703192457.png" alt="image-20210703192457555"></p>
<p>如上图所示。发送数据的时候，为每一个 TCP 段分配一个自增的 Sequence Number。接收数据的时候，虽然得到的是乱序的 TCP 段，但是可以通过 Seq 进行排序。</p>
<p>但是这样又会产生一个新的问题——接收方如果要回复发送方，也需要这个 Seq。而网络的两个终端，去同步一个自增的序号是非常困难的。因为任何两个网络主体间，时间都不能做到完全同步，又没有公共的存储空间，无法共享数据，更别说实现一个分布式的自增序号了。</p>
<p>其实这个问题的本质就好像两个人在说话一样，我们要确保他们说出去的话，和回答之间的顺序。因为 TCP 是一个双工的协议，两边可能会同时说话。所以聪明的科学家想到了确定一句话的顺序，需要两个值去描述——也就是发送的字节数和接收的字节数。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210703211701.png" alt="image-20210703211701115"></p>
<p>我们重新定义一下 Seq（如上图所示），对于任何一个接收方，如果知道了发送者发送某个 TCP 段时，已经发送了多少字节的数据，那么就可以确定发送者发送数据的顺序。</p>
<p>但是这里有一个问题。如果接收方也向发送者发送了数据请求（或者说双方在对话），接收方就不知道发送者发送的数据到底对应哪一条自己发送的数据了。</p>
<p>举个例子：下面 A 和 B 的对话中，我们可以确定他们彼此之间接收数据的顺序。但是无法确定数据之间的关联关系，所以只有 Sequence Number 是不够的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A：今天天气好吗？</span><br><span class="line"></span><br><span class="line">A：今天你开心吗？</span><br><span class="line"></span><br><span class="line">B：开心</span><br><span class="line"></span><br><span class="line">B：天气不好</span><br></pre></td></tr></table></figure>

<p>人类很容易理解这几句话的顺序，但是对于机器来说就需要特别的标注。因此我们还需要另一个数据，就是每个 TCP 段发送时，发送方已经接收了多少数据。用 Acknowledgement Number 表示，下面简写为 ACK。</p>
<p>下图中，终端发送了三条数据，并且接收到四条数据，通过观察，根据接收到的数据中的 Seq 和 ACK，将发送和接收的数据进行排序。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210705220326.png" alt="image-20210705220326603"></p>
<p>例如上图中，发送方发送了 100 字节的数据，而接收到的（Seq = 0 和 Seq =100）的两个封包，都是针对发送方（Seq = 0）这个封包的。发送 100 个字节，所以接收到的 ACK 刚好是 100。说明（Seq= 0 和 Seq= 100）这两个封包是针对接收到第 100 个字节数据后，发送回来的。这样就确定了整体的顺序。</p>
<p><strong>注意，无论 S\</strong>**eq**<em>\</em> 还是 ACK，都是针对“对方”而言的。是对方发送的数据和对方接收到的数据**。我们在实际的工作当中，可以通过 Whireshark 调试工具观察两个 TCP 连接的 Seq和 ACK。</p>
<p>具体的使用方法，我会在“09 | TCP 实战：如何进行 TCP 抓包调试？”中和你讨论。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210705220350.png" alt="image-20210705220349944"></p>
<h4 id="MSS（Maximun-Segment-Size）"><a href="#MSS（Maximun-Segment-Size）" class="headerlink" title="MSS（Maximun Segment Size）"></a>MSS（Maximun Segment Size）</h4><p>接下来，我们讨论下 MSS，它也是面试经常会问到的一个 TCP Header 中的可选项（Options），这个可选项控制了 TCP 段的大小，它是一个协商字段（Negotiate）。协议是双方都要遵循的标准，因此配置往往不能由单方决定，需要双方协商。</p>
<p>TCP 段的大小（MSS）涉及发送、接收缓冲区的大小设置，双方实际发送接收封包的大小，对拆包和粘包的过程有指导作用，因此需要双方去协商。</p>
<p>如果这个字段设置得非常大，就会带来一些影响。</p>
<p>首先对方可能会拒绝，作为服务的提供方，你可能不会愿意接收太大的 TCP 段。<strong>因为大的 TCP 段，会降低性能，比如内存使用的性能</strong>。具体你可以参考<a href="https://shenceyun.lagou.com/t/Axo?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">《重学操作系统》</a>课程中关于页表的讨论。</p>
<ul>
<li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4633&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">24 | 虚拟内存 ：一个程序最多能使用多少内存？</a></li>
<li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4634&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">25 | 内存管理单元： 什么情况下使用大内存分页？</a></li>
<li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4635&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">26 | 缓存置换算法： LRU 用什么数据结构实现更合理？</a></li>
</ul>
<p>还有就是<strong>资源的占用</strong>。一个用户占用服务器太多的资源，意味着其他的用户就需要等待或者降低他们的服务质量。</p>
<p><strong>其次，支持 TCP 协议工作的 IP 协议，工作效率会下降</strong>。TCP 协议不肯拆包，IP 协议就需要拆出大量的包。那么 IP 协议为什么需要拆包呢？这是因为在网络中，每次能够传输的数据不可能太大，这受限于具体的网络传输设备，也就是物理特性。但是 IP 协议，拆分太多的封包并没有意义。因为可能会导致属于同个 TCP 段的封包被不同的网络路线传输，这会加大延迟。同时，拆包，还需要消耗硬件和计算资源。</p>
<p>那是不是 MSS 越小越好呢？MSS 太小的情况下，会浪费传输资源（降低吞吐量）。因为数据被拆分之后，每一份数据都要增加一个头部。如果 MSS 太小，那头部的数据占比会上升，这让吞吐量成为一个灾难。<strong>所以在使用的过程当中，MSS 的配置，往往都是一个折中的方案</strong>。而根据 Unix 的哲学，不要去猜想什么样的方案是最合理的，而是要尝试去用实验证明它，一切都要用实验依据说话。</p>
<h4 id="TCP-协议是如何恢复数据的顺序的，TCP-拆包和粘包的作用是什么？"><a href="#TCP-协议是如何恢复数据的顺序的，TCP-拆包和粘包的作用是什么？" class="headerlink" title="TCP 协议是如何恢复数据的顺序的，TCP 拆包和粘包的作用是什么？"></a><strong>TCP 协议是如何恢复数据的顺序的，TCP 拆包和粘包的作用是什么</strong>？</h4><p>TCP 拆包的作用是将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力。拆包过程需要保证数据经过网络的传输，又能恢复到原始的顺序。这中间，需要数学提供保证顺序的理论依据。TCP 利用（发送字节数、接收字节数）的唯一性来确定封包之间的顺序关系。具体的算法，我们会在下一讲“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=837#/detail/pc?id=7268" target="_blank" rel="noopener">04 | TCP 的稳定性解决方案 ：滑动窗口和流量控制是怎么回事？</a>”中给出。粘包是为了防止数据量过小，导致大量的传输，而将多个 TCP 段合并成一个发送。</p>
<h3 id="滑动窗口和流速控制是怎么回事？"><a href="#滑动窗口和流速控制是怎么回事？" class="headerlink" title="滑动窗口和流速控制是怎么回事？"></a><strong>滑动窗口和流速控制是怎么回事？</strong></h3><p><strong>TCP 作为一个传输层协议，最核心的能力是传输。传输需要保证可靠性，还需要控制流速，这两个核心能力均由滑动窗口提供</strong>。而滑动窗口中解决的问题，是你在今后的工作中可以长期使用的，比如设计一个分布式的 RPC 框架、实现一个消息队列或者分布式的文件系统等。</p>
<p>所以请你带着今天的问题“<strong>滑动窗口和流速控制是怎么回事？</strong>”开始今天的学习吧！</p>
<h4 id="请求-响应模型"><a href="#请求-响应模型" class="headerlink" title="请求/响应模型"></a>请求/响应模型</h4><p>TCP 中每个发送的请求都需要响应。如果一个请求没有收到响应，发送方就会认为这次发送出现了故障，会触发重发。</p>
<p>大体的模型，和下图很像。但是如果完全和下图一样，每一个请求收到响应之后，再发送下一个请求，吞吐量会很低。因为这样的设计，会产生网络的空闲时间，说白了，就是浪费带宽。带宽没有用满，意味着可以同时发送更多的请求，接收更多的响应。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104250.png" alt="image-20210706104250605"></p>
<p>一种改进的方式，就是让发送方有请求就发送出去，而不是等待响应。通过这样的处理方式，发送的数据连在了一起，响应的数据也连在了一起，吞吐量就提升了。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104304.png" alt="image-20210706104304375"></p>
<p>但是如果可以同时发送的数据真的非常多呢？比如成百上千个 TCP 段都需要发送，这个时候带宽可能会不足。很多个数据封包都需要发送，该如何处理呢？</p>
<h4 id="排队（Queuing）"><a href="#排队（Queuing）" class="headerlink" title="排队（Queuing）"></a>排队（Queuing）</h4><p>在这种情况下，通常我们会考虑<strong>排队（Queuing）机制</strong>。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104409.png" alt="image-20210706104408978"></p>
<p>考虑这样一个模型，如上图所示，在 TCP 层实现一个队列。新元素从队列的一端（左侧）排队，作为一个未发送的数据封包。开始发送的数据封包，从队列的右侧离开。你可以思考一下，这个模型有什么问题吗？</p>
<p>这样做就需要多个队列，我们要将未发送的数据从队列中取出，加入发送中的队列。然后再将发送中的数据，收到 ACK 的部分取出，放入已接收的队列。而发送中的封包，何时收到 ACK 是一件不确定的事情，这样使用队列似乎也有一定的问题。</p>
<h4 id="滑动窗口（Sliding-Window）"><a href="#滑动窗口（Sliding-Window）" class="headerlink" title="滑动窗口（Sliding Window）"></a>滑动窗口（Sliding Window）</h4><p>在上面的模型当中，我们之所以觉得算法不好设计，是因为用错了数据结构。有个说法叫作如果程序写复杂了，那就是写错了。这里其实应该用一种叫作<strong>滑动窗口的数据结构</strong>去实现。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104440.png" alt="image-20210706104440133"></p>
<p>如上图所示：</p>
<ul>
<li>深绿色代表已经收到 ACK 的段</li>
<li>浅绿色代表发送了，但是没有收到 ACK 的段</li>
<li>白色代表没有发送的段</li>
<li>紫色代表暂时不能发送的段</li>
</ul>
<p>下面我们重新设计一下不同类型封包的顺序，将已发送的数据放到最左边，发送中的数据放到中间，未发送的数据放到右边。假设我们最多同时发送 5 个封包，也就是窗口大小 = 5。窗口中的数据被同时发送出去，然后等待 ACK。如果一个封包 ACK 到达，我们就将它标记为已接收（深绿色）。</p>
<p>如下图所示，有两个封包的 ACK 到达，因此标记为绿色。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104531.png" alt="image-20210706104531057"></p>
<p>这个时候滑动窗口可以向右滑动，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104544.png" alt="image-20210706104544432"></p>
<h4 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h4><p>如果发送过程中，部分数据没能收到 ACK 会怎样呢？这就可能发生重传。</p>
<p>如果发生下图这样的情况，段 4 迟迟没有收到 ACK。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104643.png" alt="image-20210706104643825"></p>
<p>这个时候滑动窗口只能右移一个位置，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210706104659.png" alt="image-20210706104659658"></p>
<p>在这个过程中，如果后来段 4 重传成功（接收到 ACK），那么窗口就会继续右移。如果段 4 发送失败，还是没能收到 ACK，那么接收方也会抛弃段 5、段 6、段 7。这样从段 4 开始之后的数据都需要重发。</p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>在 TCP 协议中，如果接收方想丢弃某个段，可以选择不发 ACK。发送端超时后，会重发这个 TCP 段。而有时候，接收方希望催促发送方尽快补发某个 TCP 段，这个时候可以使用<strong>快速重传</strong>能力。</p>
<p>例如段 1、段 2、段 4 到了，但是段 3 没有到。 接收方可以发送多次段 3 的 ACK。如果发送方收到多个段 3 的 ACK，就会重发段 3。这个机制称为<strong>快速重传</strong>。这和超时重发不同，是一种催促的机制。</p>
<p>为了不让发送方误以为段 3 已经收到了，在快速重传的情况下，接收方即便收到发来的段 4，依然会发段 3 的 ACK（不发段 4 的 ACK），直到发送方把段 3 重传。</p>
<h4 id="窗口大小的单位是？"><a href="#窗口大小的单位是？" class="headerlink" title="窗口大小的单位是？"></a>窗口大小的单位是？</h4><p>请你思考另一个问题，窗口大小的单位是多少呢？在上面所有的图片中，窗口大小是 TCP 段的数量。<strong>实际操作中，每个 TCP 段的大小不同，限制数量会让接收方的缓冲区不好操作，因此实际操作中窗口大小单位是字节数</strong>。</p>
<h4 id="流速控制"><a href="#流速控制" class="headerlink" title="流速控制"></a>流速控制</h4><p><strong>发送、接收窗口的大小可以用来控制 TCP 协议的流速</strong>。窗口越大，同时可以发送、接收的数据就越多，支持的吞吐量也就越大。当然，窗口越大，如果数据发生错误，损失也就越大，因为需要重传越多的数据。</p>
<p>举个例子：我们用 RTT 表示 Round Trip Time，就是消息一去一回的时间。</p>
<p>假设 RTT = 1ms，带宽是 1mb/s。如果窗口大小为 1kb，那么 1ms 可以发送一个 1kb 的数据（含 TCP 头），1s 就可以发送 1mb 的数据，刚好可以将带宽用满。如果 RTT 再慢一些，比如 RTT = 10ms，那么这样的设计就只能用完 1/10 的带宽。 当然你可以提高窗口大小提高吞吐量，但是实际的模型会比这个复杂，因为还存在重传、快速重传、丢包等因素。</p>
<p>而实际操作中，也不可以真的把带宽用完，所以最终我们会使用折中的方案，在延迟、丢包率、吞吐量中进行选择，毕竟鱼和熊掌不可兼得。</p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>为了提高传输速率，TCP 协议选择将多个段同时发送，为了让这些段不至于被接收方拒绝服务，在发送前，双方要协商好发送的速率。但是我们不可能完全确定网速，所以协商的方式，就变成确定窗口大小。</p>
<p>有了窗口，发送方利用滑动窗口算法发送消息；接收方构造缓冲区接收消息，并给发送方 ACK。滑动窗口的实现只需要数组和少量的指针即可，是一个非常高效的算法。像这种算法，简单又实用，比如求一个数组中最大的连续 k 项和，就可以使用滑动窗口算法。如果你对这个问题感兴趣，不妨用你最熟悉的语言尝试解决一下。</p>
<p><strong>滑动窗口和流速控制是怎么回事</strong>？</p>
<p><strong>滑动窗口是 TCP 协议控制可靠性的核心</strong>。发送方将数据拆包，变成多个分组。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出（FIFO）的顺序，但是窗口中的分组会一次性发送。窗口中序号最小的分组如果收到 ACK，窗口就会发生滑动；如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送。</p>
<p>另一方面，在多次传输中，网络的平均延迟往往是相对固定的，这样 TCP 协议可以通过双方协商窗口大小控制流速。补充下，上面我们说的分组和 TCP 段是一个意思。</p>
<h3 id="TCP-协议和-UDP-协议的优势和劣势？"><a href="#TCP-协议和-UDP-协议的优势和劣势？" class="headerlink" title="TCP 协议和 UDP 协议的优势和劣势？"></a><strong>TCP 协议和 UDP 协议的优势和劣势？</strong></h3><p>TCP 和 UDP 是今天应用最广泛的传输层协议，拥有最核心的垄断地位。<strong>TCP 最核心的价值是提供了可靠性，而 UDP 最核心的价值是灵活，你几乎可以用它来做任何事情</strong>。例如：HTTP 协议 1.1 和 2.0 都基于 TCP，而到了 HTTP 3.0 就开始用 UDP 了。</p>
<p>如果你打开 <a href="https://tools.ietf.org/html/rfc793?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">TCP 协议的 RFC</a><a href="https://tools.ietf.org/html/rfc793?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">文档</a>，可以看到目录中一共有 85 页；如果你打开 <a href="https://tools.ietf.org/html/rfc768?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">UDP 的 RFC 文档</a>，会看到目录中只有 3 页。一个只有 3 页的协议，能够成为今天最主流的传输层协议之一，那么它一定有非常值得我们学习的地方。</p>
<h4 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h4><p>UDP（User Datagram Protocol），目标是在传输层提供直接发送报文（Datagram）的能力。Datagram 是数据传输的最小单位。UDP 协议不会帮助拆分数据，它的目标只有一个，就是发送报文。</p>
<p>有细心的同学可能会问： 为什么不直接调用 IP 协议呢？ 如果裸发数据，IP 协议不香吗？</p>
<p>这是因为传输层协议在承接上方应用层的调用，需要提供应用到应用的通信——因此要附上端口号。每个端口，代表不同的应用。传输层下层的 IP 协议，承接传输层的调用，将数据从主机传输到主机。IP 层不能区分应用，导致哪怕是在 IP 协议上进行简单封装，也需要单独一个协议。这就构成了 UDP 协议的市场空间。</p>
<h4 id="UDP-的封包格式"><a href="#UDP-的封包格式" class="headerlink" title="UDP 的封包格式"></a>UDP 的封包格式</h4><p>UDP 的设计目标就是在允许用户直接发送报文的情况下，最大限度地简化应用的设计。下图是 UDP 的报文格式。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802114305.png" alt="image-20210802114257947"></p>
<p>你可以看到，UDP 的报文非常简化，只有 5 个部分。</p>
<p>Source Port 是源端口号。因为 UDP 协议的特性（不需要 ACK），因此这个字段是可以省略的。但有时候对于防火墙、代理来说，Source Port 有很重要的意义，它们需要用这个字段行过滤和路由。</p>
<p>Destination Port 是目标端口号（这个字段不可以省略）。</p>
<p>Length 是消息体长度。</p>
<p>Checksum 是校验和，作用是检查封包是否出错。</p>
<p>Data octets 就是一个字节一个字节的数据，Octet 是 8 位。</p>
<p>下面我们先简单聊聊校验和（Checksum）机制，这个机制在很多的网络协议中都会存在，因为校验数据在传输过程中有没有丢失、损坏是一个普遍需求。在一次网络会话中，我们传输的内容可能是：“你好！”，但事实上传输的是 01 组成的二进制。请你思考这样一个算法，我们把数据分成一个一个 byte，然后将所有 byte 相加，再将最终的结果取反。</p>
<p>比如现在数据有 4 个 byte：a,b,c,d，那么一种最简单的校验和就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksum=(a+b+c+d) ^ 0xff</span><br></pre></td></tr></table></figure>

<p>如果发送方用上述方式计算出 Checksum，并将 a,b,c,d 和 Checksum 一起发送给接收方，接收方就可以用同样的算法再计算一遍，这样就可以确定数据有没有发生损坏（变化）。当然 Checksum 的做法，只适用于数据发生少量变化的情况。如果数据发生较大的变动，校验和也可能发生碰撞。</p>
<p>你可以看到 UDP 的可靠性保证仅仅就是 Checksum 一种。如果一个数据封包 Datagram 发生了数据损坏，UDP 可以通过 Checksum 纠错或者修复。 但是 UDP 没有提供再多的任何机制，比如 ACK、顺序保证以及流控等。</p>
<h4 id="UDP-与-TCP的区别"><a href="#UDP-与-TCP的区别" class="headerlink" title="UDP 与 TCP的区别"></a>UDP 与 TCP的区别</h4><p>接下来我们说说 UDP 和 TCP 的区别。</p>
<ol>
<li><p>目的差异<br>首先，这两个协议的目的不同：TCP 协议的核心目标是提供可靠的网络传输，而 UDP 的目标是在提供报文交换能力基础上尽可能地简化协议轻装上阵。</p>
</li>
<li><p>可靠性差异<br>TCP 核心是要在保证可靠性提供更好的服务。TCP 会有握手的过程，需要建立连接，保证双方同时在线。而且TCP 有时间窗口持续收集无序的数据，直到这一批数据都可以合理地排序组成连续的结果。</p>
</li>
</ol>
<p>UDP 并不具备以上这些特性，它只管发送数据封包，而且 UDP 不需要 ACK，这意味着消息发送出去成功与否 UDP 是不管的。</p>
<ol start="3">
<li><p>连接 vs 无连接<br>TCP 是一个面向连接的协议（Connection-oriented Protocol），传输数据必须先建立连接。 UDP 是一个无连接协议（Connection-less Protocol），数据随时都可以发送，只提供发送封包（Datagram）的能力。</p>
</li>
<li><p>流控技术（Flow Control）<br>TCP 使用了流控技术来确保发送方不会因为一次发送过多的数据包而使接收方不堪重负。TCP 在发送缓冲区中存储数据，并在接收缓冲区中接收数据。当应用程序准备就绪时，它将从接收缓冲区读取数据。如果接收缓冲区已满，接收方将无法处理更多数据，并将其丢弃。UDP 没有提供类似的能力。</p>
</li>
<li><p>传输速度<br>UDP 协议简化，封包小，没有连接、可靠性检查等，因此单纯从传输速度上讲，UDP 更快。</p>
</li>
<li><p>场景差异<br>TCP 每个数据封包都需要确认，因此天然不适应高速数据传输场景，比如观看视频（流媒体应用）、网络游戏（TCP 有延迟）等。具体来说，如果网络游戏用 TCP，每个封包都需要确认，可能会造成一定的延迟；再比如音、视频传输天生就允许一定的丢包率；Ping 和 DNSLookup，这类型的操作只需要一次简单的请求/返回，不需要建立连接，用 UDP 就足够了。</p>
</li>
</ol>
<p>近些年有一个趋势，TCP/UDP 的边界逐渐变得模糊，UDP 应用越来越多。比如传输文件，如果考虑希望文件无损到达，可以用 TCP。如果考虑希望传输足够块，就可能会用 UDP。再比如 HTTP 协议，如果考虑请求/返回的可靠性，用 TCP 比较合适。但是像 HTTP 3.0 这类应用层协议，从功能性上思考，暂时没有找到太多的优化点，但是想要把网络优化到极致，就会用 UDP 作为底层技术，然后在 UDP 基础上解决可靠性。</p>
<p>所以理论上，任何一个用 TCP 协议构造的成熟应用层协议，都可以用 UDP 重构。这就好比，本来用一个工具可以解决所有问题，但是如果某一类问题体量非常大，就会专门为这类问题创造工具。因此，UDP 非常适合需要定制工具的场景。</p>
<p>下面我把场景分成三类，TCP 应用场景、UDP 应用场景、模糊地带（TCP、UDP 都可以考虑），你可以参考。</p>
<p>第一类：TCP 场景</p>
<p>远程控制（SSH）</p>
<p>File Transfer Protocol（FTP）</p>
<p>邮件（SMTP、IMAP）等</p>
<p>点对点文件传出（微信等）</p>
<p>第二类：UDP 场景</p>
<p>网络游戏</p>
<p>音视频传输</p>
<p>DNS</p>
<p>Ping</p>
<p>直播</p>
<p>第三类：模糊地带</p>
<p>HTTP（目前以 TCP 为主）</p>
<p>文件传输</p>
<p>以上我们从多个方面了解了 TCP 和 UDP 的区别，最后再来总结一下。UDP 不提供可靠性，不代表我们不能解决可靠性。UDP 的核心价值是灵活、轻量，构造了最小版本的传输层协议。在这个之上，还可以实现连接（Connection），实现会话（Session），实现可靠性（Reliability）……</p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>这一讲我们针对 UDP 协议的内容进行了探讨，到这里互联网协议群的传输层讲解就结束了。协议对于我们来说是非常重要的，协议的制定让所有参与者一致、有序地工作。</p>
<p>学习协议的设计，对你的工作非常有帮助。比如：</p>
<p>学习 TCP 协议可以培养你思维的缜密性——序号的设计、滑动窗口的设计、快速重发的设计、内在状态机的设计，都是非常精妙的想法；</p>
<p>学习 UDP 协议可以带动我们反思自己的技术架构，有时候简单的工具更受欢迎。Linux 下每个工具都是那么简单、专注，容易理解。相比 TCP 协议，UDP 更容易理解。</p>
<p>从程序架构上来说，今天我们更倾向于简单专注的设计，我们更期望有解决报文传输的工具、有解决可靠性的工具、有解决流量控制的工具、有解决连接和会话的工具……我相信这应该是未来的趋势——由大量优质的工具逐渐取代历史上沉淀下来完整统一的系统。从这个角度，我希望通过学习传输层的知识，能够帮助你重新审视自己的系统设计，看看自己还有哪些进步的空间。</p>
<h4 id="TCP-协议和-UDP-协议的优势和劣势？-1"><a href="#TCP-协议和-UDP-协议的优势和劣势？-1" class="headerlink" title="TCP 协议和 UDP 协议的优势和劣势？"></a>TCP 协议和 UDP 协议的优势和劣势？</h4><p>【解析】TCP 最核心的价值就是提供封装好的一套解决可靠性的优秀方案。 在前面 3 讲中，你可以看到解决可靠性是非常复杂的，要考虑非常多的因素。TCP 帮助我们在确保吞吐量、延迟、丢包率的基础上，保证可靠性。</p>
<p>历史上 TCP 也是靠可靠性起家的，有一次著名的实验，TCP 协议的设计者做了一次演示——利用 TCP 协议将数据在卫星和地面之间传播了很多次，没有发生任何数据损坏。从那个时候开始，研发人员开始大量选择 TCP 协议。然后随着生态的发展，逐渐提供了流控等能力。TCP 的成功在于它给人们提供了很多现成、好用的能力。</p>
<p>UDP 则不同，UDP 提供了最小版的实现，只支持 Checksum。UDP 最核心的价值是灵活、轻量、传输速度快。考虑到不同应用的特性，如果不使用一个大而全的方案，为自己的应用特性量身定做，可能会做得更好。比如网络游戏中游戏客户端不断向服务端发送玩家的位置，如果某一次消息丢失了，只要这个消息不影响最终的游戏结果，就可以只看下一个消息。不同应用有不同的特性，需要的可靠性级别不一样，这就是越来越多的应用开始使用 UDP 的原因之一。</p>
<p>其实对于我们来说，TCP 协议和 UDP 协议根本不存在什么优势和劣势，只不过是场景不同，选择不同而已。最后还有一个非常重要的考虑因素就是成本，如果没有足够专业的团队解决网络问题，TCP 无疑会是更好的选择。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><h4 id="有哪些好用的压测工具？"><a href="#有哪些好用的压测工具？" class="headerlink" title="有哪些好用的压测工具？"></a>有哪些好用的压测工具？</h4><p>压力测试最常见的工具是 Apache Benchmark（简称 AB），在 Linux 下面可以通过包管理器安装 ab：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd-tools</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">apt-get install apache2-utils</span><br></pre></td></tr></table></figure>

<p>ab 安装好后，可以利用下面这条指令向某个网站发送并发 1000 的 10000 次请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 10000 -p 1000 https://example.com/</span><br></pre></td></tr></table></figure>

<p>ab 是用 C 语言写的，作为一个随手就可以用的工具，它的设计非常简单，是一个单线程的工作模型，因此如果遇到阻塞情况，可能直接导致 ab 工具自己积压崩溃。</p>
<p>所以。这里我给你推荐一个 Java 生态好用的工具“JMeter”，拥有可视化的界面</p>
<h4 id="既然发送方有窗口，那么接收方也需要有窗口吗？"><a href="#既然发送方有窗口，那么接收方也需要有窗口吗？" class="headerlink" title="既然发送方有窗口，那么接收方也需要有窗口吗？"></a><strong>既然发送方有窗口，那么接收方也需要有窗口吗？</strong></h4><p>我们一起思考下，接收方收到发送方的每个数据分组（或者称为 TCP Segment），接收方肯定需要缓存。举例来说，如果发送方发送了：1, 2, 3, 4。 那么接收方可能收到的一种情况是：1，4，3。注意，没有收到 2 的原因可能是延迟、丢包等。这个时候，接收方有两种选择。</p>
<p><strong>选择一：什么都不做</strong>（这样分组 2 的 ACK 就不会发送给发送方，发送方发现没有收到 2 的 ACK，过一段时间就有可能重发 2,3,4,5）。 当然具体设计还需要探讨，比如不重发整个分组，只重发已发送没有收到 ACK 的分组。</p>
<p>这种方法的缺陷是<strong>性能太差</strong>，重发了整个分组（或部分）。因此我们可以考虑另一种选择。</p>
<p><strong>选择二</strong>：如果<strong>重发一个窗口，或部分窗口</strong>，问题就不会太大了。虽然增加了网络开销，但是毕竟有进步（1 进步了，不会再重发）。</p>
<p>性能方面最大的开销是<strong>等待超时的时间</strong>，就是发送方要等到超时时间才重发窗口，这样操作性能太差。因此，TCP 协议有一个<strong>快速重传</strong>的机制——接收方发现接收到了 1，但是没有接收到 2，那么马上发送 3 个分组 2 的 ACK 给到发送方，这样发送方收到多个 ACK，就知道接收方没有收到 2，于是马上重发 2。</p>
<p>无论是上面哪种方案，接收方也维护一个滑动窗口，是一个不错的选择。接收窗口的状态，可以和发送窗口的状态相互对应了。</p>
<h4 id="Moba-类游戏的网络应该用-TCP-还是-UDP？"><a href="#Moba-类游戏的网络应该用-TCP-还是-UDP？" class="headerlink" title="Moba 类游戏的网络应该用 TCP 还是 UDP？"></a><strong>Moba 类游戏的网络应该用 TCP 还是 UDP</strong>？</h4><p>所有在线联机游戏都有件非常重要的事情需要完成，就是<strong>确定事件发生的唯一性</strong>，这个性质和聊天工具是类似的。听我这么说，是不是有点迷？请听我慢慢道来。</p>
<p>你在王者荣耀中控制后羿释放技能，这是一个事件。同时，王昭君放了大招，这是第二个事件。两个事件一定要有先后顺序吗？答案是当然要有。因为游戏在同一时刻只能有一个状态。</p>
<p>类比一下，多个线程同时操作内存，发生了竞争条件（具体分析可以参见[《重学操作系统》](<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4&amp;utm_source=zhuanlan" target="_blank" rel="noopener">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4&amp;utm_source=zhuanlan</a> article&amp;utm_medium=bottom&amp;utm_campaign=《计算机网络通关 29讲》专栏内嵌&amp;_channel_track_key=D2LoirKK#/content)专栏关于“线程”的内容），那么是不是意味着，内存在同一时刻有两个状态呢？当然不是，<strong>内存同时刻只能有一个状态，所以多个线程的操作必须有先有后</strong>。</p>
<p>回到 Moba 游戏的问题，每个事件，游戏服务器必须给一个唯一的时序编号，对应后羿的技能和王昭君的技能。所以，在线竞技类游戏，事实上是玩家在不断向服务器竞争一个自增序列号的过程。无论客户端发生怎样的行为，只有竞争到自增 ID 才能进步。也就是说，<strong>服务器要尽快响应多个客户端提交的事件，并以最快的速度分配自增序号，然后返回给客户端</strong>。</p>
<p><strong>所以，Moba 服务端的核心是自增序号的计算和尽量缩减延迟</strong>。从这个角度出发，你再来看看，应该用 TCP 协议还是 UDP 协议呢？</p>
<p>虽然TCP 协议有 3 次握手，但是连接上之后，双方就不会再有额外的传输成本，因此创建连接的成本，可以忽略不计。</p>
<p>同时，TCP 协议还提供稳定性支持，不需要自己实现稳定性。如果规模较小的在线竞技类游戏，TCP 完全适用。但是当游戏玩家体量上升后，TCP 协议的头部（数据封包）较大，会增加服务器额外的 I/O 压力。要发送更多的数据，自然有更大的 I/O 压力。从这个角度来看，UDP 就有了用武之地。</p>
<h3 id="路由和寻址的区别是什么？"><a href="#路由和寻址的区别是什么？" class="headerlink" title="路由和寻址的区别是什么？"></a><strong>路由和寻址的区别是什么？</strong></h3><p>如果说传输层协议，除了 TCP/UDP，我们还可以有其他选择，比如 Google 开发的 QUIC 协议，帮助在传输层支持 HTTP 3.0 传输。但是在网络层，IP 协议几乎一统天下。IP 协议目前主要有两个版本 IPv4 和 IPv6。这一讲我们先介绍 IPv4 协议。</p>
<p>根据 Google 统计，使用 IPv6 的Google 用户比例在 30% 左右。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802115634.png" alt="image-20210802115634522"></p>
<p>IPv4使用范围很大，平时工作中很容易遇到，比如开发场景、网络优化场景、解决线上问题场景等。相信你经常会碰到一些和 IP 协议相关的名词，比如说<strong>这一</strong>讲<strong>关联的面试题目：路由和寻址的区别是什么</strong>？</p>
<h4 id="什么是-IP-协议？"><a href="#什么是-IP-协议？" class="headerlink" title="什么是 IP 协议？"></a>什么是 IP 协议？</h4><p><strong>IP 协议</strong>（<strong>Internet Protocol</strong>）是一个处于垄断地位的网络层协议。 IPv4 就是 IP 协议的第 4 个版本，是目前互联网的主要网络层协议。IPv4 为传输层提供 Host-To-Host 的能力，IPv4 需要底层数据链路层的支持。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802115717.png" alt="image-20210802115716980"></p>
<p>IP 协议并不负责数据的可靠性。传输数据时，数据被切分成一个个数据封包。IP 协议上层的传输层协议会对数据进行一次拆分，IP 协议还会进一步进行拆分。进行两次拆分是为了适配底层的设备。</p>
<p>之前我们提到过， 数据在网络中交换（封包交换算法），并不需要预先建立一个连接，而是任由数据在网络中传输，每个节点通过路由算法帮助数据封包选择下一个目的地。</p>
<p>这里再复习一下可靠性，<strong>可靠性保证数据无损地到达目的地</strong>。可靠性是 IP 协议上方的 Host-To-Host 协议保证的，比如 TCP 协议通过应答机制、窗口等保证数据的可靠性。 IP 协议自身不能保证可靠性。比如 IP 协议可能会遇到下面这几个问题：</p>
<ul>
<li>封包损坏（数据传输过程中被损坏）；</li>
<li>丢包（数据发送过程中丢失）；</li>
<li>重发（数据被重发，比如中间设备通过 2 个路径传递数据）；</li>
<li>乱序（到达目的地时数据和发送数据不一致）。</li>
</ul>
<p>但是 IP 协议并不会去处理这些问题，因为网络层只专注解决网络层的问题， 而且不同特性的应用在不同场景下需要解决的问题不一样。对于网络层来说，这里主要有 3 个问题要解决：</p>
<ul>
<li>延迟</li>
<li>吞吐量</li>
<li>丢包率</li>
</ul>
<p>这三个是鱼和熊掌不能兼得，我们后续会讨论。</p>
<p>另外，IP 协议目前主要有两种架构，一种是 IPv4，是目前应用最广泛的互联网协议；另一种是 IPv6，目前世界各地正在积极地部署 IPv6。这块我们最后讨论。</p>
<h3 id="IP-协议的工作原理"><a href="#IP-协议的工作原理" class="headerlink" title="IP 协议的工作原理"></a>IP 协议的工作原理</h3><p><strong>IP 协议接收 IP 协议上方的 Host-To-Host 协议传来的数据，然后进行拆分，这个能力叫作分片（Fragmentation）</strong>。然后 IP 协议为每个片段（Fragment）增加一个 IP 头（Header），组成一个<strong>IP 封包</strong>（Datagram）。之后，IP 协议调用底层的局域网（数据链路层）传送数据。最后 IP 协议通过寻址和路由能力最终把封包送达目的地。接下来为你讲述完整的过程。</p>
<h4 id="分片（Fragmentation）"><a href="#分片（Fragmentation）" class="headerlink" title="分片（Fragmentation）"></a>分片（Fragmentation）</h4><p><strong>分片就是把数据切分成片</strong>。 IP 协议通过它下层的局域网（链路层）协议传输数据，因此需要适配底层传输网络的传输能力。数据太大通常就不适合底层网络传输，这就需要把大的数据切片。 当然也可能选择不切片，IP 协议提供了一个能力就是把封包标记为不切片，当底层网络看到不切片的封包，又没有能力传输的时候，就会丢弃这个封包。你要注意，在网络环境中往往存在多条路径，一条路径断了，说不定其他路径可以连通。</p>
<h4 id="增加协议头（IP-Header）"><a href="#增加协议头（IP-Header）" class="headerlink" title="增加协议头（IP Header）"></a>增加协议头（IP Header）</h4><p>切片完成之后，IP 协议会为每个切片（数据封包 Datagram）增加一个协议头。一个 IPv4 的协议头看上去就是如下图所示的样子：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802121021.png" alt="image-20210802121021809"></p>
<p>其中分成 4 个部分。</p>
<ul>
<li>最重要的是原地址和目标地址。IPv4 的地址是 4 组 8 位的数字，总共是 32 位。具体地址的作用我们在下面的“寻址部分”介绍。</li>
<li>Type Of Service 服务的类型，是为了响应不同的用户诉求，用来选择延迟、吞吐量和丢包率之间的关系。关于这块知识，本讲后半部分就会分析。</li>
<li>IHL（Internet Header Length）用来描述 IP 协议头的大小。所以 IP 协议头的大小是可变的。IHL 只有 4 位，最大值 1111 = 15。最大是 15 个双字（15*4 字节 = 60 字节）。</li>
<li>Total Length 定义报文（封包 Datagram）的长度。</li>
<li>Identification（报文的 ID），发送方分配，代表顺序。</li>
<li>Fragment offset 描述要不要分包（拆分），以及如何拆分。</li>
<li>Time To Live 描述封包存活的时间。因此每个 IP 封包发送出去后，就开始销毁倒计时。如果倒计时为 0，就会销毁。比如中间的路由器看到一个 TTL 为 0 的封包，就直接丢弃。</li>
<li>Protocol 是描述上层的协议，比如 TCP = 6，UDP = 17。</li>
<li>Options 代表可选项。</li>
<li>Checksum 用来检验封包的正确性，具体原理我们在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=837#/detail/pc?id=7269&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">05 | UDP 协议：TCP 协议和 UDP 协议的优势和劣势？</a>”中已经介绍过了，如果 Checksum 对不上，就需要选择丢弃这个封包。</li>
</ul>
<h4 id="“鱼和熊掌”不能兼得——延迟、吞吐量、丢包率"><a href="#“鱼和熊掌”不能兼得——延迟、吞吐量、丢包率" class="headerlink" title="“鱼和熊掌”不能兼得——延迟、吞吐量、丢包率"></a>“鱼和熊掌”不能兼得——延迟、吞吐量、丢包率</h4><p>上面我们看到 IPv4 协议中提供了一个叫作 Type of Service（服务类型）的字段。这个字段是为了在延迟、吞吐量和丢包率三者间选择。</p>
<p><strong>延迟（latency）</strong></p>
<p>延迟指的是 1 bit 的数据从网络的一个终端传送到另一个终端需要的时间。这个时间包括在发送端准备发送的时间、排队发送的时间、发送数据的时间、数据传输的时间等。</p>
<p><strong>吞吐量（Throughput）</strong></p>
<p>吞吐量指单位时间内可以传输的平均数据量。比如用 bit/s 作为单位，就是 bps。吞吐量和延迟没有联系，比如延迟很高的网络，有可能吞吐量很高。可以类比成水管很大流速很慢，对比水管很细流速很快，这两种情况，最终流量可以是相等的。</p>
<p><strong>丢包率（Packet loss）</strong></p>
<p>丢表率指发送出去的封包没有到达目的地的比例。 在最大流速确定的网络中，丢表率会直接影响吞吐量。</p>
<p>我们的网络有时候需要低延迟，比如玩一款 RTS 游戏或者 Moba 游戏，这种时候延迟非常重要。另外如果把延迟看作一个平均指标，丢包也会影响延迟——一个包丢了，需要重发。而有的应用需要高吞吐量，延迟不是很重要，比如说网盘下载文件。大部分应用期望丢包不能太严重，比如语音电话，少量丢包还能听清，大量丢包就麻烦了，根本听不清对方说什么。严格希望不丢包的应用比较少，只有极特殊的网络控制管理场景，才需要在互联网层要求不丢包。</p>
<p>当然这三个条件，通常不能同时满足。如果同时追求延迟、吞吐量、丢包率，那么对网络设备的要求就会非常高，说白了就会非常贵。因此 IP 协议头中的 Type of Service 字段里，有以下 4 种主要的类型可以选择：</p>
<ul>
<li>低延迟</li>
<li>高吞吐量</li>
<li>低丢包率</li>
<li>低成本</li>
</ul>
<h4 id="寻址（Addressing）"><a href="#寻址（Addressing）" class="headerlink" title="寻址（Addressing）"></a>寻址（Addressing）</h4><p>地址想要表达的是一个东西在哪里。寻址要做的就是：给一个地址，然后找到这个东西。IPv4 协议的寻址过程是逐级寻址。</p>
<p><strong>IPv4 地址</strong></p>
<p>IPv4 地址是 4 个 8 位（Octet）排列而成，总共可以编址 43 亿个地址。</p>
<p>比如 103.16.3.1 就是一个合法的 Ipv4 地址。4 组数字用<code>.</code>分开，是为了让人可读，实际上在内存和传输过程中，就是直接用 32 位。</p>
<p><strong>寻址过程</strong></p>
<p>寻址就是如何根据 IP 地址找到设备。因为 IPv4 的世界中，网络是一个树状模型。顶层有多个平行的网络，每个网络有自己的网络号。然后顶层网络下方又有多个子网，子网下方还有子网，最后才是设备。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802121620.png" alt="image-20210802121620755"></p>
<p>IP 协议的寻址过程需要逐级找到网络，最后定位设备。下面我们具体分析下这个过程。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802121802.png" alt="image-20210802121802780"></p>
<p>当然子网掩码也不一定都是<code>255</code>，比如这个子网掩码<code>255.240.0.0</code>也是可以的。但通常我们把 IPv4 的网络分成这样 4 层。</p>
<h4 id="路由（Routing）"><a href="#路由（Routing）" class="headerlink" title="路由（Routing）"></a>路由（Routing）</h4><p>在寻址过程中，数据总是存于某个局域网中。如果目的地在局域网中，就可以直接定位到设备了。如果目的地不在局域网中，这个时候，就需再去往其他网络。</p>
<p>由于网络和网络间是网关在连接，因此如果目的地 IP 不在局域网中，就需要为 IP 封包选择通往下一个网络的路径，其实就是选择其中一个网关。你可能会问：网关有多个吗？如果一个网络和多个网络接壤，那自然需要多个网关了。下图中，路由器在选择 IP 封包下一个应该是去往哪个 Gateway？</p>
<p>假如，我们要为 IP 地址 14.215.177.38 寻址，当前路由器所在的网络的编号是16.0.0.0。那么我们就需要知道去往 14.0.0.0 网络的 Gateway IP 地址。</p>
<p>如果你在当前网络中用<code>route</code>查看路由表，可能可以看到一条下面这样的记录。</p>
<ul>
<li>Destination：14.0.0.0</li>
<li>Gateway：16.12.1.100</li>
<li>Mask：255.0.0.0</li>
<li>Iface：16.12.1.1</li>
</ul>
<p>这条记录就说明如果你要去往 14.0.0.0 网络，IP 地址 14.215.177.38 先要和 255.0.0.0 进行位运算，然后再查表，看到 14.0.0.0，得知去往 Gateway 的网卡（IFace）是 16.12.1.1。</p>
<p>当封包去向下一个节点后，会进入新的路由节点，然后会继续上述路由过程，直到最终定位到设备。</p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>这一讲我们学习了 IP 协议和 IP 协议的工作原理。首先 IP 协议会进行分片，将上游数据拆成一个个的封包（Datagram），然后为封包增加 IP 头部。封包发送出去后，就开始了寻址过程。寻址就是找到 IP 地址对应的设备。在局域网内，如果找不到设备，就需要路由。路由就是找到数据应该往哪里发送。最后通过层层路由定位到具体的设备。</p>
<h4 id="路由和寻址的区别是什么？-1"><a href="#路由和寻址的区别是什么？-1" class="headerlink" title="路由和寻址的区别是什么？"></a><strong>路由和寻址的区别是什么</strong>？</h4><p>【<strong>解析</strong>】寻址（Addressing）就是通过地址找设备。和现实生活中的寻址是一样的，比如根据地址找到一个公寓。在 IPv4 协议中，寻址找到的是一个设备所在的位置。</p>
<p>路由（Routing）本质是路径的选择。就好像知道地址，但是到了每个十字路口，还需要选择具体的路径。</p>
<p>所以，要做路由，就必须能够理解地址，也就是需要借助寻址的能力。要通过寻址找到最终的设备，又要借助路由在每个节点选择数据传输的线路。因此，路由和寻址，是相辅相成的关系。</p>
<h3 id="Tunnel-技术是什么？"><a href="#Tunnel-技术是什么？" class="headerlink" title="Tunnel 技术是什么？"></a><strong>Tunnel 技术是什么？</strong></h3><p>IPv4 用 32 位整数描述地址，最多只能支持 43 亿设备，显然是不够用的，这也被称作 IP 地址耗尽问题。</p>
<p>为了解决这个问题，有一种可行的方法是<strong>拆分子网</strong>。拆分子网，会带来很多问题，比如说内外网数据交互，需要网络地址转换协议（NAT 协议），增加传输成本。再比如说，多级网络会增加数据的路由和传输链路，降低网络的速度。理想的状态当然是所有设备在一个网络中，互相可以通过地址访问。</p>
<p>为了解决这个问题，1998 年互联网工程工作小组推出了全新款的 IP 协议——IPv6 协议。但是目前 IPv6 的普及程度还不够高，2019 年据中国互联网络信息中心（CNNIC）统计，IPv6 协议目前在我国普及率为 60%，已经位居世界首位。</p>
<p>既然不能做到完全普及，也就引出了<strong>本讲关联的一道面试题目：什么是 Tunnel 技术</strong>？下面请你带着这个问题，开启今天的学习吧！</p>
<h4 id="IPv4-和-IPv6-相似点"><a href="#IPv4-和-IPv6-相似点" class="headerlink" title="IPv4 和 IPv6 相似点"></a>IPv4 和 IPv6 相似点</h4><p>IPv6 的工作原理和 IPv4 类似，分成切片（Segmentation）、增加封包头、路由（寻址）这样几个阶段去工作。IPv6 同样接收上方主机到主机（Host-to-Host）协议传递来的数据，比如一个 TCP 段（Segment），然后将 TCP 段再次切片做成一个个的 IPv6 封包（Datagram or Packet），再调用底层局域网能力（数据链路层）传输数据。具体的过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802141337.png" alt="image-20210802141337083"></p>
<p><strong>作为网络层协议的 IPv6，最核心的能力是确保数据可以从发送主机到达接收主机</strong>。因此，和 IPv4 类似，IPv6同样需要定义地址的格式，以及路由算法如何工作。</p>
<h4 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h4><p>接下来我们重点说说地址格式的区别。</p>
<p>IPv4 的地址是 4 个 8 位（octet），总共 32 位。 IPv6 的地址是 8 个 16 位（hextet），总共 128 位。从这个设计来看，IPv6 可以支持的地址数量是 IPv4 的很多倍。就算将 IPv6 的地址分给每个人，每个人拥有的地址数量，依旧是今天总地址数量的很多倍。</p>
<p>格式上，IPv4 的地址用<code>.</code>分割，如<code>103.28.7.35</code>。每一个是 8 位，用 0-255 的数字表示。</p>
<p>IPv6 的地址用<code>:</code>分割，如<code>0123:4567:89ab:cdef:0123:4567:89ab:cdef</code>，总共 8 个 16 位的数字，通常用 16 进制表示。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802141549.png" alt="image-20210802141549211"></p>
<ul>
<li>Hexadecimal notation：十六进制表示</li>
<li>Quartet：16 位</li>
<li>Most significant：最高有效位</li>
<li>Binary notation：二进制表示</li>
</ul>
<p><code>::</code>只能出现一次，相当于省略了若干组<code>0000</code>。比如说<code>1111::2222</code>相当于中间省略了 6 组<code>0000</code>。为什么不能出现两个<code>::</code>呢？因为如果有两个<code>::</code>，就会对省略的<code>0000</code>的位置产生歧义。比如说<code>1111::2222:3333</code>，你就不知道究竟<code>0000</code>在<code>1111::2222</code>和<code>2222::3333</code>是怎么分布的。</p>
<p>开头的 0 也可以简写，就变成如下的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123:4567::123:4567:0:cdef</span><br></pre></td></tr></table></figure>

<p>还有一种情况我们想要后面部分都填<code>0</code>，比如说<code>3c4d::/16</code>，这个代表只有前<code>16</code>位有数据，后面是<code>0</code>；<code>1234:5878:abcd/64</code>代表只有左边<code>64</code>位有数据，后面是 0；再比如<code>ff00/8</code>，只有左边 8 位是有数据的。</p>
<h4 id="IPv6-的寻址"><a href="#IPv6-的寻址" class="headerlink" title="IPv6 的寻址"></a>IPv6 的寻址</h4><p>接下来我们讨论下寻址，和 IPv4 相同，寻址的目的是找到设备，以及规划到设备途经的路径。和 IPv4 相同，IPv6寻址最核心的内容就是要对网络进行划分。IPv6 地址很充裕，因此对网络的划分和 IPv4 有很显著的差异。</p>
<p>IPv6 的寻址分成了几种类型：</p>
<ul>
<li>全局单播寻址（和 IPv4 地址作用差不多，在互联网中通过地址查找一个设备，简单来说，单播就是 1 对 1）；</li>
<li>本地单播（类似 IPv4 里的一个内部网络，要求地址必须以<code>fe80</code>开头，类似我们 IPv4 中<code>127</code>开头的地址）；</li>
<li>分组多播（Group Multicast），类似今天我们说的广播，将消息发送给多个接收者；</li>
<li>任意播（Anycast），这个方式比较特殊，接下来我们会详细讲解。</li>
</ul>
<h4 id="全局单播"><a href="#全局单播" class="headerlink" title="全局单播"></a>全局单播</h4><p>全局单播，就是将消息从一个设备传到另一个设备，这和 IPv4 发送/接收消息大同小异。而全局单播地址，目标就是定位网络中的设备，这个地址和 IPv4 的地址作用相同，只不过格式略有差异。<strong>总的来说，IPv6 地址太多，因此不再需要子网掩码，而是直接将 IPv6 的地址分区即可</strong>。</p>
<p>在实现全局单播时，IPv6 地址通常分成 3 个部分：</p>
<ul>
<li>站点前缀（Site Prefix）48bit，一般是由 ISP（Internet Service Providor，运营商）或者RIR（Regional Internet Registry， 地区性互联网注册机构），RIR 将 IP 地址分配给运营商；</li>
<li>子网号（Subnet ID），16bit，用于站点内部区分子网；</li>
<li>接口号（Interface ID）， 64bit，用于站点内部区分设备。</li>
</ul>
<p>因此 IPv6 也是一个树状结构，站点前缀需要一定资质，子网号和接口号内部定义。IPv6 的寻址过程就是先通过站点前缀找到站点，然后追踪子网，再找到接口（也就是设备的网卡）。</p>
<p>从上面全局单播的分区，我们可以看出，IPv6 分给站点的地址非常多。一个站点，有 16bit 的子网，相当于 65535 个子网；每个子网中，还可以用 64 位整数表示设备。</p>
<h4 id="本地单播"><a href="#本地单播" class="headerlink" title="本地单播"></a>本地单播</h4><p>理论上，虽然 IPv6 可以将所有的设备都连入一个网络。但在实际场景中，很多公司还是需要一个内部网络的。这种情况在 IPv6 的设计中属于局域网络。</p>
<p>在局域网络中，实现设备到设备的通信，就是本地单播。IPv6 的本地单播地址组成如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802162709.png" alt="image-20210802162709355"></p>
<p>这种协议比较简单，本地单播地址必须以<code>fe80</code>开头，后面 64 位的 0，然后接上 54 位的设备编号。上图中的 Interface 可以理解成网络接口，其实就是网卡。</p>
<h4 id="分组多播"><a href="#分组多播" class="headerlink" title="分组多播"></a>分组多播</h4><p>有时候，我们需要实现广播。所谓广播，就是将消息同时发送给多个接收者。</p>
<p>IPv6 中设计了分组多播，来实现广播的能力。当 IP 地址以 8 个 1 开头，也就是<code>ff00</code>开头，后面会跟上一个分组的编号时，就是在进行分组多播。</p>
<p>这个时候，我们需要一个广播设备，在这个设备中已经定义了这些分组编号，并且拥有分组下所有设备的清单，这个广播设备会帮助我们将消息发送给对应分组下的所有设备。</p>
<h4 id="任意播（Anycast）"><a href="#任意播（Anycast）" class="headerlink" title="任意播（Anycast）"></a>任意播（Anycast）</h4><p>任意播，本质是将消息发送给多个接收方，并选择一条最优的路径。这样说有点抽象，接下来我具体解释一下。</p>
<p>比如说在一个网络中有多个授时服务，这些授时服务都共享了一个任播地址。当一个客户端想要获取时间，就可以将请求发送到这个任播地址。客户端的请求扩散出去后，可能会找到授时服务中的一个或者多个，但是距离最近的往往会先被发现。这个时候，客户端就使用它第一次收到的授时信息修正自己的时间。</p>
<h4 id="IPv6-和-IPv4-的兼容"><a href="#IPv6-和-IPv4-的兼容" class="headerlink" title="IPv6 和 IPv4 的兼容"></a>IPv6 和 IPv4 的兼容</h4><p>目前 IPv6 还没有完全普及，大部分知名的网站都是同时支持 IPv6 和 IPv4。这个时候我们可以分成 2 种情况讨论：</p>
<ol>
<li>一个 IPv4 的网络和一个 IPv6 的网络通信；</li>
<li>一个 IPv6 的网络和一个 IPv6 的网络通信，但是中间需要经过一个 IPv4 的网络。</li>
</ol>
<p>下面我们具体分析一下。</p>
<p><strong>情况 1：IPv4 网络和 IPv6 网络通信</strong></p>
<p>例如一个 IPv6 的客户端，想要访问 IPv4 的服务器，步骤如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802162809.png" alt="image-20210802162809719"></p>
<ol>
<li>客户端通过 DNS64 服务器查询 AAAA 记录。DNS64 是国际互联网工程任务组（IETF）提供的一种解决 IPv4 和 IPv6 兼容问题的 DNS 服务。这个 DNS 查询服务会把 IPv4 地址和 IPv6 地址同时返回。</li>
<li>DNS64 服务器返回含 IPv4 地址的 AAAA 记录。</li>
<li>客户端将对应的 IPv4 地址请求发送给一个 NAT64 路由器</li>
<li>由这个 NAT64 路由器将 IPv6 地址转换为 IPv4 地址，从而访问 IPv4 网络，并收集结果。</li>
<li>消息返回到客户端。</li>
</ol>
<p><strong>情况 2：两个 IPv6 网络被 IPv4 隔离</strong></p>
<p>这种情况在普及 IPv6 的过程中比较常见，IPv6 的网络一开始是一个个孤岛，IPv6 网络需要通信，就需要一些特别的手段。</p>
<p>不知道你有没有联想到坐火车穿越隧道的感觉，连接两个孤岛 IPv6 网络，其实就是在 IPv4 网络中建立一条隧道。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802162837.png" alt="image-20210802162837144"></p>
<p><strong>隧道的本质就是在两个 IPv6 的网络出口网关处，实现一段地址转换的程序</strong>。</p>
<h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>总结下，<strong>IPv6 解决的是地址耗尽的问题</strong>。因为解决了地址耗尽的问题，所以很多其他问题也得到了解决，比如说减少了子网，更小的封包头部体积，最终提升了性能等。</p>
<p>除了本讲介绍的内容，下一讲你还会从局域网络中看到更多对 NAT 技术的解读、对路由器的作用的探讨。随着 IPv6 彻底普及，你可以想象一下，运营商可以给到每个家庭一大批固定的 IP 地址，发布网页似乎可以利用家庭服务器……总之，林䭽也不知道最终会发生什么，我也对未来充满了期待，让我们拭目以待吧。</p>
<p>那么，通过这一讲的学习，你可以尝试回答本讲关联的面试题目：Tunnel 技术是什么了吗？</p>
<p>【<strong>解析</strong>】Tunnel 就是隧道，这和现实中的隧道是很相似的。隧道不是只有一辆车通过，而是每天都有大量的车辆来来往往。两个网络，用隧道连接，位于两个网络中的设备通信，都可以使用这个隧道。隧道是两个网络间用程序定义的一种通道。具体来说，如果两个 IPv6 网络被 IPv4 分隔开，那么两个 IPv6 网络的出口处（和 IPv4 网络的网关处）就可以用程序（或硬件）实现一个隧道，方便两个网络中设备的通信。</p>
<p><strong>IPv6与IPv4的区别主要有以下几点</strong>：1.IPv6的地址空间更大。IPv4中规定IP地址长度为32,即有2^32-1个地址；而IPv6中IP地址的长度为128,即有2^128-1个地址。夸张点说就是，如果IPV6被广泛应用以后，全世界的每一粒沙子都会有相对应的一个IP地址。2.IPv6的路由表更小。IPv6的地址分配一开始就遵循聚类(Aggregation)的原则,这使得路由器能在路由表中用一条记录(Entry)表示一片子网,大大减小了路由器中路由表的长度,提高了路由器转发数据包的速度。3.IPv6的组播支持以及对流的支持增强。这使得网络上的多媒体应用有了长足发展的机会，为服务质量控制提供了良好的网络平台。4.IPv6加入了对自动配置的支持。这是对DHCP协议的改进和扩展，使得网络(尤其是局域网)的管理更加方便和快捷。5.IPv6具有更高的安全性。在使用IPv6网络中，用户可以对网络层的数据进行加密并对IP报文进行校验，这极大地增强了网络安全</p>
<h3 id="NAT-是如何工作的？"><a href="#NAT-是如何工作的？" class="headerlink" title="NAT 是如何工作的？"></a><strong>NAT 是如何工作的？</strong></h3><p><strong>数据到王者荣耀服务器可以通过寻址和路由找到目的地，但是数据从王者荣耀服务器回来的时候，王者荣耀服务器如何知道</strong><code>192.168</code>开头的地址应该如何寻址呢？</p>
<p>要想回答这个问题，就涉及网络地址转换协议（NAT 协议）。下面请你带着这个问题，开启今天的学习吧。</p>
<h4 id="内部网络和外部网络"><a href="#内部网络和外部网络" class="headerlink" title="内部网络和外部网络"></a>内部网络和外部网络</h4><p>对一个组织、机构、家庭来说，我们通常把内部网络称为局域网，外部网络就叫作外网。下图是一个公司多个部门的网络架构。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802171040.png" alt="image-20210802171040490"></p>
<h4 id="局域网数据交换（MAC-地址）"><a href="#局域网数据交换（MAC-地址）" class="headerlink" title="局域网数据交换（MAC 地址）"></a>局域网数据交换（MAC 地址）</h4><p>接下来我们讨论下同一个局域网中的设备如何交换消息。</p>
<p>首先，我们先明确一个概念，设备间通信的本质其实是设备拥有的网络接口（网卡）间的通信。<strong>为了区别每个网络接口，互联网工程任务组（IETF）要求每个设备拥有一个唯一的编号，这个就是 MAC 地址</strong>。</p>
<p><strong>你可能会问：IP 地址不也是唯一的吗</strong>？其实不然，一旦设备更换位置，比如你把你的电脑从北京邮寄的广州，那么 IP 地址就变了，而电脑网卡的 MAC 地址不会发生变化。总的来说，IP 地址更像现实生活中的地址，而 MAC 地址更像你的身份证号。</p>
<p>然后，我们再明确另一个基本的概念。<strong>在一个局域网中，我们不可以将消息从一个接口（网卡）发送到另一个接口（网卡），而是要通过交换机</strong>。为什么是这样呢？因为两个网卡间没有线啊！所以数据交换，必须经过交换机，毕竟线路都是由网卡连接交换机的。</p>
<p>总结下，数据的发送方，将自己的 MAC 地址、目的地 MAC 地址，以及数据作为一个分组（Packet），也称作 Frame 或者封包，发送给交换机。交换机再根据目的地 MAC 地址，将数据转发到目的地的网络接口（网卡）。</p>
<p><strong>最后一个问题，你可能问，这个分组或者 Frame，是不是 IP 协议的分组呢</strong>？——不是，这里提到的是链路层的数据交换，它支持 IP 协议工作，是网络层的底层。所以，<strong>如果 IP 协议要传输数据，就要将数据转换成为链路层的分组，然后才可以在链路层传输</strong>。</p>
<p>链路层分组大小受限于链路层的网络设备、线路以及使用了链路层协议的设计。你有时候可能会看到 MTU 这个缩写词，它指的是 Maximun Transmission Unit，最大传输单元，意思是链路层网络允许的最大传输数据分组的大小。<strong>因此 IP 协议要根据 MTU 拆分封包</strong>。</p>
<p>之前在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=837#/detail/pc?id=7268&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">04 | TCP 的稳定性：滑动窗口和流速控制是怎么回事？</a>”介绍 TCP 协议滑动窗口的时候，还提到过一个词，叫作 MSS，这里我们复习下。MSS（Maximun Segment Size，最大段大小）是 TCP 段，或者称为 TCP 分组（TCP Packet）的最大大小。<strong>MSS 是传输层概念，MTU 是链路层概念</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MTU = MSS + TCP Header + IP Header</span><br></pre></td></tr></table></figure>

<p><strong>这个思路有一定道理，但是不对</strong>。先说说这个思路怎么来的，你可能会这么思考：TCP 传输数据大于 MSS，就拆包。每个封包加上 TCP Header ，之后经过 IP 协议，再加上 IP Header。于是这个加上 IP 头的分组（Packet）不能超过 MTU。固然这个思路很有道理，可惜是错的。<strong>因为 TCP 解决的是广域网的问题，MTU 是一个链路层的概念，要知道不同网络 MTU 是不同的，所以二者不可能产生关联。这也是为什么 IP 协议还可能会再拆包的原因</strong>。</p>
<h4 id="地址解析协议（ARP）"><a href="#地址解析协议（ARP）" class="headerlink" title="地址解析协议（ARP）"></a>地址解析协议（ARP）</h4><p>上面我们讨论了 MAC 地址，链路层通过 MAC 地址定位网络接口（网卡）。在一个网络接口向另一个网络接口发送数据的时候，至少要提供这样 3 个字段：</p>
<ol>
<li>源 MAC 地址</li>
<li>目标 MAC 地址</li>
<li>数据</li>
</ol>
<p><strong>这里我们一起再来思考一个问题，对于一个网络接口，它如何能知道目标接口的 MAC 地址呢</strong>？我们在使用传输层协议的时候，清楚地知道目的地的 IP 地址，但是我们不知道 MAC 地址。这个时候，就需要一个中间服务帮助根据 IP 地址找到 MAC 地址——这就是地址解析协议（Address Resolution Protocol，ARP）。</p>
<p>整个工作过程和 DNS 非常类似，如果一个网络接口已经知道目标 IP 地址对应的 MAC 地址了，它会将数据直接发送给交换机，交换机将数据转发给目的地，这个过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174247.png" alt="image-20210802174246892"></p>
<p>那么如果网络接口不知道目的地地址呢？这个时候，地址解析协议就开始工作了。发送接口会发送一个广播查询给到交换机，交换机将查询转发给所有接口。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174259.png" alt="image-20210802174259362"></p>
<p>如果某个接口发现自己就是对方要查询的接口，则会将自己的 MAC 地址回传。接下来，会在交换机和发送接口的 ARP 表中，增加一个缓存条目。也就是说，接下来发送接口再次向 IP 地址 2.2.2.2 发送数据时，不需要再广播一次查询了。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174313.png" alt="image-20210802174313038"></p>
<p><strong>前面提到这个过程和 DNS 非常相似，采用的是逐级缓存的设计减少 ARP 请求</strong>。发送接口先查询本地的 ARP 表，如果本地没有数据，然后广播 ARP 查询。这个时候如果交换机中有数据，那么查询交换机的 ARP 表；如果交换机中没有数据，才去广播消息给其他接口。<strong>注意，ARP 表是一种缓存，也要考虑缓存的设计</strong>。通常缓存的设计要考虑缓存的失效时间、更新策略、数据结构等。</p>
<p>比如可以考虑用 TTL（Time To Live）的设计，为每个缓存条目增加一个失效时间。另外，更新策略可以考虑利用老化（Aging）算法模拟 LRU。</p>
<p>最后请你思考路由器和交换机的异同点。不知道你有没有在网上订购过家用无线路由器，通常这种家用设备也会提供局域网，具备交换机的能力。同时，这种设备又具有路由器的能力。所以，很多同学可能会分不清路由器和交换机。</p>
<p>总的来说，家用的路由器，也具备交换机的功能。但是当 ARP 表很大的时候，就需要专门的、能够承载大量网络接口的交换设备。就好比，如果用数组实现 ARP 表，数据量小的时候，遍历即可；但如果数据量大的话，就需要设计更高效的查询结构和设计缓存。</p>
<p>详细的缓存设计原理的介绍，可以参考<a href="https://shenceyun.lagou.com/t/Axo?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">《重学操作系统》</a>专栏中关于 CPU 缓存的设计，以及 MMU 中 TLB 的设计的内容，分别在以下 3 讲：</p>
<ul>
<li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4610&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">05 | 存储器分级：L1 Cache 比内存和 SSD 快多少倍？</a></li>
<li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4634&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">25 | 内存管理单元： 什么情况下使用大内存分页？</a></li>
<li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4635&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">26 | 缓存置换算法： LRU 用什么数据结构实现更合理？</a></li>
</ul>
<h4 id="连接内网"><a href="#连接内网" class="headerlink" title="连接内网"></a>连接内网</h4><p>有时候，公司内部有多个子网。这个时候一个子网如果要访问另一个子网，就需要通过路由器。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174554.png" alt="image-20210802174554758"></p>
<p>也就是说，图中的路由器，其实充当了两个子网通信的桥梁。在上述过程中，发送接口不能直接通过 MAC 地址发送数据到接收接口，因为子网 1 的交换机不知道子网 2 的接口。这个时候，发送接口需要通过 IP 协议，将数据发送到路由器，再由路由器转发信息到子网 2 的交换机。这里提一个问题，<strong>子网 2 的交换机如何根据 IP 地址找到接收接口呢</strong>？答案是通过查询 ARP 表。</p>
<h4 id="连接外网（网络地址转换技术，NAT）"><a href="#连接外网（网络地址转换技术，NAT）" class="headerlink" title="连接外网（网络地址转换技术，NAT）"></a>连接外网（网络地址转换技术，NAT）</h4><p>最后我们讨论下连接外网的问题。</p>
<p>IPv4 协议因为存在网络地址耗尽的问题，不能为一个公司提供足够的地址，因此内网 IP 可能会和外网重复。比如内网 IP 地址<code>192.168.0.1</code>发送信息给<code>22.22.22.22</code>，这个时候，其实是跨着网络的。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174617.png" alt="image-20210802174616966"></p>
<p>跨网络必然会通过多次路由，最终将消息转发到目的地。但是这里存在一个问题，寻找的目标 IP 地址<code>22.22.22.22</code>是一个公网 IP，可以通过正常的寻址 + 路由算法定位。当<code>22.22.22.22</code>寻找<code>192.168.0.1</code>的时候，是寻找一个私网 IP，这个时候是找不到的。解决方案就是网络地址转换技术（Network Address Translation）。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802174930.png" alt="image-20210802174930780"></p>
<p>NAT 技术转换的是 IP 地址，私有 IP 通过 NAT 转换为公网 IP 发送到服务器。服务器的响应，通过 NAT 转换为私有 IP，返回给客户端。通过这种方式，就解决了内网和外网的通信问题。</p>
<h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p>总结一下，链路层发送数据靠的是 MAC 地址，MAC 地址就好像人的身份证一样。局域网中，数据不可能从一个终端直达另一个终端，而是必须经过交换机交换。交换机也叫作链路层交换机，它的工作就是不断接收数据，然后转发数据。<strong>通常意义上，交换机不具有路由功能，路由器往往具有交换功能</strong>。但是往往路由器交换的效率，不如交换机。已知 IP 地址，找到 MAC 地址的协议，叫作地址解析协议（ARP）。</p>
<p>网络和网络的衔接，必须有路由器（或者等价的设备）。一个网络的设备不能直接发送链路层分组给另一个网络的设备，而是需要通过 IP 协议让路由器转发。</p>
<p>那么，通过这一讲的学习，你可以来回答本讲关联的面试题目：网络地址转换协议是如何工作的？</p>
<p>【<strong>解析</strong>】网络地址解析协议（NAT）解决的是内外网通信的问题。NAT 通常发生在内网和外网衔接的路由器中，由路由器中的 NAT 模块提供网络地址转换能力。从设计上看，NAT 最核心的能力，就是能够将内网中某个 IP 地址映射到外网 IP，然后再把数据发送给外网的服务器。当服务器返回数据的时候，NAT 又能够准确地判断外网服务器的数据返回给哪个内网 IP。</p>
<p>你可以思考下 NAT 是如何做到这点的呢？需要做两件事。</p>
<ol>
<li>NAT 需要作为一个中间层替换 IP 地址。 发送的时候，NAT 替换源 IP 地址（也就是将内网 IP 替换为出口 IP）；接收的时候，NAT 替换目标 IP 地址（也就是将出口 IP 替换回内网 IP 地址）。</li>
<li>NAT 需要缓存内网 IP 地址和出口 IP 地址 + 端口的对应关系。也就是说，发送的时候，NAT 要为每个替换的内网 IP 地址分配不同的端口，确保出口 IP 地址+ 端口的唯一性，这样当服务器返回数据的时候，就可以根据出口 IP 地址 + 端口找到内网 IP。</li>
</ol>
<p>这里不去讨论更加详细复杂的情况，NAT技术又细分为静态动态等等几个情况。</p>
<h3 id="如何进行-TCP-抓包调试？"><a href="#如何进行-TCP-抓包调试？" class="headerlink" title="如何进行 TCP 抓包调试？"></a><strong>如何进行 TCP 抓包调试？</strong></h3><p>这一讲给你带来了一个<strong>网络调试工具——Wireshark</strong>。Wireshark 是世界上应用最广泛的网络协议分析器，它让我们在微观层面上看到整个网络正在发生的事情。</p>
<p>Wireshark 本身是一个开源项目，所以也得到了很多志愿者的支持。同时，Wireshark 具有丰富的功能集，包括：</p>
<ol>
<li>深入检查数百个协议，并不断添加更多协议；</li>
<li>实时捕获和离线分析；</li>
<li>支持 Windows、Linux、macOS、Solaris、FreeBSD、NetBSD，以及许多其他平台；</li>
<li>提供 GUI 浏览，也可以通过 TTY；</li>
<li>支持 VOIP；</li>
<li>支持 Gzip；</li>
<li>支持 IPSec。</li>
<li>……</li>
</ol>
<p>是不是觉得Wireshark非常强大？无论你从事哪种开发工作，它都可以帮到你，因此也是面试经常考察的内容。<strong>比如本讲关联的面试题：如何进行 TCP 抓包和调试</strong>？下面请你带着问题，开始今天的学习吧。</p>
<p><em>注：你可以到 Wireshark 的主页：</em><a href="https://www.wireshark.org/download.html?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">https://www.wireshark.org/download.html</a><em>下载 Wireshark。</em></p>
<p>如果你是一个黑客、网络安全工程师，或者你的服务总是不稳定，就需要排查，那么你会如何 hack 这些网络连接、网络接口以及分析网络接口的封包呢？</p>
<h4 id="接口列表"><a href="#接口列表" class="headerlink" title="接口列表"></a>接口列表</h4><p>Whireshark 可以帮你看到整个网络交通情况，也可以帮你深入了解每个封包。而且 Whireshark 在 macOS、Linux、Windows 上的操作都是一致的，打开 Wireshark 会先看到如下图所示的一个选择网络接口的界面。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183750.png" alt="image-20210802183750408"></p>
<p>我们要做的第一件事情就是<strong>选择一个网络接口</strong>（<strong>Network Interface</strong>）。Linux 下可以使用<code>ifconfig</code>指令看到所有的网络接口，Windows 下则使用 ipconfig。可以看到，上图中有很多网络接口，目前我教学这台机器上，连接路由器的接口是<strong>以太网 2</strong>。另外可以看到，我的机器上还有<code>VMware</code>的虚拟网络接口（你的机器可能和我的机器显示的不一样）。</p>
<h4 id="开启捕获功能"><a href="#开启捕获功能" class="headerlink" title="开启捕获功能"></a>开启捕获功能</h4><p>选择好接口之后，点击左上角的按钮就可以开启捕获，开启后看到的是一个个数据条目。</p>
<p>因为整个网络的数据非常多，大量的应用都在使用网络，你会看到非常多数据条目，每个条目是一次数据的发送或者接收。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183809.png" alt="image-20210802183809553"></p>
<p>以下是具体捕获到的内容：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183828.png" alt="image-20210802183828623"></p>
<ul>
<li>序号（No.）是 Wireshark 分配的一个从捕获开始的编号。</li>
<li>时间（Time）是从捕获开始过去的时间戳，具体可以在视图中设置，比如可以设置成中文的年月日等。这里有很多配置需要你自己摸索一下，我就不详细介绍了。</li>
<li>源地址和目标地址（Source 和 Destination）是 IP 协议，注意这里有 IPv6 的地址，也有 IPV4 的地址。</li>
<li>协议可能有很多种，比如 TCP/UDP/ICMP 等，ICMP 是 IP 协议之上搭建的一个消息控制协议（Internet Control Message Protocol），比如 Ping 用的就是 ICMP；还有 ARP 协议（Address Resolution Protocol）用来在局域网广播自己的 MAC 地址。</li>
<li>Length 是消息的长度（Bytes）。</li>
<li>Info 是根据不同协议显示的数据，比如你可以看到在TCP 协议上看到Seq 和 ACK。这里的 Seq 和 ACK 已经简化过了，正常情况下是一个大随机数，Whireshark 帮你共同减去了一个初始值。</li>
</ul>
<h4 id="观察-TCP-协议"><a href="#观察-TCP-协议" class="headerlink" title="观察 TCP 协议"></a>观察 TCP 协议</h4><p>如果你具体选择一个 TCP 协议的捕获，可以看到如下图所示的内容：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183916.png" alt="image-20210802183916603"></p>
<p>然后在这下面可以观察到详情内容：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802183939.png" alt="image-20210802183939049"></p>
<p>我们可以从不同的层面来看这次捕获。从传输层看是 TCP 段；从网络层来看是 IP 封包；从链路层来看是 Frame。</p>
<p>点开不同层面观察这个 TCP 段，就可以获得对它更具体的认识，例如下图是从 TCP 层面理解这次捕获：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802184039.png" alt="image-20210802184038793"></p>
<p>你可以看到这次捕获是一次 ACK（见 Flags）字段，从端口 58260 发往 443，那么大概率是 HTTPS 客户端给服务器的响应。</p>
<h4 id="消息视图"><a href="#消息视图" class="headerlink" title="消息视图"></a>消息视图</h4><p>如果你选中一条消息，下面会出现一个消息视图。还有一个二进制视图。二进制视图里面是数据的二进制形式，消息视图是对二进制形式的解读。</p>
<p>Whireshark 追溯的是最底层网卡传输的 Frame（帧），可以追溯到数据链路层。因此对二进制形式的解读，也就是我们的消息视图也要分层。因为对于同样的数据，不同层的解读是不同的。</p>
<ul>
<li>最上面是 Frame 数据，主要是关注数据的收发时间和大小。</li>
<li>接着是数据链路层数据，关注的是设备间的传递。你可以在这里看到源 MAC 地址和目标 MAC 地址。</li>
<li>然后是网络层数据，IP 层数据。这里有 IP 地址（源 IP 地址和目标 IP 地址）；也有头部的 Checksum（用来纠错的）。这里就不一一介绍了，你可以回到“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=837#/detail/pc?id=7271&fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">06 | IPv4 协议：路由和寻址的区别是什么？</a>”复习这块内容。</li>
<li>最下面是传输层数据。 也就是 TCP 协议。关注的是源端口，目标端口，Seq、ACK 等。</li>
<li>有的传输层上还有一个 TLS 协议，这是因为用 HTTPS 请求了数据。TLS 也是传输层。TLS 是建立在 TCP 之上，复用了 TCP 的逻辑。</li>
</ul>
<h4 id="观察-HTTP-协议"><a href="#观察-HTTP-协议" class="headerlink" title="观察 HTTP 协议"></a>观察 HTTP 协议</h4><p>Wireshark 还可以用来观察其他的协议，比如说 HTTP 协议，下图是对 HTTP 协议的一次捕获：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802200225.png" alt="image-20210802200225492"></p>
<p>可以看到，Wireshark 不仅仅捕获了应用层，还可以看到这次 HTTP 捕获对应的传输层、网络层和链路层数据。</p>
<h4 id="过滤和筛选"><a href="#过滤和筛选" class="headerlink" title="过滤和筛选"></a>过滤和筛选</h4><p>Wireshark 还提供了捕获的过滤，我们只需要输入过滤条件，就可以只看符合条件的捕获。</p>
<p>比如我们想分析一次到百度的握手。首先开启捕获，然后在浏览器输入百度的网址，最后通过<code>ping</code>指令看下百度的 IP 地址，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210802200313.png" alt="image-20210802200313749"></p>
<p>看到IP 地址之后，我们在 Wireshark 中输入表达式，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803112824.png" alt="image-20210803112823819"></p>
<p>这样看到的就是和百度关联的所有连接。上图中刚好是一次从建立 TCP 连接（3 次握手），到 HTTPS 协议传输握手的完整过程。你可以只看从<code>192.168.1.5</code>到<code>14.215.177.39</code>的请求。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803112917.png" alt="image-20210803112917193"></p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113019.png" alt="image-20210803113019378"></p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113046.png" alt="image-20210803113046506"></p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113103.png" alt="image-20210803113103219"></p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803113115.png" alt="image-20210803113114942"></p>
<p>报文颜色<br>在抓包过程中，黑色报文代表各类报文错误；红色代表出现异常；其他颜色代表正常传输。</p>
<p>Wireshark 是个强大的工具，支持大量的协议。还有很多关于 Wireshark 的能力，希望你可以进一步探索，如下图中鼠标右键一次捕获，可以看到很多选项，都是可以深挖的。</p>
<h3 id="模块二加餐"><a href="#模块二加餐" class="headerlink" title="模块二加餐"></a>模块二加餐</h3><h4 id="下面这几个地址-127-0-0-1-localhost-0-0-0-0-有什么不同？"><a href="#下面这几个地址-127-0-0-1-localhost-0-0-0-0-有什么不同？" class="headerlink" title="下面这几个地址 127.0.0.1, localhost, 0.0.0.0 有什么不同？"></a>下面这几个地址 127.0.0.1, localhost, 0.0.0.0 有什么不同？</h4><p>127.0.0.1是本地回环地址（loopback），发送到 loopback 的数据会被转发到本地应用。</p>
<p>localhost 指代的是本地计算机，用于访问绑定在 loopback 上的服务。localhost 是一个主机名，不仅仅可以指向 IPv4 的本地回环地址，也可以指向 IPv6 的本地回环地址 [::1]。</p>
<p>0.0.0.0是一个特殊目的 IP 地址，称作不可路由 IP 地址，它的用途会被特殊规定。通常情况下，当我们把一个服务绑定到0.0.0.0，相当于把服务绑定到任意的 IP 地址。比如一台服务器上有多个网卡，不同网卡连接不同的网络，如果服务绑定到 0.0.0.0 就可以保证服务在多个 IP 地址上都可以用。</p>
<h4 id="IPv6-和-IPv4-究竟有哪些区别？"><a href="#IPv6-和-IPv4-究竟有哪些区别？" class="headerlink" title="IPv6 和 IPv4 究竟有哪些区别？"></a>IPv6 和 IPv4 究竟有哪些区别？</h4><p>IPv6 和 IPv4 最核心的区别是地址空间大小不同。IPv6 用 128 位地址，解决了 IP 地址耗尽问题。因为地址空间大小不同，它们对地址的定义，对路由寻址策略都有显著的差异。</p>
<p>在路由寻址策略上，IPv6 消除了设备间地址冲突的问题，改变了划分子网的方式。在 IPv4 网络中，一个局域网往往会共享一个公网 IP，因此需要 NAT 协议和外网连接。</p>
<p>在划分子网的时候，IPv4 地址少，需要子网掩码来处理划分子网。IPv6 有充足的地址，因此不需要局域网共享外网 IP。也正因为 IPv6 地址多，可以直接将 IPv6 地址划分成站点、子网、设备，每个段都有充足的 IP 地址。</p>
<p>因为 IPv6 支持的 IP 地址数量大大上升，一个子网可以有 248 个 IP 地址，这个子网可能是公司网络、家庭网络等。这样 IP 地址的分配方式也发生了变化，IPv4 网络中设备分配 IP 地址的方式是中心化的，由 DHCP（动态主机协议）为局域网中的设备分配 IP 地址。而在 IPv6 网络中，因为 IP 地址很少发生冲突，可以由设备自己申请自己的 IP 地址。</p>
<p>另外因为 IPv6 中任何一个节点都可以是一个组播节点，这样就可以构造一个对等的网络，也就是可以支持在没有中心化的路由器，或者一个网络多个路由器的情况下工作。节点可以通过向周围节点类似打探消息的方式，发现更多的节点。这是一个配套 IPv6 的能力，叫作邻居发现（ND）。</p>
<h4 id="IPv6-协议还需要-NAT-吗？"><a href="#IPv6-协议还需要-NAT-吗？" class="headerlink" title="IPv6 协议还需要 NAT 吗？"></a>IPv6 协议还需要 NAT 吗？</h4><p>IPv6 解决了 IP 耗尽的问题，为机构、组织、公司、家庭等网络提供了充足的 IP 资源，从这个角度看是不是就不需要 NAT 协议了呢？</p>
<p>在没有 IPv6 之前，NAT 是 IP 资源耗尽的主流解决方案。在一个内网中的全部设备通过 NAT 协议共享一个外网的 IPv4 地址，是目前内外网对接的主要方式。IPv6 地址资源充足，可以给全球每个设备一个独立的地址。从这个角度看 IPv6 的确不需要 NAT 协议。</p>
<p>但是目前的情况，是 IPv6 网络还没有完全普及。尽管很多公司已经支持自己的互联网产品可以使用 IPv6 访问，但是公司内部员工使用的内部网络还是 IPv4。如果要连接 IPv6 和 IPv4 网络，仍然需要 NAT 协议（NAT64），这个协议可以让多个 IPv6 的设备共享一个 IPv4 的公网地址。</p>
<h4 id="写一个-UDP-连接程序，然后用-Wireshark-抓包。"><a href="#写一个-UDP-连接程序，然后用-Wireshark-抓包。" class="headerlink" title="写一个 UDP 连接程序，然后用 Wireshark 抓包。"></a>写一个 UDP 连接程序，然后用 Wireshark 抓包。</h4><p>服务端程序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> byte[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">    DatagramPacket packet</span><br><span class="line"></span><br><span class="line">            = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"try receive..."</span>);</span><br><span class="line"></span><br><span class="line">    socket.receive(packet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> address = packet.getAddress();</span><br><span class="line"></span><br><span class="line">    int port = packet.getPort();</span><br><span class="line"></span><br><span class="line">    packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length, address, port);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> received</span><br><span class="line"></span><br><span class="line">            = <span class="keyword">new</span> <span class="built_in">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line"></span><br><span class="line">    socket.send(packet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> buf = <span class="string">"Hello"</span>.getBytes();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> address = InetAddress.getByName(<span class="string">"localhost"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> packet</span><br><span class="line"></span><br><span class="line">          = <span class="keyword">new</span> DatagramPacket(buf, buf.length, address, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">  socket.send(packet);</span><br><span class="line"></span><br><span class="line">  socket.receive(packet);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> received = <span class="keyword">new</span> <span class="built_in">String</span>(</span><br><span class="line"></span><br><span class="line">          packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line"></span><br><span class="line">  System.out.format(<span class="string">"Server echo : %s\n"</span>, received);</span><br></pre></td></tr></table></figure>

<p>发现发送和接收的都是<code>Datagram</code>报文。而且服务端和客户端之间不需要建立连接。服务端可以通过读取客户端的地址区分客户端，客户端通过服务端地址和端口发送数据到服务端。</p>
<h3 id="Socket-编程：epoll-为什么用红黑树？"><a href="#Socket-编程：epoll-为什么用红黑树？" class="headerlink" title="Socket 编程：epoll 为什么用红黑树？"></a>Socket 编程：epoll 为什么用红黑树？</h3><p>从编程的角度来看，客户端将数据发送给在客户端侧的<strong>Socket 对象</strong>，然后客户端侧的 Socket 对象将数据发送给服务端侧的 Socket 对象。<strong>Socket 对象负责提供通信能力，并处理底层的 TCP 连接/UDP 连接</strong>。对服务端而言，每一个客户端接入，就会形成一个和客户端对应的 Socket 对象，如果服务器要读取客户端发送的信息，或者向客户端发送信息，就需要通过这个客户端 Socket 对象。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803144303.png" alt="image-20210803144303830"></p>
<p><strong>但是如果从另一个角度去分析，Socket 还是一种文件，准确来说是一种双向管道文件</strong>。什么是管道文件呢？管道会将一个程序的输出，导向另一个程序的输入。那么什么是双向管道文件呢？双向管道文件连接的程序是对等的，都可以作为输入和输出。</p>
<p>比如下面这段服务端侧程序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">80</span>));</span><br></pre></td></tr></table></figure>

<p>看起来我们创建的是一个服务端 Socket 对象，但如果单纯看这个对象，它又代表什么呢？如果我们理解成代表服务端本身合不合理呢——这可能会比较抽象，在服务端存在一个服务端 Socket。但如果我们从管道文件的层面去理解它，就会比较容易了。其一，这是一个文件；其二，它里面存的是所有客户端 Socket 文件的文件描述符。</p>
<p>当一个客户端连接到服务端的时候，操作系统就会创建一个客户端 Socket 的文件。然后操作系统将这个文件的文件描述符写入服务端程序创建的服务端 Socket 文件中。服务端 Socket 文件，是一个管道文件。如果读取这个文件的内容，就相当于从管道中取走了一个客户端文件描述符。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803145544.png" alt="image-20210803145544248"></p>
<p>如上图所示，服务端 Socket 文件相当于一个客户端 Socket 的目录，线程可以通过 accept() 操作每次拿走一个客户端文件描述符。拿到客户端文件描述符，就相当于拿到了和客户端进行通信的接口。</p>
<p>前面我们提到 Socket 是一个双向的管道文件，当线程想要读取客户端传输来的数据时，就从客户端 Socket 文件中读取数据；当线程想要发送数据到客户端时，就向客户端 Socket 文件中写入数据。<strong>客户端 Socket 是一个双向管道，操作系统将客户端传来的数据写入这个管道，也将线程写入管道的数据发送到客户端</strong>。</p>
<p>有同学会说，那既然可以双向传送，这不就是两个单向管道被拼凑在了一起吗？这里具体的实现取决于操作系统，Linux 中的管道文件都是单向的，因此 Socket 文件是一种区别于原有操作系统管道的单独的实现。</p>
<p>总结下，Socket 首先是文件，存储的是数据。对服务端而言，分成服务端 Socket 文件和客户端 Socket 文件。服务端 Socket 文件存储的是客户端 Socket 文件描述符；客户端 Socket 文件存储的是传输的数据。读取客户端 Socket 文件，就是读取客户端发送来的数据；写入客户端文件，就是向客户端发送数据。对一个客户端而言， Socket 文件存储的是发送给服务端（或接收的）数据。</p>
<p><strong>综上，Socket 首先是文件，在文件的基础上，又封装了一段程序，这段程序提供了 API 负责最终的数据传输</strong>。</p>
<h4 id="服务端-Socket-的绑定"><a href="#服务端-Socket-的绑定" class="headerlink" title="服务端 Socket 的绑定"></a>服务端 Socket 的绑定</h4><p>为了区分应用，对于一个服务端 Socket 文件，我们要设置它监听的端口。比如 Nginx 监听 80 端口、Node 监听 3000 端口、SSH 监听 22 端口、Tomcat 监听 8080 端口。端口监听不能冲突，不然客户端连接进来创建客户端 Socket 文件，文件描述符就不知道写入哪个服务端 Socket 文件了。这样操作系统就会把连接到不同端口的客户端分类，将客户端 Socket 文件描述符存到对应不同端口的服务端 Socket 文件中。</p>
<p><strong>因此，服务端监听端口的本质，是将服务端 Socket 文件和端口绑定，这个操作也称为 bind</strong>。有时候我们不仅仅绑定端口，还需要绑定 IP 地址。这是因为有时候我们只想允许指定 IP 访问我们的服务端程序。</p>
<h4 id="扫描和监听"><a href="#扫描和监听" class="headerlink" title="扫描和监听"></a>扫描和监听</h4><p>对于一个服务端程序，可以定期扫描服务端 Socket 文件的变更，来了解有哪些客户端想要连接进来。如果在服务端 Socket 文件中读取到一个客户端的文件描述符，就可以将这个文件描述符实例化成一个 Socket 对象。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803152908.png" alt="image-20210803152908750"></p>
<p>之后，服务端可以将这个 Socket 对象加入一个容器（集合），通过定期遍历所有的客户端 Socket 对象，查看背后 Socket 文件的状态，从而确定是否有新的数据从客户端传输过来。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803153001.png" alt="image-20210803153001467"></p>
<p>上述的过程，我们通过一个线程就可以响应多个客户端的连接，也被称作<strong>I/O 多路复用技术</strong>。</p>
<h4 id="响应式（Reactive）"><a href="#响应式（Reactive）" class="headerlink" title="响应式（Reactive）"></a>响应式（Reactive）</h4><p>在 I/O 多路复用技术中，服务端程序（线程）需要维护一个 Socket 的集合（可以是数组、链表等），然后定期遍历这个集合。这样的做法在客户端 Socket 较少的情况下没有问题，但是如果接入的客户端 Socket 较多，比如达到上万，那么每次轮询的开销都会很大。</p>
<p>从程序设计的角度来看，像这样主动遍历，比如遍历一个 Socket 集合看看有没有发生写入（有数据从网卡传过来），称为<strong>命令式的程序</strong>。这样的程序设计就好像在执行一条条命令一样，程序主动地去查看每个 Socket 的状态。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803153240.png" alt="image-20210803153240124"></p>
<p>命令式会让负责下命令的程序负载过重，例如，在高并发场景下，上述讨论中循环遍历 Socket 集合的线程，会因为负担过重导致系统吞吐量下降。</p>
<p>与命令式相反的是响应式（Reactive），响应式的程序就不会有这样的问题。在响应式的程序当中，每一个参与者有着独立的思考方式，就好像拥有独立的人格，可以自己针对不同的环境触发不同的行为。</p>
<p>从响应式的角度去看 Socket 编程，应该是有某个观察者会观察到 Socket 文件状态的变化，从而通知处理线程响应。线程不再需要遍历 Socket 集合，而是等待观察程序的通知。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210803153251.png" alt="image-20210803153251665"></p>
<p>当然，最合适的观察者其实是操作系统本身，因为只有操作系统非常清楚每一个 Socket 文件的状态。原因是对 Socket 文件的读写都要经过操作系统。在实现这个模型的时候，有几件事情要注意。</p>
<ol>
<li>线程需要告诉中间的观察者自己要观察什么，或者说在什么情况下才响应？比如具体到哪个 Socket 发生了什么事件？是读写还是其他的事件？这一步我们通常称为<strong>注册</strong>。</li>
<li>中间的观察者需要实现一个高效的数据结构（通常是基于红黑树的二叉搜索树）。这是因为中间的观察者不仅仅是服务于某个线程，而是服务于很多的线程。当一个 Socket 文件发生变化的时候，中间观察者需要立刻知道，究竟是哪个线程需要这个信息，而不是将所有的线程都遍历一遍。</li>
</ol>
<h4 id="为什么用红黑树？"><a href="#为什么用红黑树？" class="headerlink" title="为什么用红黑树？"></a>为什么用红黑树？</h4><p>关于为什么要红黑树，这里我给你再仔细解释一下。考虑到中间观察者最核心的诉求有两个。</p>
<p><strong>第一个核心诉求，是让线程可以注册自己关心的消息类型</strong>。比如线程对文件描述符 =123 的 Socket 文件读写都感兴趣，会去中间观察者处注册。当 FD=123 的 Socket 发生读写时，中间观察者负责通知线程，这是一个响应式的模型。</p>
<p><strong>第二个核心诉求，是当 FD=123 的 Socket 发生变化（读写等）时，能够快速地判断是哪个线程需要知道这个消息</strong>。</p>
<p>所以，中间观察者需要一个快速能插入（注册过程）、查询（通知过程）一个整数的数据结构，这个整数就是 Socket 的文件描述符。综合来看，能够解决这个问题的数据结构中，跳表和二叉搜索树都是不错的选择。</p>
<p>因此，在 Linux 的 epoll 模型中，选择了红黑树。红黑树是二叉搜索树的一种，红与黑是红黑树的实现者才关心的内容，对于我们使用者来说不用关心颜色，Java 中的 TreeMap 底层就是红黑树。</p>
<h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p>总结一下，<strong>Socket 既是一种编程模型，或者说是一段程序，同时也是一个文件，一个双向管道文件</strong>。你也可以这样理解，Socket API 是在 Socket 文件基础上进行的一层封装，而 Socket 文件是操作系统提供支持网络通信的一种文件格式。</p>
<p>在服务端有两种 Socket 文件，每个客户端接入之后会形成一个客户端的 Socket 文件，客户端 Socket 文件的文件描述符会存入服务端 Socket 文件。通过这种方式，一个线程可以通过读取服务端 Socket 文件中的内容拿到所有的客户端 Socket。这样一个线程就可以负责响应所有客户端的 I/O，这个技术称为 I/O 多路复用。</p>
<p>主动式的 I/O 多路复用，对负责 I/O 的线程压力过大，因此通常会设计一个高效的中间数据结构作为 I/O 事件的观察者，线程通过订阅 I/O 事件被动响应，这就是响应式模型。在 Socket 编程中，最适合提供这种中间数据结构的就是操作系统的内核，事实上 epoll 模型也是在操作系统的内核中提供了红黑树结构。</p>
<h4 id="epoll-为什么用红黑树？"><a href="#epoll-为什么用红黑树？" class="headerlink" title="epoll 为什么用红黑树？"></a><strong>epoll 为什么用红黑树</strong>？</h4><p>【<strong>解析</strong>】在 Linux 的设计中有三种典型的 I/O 多路复用模型 select、poll、epoll。</p>
<p>select 是一个主动模型，需要线程自己通过一个集合存放所有的 Socket，然后发生 I/O 变化的时候遍历。在 select 模型下，操作系统不知道哪个线程应该响应哪个事件，而是由线程自己去操作系统看有没有发生网络 I/O 事件，然后再遍历自己管理的所有 Socket，看看这些 Socket 有没有发生变化。</p>
<p>poll 提供了更优质的编程接口，但是本质和 select 模型相同。因此千级并发以下的 I/O，你可以考虑 select 和 poll，但是如果出现更大的并发量，就需要用 epoll 模型。</p>
<p>epoll 模型在操作系统内核中提供了一个中间数据结构，这个中间数据结构会提供事件监听注册，以及快速判断消息关联到哪个线程的能力（红黑树实现）。因此在高并发 I/O 下，可以考虑 epoll 模型，它的速度更快，开销更小。</p>
<h3 id="流和缓冲区：缓冲区的-flip-是怎么回事？"><a href="#流和缓冲区：缓冲区的-flip-是怎么回事？" class="headerlink" title="流和缓冲区：缓冲区的 flip 是怎么回事？"></a>流和缓冲区：缓冲区的 flip 是怎么回事？</h3><p>计算机中，数据往往会被抽象成流，然后传输。比如读取一个文件，数据会被抽象成文件流；播放一个视频，视频被抽象成视频流。处理节点为了防止过载，又会使用缓冲区削峰（减少瞬间压力）。在传输层协议当中，应用往往先把数据放入缓冲区，然后再将缓冲区提供给发送数据的程序。发送数据的程序，从缓冲区读取出数据，然后进行发送。</p>
<h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>流代表数据，具体来说是随着时间产生的数据，类比自然界的河流。你不知道一个流什么时候会完结，直到你将流中的数据都读完。</p>
<p>读取文件的时候，文件被抽象成流。流的内部构造，决定了你每次能从文件中读取多少数据。从流中读取数据的操作，本质上是一种迭代器。流的内部构造决定了迭代器每次能读出的数据规模。比如你可以设计一个读文件的流，每次至少会读出 4k 大小，也可以设计一个读文件的程序，每次读出一个字节大小。</p>
<p>通常情况读取数据的流，是读取流；写入数据的流，是写入流。那么一个写入流还能被理解成随着时间产生的数据吗？其实是一样的，随着时间产生的数据，通过写入流写入某个文件，或者被其他线程、程序拿走使用。</p>
<p>这里请你思考一个问题：流中一定有数据吗？看上去的确是这样。对于文件流来说，打开一个文件，形成读取流。读取流的本质当然是内存中的一个对象。当用户读取文件内容的时候，实际上是通过流进行读取，看上去好像从流中读取了数据，而本质上读取的是文件的数据。从这个角度去观察整体的设计，数据从文件到了流，然后再到了用户线程，因此数据是经过流的。</p>
<p>但是仔细思考这个问题，可不可以将数据直接从文件传输到用户线程呢？比如流对象中只设计一个整数型指针，一开始指向文件的头部，每次发生读取，都从文件中读出内容，然后再返回给用户线程。做完这次操作，指针自增。通过这样的设计，流中就不需要再有数据了。可见，流中不一定要有数据。再举一个极端的例子，如果我们设计一个随机数的产生流，每次读取流中的数据，都调用随机数函数生成一个随机数并返回，那么流中也不需要有数据的存储。</p>
<h4 id="为什么要缓冲区？"><a href="#为什么要缓冲区？" class="headerlink" title="为什么要缓冲区？"></a>为什么要缓冲区？</h4><p>在上面的例子当中，我们讨论的时候发现，设计文件流时，可以只保留一个位置指针，不用真的将整个文件都读入内存，像下图这样：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805093142.png" alt="image-20210805093135218"></p>
<p>把文件看作是一系列线性排列连续字节的合集，用户线程调用流对象的读取数据方法，每次从文件中读取一个字节。流中只保留一个读取位置 position，指向下一个要读取的字节。</p>
<p>看上去这个方案可行，但实际上性能极差。因为从文件中读取数据这个操作，是一次磁盘的 I/O 操作，非常耗时。正确的做法是每次读取 2k、4k 这样大小的数据，这是因为操作系统中的内存分页通常是这样的大小，而磁盘的读写往往是会适配页表大小。而且现在的文件系统主要都是日志文件系统，存储的并不是原始数据本身，也就是说多数情况下你看到的文件并不是一个连续紧密的字节线性排列，而是日志。关于这块内容，具体可以参考《重学操作系统》中《30 | 文件系统的底层实现：FAT、NTFS 和 Ext3 有什么区别》。</p>
<p>如果你不想花时间再去完整地学习一遍“操作系统”相关的内容，我这里先给一个结论：当你向磁盘读取 2k 数据，读取到的不一定是 2k 实际的数据，很有可能会比 2k 少，这是因为文件内容是以日志形式存储，会有冗余。</p>
<p>我们用下面这张图来描述下需求：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805093848.png" alt="image-20210805093848249"></p>
<p>如上图所示，内核每次从文件系统中读取到的数据是确定的，但是里边的有效数据是不确定的。流对象的设计，至少应该支持两种操作：一种是读取一个字节，另一种是读取多个字节。而无论读取一个字节还是读取多个字节，都应该适配内核的底层行为。也就是说，每次流对象读取一个字节，内核可能会读取 2k、4k 的数据。这样的行为，才能真的做到减少磁盘的 I/O 操作。那么有同学可能会问：内核为什么不一次先读取几兆数据或者读取更大的数据呢？这有两个原因。</p>
<p>如果是高并发场景下，并发读取数据时内存使用是根据并发数翻倍的，如果同时读取的数据量过大，可能会导致内存不足。</p>
<p>读取比 2k/4k……大很多倍的数据，比如 1M/2M 这种远远大于内存分页大小的数据，并不能提升性能。</p>
<p>所以最后我们的解决办就是创建两个缓冲区。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805093929.png" alt="image-20210805093928925"></p>
<p>上图中内核中的缓冲区，用于缓冲读取文件中的数据。流中的缓冲区，用于缓冲内核中拷贝过来的数据。有同学可能不理解，为什么不把内核的缓冲区直接给到流呢？这是因为流对象工作在用户空间，内核中的缓冲区工作在内核空间。用户空间的程序不可以直接访问内核空间的数据，这是操作系统的一种保护策略。具体可以参考《重学操作系统》中《14 | 用户态和内核态：用户态线程和内核态线程有什么区别？》，这里不再赘述。</p>
<p>当然也存在一种叫作内存映射的方式，就是内核通过内存映射，直接将内核空间中的一块内存区域分享给用户空间只读使用，这样的方式可以节省一次数据拷贝。这个能力在 Java 的 NIO 中称作 DirectMemory，对应 C 语言是 mmap。</p>
<h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>上面的设计中，我们已经开始用缓冲区解决问题了。那么具体什么是缓冲区呢？缓冲区就是一块用来做缓冲的内存区域。在上面的例子当中，为了应对频繁的字节读取，我们在内存当中设置一个 2k 大小缓冲区。这样读取 2048 次，才会真的发生一次读取。同理，如果应对频繁的字节写入，也可以使用缓冲区。</p>
<p>不仅仅如此，比如说你设计一个秒杀系统，如果同时到达的流量过高，也可以使用缓冲区将用户请求先存储下来，再进行处理。这个操作我们称为削峰，削去流量的峰值。</p>
<p>缓冲区中的数据通常具有朴素的公平，说白了就是排队，先进先出（FIFO）。从数据结构的设计上，缓冲区像一个队列。在实际的使用场景中，缓冲区有一些自己特别的需求，比如说缓冲区需要被重复利用。多次读取数据，可以复用一个缓冲区，这样可以节省内存，也可以减少分配和回收内存的开销。</p>
<p>举个例子：读取一个流的数据到一个缓冲区，然后再将缓冲区中的数据交给另一个流。 比如说读取文件流中的数据交给网络流发送出去。首先，我们要将文件流的数据写入缓冲区，然后网络流会读取缓冲区中的数据。这个过程会反反复复进行，直到文件内容全部发送。</p>
<p>这个设计中，缓冲区需要支持这几种操作：</p>
<p>写入数据</p>
<p>读出数据</p>
<p>清空（应对下一次读写）</p>
<p>那么具体怎么设计这个缓冲区呢？首先，数据可以考虑存放到一个数组中，下图是可以存 8 个字节的缓冲区：</p>
<p>写入数据的时候，需要一个指针指向下一个可以写入的位置，如下图所示：</p>
<p>每次写入数据，position 增 1，比如我们顺序写入 a,b,c,d 后，缓冲区如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805112609.png" alt="image-20210805112609774"></p>
<p>那么如果这个时候，要切换到读取状态该怎么做呢？再增加一个读取指针吗？聪明的设计者想到了一个办法，增加一个 limit 指针，随着写入指针一起增长，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805112645.png" alt="image-20210805112645759"></p>
<p>当需要切换到读取状态的时候，将 position 设置为 0，limit 不变即可。下图中，我们可以从 0 开始读取数据，每次读取 position 增 1。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210805112658.png" alt="image-20210805112658630"></p>
<p>我们将 position 设置为 0，limit 不变的操作称为flip操作，flip 本意是翻转，在这个场景中是读、写状态的切换。</p>
<p>读取操作可以控制循环从 position 一直读取到 limit，这样就可以读取出 a,b,c,d。那么如果要继续写入应该如何操作呢？ 这个时候就需要用到缓冲区的clear操作，这个操作会清空缓冲区。具体来说，clear操作会把 position,limit 都设置为 0，而不需要真的一点点擦除缓冲区中已有的值，就可以做到重复利用缓冲区了。</p>
<p>写入过程从 position = 0 开始，position 和 limit 一起自增。读取时，用flip操作切换缓冲区读写状态。读取数据完毕，用clear操作重置缓冲区状态。</p>
<p>总结<br>总结一下，流是随着时间产生的数据。数据抽象成流，是因为客观世界存在着这样的现象。数据被抽象成流之后，我们不需要把所有的数据都读取到内存当中进行计算和迭代，而是每次处理或者计算一个缓冲区的数据。</p>
<p>缓冲区的作用是缓冲，它在高频的 I/O 操作中很有意义。针对不同场景，也不只有这一种缓冲区的设计，比如用双向链表实现队列（FIFO 结构）可以作为缓冲区；Redis 中的列表可以作为缓冲区；RocketMQ，Kafka 等也可以作为缓冲区。针对某些特定场景，比如高并发场景下的下单处理，可能会用订单队列表（MySQL 的表）作为缓冲区。</p>
<p>因此从这个角度来说，作为开发者我们首先要有缓冲的意识，去减少 I/O 的次数，提升 I/O 的性能，然后才是思考具体的缓冲策略。</p>
<p>那么通过这一讲的学习，你可以尝试来回答本讲关联的面试题目：缓冲区的 flip 操作是怎么回事？</p>
<p>【解析】flip 操作意味翻转，是切换缓冲区的读写状态，在 flip 操作中，通常将 position 指针置 0，limit 指针不变。</p>
<h3 id="网络-I-O-模型：BIO、NIO-和-AIO-有什么区别？"><a href="#网络-I-O-模型：BIO、NIO-和-AIO-有什么区别？" class="headerlink" title="网络 I/O 模型：BIO、NIO 和 AIO 有什么区别？"></a>网络 I/O 模型：BIO、NIO 和 AIO 有什么区别？</h3><p>从本质上说，讨论 BIO、NIO、AIO 的区别，其实就是在讨论 I/O 的模型，我们可以从下面 3 个方面来思考 。</p>
<p>编程模型：合理设计 API，让程序写得更舒服。</p>
<p>数据的传输和转化成本：比如减少数据拷贝次数，合理压缩数据等。</p>
<p>高效的数据结构：利用好缓冲区、红黑树等（见本讲后续讨论）。</p>
<h4 id="I-O-的编程模型"><a href="#I-O-的编程模型" class="headerlink" title="I/O 的编程模型"></a>I/O 的编程模型</h4><p>我们先从编程模型上讨论下 BIO、NIO 和 AIO 的区别。</p>
<p>BIO（Blocking I/O，阻塞 I/O），API 的设计会阻塞程序调用。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte a = readKey()</span><br></pre></td></tr></table></figure>

<p>假设<code>readKey</code>方法会从键盘中读取一个用户的按键，如果是阻塞 I/O 的设计，ReadKey 会阻塞当前用户线程直到用户按键。这个阻塞指的是线程进入<strong>阻塞态</strong>。进入阻塞态的线程，状态会被存在内存中，执行会被中断，也就是不会占用 CPU å资源。阻塞态的线程要恢复执行，先要进入<strong>就绪态</strong>排队，然后轮到自己才能够继续执行。从一个线程执行切换到另一个线程执行，也叫作<strong>线程的上下文切换</strong>（Context Switch），是一个相对耗时的操作。</p>
<p>再说说 NIO （None Blocking I/O，非阻塞 IO），API 的设计不会阻塞程序的调用，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte a = readKey()</span><br></pre></td></tr></table></figure>

<p>假设<code>readKey</code>方法从键盘读取一个按键，如果是非阻塞 I/O 的设计，<code>readKey</code>不会阻塞当前的线程。你可能会问：那如果用户没有按键怎么办？在阻塞 I/O 的设计中，如果用户没有按键线程会阻塞等待用户按键，在非阻塞 I/O 的设计中，线程不会阻塞，没有按键会返回一个空值，比如 null。</p>
<p>最后我们说说 AIO（Asynchronous I/O， 异步 I/O），API 的设计会多创造一条时间线。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func callBackFunction(byte keyCode) &#123;</span><br><span class="line">  // 处理按键</span><br><span class="line">&#125;</span><br><span class="line">readKey( callBackFunction )</span><br></pre></td></tr></table></figure>

<p>在异步 I/O 中，<code>readKey</code>方法会直接返回，但是没有结果。结果需要一个回调函数<code>callBackFunction</code>去接收。从这个角度看，其实有两条时间线。第一条是程序的主干时间线，<code>readKey</code>的执行到<code>readKey</code>下文的程序都在这条主干时间线中。而<code>callBackFunction</code>的执行会在用户按键时触发，也就是时间不确定，因此<code>callBackFunction</code>中的程序是另一条时间线也是基于这种原因产生的，我们称作<strong>异步</strong>，异步描述的就是这种时间线上无法同步的现象，你不知道<code>callbackFunction</code>何时会执行。</p>
<p>但是我们通常说某某语言提供了异步 I/O，不仅仅是说提供上面程序这种写法，上面的写法会产生一个叫作<strong>回调地狱</strong>的问题，本质是异步程序的时间线错乱，导致维护成本较高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request(&quot;/order/123&quot;, (data1) -&gt; &#123;</span><br><span class="line">  //..</span><br><span class="line">  request(&quot;/product/456&quot;, (data2) -&gt; &#123;</span><br><span class="line">    // ..</span><br><span class="line">    request(&quot;/sku/789&quot;, (data3) -&gt; &#123;</span><br><span class="line">      //...</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>比如上面这段程序（称作回调地狱）维护成本较高，因此通常提供异步 API 编程模型时，我们会提供一种将异步转化为同步程序的语法。比如下面这段伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future future1 = request(&quot;/order/123&quot;)</span><br><span class="line">Future future2 = request(&quot;/product/456&quot;)</span><br><span class="line">Future future3 = request(&quot;/sku/789&quot;)</span><br><span class="line">// ...</span><br><span class="line">// ...</span><br><span class="line">order = future1.get()</span><br><span class="line">product = future2.get()</span><br><span class="line">sku = future3.get()</span><br></pre></td></tr></table></figure>

<p>request 函数是一次网络调用，请求订单 ID=123 的订单数据。本身 request 函数不会阻塞，会马上执行完成，而网络调用是一次异步请求，调用不会在<code>request(&quot;/order/123&quot;)</code>下一行结束，而是会在未来的某个时间结束。因此，我们用一个 Future 对象封装这个异步操作。<code>future.get()</code>是一个阻塞操作，会阻塞直到网络调用返回。</p>
<p>在<code>request</code>和<code>future.get</code>之间，我们还可以进行很多别的操作，比如发送更多的请求。 像 Future 这样能够将异步操作再同步回主时间线的操作，我们称作<strong>异步转同步</strong>，也叫作<strong>异步编程</strong>。通常一门语言如果提供异步编程的能力，指的是提供异步转同步的能力，程序员更适应同步操作，同步程序更好维护。</p>
<h4 id="数据的传输和转化成本"><a href="#数据的传输和转化成本" class="headerlink" title="数据的传输和转化成本"></a>数据的传输和转化成本</h4><p>上面我们从编程的模型上对 I/O 进行了思考，接下来我们从内部实现分析下 BIO、NIO 和 AIO。无论是哪种 I/O 模型，都要将数据从网卡拷贝到用户程序（接收），或者将数据从用户程序传输到网卡（发送）。另一方面，有的数据需要编码解码，比如 JSON 格式的数据。还有的数据需要压缩和解压。数据从网卡到内核再到用户程序是 2 次传输。注意，将数据从内存中的一个区域拷贝到另一个区域，这是一个 CPU 密集型操作。数据的拷贝归根结底要一个字节一个字节去做。</p>
<p>从网卡到内核空间的这步操作，可以用 DMA（Direct Memory Access）技术控制。DMA 是一种小型设备，用 DMA 拷贝数据可以不使用 CPU，从而节省计算资源。遗憾的是，通常我们写程序的时候，不能直接控制 DMA，因此 DMA 仅仅用于设备传输数据到内存中。不过，从内核到用户空间这次拷贝，可以用内存映射技术，将内核空间的数据映射到用户空间。</p>
<blockquote>
<p>本文关于 DMA 技术和多线程讨论较浅，对这两个技术感兴趣的同学可以看下我在拉勾教育平台推出的<a href="https://shenceyun.lagou.com/t/Axo?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noopener">《重学操作系统》</a>专栏。</p>
</blockquote>
<p>有同学会问：上面我们讨论的内容和 I/O 模型有什么关联吗？其实我是想告诉你，无论 I/O 的编程模型如何选择，数据传输和转化成本是逃不掉的。或者说不会因为选择某种模型，就减少数据传输、数据压缩解压、数据编码解码这方面的成本。但是通过 DMA 技术和内存映射技术，就可以节省这部分成本。<strong>之所以会特别强调这点，是因为网上很多的博文会把 DMA、内存映射技术和 BIO/AIO/NIO 等概念混为一谈。</strong></p>
<h4 id="数据结构运用"><a href="#数据结构运用" class="headerlink" title="数据结构运用"></a>数据结构运用</h4><p>在处理网络 I/O 问题的时候，还有一个重点问题要注意，就是数据结构的运用。</p>
<h4 id="缓冲区-1"><a href="#缓冲区-1" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>缓冲区是一种在处理 I/O 问题中常用的数据结构，<strong>一方面缓冲区起到缓冲作用</strong>，在瞬时 I/O 量较大的时候，利用排队机制进行处理。<strong>另一方面，缓冲区起到一个批处理的作用</strong>，比如 1000 次 I/O 请求进入缓冲区，可以合并成 50 次 I/O 请求，那么整体性能就会上一个档次。</p>
<p>举个例子，比如你有 1000 个订单要写入 MySQL，如果这个时候你可以将这 1000 次请求合并成 50 次，那么磁盘写入次数将大大减少。同理，假设有 10000 次网络请求，如果可以合并发送，会减少 TCP 协议握手时间，可以最大程度地复用连接；另一方面，如果这些请求都较小，还可以粘包复用 TCP 段。在处理 Web 网站的时候，经常会碰到将多个 HTTP 请求合并成一个发送，从而减少整体网络开销的情况。</p>
<p><strong>除了上述两方面原因，缓冲区还可以减少实际对内存的诉求</strong>。数据在网卡到内核，内核到用户空间的过程中，建议都要使用缓冲区。当收到的某个请求较大的时候，抽象成流，然后使用缓冲区可以减少对内存的使用压力。这是因为使用了缓冲区和流，就不需要真的准备和请求数据大小一致的内存空间了。可以将缓冲区大小规模的数据分成多次处理完，实际的内存开销是缓冲区的大小。</p>
<h4 id="I-O-多路复用模型"><a href="#I-O-多路复用模型" class="headerlink" title="I/O 多路复用模型"></a>I/O 多路复用模型</h4><p>在运用数据结构的时候，还要思考 I/O 的多路复用用什么模型。</p>
<p>假设你在处理一个高并发的网站，每秒有大量的请求打到你的服务器上，你用多少个线程去处理 I/O 呢？对于没有需要压缩解压的场景，处理 I/O 的主要开销还是数据的拷贝。那么一个 CPU 核心每秒可以完成多少次数据拷贝呢？</p>
<p>拷贝，其实就是将内存中的数据从一个地址拷贝到另一个地址。再加上有 DMA，内存映射等技术，拷贝是非常快的。不考虑 DMA 和内存映射，一个 3GHz 主频的 CPU 每秒可以拷贝的数据也是百兆级别的。当然，速度还受限于内存本身的速度。<strong>因此总的来说，I/O 并不需要很大的计算资源</strong>。通常我们在处理高并发的时候，也不需要大量的线程去进行 I/O 处理。</p>
<p>对于多数应用来说，处理 I/O 的成本小于处理业务的成本。处理高并发的业务，可能需要大量的计算资源。每笔业务也可能会需要更多的 I/O，比如远程的 RPC 调用等。</p>
<p><strong>因此我们在处理高并发的时候，一种常见的 I/O 多路复用模式就是由少量的线程处理大量的网络接收、发送工作。然后再由更多的线程，通常是一个线程池处理具体的业务工作</strong>。在这样一个模式下，有一个核心问题需要解决，就是当操作系统内核监测到一次 I/O 操作发生，它如何具体地通知到哪个线程调用哪段程序呢？</p>
<p>这时，一种高效的模型会要求我们将线程、线程监听的事件类型，以及响应的程序注册到内核。具体来说，比如某个客户端发送消息到服务器的时候，我们需要尽快知道哪个线程关心这条消息（处理这个数据）。例如 epoll 就是这样的模型，内部是红黑树。我们可以具体地看到文件描述符构成了一棵红黑树，而红黑树的节点上挂着文件描述符对应的线程、线程监听事件类型以及相应程序。</p>
<p>最后，你可能会问：老师你讲了这么多，和 BIO、AIO、NIO 有什么关系？这里有两个联系。</p>
<p><strong>首先是无论哪种编程模型都需要使用缓冲区，也就是说 BIO、AIO、NIO 都需要缓冲区</strong>，因此关系很大。在我们使用任何编程模型的时候，如果内部没有使用缓冲区，那么一定要在外部增加缓冲区。<strong>另一个联系是类似 epoll 这种注册+消息推送的方式，可以帮助我们节省大量定位具体线程以及事件类型的时间</strong>。这是一个通用技巧，并不是独有某种 I/O 模型才可以使用。</p>
<p>不过从能力上分析，使用类似 epoll 这种模型，确实没有必要让处理 I/O 的线程阻塞，因为操作系统会将需要响应的事件源源不断地推送给处理的线程，因此可以考虑不让处理线程阻塞（比如用 NIO）。</p>
<h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><p>这一讲我们从 3 个方面讨论了 I/O 模型。</p>
<ul>
<li><strong>第一个是编程模型</strong>，阻塞、非阻塞、异步 3 者 API 的设计会有比较大的差异。通常情况下我们说的异步编程是异步转同步。异步转同步最大的价值，就是提升代码的可读性。可读，就意味着维护成本的下降以及扩展性的提升。</li>
<li>第二个在设计系统的 I/O 时，另一件<strong>需要考虑的就是数据传输以及转化的成本</strong>。传输主要是拷贝，比如可以使用内存映射来减少数据的传输。但是这里要注意一点，内存映射使用的内存是内核空间的缓冲区，因此千万不要忘记回收。因为这一部分内存往往不在我们所使用的语言提供的内存回收机制的管控范围之内。</li>
<li><strong>最后是关于数据结构的运用</strong>，针对不同的场景使用不同的缓冲区，以及选择不同的消息通知机制，也是处理高并发的一个核心问题。</li>
</ul>
<p>从上面几个角度去看 I/O 的模型，你会发现，编程模型是编程模型、数据的传输是数据的传输、消息的通知是消息的通知，它们是不同的模块，完全可以解耦，也可以根据自己不同的业务特性进行选择。虽然在一个完整的系统设计中，往往提出的是一套完整的解决方案（这也是很多网上的博文会将者 3 者混为一谈的原因），但实际上我们还是应该将它们分开去思考，这样可以产生更好的设计思路。</p>
<p><strong>那么现在你可以尝试来回答本讲关联的面试题目：BIO、NIO 和 AIO 有什么区别?</strong></p>
<p>【<strong>解析</strong>】总的来说，这三者是三个 I/O 的编程模型。BIO 接口设计会直接导致当前线程阻塞。NIO 的设计不会触发当前线程的阻塞。AIO 为 I/O 提供了异步能力，也就是将 I/O 的响应程序放到一个独立的时间线上去执行。但是通常 AIO 的提供者还会提供异步编程模型，就是实现一种对异步计算封装的数据结构，并且提供将异步计算同步回主线的能力。</p>
<p>通常情况下，这 3 种 API 都会伴随 I/O 多路复用。如果底层用红黑树管理注册的文件描述符和事件，可以在很小的开销内由内核将 I/O 消息发送给指定的线程。另外，还可以用 DMA，内存映射等方式优化 I/O。</p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>零拷贝的核心是CPU不执行将数据从一个存储区复制到另一个存储区的任务。</p>
<p>可能你会说，那零拷贝是不是0次调用CPU消耗资源啊？既对也不对，为什么这样说呢？</p>
<p>实际上，零拷贝有广义和狭义之分。</p>
<h4 id="广义零拷贝"><a href="#广义零拷贝" class="headerlink" title="广义零拷贝"></a>广义零拷贝</h4><p>能减少拷贝次数，减少不必要的数据拷贝，就算作“零拷贝”。</p>
<p>这是目前，对零拷贝最为广泛的定义，我们需要知道的是，这是广义上的零拷贝，并不是操作系统意义上的零拷贝。</p>
<h4 id="狭义零拷贝"><a href="#狭义零拷贝" class="headerlink" title="狭义零拷贝"></a>狭义零拷贝</h4><p>Linux 2.4 内核新增 sendfile 系统调用，提供了零拷贝。磁盘数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer(socket buffer)，无需 CPU 拷贝。这是真正操作系统意义上的零拷贝(也就是狭义零拷贝)。</p>
<h4 id="Linux-I-O-机制"><a href="#Linux-I-O-机制" class="headerlink" title="Linux I/O 机制"></a><strong>Linux I/O 机制</strong></h4><p>介绍 DMA 之前，我们先来了解下 Linux I/O 机制。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808194717.png" alt="image-20210808194709993"></p>
<p>为了解决CPU的上下文切换，聪明的程序员们提出了 <code>DMA(Direct Memory Access，直接内存存取)</code>，是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。通俗点理解，就是让硬件可以跳过CPU的调度，直接访问主内存。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808195425.png" alt="image-20210808195425225"></p>
<p>DMA 控制器，接管了数据读写请求，减少 CPU 的负担。这样一来，CPU 能高效工作了。<br>现代硬盘基本都支持 DMA。</p>
<p>比如我们常见的磁盘控制器、显卡、网卡、声卡都是支持 DMA 的，可以说 DMA 已经彻底融入我们的计算机世界了。</p>
<h4 id="Linux-IO-流程"><a href="#Linux-IO-流程" class="headerlink" title="Linux IO 流程"></a><strong>Linux IO 流程</strong></h4><p>那么什么又是<strong>DMA</strong>拷贝呢？</p>
<p>因为对于一个IO操作而言，都是通过CPU发出对应的指令来完成，但是相比CPU来说，IO的速度太慢了，CPU有大量的时间处于等待IO的状态。</p>
<p>因此就产生了DMA（Direct Memory Access）直接内存访问技术，本质上来说他就是一块主板上独立的芯片，通过它来进行内存和IO设备的数据传输，从而减少CPU的等待时间。</p>
<p>但是无论谁来拷贝，频繁的拷贝耗时也是对性能的影响。</p>
<p>实际因此 IO 读取，涉及两个过程：</p>
<ul>
<li>DMA 等待数据准备好，把磁盘数据读取到操作系统内核缓冲区；</li>
<li>用户进程，将内核缓冲区的数据 copy 到用户空间。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808195528.png" alt="image-20210808195528165"></p>
<p>了解完 DMA 以及 Linux I/O 流程，相信你对 Linux I/O 机制有个大致的脉络了，但你可能会问，了解完这些，跟我们零拷贝技术有啥关联么？有的.</p>
<h4 id="传统-IO-的劣势"><a href="#传统-IO-的劣势" class="headerlink" title="传统 IO 的劣势"></a>传统 IO 的劣势</h4><p>我们刚学 Java 的时候，都会学 IO 和 网络编程，最常见的就是写个聊天程序或是群聊。</p>
<p>我们来写个简单的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;index.html&quot;);</span><br><span class="line">RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line"> </span><br><span class="line">byte[] arr = new byte[(int) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"> </span><br><span class="line">Socket socket = new ServerSocket(8080).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure>

<p>服务端读取 html 里的内容后变成字节数组，然后监听 8080 端口，接收请求处理，将 html 里的字节流写到 socket 中，那么，我们调用read、write这两个方法，在 OS 底层发生了什么呢？</p>
<p>整个过程发生了<strong>4次用户态和内核态的上下文切换</strong>和<strong>4次拷贝</strong></p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808195704.png" alt="image-20210808195704164"></p>
<p>read 调用导致用户态到内核态的一次变化，同时，</p>
<ul>
<li>第一次复制开始：DMA（Direct Memory Access，直接内存存取，即不使用 CPU 拷贝数据到内存，而是 DMA 引擎传输数据到内存）引擎从磁盘读取 index.html 文件，并将数据放入到内核缓冲区。</li>
<li>发生第二次数据拷贝，即：将内核缓冲区的数据拷贝到用户缓冲区，同时，发生了一次用内核态到用户态的上下文切换。</li>
<li>发生第三次数据拷贝，我们调用 write 方法，系统将用户缓冲区的数据拷贝到 socket 缓冲区。此时，又发生了一次用户态到内核态的上下文切换。</li>
<li>第四次拷贝，数据异步的从 socket 缓冲区，使用 DMA 引擎拷贝到网络协议引擎。这一段，不需要进行上下文切换。<br>write 方法返回，再次从内核态切换到用户态。</li>
</ul>
<p>目的：减少 IO 流程中不必要的拷贝</p>
<p>零拷贝需要 OS 支持，也就是需要 kernel暴 露 api，虚拟机不能操作内核。</p>
<p><strong>Linux 支持的(常见)零拷贝</strong></p>
<p><strong>1、mmap 内存映射</strong></p>
<p>那我们这里先来了解下什么是mmap 内存映射。</p>
<p>在 Linux 中我们可以使用 mmap 用来在进程虚拟内存地址空间中分配地址空间，创建和物理内存的映射关系。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808202324.png" alt="image-20210808202323982"></p>
<p>映射关系可以分为两种</p>
<ul>
<li>文件映射：磁盘文件映射进程的虚拟地址空间，使用文件内容初始化物理内存。</li>
<li>匿名映射：初始化全为 0 的内存空间。<br>而对于映射关系是否共享又分为</li>
</ul>
<p>私有映射(MAP_PRIVATE) 多进程间数据共享，修改不反应到磁盘实际文件，是一个 copy-on- write(写时复制) 的映射方式。<br>共享映射(MAP_SHARED) 多进程间数据共享，修改反应到磁盘实际文件中。</p>
<p>因此总结起来有4种组合</p>
<ul>
<li>私有文件映射：多个进程使用同样的物理内存页进行初始化，但是各个进程对内存文件的修改不会共享，也不会反应到物理文件中。</li>
<li>私有匿名映射：mmap会创建一个新的映射，各个进程不共享，这种使用主要用于分配内存 (malloc分配大内存会调用mmap)。 例如开辟新进程时，会为每个进程分配虚拟的地址空间，这些虚拟地址映射的物理内存空间各个进程间读的时候共享，写的时候会 copy-on-write。</li>
<li>共享文件映射：多个进程通过虚拟内存技术共享同样的物理内存空间，对内存文件的修改会反应到实际物理文件中，他也是进程间通信(IPC)的一种机制。</li>
<li>共享匿名映射：这种机制在进行fork的时候不会采用写时复制，父子进程完全共享同样的物理内存页，这也就实现了父子进程通信(IPC)。</li>
</ul>
<p>mmap 只是在虚拟内存分配了地址空间，只有在第一次访问虚拟内存的时候才分配物理内存。</p>
<p>在 mmap 之后，并没有在将文件内容加载到物理页上，只上在虚拟内存中分配了地址空间。当进程在访问这段地址时，通过查找页表，发现虚拟内存对应的页没有在物理内存中缓存，则产生”缺页”，由内核的缺页异常处理程序处理，将文件对应内容，以页为单位(4096)加载到物理内存，注意是只加载缺页，但也会受操作系统一些调度策略影响，加载的比所需的多。</p>
<p><strong>mmap+write</strong></p>
<p>mmap+write简单来说就是使用<code>mmap</code>替换了read+write中的read操作，减少了一次CPU的拷贝。</p>
<p><code>mmap</code>主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次CPU拷贝。</p>
<p>整个过程发生了<strong>4次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong>，具体流程如下：</p>
<ol>
<li>用户进程通过<code>mmap()</code>方法向操作系统发起调用，上下文从用户态转向内核态</li>
<li>DMA控制器把数据从硬盘中拷贝到读缓冲区</li>
<li><strong>上下文从内核态转为用户态，mmap调用返回</strong></li>
<li>用户进程通过<code>write()</code>方法发起调用，上下文从用户态转为内核态</li>
<li><strong>CPU将读缓冲区中数据拷贝到socket缓冲区</strong></li>
<li>DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>write()</code>返回</li>
</ol>
<p><code>mmap</code>的方式节省了一次CPU拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。</p>
<p><strong>2、sendfile</strong></p>
<p>其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808205656.png" alt="image-20210808205656109"></p>
<p>如上图，我们进行 sendFile 系统调用时，数据被 DMA 引擎从文件复制到内核缓冲区，然后调用 write 方法时，从内核缓冲区进入到 socket，这时，是没有上下文切换的，因为都在内核空间。</p>
<p>最后，数据从 socket 缓冲区进入到协议栈。此时，数据经过了 3 次拷贝，2 次上下文切换。那么，还能不能再继续优化呢？ 例如直接从内核缓冲区拷贝到网络协议栈？</p>
<p><code>sendfile</code>是Linux2.1内核版本后引入的一个系统调用函数，通过使用<code>sendfile</code>数据可以直接在内核空间进行传输，因此避免了用户空间和内核空间的拷贝，同时由于使用<code>sendfile</code>替代了<code>read+write</code>从而节省了一次系统调用，也就是2次上下文切换。</p>
<p>整个过程发生了<strong>2次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong>，具体流程如下：</p>
<ol>
<li>用户进程通过<code>sendfile()</code>方法向操作系统发起调用，上下文从用户态转向内核态</li>
<li>DMA控制器把数据从硬盘中拷贝到读缓冲区</li>
<li>CPU将读缓冲区中数据拷贝到socket缓冲区</li>
<li>DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>sendfile</code>调用返回</li>
</ol>
<p><code>sendfile</code>方法IO数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。</p>
<p><strong>3、Sendfile With DMA Scatter/Gather Copy</strong></p>
<p>实际上，Linux 在 2.4 版本中，做了一些优化。</p>
<p>避免了从内核缓冲区拷贝到 socket buffer 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808205853.png" alt="image-20210808205853295"></p>
<p>Scatter/Gather 可以看作是 sendfile 的增强版，批量 sendfile。</p>
<p>现在，index.html 要从文件进入到网络协议栈，只需 2 次拷贝：第一次使用 DMA 引擎从文件拷贝到内核缓冲区，第二次从内核缓冲区将数据拷贝到网络协议栈；内核缓存区只会拷贝一些 offset 和 length 信息到 socket buffer，基本无消耗。</p>
<p>首先我们说零拷贝，是从操作系统的角度来说的(也就是我们上文所说的狭义零拷贝)。因为内核缓冲区之间，没有数据是重复的（只有 kernel buffer 有一份数据，sendFile 2.1 版本实际上有 2 份数据，算不上零拷贝(严谨点的话叫狭义零拷贝)）。例如我们刚开始的例子，内核缓存区和 socket 缓冲区的数据就是重复的。</p>
<p><img src="https://raw.githubusercontent.com/FlyMeToTheMars/PictureRepo/main/img/20210808205946.png" alt="image-20210808205946299"></p>
<p>整个过程发生了<strong>2次用户态和内核态的上下文切换</strong>和<strong>2次拷贝</strong>，其中更重要的是完全没有CPU拷贝，具体流程如下：</p>
<ol>
<li>用户进程通过<code>sendfile()</code>方法向操作系统发起调用，上下文从用户态转向内核态</li>
<li>DMA控制器利用scatter把数据从硬盘中拷贝到读缓冲区离散存储</li>
<li>CPU把读缓冲区中的文件描述符和数据长度发送到socket缓冲区</li>
<li>DMA控制器根据文件描述符和数据长度，使用scatter/gather把数据从内核缓冲区拷贝到网卡</li>
<li><code>sendfile()</code>调用返回，上下文从内核态切换回用户态</li>
</ol>
<p><code>DMA gather</code>和<code>sendfile</code>一样数据对用户空间不可见，而且需要硬件支持，同时输入文件描述符只能是文件，但是过程中完全没有CPU拷贝过程，极大提升了性能。</p>
<h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><p>传统的IO<code>read+write</code>方式会产生2次DMA拷贝+2次CPU拷贝，同时有4次上下文切换。</p>
<p>而通过<code>mmap+write</code>方式则产生2次DMA拷贝+1次CPU拷贝，4次上下文切换，通过内存映射减少了一次CPU拷贝，可以减少内存使用，适合大文件的传输。</p>
<p><code>sendfile</code>方式是新增的一个系统调用函数，产生2次DMA拷贝+1次CPU拷贝，但是只有2次上下文切换。因为只有一次调用，减少了上下文的切换，但是用户空间对IO数据不可见，适用于静态文件服务器。</p>
<p><code>sendfile+DMA gather</code>方式产生2次DMA拷贝，没有CPU拷贝，而且也只有2次上下文切换。虽然极大地提升了性能，但是需要依赖新的硬件设备支持。</p>
<h4 id="零拷贝在Java中的应用"><a href="#零拷贝在Java中的应用" class="headerlink" title="零拷贝在Java中的应用"></a>零拷贝在Java中的应用</h4><p><a href="https://blog.csdn.net/riemann_/article/details/114378152" target="_blank" rel="noopener">https://blog.csdn.net/riemann_/article/details/114378152</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Basic-Knowledge/" rel="tag"># Basic Knowledge</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/18/TTRSS-RSSHUB/" rel="prev" title="TTRSS + RSSHUB">
      <i class="fa fa-chevron-left"></i> TTRSS + RSSHUB
    </a></div>
      <div class="post-nav-item">
    <a href="/2050/10/14/朝花夕拾/" rel="next" title="朝花夕拾">
      朝花夕拾 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80Mzk4NC8yMDUyMA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统相关"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#芯片工作的原理"><span class="nav-number">1.1.1.</span> <span class="nav-text">芯片工作的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图灵机的构造"><span class="nav-number">1.1.2.</span> <span class="nav-text">图灵机的构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图灵机如何执行程序"><span class="nav-number">1.1.3.</span> <span class="nav-text">图灵机如何执行程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#冯诺依曼模型"><span class="nav-number">1.1.4.</span> <span class="nav-text">冯诺依曼模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#控制单元和逻辑运算单元"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">控制单元和逻辑运算单元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寄存器"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总线"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">总线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入、输出设备"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">输入、输出设备</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#冯诺依曼模型的几个问题："><span class="nav-number">1.1.5.</span> <span class="nav-text">冯诺依曼模型的几个问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-线路位宽问题"><span class="nav-number">1.1.5.0.1.</span> <span class="nav-text">1.线路位宽问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-64-位和-32-位的计算"><span class="nav-number">1.1.5.0.2.</span> <span class="nav-text">2. 64 位和 32 位的计算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的执行过程"><span class="nav-number">1.1.6.</span> <span class="nav-text">程序的执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#详解-a-11-15-的执行过程"><span class="nav-number">1.1.7.</span> <span class="nav-text">详解 a = 11 + 15 的执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令"><span class="nav-number">1.1.8.</span> <span class="nav-text">指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令的类型"><span class="nav-number">1.1.9.</span> <span class="nav-text">指令的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令的执行速度"><span class="nav-number">1.1.10.</span> <span class="nav-text">指令的执行速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-位和-32-位比较有哪些优势？"><span class="nav-number">1.1.11.</span> <span class="nav-text">64 位和 32 位比较有哪些优势？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-循环如何被执行"><span class="nav-number">1.1.12.</span> <span class="nav-text">for 循环如何被执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件控制程序"><span class="nav-number">1.1.13.</span> <span class="nav-text">条件控制程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">1.1.14.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归函数如何被执行"><span class="nav-number">1.1.15.</span> <span class="nav-text">递归函数如何被执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型（class）如何实现"><span class="nav-number">1.1.16.</span> <span class="nav-text">类型（class）如何实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么会有存储器分级策略？"><span class="nav-number">1.1.17.</span> <span class="nav-text">为什么会有存储器分级策略？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储器分级策略"><span class="nav-number">1.1.18.</span> <span class="nav-text">存储器分级策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#寄存器（Register）"><span class="nav-number">1.1.18.1.</span> <span class="nav-text">寄存器（Register）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#L1-Cache"><span class="nav-number">1.1.18.2.</span> <span class="nav-text">L1-Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#L2-Cache"><span class="nav-number">1.1.18.3.</span> <span class="nav-text">L2-Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#L3-Cache"><span class="nav-number">1.1.18.4.</span> <span class="nav-text">L3-Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存-1"><span class="nav-number">1.1.18.5.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSD-和硬盘"><span class="nav-number">1.1.18.6.</span> <span class="nav-text">SSD 和硬盘</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存条目结构"><span class="nav-number">1.1.19.</span> <span class="nav-text">缓存条目结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方案-1"><span class="nav-number">1.1.19.1.</span> <span class="nav-text">方案 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方案-2"><span class="nav-number">1.1.19.2.</span> <span class="nav-text">方案 2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令的预读"><span class="nav-number">1.1.20.</span> <span class="nav-text">指令的预读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存的命中率"><span class="nav-number">1.1.21.</span> <span class="nav-text">缓存的命中率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存置换问题"><span class="nav-number">1.1.22.</span> <span class="nav-text">缓存置换问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-Shell-和-Bash"><span class="nav-number">1.1.23.</span> <span class="nav-text">什么是 Shell 和 Bash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#几种常见的文件类型"><span class="nav-number">1.1.24.</span> <span class="nav-text">几种常见的文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程"><span class="nav-number">1.1.25.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ps"><span class="nav-number">1.1.25.1.</span> <span class="nav-text">ps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#top"><span class="nav-number">1.1.25.2.</span> <span class="nav-text">top</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道（Pipeline）"><span class="nav-number">1.1.26.</span> <span class="nav-text">管道（Pipeline）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入输出流"><span class="nav-number">1.1.26.1.</span> <span class="nav-text">输入输出流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管道的作用和分类"><span class="nav-number">1.1.26.2.</span> <span class="nav-text">管道的作用和分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FIFO"><span class="nav-number">1.1.26.3.</span> <span class="nav-text">FIFO</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景分析"><span class="nav-number">1.1.27.</span> <span class="nav-text">使用场景分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#排序"><span class="nav-number">1.1.27.1.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#去重"><span class="nav-number">1.1.27.2.</span> <span class="nav-text">去重</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#筛选"><span class="nav-number">1.1.27.3.</span> <span class="nav-text">筛选</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数行数"><span class="nav-number">1.1.27.4.</span> <span class="nav-text">数行数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中间结果"><span class="nav-number">1.1.27.5.</span> <span class="nav-text">中间结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xargs"><span class="nav-number">1.1.27.6.</span> <span class="nav-text">xargs</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道文件"><span class="nav-number">1.1.28.</span> <span class="nav-text">管道文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限抽象"><span class="nav-number">1.1.29.</span> <span class="nav-text">权限抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题一：初始权限问题"><span class="nav-number">1.1.29.1.</span> <span class="nav-text">问题一：初始权限问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题二：公共执行文件的权限"><span class="nav-number">1.1.29.2.</span> <span class="nav-text">问题二：公共执行文件的权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题三：执行文件"><span class="nav-number">1.1.29.3.</span> <span class="nav-text">问题三：执行文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题四：可不可以都-root"><span class="nav-number">1.1.29.4.</span> <span class="nav-text">问题四：可不可以都 root</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限架构思想"><span class="nav-number">1.1.30.</span> <span class="nav-text">权限架构思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限划分"><span class="nav-number">1.1.31.</span> <span class="nav-text">权限划分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分级保护"><span class="nav-number">1.1.31.1.</span> <span class="nav-text">分级保护</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户分组指令"><span class="nav-number">1.1.32.</span> <span class="nav-text">用户分组指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查看"><span class="nav-number">1.1.32.1.</span> <span class="nav-text">查看</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建用户"><span class="nav-number">1.1.32.2.</span> <span class="nav-text">创建用户</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建分组"><span class="nav-number">1.1.32.3.</span> <span class="nav-text">创建分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为用户增加次级分组"><span class="nav-number">1.1.32.4.</span> <span class="nav-text">为用户增加次级分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改用户主要分组"><span class="nav-number">1.1.32.5.</span> <span class="nav-text">修改用户主要分组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件权限管理指令"><span class="nav-number">1.1.33.</span> <span class="nav-text">文件权限管理指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查看-1"><span class="nav-number">1.1.33.1.</span> <span class="nav-text">查看</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改文件权限"><span class="nav-number">1.1.33.2.</span> <span class="nav-text">修改文件权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改文件所属用户"><span class="nav-number">1.1.33.3.</span> <span class="nav-text">修改文件所属用户</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程操作指令"><span class="nav-number">1.1.34.</span> <span class="nav-text">远程操作指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ssh（Secure-Shell）"><span class="nav-number">1.1.34.1.</span> <span class="nav-text">ssh（Secure Shell）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scp"><span class="nav-number">1.1.34.2.</span> <span class="nav-text">scp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看本地网络状态"><span class="nav-number">1.1.35.</span> <span class="nav-text">查看本地网络状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ifconfig"><span class="nav-number">1.1.35.1.</span> <span class="nav-text">ifconfig</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#netstat"><span class="nav-number">1.1.35.2.</span> <span class="nav-text">netstat</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络测试"><span class="nav-number">1.1.36.</span> <span class="nav-text">网络测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ping"><span class="nav-number">1.1.36.1.</span> <span class="nav-text">ping</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#telnet"><span class="nav-number">1.1.36.2.</span> <span class="nav-text">telnet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS-查询"><span class="nav-number">1.1.37.</span> <span class="nav-text">DNS 查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#host"><span class="nav-number">1.1.37.1.</span> <span class="nav-text">host</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dig"><span class="nav-number">1.1.37.2.</span> <span class="nav-text">dig</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-相关"><span class="nav-number">1.1.38.</span> <span class="nav-text">HTTP 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#curl"><span class="nav-number">1.1.38.1.</span> <span class="nav-text">curl</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何查看一个域名有哪些-NS-记录？"><span class="nav-number">1.1.39.</span> <span class="nav-text">如何查看一个域名有哪些 NS 记录？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装程序"><span class="nav-number">1.1.40.</span> <span class="nav-text">安装程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包管理器使用"><span class="nav-number">1.1.41.</span> <span class="nav-text">包管理器使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动依赖管理"><span class="nav-number">1.1.41.1.</span> <span class="nav-text">自动依赖管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译安装-Nginx"><span class="nav-number">1.1.42.</span> <span class="nav-text">编译安装 Nginx</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么会有编译安装？"><span class="nav-number">1.1.42.1.</span> <span class="nav-text">为什么会有编译安装？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用-Linux-指令分析-Web-日志"><span class="nav-number">1.1.43.</span> <span class="nav-text">利用 Linux 指令分析 Web 日志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一步：能不能这样做？"><span class="nav-number">1.1.43.1.</span> <span class="nav-text">第一步：能不能这样做？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二步：LESS-日志文件"><span class="nav-number">1.1.43.2.</span> <span class="nav-text">第二步：LESS 日志文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三步：PV-分析"><span class="nav-number">1.1.43.3.</span> <span class="nav-text">第三步：PV 分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第四步：PV-分组"><span class="nav-number">1.1.43.4.</span> <span class="nav-text">第四步：PV 分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第五步：分析-UV"><span class="nav-number">1.1.43.5.</span> <span class="nav-text">第五步：分析 UV</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第六步：分组分析-UV"><span class="nav-number">1.1.43.6.</span> <span class="nav-text">第六步：分组分析 UV</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在成百上千的集群中安装一个-Java-环境"><span class="nav-number">1.1.44.</span> <span class="nav-text">在成百上千的集群中安装一个 Java 环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一步：搭建学习用的集群"><span class="nav-number">1.1.44.1.</span> <span class="nav-text">第一步：搭建学习用的集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二步：循环遍历-IP-列表"><span class="nav-number">1.1.44.2.</span> <span class="nav-text">第二步：循环遍历 IP 列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三步：创建集群管理账户"><span class="nav-number">1.1.44.3.</span> <span class="nav-text">第三步：创建集群管理账户</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第四步：-打通集群权限"><span class="nav-number">1.1.44.4.</span> <span class="nav-text">第四步： 打通集群权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第五步：单机安装-Java-环境"><span class="nav-number">1.1.44.5.</span> <span class="nav-text">第五步：单机安装 Java 环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第六步：远程安装-Java-环境"><span class="nav-number">1.1.44.6.</span> <span class="nav-text">第六步：远程安装 Java 环境</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux命令的一些题目"><span class="nav-number">1.1.45.</span> <span class="nav-text">linux命令的一些题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#搜索文件系统中所有以包含-std字符串且以-h扩展名结尾的文件。"><span class="nav-number">1.1.45.1.</span> <span class="nav-text">搜索文件系统中所有以包含 std字符串且以.h扩展名结尾的文件。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请问下面这段-Shell-程序的作用是什么？"><span class="nav-number">1.1.45.2.</span> <span class="nav-text">请问下面这段 Shell 程序的作用是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如果一个目录是只读权限，那么这个目录下面的文件还可写吗？"><span class="nav-number">1.1.45.3.</span> <span class="nav-text">如果一个目录是只读权限，那么这个目录下面的文件还可写吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何查看正在-TIME-WAIT-状态的连接数量？"><span class="nav-number">1.1.45.4.</span> <span class="nav-text">如何查看正在 TIME_WAIT 状态的连接数量？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如果你在编译安装-MySQL-时，发现找不到libcrypt-so-，应该如何处理？"><span class="nav-number">1.1.45.5.</span> <span class="nav-text">如果你在编译安装 MySQL 时，发现找不到libcrypt.so ，应该如何处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#根据今天的-access-log-分析出有哪些终端访问了这个网站，并给出分组统计结果。"><span class="nav-number">1.1.45.6.</span> <span class="nav-text">根据今天的 access_log 分析出有哪些终端访问了这个网站，并给出分组统计结果。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#根据-access-log-分析出访问量-Top-前三的网页。"><span class="nav-number">1.1.45.7.</span> <span class="nav-text">根据 access_log 分析出访问量 Top 前三的网页。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bashrc-bash-profile-profile-和-etc-profile-的区别是什么？"><span class="nav-number">1.1.45.8.</span> <span class="nav-text">~/.bashrc ~/.bash_profile, ~/.profile 和 /etc/profile 的区别是什么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-内核和-Windows-内核有什么区别？"><span class="nav-number">1.1.46.</span> <span class="nav-text">Linux 内核和 Windows 内核有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是内核？"><span class="nav-number">1.1.46.1.</span> <span class="nav-text">什么是内核？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内核的能力"><span class="nav-number">1.1.46.2.</span> <span class="nav-text">内核的能力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统分层"><span class="nav-number">1.1.46.3.</span> <span class="nav-text">操作系统分层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内核是如何工作的？"><span class="nav-number">1.1.46.4.</span> <span class="nav-text">内核是如何工作的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux-的设计"><span class="nav-number">1.1.46.5.</span> <span class="nav-text">Linux 的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Window-设计"><span class="nav-number">1.1.46.6.</span> <span class="nav-text">Window 设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux-内核和-Windows-内核有什么区别？-1"><span class="nav-number">1.1.46.7.</span> <span class="nav-text">Linux 内核和 Windows 内核有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户态线程和内核态线程"><span class="nav-number">1.1.47.</span> <span class="nav-text">用户态线程和内核态线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是用户态和内核态"><span class="nav-number">1.1.47.1.</span> <span class="nav-text">什么是用户态和内核态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户态和内核态"><span class="nav-number">1.1.47.2.</span> <span class="nav-text">用户态和内核态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统调用过程"><span class="nav-number">1.1.47.3.</span> <span class="nav-text">系统调用过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程和线程"><span class="nav-number">1.1.47.4.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户态线程"><span class="nav-number">1.1.47.5.</span> <span class="nav-text">用户态线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内核态线程"><span class="nav-number">1.1.47.6.</span> <span class="nav-text">内核态线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户态线程和内核态线程之间的映射关系"><span class="nav-number">1.1.47.7.</span> <span class="nav-text">用户态线程和内核态线程之间的映射关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多对一（Many-to-One）"><span class="nav-number">1.1.47.8.</span> <span class="nav-text">多对一（Many to One）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一对一（One-to-One）"><span class="nav-number">1.1.47.9.</span> <span class="nav-text">一对一（One to One）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多对多（Many-To-Many）"><span class="nav-number">1.1.47.10.</span> <span class="nav-text">多对多（Many To Many）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两层设计（Two-Level）"><span class="nav-number">1.1.47.11.</span> <span class="nav-text">两层设计（Two Level）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户态线程和内核态线程的区别？"><span class="nav-number">1.1.47.12.</span> <span class="nav-text">用户态线程和内核态线程的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断和中断向量"><span class="nav-number">1.1.48.</span> <span class="nav-text">中断和中断向量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何设计响应键盘的整个链路？"><span class="nav-number">1.1.48.1.</span> <span class="nav-text">如何设计响应键盘的整个链路？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路的整理：中断的设计"><span class="nav-number">1.1.48.2.</span> <span class="nav-text">思路的整理：中断的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断的类型"><span class="nav-number">1.1.48.3.</span> <span class="nav-text">中断的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-Js-等语言为什么可以捕获到键盘输入？"><span class="nav-number">1.1.48.4.</span> <span class="nav-text">Java/Js 等语言为什么可以捕获到键盘输入？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程和线程-1"><span class="nav-number">1.1.49.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#资源分配问题"><span class="nav-number">1.1.49.1.</span> <span class="nav-text">资源分配问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级进程"><span class="nav-number">1.1.49.2.</span> <span class="nav-text">轻量级进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分时和调度"><span class="nav-number">1.1.49.3.</span> <span class="nav-text">分时和调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分配时间片段"><span class="nav-number">1.1.49.4.</span> <span class="nav-text">分配时间片段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程和线程的状态"><span class="nav-number">1.1.49.5.</span> <span class="nav-text">进程和线程的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程和线程的设计"><span class="nav-number">1.1.49.6.</span> <span class="nav-text">进程和线程的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程和线程的表示"><span class="nav-number">1.1.49.7.</span> <span class="nav-text">进程和线程的表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隔离方案"><span class="nav-number">1.1.49.8.</span> <span class="nav-text">隔离方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程（线程）切换"><span class="nav-number">1.1.49.9.</span> <span class="nav-text">进程（线程）切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多核处理"><span class="nav-number">1.1.49.10.</span> <span class="nav-text">多核处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建进程（线程）的-API"><span class="nav-number">1.1.49.11.</span> <span class="nav-text">创建进程（线程）的 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的开销比线程大在了哪里？"><span class="nav-number">1.1.49.12.</span> <span class="nav-text">进程的开销比线程大在了哪里？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何控制同一时间只有-2-个线程运行？"><span class="nav-number">1.1.50.</span> <span class="nav-text">如何控制同一时间只有 2 个线程运行？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原子操作"><span class="nav-number">1.1.50.1.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#竞争条件"><span class="nav-number">1.1.50.2.</span> <span class="nav-text">竞争条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决竞争条件"><span class="nav-number">1.1.50.3.</span> <span class="nav-text">解决竞争条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免临界区"><span class="nav-number">1.1.50.4.</span> <span class="nav-text">避免临界区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cas-指令"><span class="nav-number">1.1.50.5.</span> <span class="nav-text">cas 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tas-指令"><span class="nav-number">1.1.50.6.</span> <span class="nav-text">tas 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁"><span class="nav-number">1.1.50.7.</span> <span class="nav-text">锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语言级锁的实现"><span class="nav-number">1.1.50.8.</span> <span class="nav-text">语言级锁的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自旋锁"><span class="nav-number">1.1.50.9.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-操作"><span class="nav-number">1.1.50.10.</span> <span class="nav-text">wait 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者消费者模型"><span class="nav-number">1.1.50.11.</span> <span class="nav-text">生产者消费者模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量"><span class="nav-number">1.1.50.12.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量实现生产者消费者模型"><span class="nav-number">1.1.50.13.</span> <span class="nav-text">信号量实现生产者消费者模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁问题"><span class="nav-number">1.1.50.14.</span> <span class="nav-text">死锁问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式环境的锁"><span class="nav-number">1.1.50.15.</span> <span class="nav-text">分布式环境的锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何控制同一时间只有-2-个线程运行？-1"><span class="nav-number">1.1.50.16.</span> <span class="nav-text">如何控制同一时间只有 2 个线程运行？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#除了上锁还有哪些并发控制方法？"><span class="nav-number">1.1.51.</span> <span class="nav-text">除了上锁还有哪些并发控制方法？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#悲观锁-乐观锁"><span class="nav-number">1.1.51.1.</span> <span class="nav-text">悲观锁/乐观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Git-的类比"><span class="nav-number">1.1.51.2.</span> <span class="nav-text">Git 的类比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#购物车的类比"><span class="nav-number">1.1.51.3.</span> <span class="nav-text">购物车的类比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#去中心化方案：区块链的类比"><span class="nav-number">1.1.51.4.</span> <span class="nav-text">去中心化方案：区块链的类比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决最基本的信用问题"><span class="nav-number">1.1.51.5.</span> <span class="nav-text">解决最基本的信用问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决货币和库存的问题"><span class="nav-number">1.1.51.6.</span> <span class="nav-text">解决货币和库存的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#购买转账的过程"><span class="nav-number">1.1.51.7.</span> <span class="nav-text">购买转账的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决欺诈问题"><span class="nav-number">1.1.51.8.</span> <span class="nav-text">解决欺诈问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决并发问题"><span class="nav-number">1.1.51.9.</span> <span class="nav-text">解决并发问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#除了上锁还有哪些并发控制方法？-1"><span class="nav-number">1.1.51.10.</span> <span class="nav-text">除了上锁还有哪些并发控制方法？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程调度都有哪些方法？"><span class="nav-number">1.1.52.</span> <span class="nav-text">线程调度都有哪些方法？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#先到先服务"><span class="nav-number">1.1.52.1.</span> <span class="nav-text">先到先服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#短作业优先"><span class="nav-number">1.1.52.2.</span> <span class="nav-text">短作业优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平均等待时间-总等待时间-任务数"><span class="nav-number">1.1.52.3.</span> <span class="nav-text">平均等待时间 = 总等待时间/任务数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级队列（PriorityQueue）"><span class="nav-number">1.1.52.4.</span> <span class="nav-text">优先级队列（PriorityQueue）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抢占"><span class="nav-number">1.1.52.5.</span> <span class="nav-text">抢占</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多级队列模型"><span class="nav-number">1.1.52.6.</span> <span class="nav-text">多级队列模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么情况下会触发饥饿和死锁？"><span class="nav-number">1.1.53.</span> <span class="nav-text">什么情况下会触发饥饿和死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哲学家就餐问题"><span class="nav-number">1.1.54.</span> <span class="nav-text">哲学家就餐问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题的抽象"><span class="nav-number">1.1.54.1.</span> <span class="nav-text">问题的抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁（DeadLock）和活锁（LiveLock）"><span class="nav-number">1.1.54.2.</span> <span class="nav-text">死锁（DeadLock）和活锁（LiveLock）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决方案"><span class="nav-number">1.1.54.3.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思考和最终方案"><span class="nav-number">1.1.54.4.</span> <span class="nav-text">思考和最终方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通信都有哪些方法？"><span class="nav-number">1.1.55.</span> <span class="nav-text">进程间通信都有哪些方法？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是进程间通信？"><span class="nav-number">1.1.55.1.</span> <span class="nav-text">什么是进程间通信？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管道"><span class="nav-number">1.1.55.2.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本地内存共享"><span class="nav-number">1.1.55.3.</span> <span class="nav-text">本地内存共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本地消息-队列"><span class="nav-number">1.1.55.4.</span> <span class="nav-text">本地消息/队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#远程调用"><span class="nav-number">1.1.55.5.</span> <span class="nav-text">远程调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务应该开多少个进程、多少个线程？"><span class="nav-number">1.1.56.</span> <span class="nav-text">服务应该开多少个进程、多少个线程？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算密集型和-I-O-密集型"><span class="nav-number">1.1.56.1.</span> <span class="nav-text">计算密集型和 I/O 密集型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#衡量-CPU-的工作情况的指标"><span class="nav-number">1.1.56.2.</span> <span class="nav-text">衡量 CPU 的工作情况的指标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负载指标"><span class="nav-number">1.1.57.</span> <span class="nav-text">负载指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通信量（Traffic）"><span class="nav-number">1.1.58.</span> <span class="nav-text">通信量（Traffic）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#衡量磁盘工作情况"><span class="nav-number">1.1.58.1.</span> <span class="nav-text">衡量磁盘工作情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监控平台"><span class="nav-number">1.1.58.2.</span> <span class="nav-text">监控平台</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#决定进程-线程数量"><span class="nav-number">1.1.58.3.</span> <span class="nav-text">决定进程/线程数量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关面试题"><span class="nav-number">1.1.59.</span> <span class="nav-text">相关面试题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个程序最多能使用多少内存？"><span class="nav-number">1.1.60.</span> <span class="nav-text">一个程序最多能使用多少内存？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么内存不够用？"><span class="nav-number">1.1.60.1.</span> <span class="nav-text">为什么内存不够用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交换（Swap）技术"><span class="nav-number">1.1.60.2.</span> <span class="nav-text">交换（Swap）技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟内存"><span class="nav-number">1.1.60.3.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页（Page）和页表"><span class="nav-number">1.1.60.4.</span> <span class="nav-text">页（Page）和页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MMU"><span class="nav-number">1.1.60.5.</span> <span class="nav-text">MMU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页表条目"><span class="nav-number">1.1.60.6.</span> <span class="nav-text">页表条目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大页面问题"><span class="nav-number">1.1.60.7.</span> <span class="nav-text">大页面问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么情况下使用大内存分页？"><span class="nav-number">1.1.61.</span> <span class="nav-text">什么情况下使用大内存分页？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB-和-MMU-的性能问题"><span class="nav-number">1.1.61.1.</span> <span class="nav-text">TLB 和 MMU 的性能问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB-Miss-问题"><span class="nav-number">1.1.61.2.</span> <span class="nav-text">TLB Miss 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB-缓存的设计"><span class="nav-number">1.1.61.3.</span> <span class="nav-text">TLB 缓存的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大内存分页"><span class="nav-number">1.1.61.4.</span> <span class="nav-text">大内存分页</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU-用什么数据结构实现更合理？"><span class="nav-number">1.1.62.</span> <span class="nav-text">LRU 用什么数据结构实现更合理？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#理想状态"><span class="nav-number">1.1.62.1.</span> <span class="nav-text">理想状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#随机-FIFO-FILO"><span class="nav-number">1.1.62.2.</span> <span class="nav-text">随机/FIFO/FILO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最近未使用（NRU）"><span class="nav-number">1.1.62.3.</span> <span class="nav-text">最近未使用（NRU）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最近使用最少（LRU）"><span class="nav-number">1.1.62.4.</span> <span class="nav-text">最近使用最少（LRU）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何解决内存的循环引用问题？"><span class="nav-number">1.1.63.</span> <span class="nav-text">如何解决内存的循环引用问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是-GC"><span class="nav-number">1.1.63.1.</span> <span class="nav-text">什么是 GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数算法（Reference-Counter）"><span class="nav-number">1.1.63.2.</span> <span class="nav-text">引用计数算法（Reference Counter）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Root-Tracing-算法"><span class="nav-number">1.1.63.3.</span> <span class="nav-text">Root Tracing 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标记-清除（Mark-Sweep）算法"><span class="nav-number">1.1.63.4.</span> <span class="nav-text">标记-清除（Mark Sweep）算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充知识"><span class="nav-number">1.1.63.5.</span> <span class="nav-text">补充知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三色标记-清除算法（Tri-Color-Mark-Sweep）"><span class="nav-number">1.1.63.6.</span> <span class="nav-text">三色标记-清除算法（Tri-Color Mark Sweep）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#碎片整理和生代技术"><span class="nav-number">1.1.63.7.</span> <span class="nav-text">碎片整理和生代技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC-的选择"><span class="nav-number">1.1.63.8.</span> <span class="nav-text">GC 的选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-下的各个目录有什么作用？"><span class="nav-number">1.1.64.</span> <span class="nav-text">Linux 下的各个目录有什么作用？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分区结构"><span class="nav-number">1.1.64.1.</span> <span class="nav-text">分区结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#挂载"><span class="nav-number">1.1.64.2.</span> <span class="nav-text">挂载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目录结构"><span class="nav-number">1.1.64.3.</span> <span class="nav-text">目录结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FAT、NTFS-和-Ext3-文件系统有什么区别？"><span class="nav-number">1.1.65.</span> <span class="nav-text">FAT、NTFS 和 Ext3 文件系统有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#硬盘分块"><span class="nav-number">1.1.65.1.</span> <span class="nav-text">硬盘分块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的描述"><span class="nav-number">1.1.65.2.</span> <span class="nav-text">文件的描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FAT-表"><span class="nav-number">1.1.65.3.</span> <span class="nav-text">FAT 表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引节点（inode）"><span class="nav-number">1.1.65.4.</span> <span class="nav-text">索引节点（inode）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目录的实现"><span class="nav-number">1.1.65.5.</span> <span class="nav-text">目录的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决性能和故障：日志文件系统"><span class="nav-number">1.1.65.6.</span> <span class="nav-text">解决性能和故障：日志文件系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-中-B-树和-B-树有什么区别？"><span class="nav-number">1.1.66.</span> <span class="nav-text">MySQL 中 B 树和 B+ 树有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#行存储和列存储"><span class="nav-number">1.1.66.1.</span> <span class="nav-text">行存储和列存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引"><span class="nav-number">1.1.66.2.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉搜索树"><span class="nav-number">1.1.66.3.</span> <span class="nav-text">二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树和-B-树"><span class="nav-number">1.1.66.4.</span> <span class="nav-text">B 树和 B+ 树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承-B-树：B-树"><span class="nav-number">1.1.66.5.</span> <span class="nav-text">继承 B 树：B+ 树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树的形成：插入"><span class="nav-number">1.1.66.6.</span> <span class="nav-text">树的形成：插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入和删除效率"><span class="nav-number">1.1.66.7.</span> <span class="nav-text">插入和删除效率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#搜索：链表的作用"><span class="nav-number">1.1.66.8.</span> <span class="nav-text">搜索：链表的作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-中的-B-树和-B-树有什么区别？"><span class="nav-number">1.1.67.</span> <span class="nav-text">MySQL 中的 B 树和 B+ 树有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式文件系统是怎么回事？"><span class="nav-number">1.1.68.</span> <span class="nav-text">分布式文件系统是怎么回事？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#存储所有的网页"><span class="nav-number">1.1.68.1.</span> <span class="nav-text">存储所有的网页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模型的选择"><span class="nav-number">1.1.68.2.</span> <span class="nav-text">模型的选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询和写入"><span class="nav-number">1.1.68.3.</span> <span class="nav-text">查询和写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分片（Tablet）的抽象"><span class="nav-number">1.1.68.4.</span> <span class="nav-text">分片（Tablet）的抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#块（Chunk）的抽象"><span class="nav-number">1.1.68.5.</span> <span class="nav-text">块（Chunk）的抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式文件的管理"><span class="nav-number">1.1.68.6.</span> <span class="nav-text">分布式文件的管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读和写"><span class="nav-number">1.1.68.7.</span> <span class="nav-text">读和写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容灾"><span class="nav-number">1.1.68.8.</span> <span class="nav-text">容灾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他"><span class="nav-number">1.1.68.9.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">1.1.68.10.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-1"><span class="nav-number">1.1.68.11.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#互联网协议群（TCP-IP）：多路复用是怎么回事？"><span class="nav-number">1.1.69.</span> <span class="nav-text">互联网协议群（TCP/IP）：多路复用是怎么回事？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#协议的分层"><span class="nav-number">1.1.69.1.</span> <span class="nav-text">协议的分层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用层"><span class="nav-number">1.1.69.2.</span> <span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传输层"><span class="nav-number">1.1.69.3.</span> <span class="nav-text">传输层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络层"><span class="nav-number">1.1.69.4.</span> <span class="nav-text">网络层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据链路层（Data-Link-Layer）"><span class="nav-number">1.1.69.5.</span> <span class="nav-text">数据链路层（Data Link Layer）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物理层"><span class="nav-number">1.1.69.6.</span> <span class="nav-text">物理层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多路复用"><span class="nav-number">1.1.69.7.</span> <span class="nav-text">多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传输层多路复用"><span class="nav-number">1.1.69.8.</span> <span class="nav-text">传输层多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络层多路复用"><span class="nav-number">1.1.69.9.</span> <span class="nav-text">网络层多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多路复用的意义"><span class="nav-number">1.1.69.10.</span> <span class="nav-text">多路复用的意义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP-协议：UDP-和-TCP-相比快在哪里？"><span class="nav-number">1.1.70.</span> <span class="nav-text">UDP 协议：UDP 和 TCP 相比快在哪里？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可靠性"><span class="nav-number">1.1.70.1.</span> <span class="nav-text">可靠性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#校验和（Checksum）"><span class="nav-number">1.1.70.2.</span> <span class="nav-text">校验和（Checksum）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求-应答-连接模型"><span class="nav-number">1.1.70.3.</span> <span class="nav-text">请求/应答/连接模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封包排序"><span class="nav-number">1.1.70.4.</span> <span class="nav-text">封包排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景"><span class="nav-number">1.1.71.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">1.1.72.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-poll-epoll-有什么区别？"><span class="nav-number">1.1.73.</span> <span class="nav-text">select/poll/epoll 有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从网卡到操作系统"><span class="nav-number">1.1.73.1.</span> <span class="nav-text">从网卡到操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket-编程模型"><span class="nav-number">1.1.73.2.</span> <span class="nav-text">Socket 编程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O-多路复用"><span class="nav-number">1.1.73.3.</span> <span class="nav-text">I/O 多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select"><span class="nav-number">1.1.73.4.</span> <span class="nav-text">select()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll"><span class="nav-number">1.1.73.5.</span> <span class="nav-text">poll()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-number">1.1.73.6.</span> <span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重新思考：I-O-模型"><span class="nav-number">1.1.73.7.</span> <span class="nav-text">重新思考：I/O 模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公私钥体系和网络安全：什么是中间人攻击？"><span class="nav-number">1.1.74.</span> <span class="nav-text">公私钥体系和网络安全：什么是中间人攻击？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#摘要算法"><span class="nav-number">1.1.74.1.</span> <span class="nav-text">摘要算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安全保存的困难"><span class="nav-number">1.1.74.2.</span> <span class="nav-text">安全保存的困难</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数字签名和证书"><span class="nav-number">1.1.74.3.</span> <span class="nav-text">数字签名和证书</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#证书"><span class="nav-number">1.1.74.4.</span> <span class="nav-text">证书</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信任链"><span class="nav-number">1.1.74.5.</span> <span class="nav-text">信任链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中间人攻击"><span class="nav-number">1.1.74.6.</span> <span class="nav-text">中间人攻击</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4-和-IPv6-有什么区别？"><span class="nav-number">1.1.75.</span> <span class="nav-text">IPv4 和 IPv6 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VMware-和-Docker-的区别？"><span class="nav-number">1.1.76.</span> <span class="nav-text">VMware 和 Docker 的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是“虚拟化”"><span class="nav-number">1.1.76.1.</span> <span class="nav-text">什么是“虚拟化”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟机的设计"><span class="nav-number">1.1.76.2.</span> <span class="nav-text">虚拟机的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制翻译"><span class="nav-number">1.1.76.3.</span> <span class="nav-text">二进制翻译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#世界切换和虚拟化支持"><span class="nav-number">1.1.76.4.</span> <span class="nav-text">世界切换和虚拟化支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Type-2-虚拟机"><span class="nav-number">1.1.76.5.</span> <span class="nav-text">Type-2 虚拟机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hyper-V"><span class="nav-number">1.1.76.6.</span> <span class="nav-text">Hyper-V</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器（Container）"><span class="nav-number">1.1.76.7.</span> <span class="nav-text">容器（Container）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何利用-K8s-和-Docker-Swarm-管理微服务？"><span class="nav-number">1.1.76.8.</span> <span class="nav-text">如何利用 K8s 和 Docker Swarm 管理微服务？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kubernetes"><span class="nav-number">1.1.76.9.</span> <span class="nav-text">Kubernetes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点（Master-amp-Worker）"><span class="nav-number">1.1.76.10.</span> <span class="nav-text">节点（Master&amp;Worker）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单点架构"><span class="nav-number">1.1.76.11.</span> <span class="nav-text">单点架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#负载均衡"><span class="nav-number">1.1.76.12.</span> <span class="nav-text">负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Docker-Swarm"><span class="nav-number">1.1.76.13.</span> <span class="nav-text">Docker Swarm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器编排设计思考"><span class="nav-number">1.1.76.14.</span> <span class="nav-text">容器编排设计思考</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-架构优秀在哪里"><span class="nav-number">1.1.77.</span> <span class="nav-text">Linux 架构优秀在哪里?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#组合性设计（Composability）"><span class="nav-number">1.1.77.1.</span> <span class="nav-text">组合性设计（Composability）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管道设计（Pipeline）"><span class="nav-number">1.1.77.2.</span> <span class="nav-text">管道设计（Pipeline）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重构和丢弃"><span class="nav-number">1.1.77.3.</span> <span class="nav-text">重构和丢弃</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写复杂的程序就是写错了"><span class="nav-number">1.1.77.4.</span> <span class="nav-text">写复杂的程序就是写错了</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先使用工具而不是“熟练”"><span class="nav-number">1.1.77.5.</span> <span class="nav-text">优先使用工具而不是“熟练”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他优秀的原则"><span class="nav-number">1.1.77.6.</span> <span class="nav-text">其他优秀的原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#商业操作系统：电商操作系统是不是一个噱头？"><span class="nav-number">1.1.78.</span> <span class="nav-text">商业操作系统：电商操作系统是不是一个噱头？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的抽象"><span class="nav-number">1.1.78.1.</span> <span class="nav-text">进程的抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源和权限"><span class="nav-number">1.1.78.2.</span> <span class="nav-text">资源和权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#策略"><span class="nav-number">1.1.78.3.</span> <span class="nav-text">策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-3"><span class="nav-number">1.1.78.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机网络相关"><span class="nav-number">1.2.</span> <span class="nav-text">计算机网络相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#知识结构"><span class="nav-number">1.2.1.</span> <span class="nav-text">知识结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是蜂窝移动网络？"><span class="nav-number">1.2.2.</span> <span class="nav-text">什么是蜂窝移动网络？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#移动网络"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">移动网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#家用网络"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">家用网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据的传输"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">数据的传输</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-为什么握手是-3-次、挥手是-4-次？"><span class="nav-number">1.2.3.</span> <span class="nav-text">TCP 为什么握手是 3 次、挥手是 4 次？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#断开连接的过程（4-次挥手）"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">断开连接的过程（4 次挥手）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一台内存在-8G-左右的服务器，可以同时维护多少个连接？"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">一台内存在 8G 左右的服务器，可以同时维护多少个连接？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-为什么要粘包和拆包？"><span class="nav-number">1.2.4.</span> <span class="nav-text">TCP 为什么要粘包和拆包？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Sequence-Number-和-Acknowledgement-Number"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">Sequence Number 和 Acknowledgement Number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MSS（Maximun-Segment-Size）"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">MSS（Maximun Segment Size）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-协议是如何恢复数据的顺序的，TCP-拆包和粘包的作用是什么？"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">TCP 协议是如何恢复数据的顺序的，TCP 拆包和粘包的作用是什么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动窗口和流速控制是怎么回事？"><span class="nav-number">1.2.5.</span> <span class="nav-text">滑动窗口和流速控制是怎么回事？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#请求-响应模型"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">请求/响应模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排队（Queuing）"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">排队（Queuing）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#滑动窗口（Sliding-Window）"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">滑动窗口（Sliding Window）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重传"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速重传"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">快速重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#窗口大小的单位是？"><span class="nav-number">1.2.5.6.</span> <span class="nav-text">窗口大小的单位是？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流速控制"><span class="nav-number">1.2.5.7.</span> <span class="nav-text">流速控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-4"><span class="nav-number">1.2.5.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-协议和-UDP-协议的优势和劣势？"><span class="nav-number">1.2.6.</span> <span class="nav-text">TCP 协议和 UDP 协议的优势和劣势？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP-协议"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">UDP 协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP-的封包格式"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">UDP 的封包格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP-与-TCP的区别"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">UDP 与 TCP的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-5"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-协议和-UDP-协议的优势和劣势？-1"><span class="nav-number">1.2.6.5.</span> <span class="nav-text">TCP 协议和 UDP 协议的优势和劣势？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tips"><span class="nav-number">1.2.7.</span> <span class="nav-text">Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有哪些好用的压测工具？"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">有哪些好用的压测工具？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#既然发送方有窗口，那么接收方也需要有窗口吗？"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">既然发送方有窗口，那么接收方也需要有窗口吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Moba-类游戏的网络应该用-TCP-还是-UDP？"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">Moba 类游戏的网络应该用 TCP 还是 UDP？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由和寻址的区别是什么？"><span class="nav-number">1.2.8.</span> <span class="nav-text">路由和寻址的区别是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是-IP-协议？"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">什么是 IP 协议？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP-协议的工作原理"><span class="nav-number">1.2.9.</span> <span class="nav-text">IP 协议的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分片（Fragmentation）"><span class="nav-number">1.2.9.1.</span> <span class="nav-text">分片（Fragmentation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#增加协议头（IP-Header）"><span class="nav-number">1.2.9.2.</span> <span class="nav-text">增加协议头（IP Header）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#“鱼和熊掌”不能兼得——延迟、吞吐量、丢包率"><span class="nav-number">1.2.9.3.</span> <span class="nav-text">“鱼和熊掌”不能兼得——延迟、吞吐量、丢包率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寻址（Addressing）"><span class="nav-number">1.2.9.4.</span> <span class="nav-text">寻址（Addressing）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路由（Routing）"><span class="nav-number">1.2.9.5.</span> <span class="nav-text">路由（Routing）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-6"><span class="nav-number">1.2.9.6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路由和寻址的区别是什么？-1"><span class="nav-number">1.2.9.7.</span> <span class="nav-text">路由和寻址的区别是什么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tunnel-技术是什么？"><span class="nav-number">1.2.10.</span> <span class="nav-text">Tunnel 技术是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv4-和-IPv6-相似点"><span class="nav-number">1.2.10.1.</span> <span class="nav-text">IPv4 和 IPv6 相似点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6-地址"><span class="nav-number">1.2.10.2.</span> <span class="nav-text">IPv6 地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6-的寻址"><span class="nav-number">1.2.10.3.</span> <span class="nav-text">IPv6 的寻址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全局单播"><span class="nav-number">1.2.10.4.</span> <span class="nav-text">全局单播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本地单播"><span class="nav-number">1.2.10.5.</span> <span class="nav-text">本地单播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分组多播"><span class="nav-number">1.2.10.6.</span> <span class="nav-text">分组多播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#任意播（Anycast）"><span class="nav-number">1.2.10.7.</span> <span class="nav-text">任意播（Anycast）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6-和-IPv4-的兼容"><span class="nav-number">1.2.10.8.</span> <span class="nav-text">IPv6 和 IPv4 的兼容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-7"><span class="nav-number">1.2.10.9.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NAT-是如何工作的？"><span class="nav-number">1.2.11.</span> <span class="nav-text">NAT 是如何工作的？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内部网络和外部网络"><span class="nav-number">1.2.11.1.</span> <span class="nav-text">内部网络和外部网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局域网数据交换（MAC-地址）"><span class="nav-number">1.2.11.2.</span> <span class="nav-text">局域网数据交换（MAC 地址）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址解析协议（ARP）"><span class="nav-number">1.2.11.3.</span> <span class="nav-text">地址解析协议（ARP）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接内网"><span class="nav-number">1.2.11.4.</span> <span class="nav-text">连接内网</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接外网（网络地址转换技术，NAT）"><span class="nav-number">1.2.11.5.</span> <span class="nav-text">连接外网（网络地址转换技术，NAT）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-8"><span class="nav-number">1.2.11.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何进行-TCP-抓包调试？"><span class="nav-number">1.2.12.</span> <span class="nav-text">如何进行 TCP 抓包调试？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口列表"><span class="nav-number">1.2.12.1.</span> <span class="nav-text">接口列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开启捕获功能"><span class="nav-number">1.2.12.2.</span> <span class="nav-text">开启捕获功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#观察-TCP-协议"><span class="nav-number">1.2.12.3.</span> <span class="nav-text">观察 TCP 协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息视图"><span class="nav-number">1.2.12.4.</span> <span class="nav-text">消息视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#观察-HTTP-协议"><span class="nav-number">1.2.12.5.</span> <span class="nav-text">观察 HTTP 协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过滤和筛选"><span class="nav-number">1.2.12.6.</span> <span class="nav-text">过滤和筛选</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块二加餐"><span class="nav-number">1.2.13.</span> <span class="nav-text">模块二加餐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#下面这几个地址-127-0-0-1-localhost-0-0-0-0-有什么不同？"><span class="nav-number">1.2.13.1.</span> <span class="nav-text">下面这几个地址 127.0.0.1, localhost, 0.0.0.0 有什么不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6-和-IPv4-究竟有哪些区别？"><span class="nav-number">1.2.13.2.</span> <span class="nav-text">IPv6 和 IPv4 究竟有哪些区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6-协议还需要-NAT-吗？"><span class="nav-number">1.2.13.3.</span> <span class="nav-text">IPv6 协议还需要 NAT 吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写一个-UDP-连接程序，然后用-Wireshark-抓包。"><span class="nav-number">1.2.13.4.</span> <span class="nav-text">写一个 UDP 连接程序，然后用 Wireshark 抓包。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket-编程：epoll-为什么用红黑树？"><span class="nav-number">1.2.14.</span> <span class="nav-text">Socket 编程：epoll 为什么用红黑树？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#服务端-Socket-的绑定"><span class="nav-number">1.2.14.1.</span> <span class="nav-text">服务端 Socket 的绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扫描和监听"><span class="nav-number">1.2.14.2.</span> <span class="nav-text">扫描和监听</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应式（Reactive）"><span class="nav-number">1.2.14.3.</span> <span class="nav-text">响应式（Reactive）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么用红黑树？"><span class="nav-number">1.2.14.4.</span> <span class="nav-text">为什么用红黑树？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-9"><span class="nav-number">1.2.14.5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-为什么用红黑树？"><span class="nav-number">1.2.14.6.</span> <span class="nav-text">epoll 为什么用红黑树？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流和缓冲区：缓冲区的-flip-是怎么回事？"><span class="nav-number">1.2.15.</span> <span class="nav-text">流和缓冲区：缓冲区的 flip 是怎么回事？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#流"><span class="nav-number">1.2.15.1.</span> <span class="nav-text">流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要缓冲区？"><span class="nav-number">1.2.15.2.</span> <span class="nav-text">为什么要缓冲区？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲区"><span class="nav-number">1.2.15.3.</span> <span class="nav-text">缓冲区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络-I-O-模型：BIO、NIO-和-AIO-有什么区别？"><span class="nav-number">1.2.16.</span> <span class="nav-text">网络 I/O 模型：BIO、NIO 和 AIO 有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O-的编程模型"><span class="nav-number">1.2.16.1.</span> <span class="nav-text">I/O 的编程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据的传输和转化成本"><span class="nav-number">1.2.16.2.</span> <span class="nav-text">数据的传输和转化成本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构运用"><span class="nav-number">1.2.16.3.</span> <span class="nav-text">数据结构运用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲区-1"><span class="nav-number">1.2.16.4.</span> <span class="nav-text">缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O-多路复用模型"><span class="nav-number">1.2.16.5.</span> <span class="nav-text">I/O 多路复用模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-10"><span class="nav-number">1.2.16.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#零拷贝"><span class="nav-number">1.2.17.</span> <span class="nav-text">零拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#广义零拷贝"><span class="nav-number">1.2.17.1.</span> <span class="nav-text">广义零拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#狭义零拷贝"><span class="nav-number">1.2.17.2.</span> <span class="nav-text">狭义零拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux-I-O-机制"><span class="nav-number">1.2.17.3.</span> <span class="nav-text">Linux I/O 机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux-IO-流程"><span class="nav-number">1.2.17.4.</span> <span class="nav-text">Linux IO 流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传统-IO-的劣势"><span class="nav-number">1.2.17.5.</span> <span class="nav-text">传统 IO 的劣势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-11"><span class="nav-number">1.2.17.6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#零拷贝在Java中的应用"><span class="nav-number">1.2.17.7.</span> <span class="nav-text">零拷贝在Java中的应用</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fly Hugh"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Fly Hugh</p>
  <div class="site-description" itemprop="description">WE CHOOSE TO  GO TO THE MARS</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/FlyMeToTheMars" title="GitHub → https://github.com/FlyMeToTheMars" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/flyhobo@live.com" title="E-Mail → flyhobo@live.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3200892914" title="Weibo → https://weibo.com/u/3200892914" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Fly__HoBo" title="Twitter → https://twitter.com/Fly__HoBo" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fly Hugh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
